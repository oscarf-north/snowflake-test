OBJECT_TYPE,SCHEMA_NAME,OBJECT_NAME,DDL
PROCEDURE,DATAADMIN,SP_DAG_CHECKNEGONE_ALL(),"CREATE OR REPLACE PROCEDURE ""SP_DAG_CHECKNEGONE_ALL""()
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS OWNER
AS '
DECLARE
     -- Runtime metadata
    run_metadata VARIANT;
    --error handling vars
    failed_query_id VARCHAR;
    details_json VARIANT;
    failure_count NUMBER;
    error_message_summary VARCHAR;
BEGIN
    CALL dataadmin.sp_get_dag_run_metadata(COALESCE(last_query_id(), ''NOT_FOUND'')) INTO :run_metadata;

    --TODO add query tags in future sprints

    CALL dataadmin.SP_CHECKNEGONE_ALL();
    failed_query_id := COALESCE(last_query_id(), ''NOT_FOUND'');

    -- 3. Analyze the results from the last query (the CALL statement)
    -- We create a temporary table of only the failures.
    CREATE OR REPLACE TEMPORARY TABLE failed_dq_checks AS
    SELECT *
    FROM TABLE(RESULT_SCAN(:failed_query_id))
    WHERE COUNTVAL <> 1;

    -- 4. Count the number of failures
    SELECT COUNT(*) INTO :failure_count FROM failed_dq_checks;

    IF (:failure_count > 0) THEN

        error_message_summary := ''DQ Check Failed: '' || :failure_count || '' dimension table(s) have an incorrect count for the -1 record.'';

        details_json := (SELECT OBJECT_CONSTRUCT(
            ''query_output'', ARRAY_AGG(OBJECT_CONSTRUCT(*))
            )
            FROM failed_dq_checks);

        -- Insert a SINGLE row into the error log table
        INSERT INTO dataadmin.error_logs (
            parent_query_id,
            task_run_group_id,
            attempt_number,
            session_id,
            task_name,
            failed_query_id,
            error_type_id,
            severity,
            sql_error_message,
            details
        )
        SELECT 
            :run_metadata:parent_query_id::VARCHAR,
            :run_metadata:graph_run_group_id::VARCHAR,
            :run_metadata:run_attempt_number::NUMBER,
            :run_metadata:session_id::VARCHAR,
            :run_metadata:task_name::VARCHAR,
            :failed_query_id,
            3, -- Data Quality Issue
            ''WARN'',
            :error_message_summary,
            :details_json
        ;

        RETURN ''Data quality issues found and logged: '' || :failure_count || '' tables failed.'';
    ELSE
        RETURN ''Data quality check passed. No issues found.'';
    END IF;

END;
';"
PROCEDURE,DATAADMIN,"SP_DATASHARE_CRAFTABLE_DISCOUNT(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_DATASHARE_CRAFTABLE_DISCOUNT""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE
  reportSet resultset;
  -- startdate timestamp_tz      := ''2020-08-20T14:48:37.661Z'';
  -- enddate timestamp_tz        := ''2029-08-20T14:48:37.661Z'';
  -- locationid string           := ''[35]'';
  locationidS string          :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
  today char(11)              := CURRENT_DATE()::date::VARCHAR(10);
-----------------------------------------------------------------------------------------------------------------------
BEGIN
-----------------------------------------------------------------------------------------------------------------------
    reportSet   := ( 
            SELECT 
             ORG.ORGANIZATION                           AS ""Organization Name""
            ,ORG.ORGANIZATION_DIM_NK                    AS ""Organization ID""
            ,LOC.LOCATIONNAME                           AS ""Location Name""
            ,CHF.LOCATION_DIM_FK                        AS ""Location ID"" 
            ,CHF.FISCAL_DATE::DATE                      AS ""Business Day""
            ,CHF.DISCOUNTITEM_FACT_NK                    AS ""Discount ID""
            ,CHF.DISCOUNTLEVEL                          AS ""Discount Level""
            ,STD.STANDARDDISCOUNTNAME                   AS ""Discount Name""
            ,CHF.CHEQUENUMBER                           AS ""Check Number""  
            ,CHF.CHEQUE_FACT_FK                         AS ""Check ID""
            ,ITF.NAME                                   AS ""Item Name""
            ,ITF.ITEM_FACT_NK                           AS ""Item ID""
            ,COALESCE(EMD_APP.EMPLOYEE_NAME,''None'')     AS ""Employee for Discount (approver)""
            ,CHF.APPLIED_AMOUNT  ::NUMBER(18,2)         AS ""Discount Amount""
            ,CASE WHEN (CHF.DISCOUNTREASON = ''CASHDISCOUNT'') 
              THEN CHF.APPLIED_AMOUNT ELSE 0 END        AS ""Cash Discount Amount""
            ,""Discount Amount"" - ""Cash Discount Amount"" AS  ""Disc Amount No Cash""
            
        FROM DATAWAREHOUSE.DISCOUNTITEM_FACT                      CHF
            INNER JOIN DATAWAREHOUSE.ITEM_FACT                    ITF
              ON CHF.ITEM_FACT_FK = ITF.ITEM_FACT_NK
                  AND ITF.ITEMSTATUS IN (''Added'',''Sent'')
                  AND NOT CHF.STATUS  = ''Disabled''
                  AND CHF.CHEQUESTATUS  IN (''Closed'')
                  -- AND CHF.DISCOUNTREASON <> ''CASHDISCOUNT''
                  AND CHF.FISCAL_DATE::date
                      >= :startdate::date
                  AND CHF.FISCAL_DATE::date   
                      <= :enddate ::date 
                  AND CHF.LOCATION_DIM_FK IN (
                     SELECT table1.value 
                       FROM table(split_to_table(:locationidS, '',''))  table1)
                  AND CHF.DW_ISCURRENTROW
                  AND ITF.DW_ISCURRENTROW
                  AND NOT CHF.DW_ISDELETED                
                  AND NOT CHF.IS_TRAINING
            INNER JOIN DATAWAREHOUSE.LOCATION_DIM                 LOC  
              ON CHF.LOCATION_DIM_FK = LOC.LOCATION_DIM_NK
                 AND LOC.DW_ISCURRENTROW  
            INNER JOIN DATAWAREHOUSE.ORGANIZATION_DIM             ORG
                ON LOC.ORGANIZATION_DIM_FK = ORG.ORGANIZATION_DIM_NK
                    AND ORG.DW_ISCURRENTROW
            INNER JOIN DATAWAREHOUSE.STANDARDDISCOUNT_DIM         STD
               ON STD.STANDARDDISCOUNT_DIM_NK = CHF.STANDARDDISCOUNT_DIM_FK
                 AND STD.DW_ISCURRENTROW
            -- INNER JOIN DATAWAREHOUSE.DAYPART_DIM                  DAD
            --   ON CHF.DAYPART_DIM_FK = DAD.DAYPART_DIM_NK
            --       AND DAD.DW_ISCURRENTROW
            -- LEFT JOIN DATAWAREHOUSE.EMPLOYEE_DIM                 EMD_ADD
            --   ON EMPLOYEE_DIM_FK_AS_ADDED_BY = EMD_ADD.EMPLOYEE_DIM_NK
            --     AND EMD_ADD.DW_ISCURRENTROW
            LEFT JOIN DATAWAREHOUSE.EMPLOYEE_DIM                 EMD_APP
              ON EMPLOYEE_DIM_FK_AS_APPROVED_BY = EMD_APP.EMPLOYEE_DIM_NK
                AND EMD_APP.DW_ISCURRENTROW
    UNION ALL

        SELECT
             ORG.ORGANIZATION                           AS ""Organization Name""
            ,ORG.ORGANIZATION_DIM_NK                    AS ""Organization ID""
            ,LOC.LOCATIONNAME                           AS ""Location Name""
            ,CHF.LOCATION_DIM_FK                        AS ""Location ID"" 
            ,CHF.FISCAL_DATE::DATE                      AS ""Business Day""
            ,CHF.DISCOUNTCHECK_FACT_NK                   AS ""Discount ID""
            ,CHF.DISCOUNTLEVEL                          AS ""Discount Level""
            ,STD.STANDARDDISCOUNTNAME                   AS ""Discount Name""
            ,CHF.CHEQUENUMBER                           AS ""Check Number""  
            ,CHF.CHEQUE_FACT_FK                         AS ""Check ID""
            ,null                                       AS ""Item Name""
            ,null                                       AS ""Item ID""
            ,COALESCE(EMD_APP.EMPLOYEE_NAME,''None'')     AS ""Employee for Discount (approver)""
            ,CHF.APPLIED_AMOUNT  ::NUMBER(18,2)         AS ""Discount Amount"" 
            ,CASE WHEN CHF.DISCOUNTREASON = ''CASHDISCOUNT'' 
              THEN CHF.APPLIED_AMOUNT ELSE 0 END        AS ""Cash Discount Amount""
            ,""Discount Amount"" - ""Cash Discount Amount"" AS ""Disc Amount No Cash""
        --------------------------------------------------------------------------------------------------------
        FROM DATAWAREHOUSE.DISCOUNTCHECK_FACT                     CHF
            INNER JOIN DATAWAREHOUSE.LOCATION_DIM                 LOC
              ON CHF.LOCATION_DIM_FK = LOC.LOCATION_DIM_NK
                  AND CHF.FISCAL_DATE::date
                      >= :startdate::date
                  AND CHF.FISCAL_DATE::date   
                      <= :enddate ::date 
                  AND CHF.LOCATION_DIM_FK IN (
                     SELECT table1.value 
                       FROM table(split_to_table(:locationidS, '',''))  table1)
                  AND CHF.CHEQUESTATUS IN (''Closed'')
                  AND NOT CHF.STATUS = ''Disabled''
                  -- AND CHF.DISCOUNTREASON <> ''CASHDISCOUNT''
                  AND CHF.DW_ISCURRENTROW
                  AND NOT CHF.DW_ISDELETED
                  AND LOC.DW_ISCURRENTROW          
                  AND NOT CHF.IS_TRAINING
            INNER JOIN DATAWAREHOUSE.ORGANIZATION_DIM                                        ORG
                ON LOC.ORGANIZATION_DIM_FK = ORG.ORGANIZATION_DIM_NK
                AND ORG.DW_ISCURRENTROW
            -- INNER JOIN DATAWAREHOUSE.DAYPART_DIM                 DAD
            --   ON CHF.DAYPART_DIM_FK = DAD.DAYPART_DIM_NK
            --       AND DAD.DW_ISCURRENTROW                  
            LEFT JOIN DATAWAREHOUSE.STANDARDDISCOUNT_DIM         STD
               ON STD.STANDARDDISCOUNT_DIM_NK = CHF.STANDARDDISCOUNT_DIM_FK
                 AND STD.DW_ISCURRENTROW
            -- LEFT JOIN DATAWAREHOUSE.EMPLOYEE_DIM                 EMD_ADD
            --   ON EMPLOYEE_DIM_FK_AS_ADDED_BY = EMD_ADD.EMPLOYEE_DIM_NK
            --     AND EMD_ADD.DW_ISCURRENTROW
            LEFT JOIN DATAWAREHOUSE.EMPLOYEE_DIM                 EMD_APP
              ON EMPLOYEE_DIM_FK_AS_APPROVED_BY = EMD_APP.EMPLOYEE_DIM_NK
                AND EMD_APP.DW_ISCURRENTROW        
); 
--=====================================================================================================================
RETURN TABLE(reportSet);
END';"
PROCEDURE,DATAADMIN,"SP_DATAWAREHOUSE_DASHBOARD_SHIFT(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_DATAWAREHOUSE_DASHBOARD_SHIFT""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet      resultset;
  -- startdate      date     := ''2025-04-21'';  
  -- enddate        date     := ''2025-04-21''; 
  -- locationid     string   := ''[1,2,3,4,5,6,7,8,9,351]'';
  locationidS string      :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
  today          char(11) := CURRENT_DATE()::DATE::VARCHAR(10);
  yesterdaydate  date     := dateadd(day,-1,:today);
  weekOffset     int      := (  
                              SELECT TOP 1 ORG.START_OF_BIZ_WEEK_INT  
                                FROM DATAWAREHOUSE.ORGANIZATION_DIM          ORG
                                  INNER JOIN DATAWAREHOUSE.LOCATION_DIM      LOC 
                                     ON LOC.ORGANIZATION_DIM_FK = ORG.ORGANIZATION_DIM_NK
                                        AND LOC.DW_ISCURRENTROW
                                        AND LOC.DW_ISCURRENTROW
                                        AND LOC.LOCATION_DIM_NK in (
                                             SELECT table1.value 
                                          FROM table(split_to_table(:locationidS, '',''))  table1) 
                             );
  lastWeekStart  date     := (DATEADD(DAY,
                                ((DAYOFWEEK(:today::date) - (:weekOffset )  ) * -1)  -7
                                + case when DAYOFWEEK(:today::date)< :weekOffset then -0 else 0 end
                                 , :today)) ::date;
  lastWeekEnd    date     := dateadd(day,6,:lastWeekStart);
  lastMonthStart date     := left(dateadd(month,-1,:today)::date::string,7) || ''-01'';
  lastMonthEnd   date     := dateadd(day,-1,dateadd(month,1,lastMonthStart))::date;
  lastYearStart  date     := date_part(year,(dateadd(year,-1,:today))) || ''-01-01'';                  
  lastYearEnd    date     := dateadd(day,-1,dateadd(year,1,:lastYearStart));

---====================================================================================================================
BEGIN
  DROP TABLE if exists SHIFT_DATA_TEMP; 
  DROP TABLE if exists BREAK_DATA_TEMP; 

-----------------------------------------------------------------------------------------------------------------------
SELECT TO_CHAR(SHD.SHIFT_DIM_NK)                                                 AS ""Support ID""
  ,''DataWarehouse''                                                               AS ""Origin""
  ,''None''                                                                        AS ""Check Status""
  ,''Shift''                                                                       AS ""Level""
  ,NULL                                                                          AS ""Check ID""
  ,SHD.SHIFT_DIM_NK                                                              AS ""Shift ID""
  ,SHD.LOCATION_DIM_FK                                                           AS ""Location ID""  
  ,NULL                                                                          AS ""Revenue Center""
  ,SHD.EMPLOYEE_DIM_FK                                                           AS ""Employee ID""
  ,NULL                                                                          AS ""Daypart ID""
  ,NULL                                                                          AS ""Order Type ID""   
  ,NULL                                                                          AS ""Daypart""
  ,NULL                                                                          AS ""Order Type""
  ,LOC.LOCATIONNAME                                                              AS ""Location""
  ,NULL                                                                          AS ""Menu Item""
  ,SHD.GETS_PAID_BREAK                                                           AS ""Gets Paid Break""
  ---------------------------------------------------------------------------------------
  ,SHD.FISCAL_DAY::DATE                                                          AS ""Fiscal Date"" 
  ,NULL                                                                          AS ""Opened At""  
  ,TO_CHAR(TO_CHAR(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME
       ,SHD.CLOCKEDIN_AT::timestamp_ntz)::timestamp ) ::timestamp 
  , ''HH24'') ::NUMBER(5,0)                                                        AS ""Hour""    
  ,SHD.REGULAR_RATE::DECIMAL(36,2)                                               AS ""Rate""
  ,CASE WHEN TO_CHAR(SHD.FISCAL_DAY)::DATE  
    BETWEEN :startdate::DATE AND :enddate::DATE THEN TRUE ELSE FALSE END                                                                                                                                     AS ""Is Current""
  ,CASE WHEN TO_CHAR(SHD.FISCAL_DAY)::DATE  
    = :today::DATE THEN TRUE ELSE FALSE END                                      AS ""Is Today""                                                                              
  ,CASE WHEN TO_CHAR(SHD.FISCAL_DAY)::DATE  
    = :yesterdaydate::DATE THEN TRUE ELSE FALSE END                              AS ""Is Yesterday""
    
  ,CASE WHEN TO_CHAR(SHD.FISCAL_DAY)::DATE  
    BETWEEN :lastWeekStart::DATE AND :lastWeekEnd::DATE 
      THEN TRUE ELSE FALSE END                                                   AS ""Is Last Week""
      
  ,CASE WHEN TO_CHAR(SHD.FISCAL_DAY)::DATE  
    BETWEEN :lastMonthStart::DATE AND :lastMonthEnd::DATE 
       THEN TRUE ELSE FALSE END                                                  AS ""Is Last Month""
       
  ,CASE WHEN TO_CHAR(SHD.FISCAL_DAY)::DATE  
    BETWEEN :lastYearStart::DATE AND :lastYearEnd::DATE 
        THEN TRUE ELSE FALSE END                                                 AS ""Is Last Year""
-----------------------------------------------------------------------------------------------------------------
--Facts CHECK LEVEL
 ,0::NUMBER(36,0)                                                                AS ""Guest Count""
 ,0 ::NUMBER(36,0)                                                               AS ""Fee Amount""
 ,0 ::NUMBER(36,0)                                                               AS ""Gratuity Amount""
 ,0 ::NUMBER(36,0)                                                               AS ""Table Time""   
  -----------------------------------------------------------------------------------------------------------------
  ,IFF( SHD.IS_SHIFTCOMPLETE,SHD.SHIFT_SECONDS, 
          ROUND(TIMEDIFF(second
               ,SHD.CLOCKEDIN_AT::timestamp_ntz 
               ,CONVERT_TIMEZONE(''UTC'', CURRENT_TIMESTAMP())::timestamp_ntz
              )::Number(36,0),0))
                                                                               AS ""Shift Seconds""  
  ,1::NUMBER(36,0)                                                             AS ""Shift Count""
  ,0::NUMBER(36,0)                                                             AS ""Item Count""  
  ,0::NUMBER(36,0)                                                             AS ""Check Count"" 
  ,0::NUMBER(36,0)                                                             AS ""Void Count""
  ,0::DECIMAL(36,2)                                                            AS ""Void Amount"" 
  ,0::DECIMAL(36,2)                                                            AS ""Net Amount""
  ,0::DECIMAL(36,2)                                                            AS ""Discount Amount""
  ,0::DECIMAL(36,2)                                                            AS ""Gross Amount""  
----------------------------------------------------------------------------------------------------------------- 
  FROM DATAWAREHOUSE.SHIFT_DIM                                                 SHD
          INNER JOIN DATAWAREHOUSE.LOCATION_DIM                                LOC
             ON SHD.LOCATION_DIM_FK = LOC.LOCATION_DIM_NK
                AND LOC.DW_ISCURRENTROW
                AND SHD.DW_ISCURRENTROW
                AND NOT SHD.DW_ISDELETED
                AND NOT SHD.IS_ARCHIVED
                AND SHD.FISCAL_DAY::date >= :lastYearEnd::date 
                AND SHD.FISCAL_DAY::date <= :today::date  
                AND SHD.LOCATION_DIM_FK in (
                  SELECT table1.value 
                     FROM table(split_to_table(:locationidS, '',''))  table1)
          INNER JOIN DATAWAREHOUSE.JOBPOSITION_DIM                 JBP
            ON JBP.JOBPOSITION_DIM_NK = SHD.JOBPOSITION_DIM_FK 
              AND JBP.DW_ISCURRENTROW
         ORDER BY SHD.CLOCKEDIN_AT DESC  
;

CREATE TEMP TABLE SHIFT_DATA_TEMP AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))
;

-----------------------------------------------------------------------------------------------------------------------
SELECT SHD_1.""Shift ID""                                         AS ""Shift ID""
 ,SHD_1.""Gets Paid Break""                                       AS ""Gets Paid Break""
 ,SUM(IFF( BRK.IS_BREAKCOMPLETE ,BRK.BREAK_SECONDS , 
          ROUND(TIMEDIFF(SECOND
            ,BRK.START_AT::timestamp_ntz 
            ,CURRENT_TIMESTAMP::timestamp_ntz 
                )::Number(38,0),0)) )                                                  
                                                                AS ""Break Seconds""

          FROM SHIFT_DATA_TEMP                                  SHD_1
            INNER JOIN DATAWAREHOUSE.SHIFTBREAK_FACT            BRK
              ON SHD_1.""Shift ID"" = BRK.SHIFT_DIM_FK
                 AND BRK.DW_ISCURRENTROW
                 AND NOT BRK.DW_ISDELETED
         GROUP BY SHD_1.""Shift ID""
            ,SHD_1.""Gets Paid Break""
;


CREATE TEMP TABLE BREAK_DATA_TEMP AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))
;

----------------------------------------------------------------------------------------------------------------------
UPDATE SHIFT_DATA_TEMP  shd_2
  SET shd_2.""Shift Seconds"" = shd_2.""Shift Seconds""
    - (IFNULL( brk_1.""Break Seconds"" ,0))
  
  FROM BREAK_DATA_TEMP  brk_1
  WHERE shd_2.""Shift ID"" = brk_1.""Shift ID""
    AND  brk_1.""Gets Paid Break""
;

-- ====================================================================================================================
 reportSet   := (
     SELECT * FROM SHIFT_DATA_TEMP  
   
--===================================================================================================
); 
 RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,SP_LOADSTAGETABLES_ALL(),"CREATE OR REPLACE PROCEDURE ""SP_LOADSTAGETABLES_ALL""()
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
    SQLStmt resultset;
    SQLMessage resultset := (SELECT ''Stage load comlete.'' );
--========================================================================================================
--Get all of the Load Sprocs
--========================================================================================================
-- --Put all of the sprocs into a list
-- drop table proclist;
-- SHOW PROCEDURES;

-- CREATE TEMP TABLE proclist AS
--      SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

-- select * from proclist;

-- SELECT ''CALL '' || ""schema_name"" || ''.'' || ""name"" || ''(TRUE);'' as sqltext
--   FROM proclist
-- WHERE ""schema_name"" = ''DATAADMIN''
--   AND ""name"" ilike ''SP_STAGELOAD%''
--   AND ""name"" not ilike ''%ERROR%''
-- ;

  -- CALL DATAADMIN.SP_STAGELOADCASHPAYMENTLEDGER_FACT(TRUE);
  -- TRUNCATE TABLE DATAWAREHOUSE_TEMP.CASHPAYMENTLEDGER_FACT;
  --SELECT COUNT(*) FROM DATAADMIN.ADDRESS_DIM;   --1850
   --SELECT COUNT(*) FROM DATAWAREHOUSE_TEMP.ADDRESS_DIM; 
    -- TRUNCATE TABLE DATAWAREHOUSE_TEMP.ADDRESS_DIM;
 ----------------------------------------------------------------------------------------------------------- 
BEGIN 

CALL DATAADMIN.SP_STAGELOADACTIVITY_FACT(TRUE);
CALL DATAADMIN.SP_STAGELOADADDRESS_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADBATCH_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADCASHBANKEVENT_FACT(TRUE);
CALL DATAADMIN.SP_STAGELOADCASHBANK_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADCASHPAYMENTLEDGER_FACT(TRUE);
CALL DATAADMIN.SP_STAGELOADCCTRANSACTION_FACT(TRUE);
CALL DATAADMIN.SP_STAGELOADCHECKCASHPAYMENTLEDGER_FACT(TRUE);
CALL DATAADMIN.SP_STAGELOADCHEQUE_FACT(TRUE);
CALL DATAADMIN.SP_STAGELOADCLOSEOUTSUMMARY_FACT(TRUE);
CALL DATAADMIN.SP_STAGELOADCOGSCATEGORY_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADDAYPART_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADDAYPARTSCHEDULE_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADDISCOUNTCHECK_FACT(TRUE);
CALL DATAADMIN.SP_STAGELOADDISCOUNTITEM_FACT(TRUE);
CALL DATAADMIN.SP_STAGELOADDISCOUNTREASON_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADDRAWER_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADEMPLOYEE_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADEMPLOYMENTPERIOD_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADFEETAX_FACT(TRUE);
CALL DATAADMIN.SP_STAGELOADTAX_FACT(TRUE);
CALL DATAADMIN.SP_STAGELOADGIFTCARDACTIVITY_FACT(TRUE);
CALL DATAADMIN.SP_STAGELOADGIFTCARDTRANSACTION_FACT(TRUE);
CALL DATAADMIN.SP_STAGELOADGIFTCARD_DIM(TRUE);


CALL DATAADMIN.SP_STAGELOADITEM_FACT(TRUE);
CALL DATAADMIN.SP_STAGELOADJOBPOSITION_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADLOCATIONGROUP_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADLOCATION_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADLOCATION_LOCATIONGROUP_XREF(TRUE);
CALL DATAADMIN.SP_STAGELOADMENUGROUP_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADMENUITEMNAME_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADMENUITEM_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADMENUITEM_MENUGROUP_XREF(TRUE);

CALL DATAADMIN.SP_STAGELOADINTEGRATIONTYPE_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADINTEGRATION_FACT(TRUE);

CALL DATAADMIN.SP_STAGELOADITEMMODIFIER_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADMERCHANT_ORGANIZATION_XREF(TRUE);
CALL DATAADMIN.SP_STAGELOADMERCHANT_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADMODIFIER_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADMODIFIEROPTIONS_DIM(TRUE);


CALL DATAADMIN.SP_STAGELOADORDERTYPE_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADORGANIZATION_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADOVERTIMELABORRULE_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADOVERTIMELABORRULE_JOBPOSITION_XREF(TRUE);
CALL DATAADMIN.SP_STAGELOADPAYINOUT_FACT(TRUE);
CALL DATAADMIN.SP_STAGELOADPAYINPAYOUTREASON_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADPAYMENTMETHOD_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADPAYMENTS_FACT(TRUE);
CALL DATAADMIN.SP_STAGELOADPHONENUMBER_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADREFUNDS_FACT(TRUE);
CALL DATAADMIN.SP_STAGELOADREPORTCATEGORY_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADREVENUECENTER_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADSHIFTBREAK_FACT(TRUE);
CALL DATAADMIN.SP_STAGELOADSHIFT_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADSTANDARDDISCOUNT_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADSURCHARGE_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADSURCHARGE_FACT(TRUE);
CALL DATAADMIN.SP_STAGELOADTAXASSOCIATION_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADTAXASSOCIATION_MENUITEM_XREF(TRUE);
CALL DATAADMIN.SP_STAGELOADTAXRATE_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADTAXSETTINGS_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADTAX_FACT(TRUE);
CALL DATAADMIN.SP_STAGELOADTERMINAL_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADVARIANT_DIM(TRUE);
CALL DATAADMIN.SP_STAGELOADVOIDREASON_DIM(TRUE);


    RETURN TABLE(SQLMessage);

END';"
PROCEDURE,DATAADMIN,"SP_LOAD_HARRI_SALES(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_HARRI_SALES""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2025-06-03'';  
  -- enddate timestamp_tz   := ''2025-06-03''; 
  -- locationid string      := ''[1,351]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--=================================================================================================================================
BEGIN

DROP TABLE IF EXISTS temp_SALES;

-----------------------------------------------------------------------------------------------------------------------------------
--Sales Data
SELECT CHF.LOCATION_DIM_FK AS ""storeId""
,CHF.FISCAL_DATE           AS ""qtr_end_time""	
,SUM(CHF.NET)              AS ""net_sales""	    --aggregate
,SUM(CHF.PARTY_COUNT)      AS ""covers""	        --aggregate
,SUM(1)                    AS ""checks""	        --aggregate
,ORD.ORDER_TYPE            AS ""revenue_center""
FROM DATAWAREHOUSE.CHEQUE_FACT                              CHF
   INNER JOIN DATAWAREHOUSE.ORDERTYPE_DIM                    ORD
      ON CHF.ORDERTYPE_DIM_FK = ORD.ORDERTYPE_DIM_NK
        AND CHF.DW_ISCURRENTROW
        AND ORD.DW_ISCURRENTROW
        AND CHF.STATUS in (''Closed'')
        AND NOT CHF.IS_TRAINING
        AND NOT CHF.DW_ISDELETED
        AND (CHF.UNPAID = 0 /* OR chk.STATUS = ''Voided''*/)
        AND CHF.LOCATION_DIM_FK IN (--351,352
            SELECT table1.value 
               FROM table(
              split_to_table(:locationidS, '',''))  table1)
        AND (CHF.FISCAL_DATE::date >= :startdate::date 
            AND CHF.FISCAL_DATE::date  <= :enddate::date)
  GROUP BY CHF.LOCATION_DIM_FK
     ,CHF.FISCAL_DATE
     ,ORD.ORDER_TYPE
;

  CREATE TEMP TABLE temp_SALES AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));  
     
--=================================================================================================================================
reportSet := (  
-----------------------------------------------------------------------------------------------------------------------------------
SELECT * FROM temp_SALES  RES
--=================================================================================================================================
);

RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,"SP_REPORT_GIFTCARDAGING(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_GIFTCARDAGING""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- locationid string      := ''[4,352,351,1,2,3,5,6,7]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--================================================================================================================================
BEGIN
--================================================================================================================================
--Find all of the locations for a merchant
DROP TABLE if exists TEMP_LOCS;

SELECT MOD.MERCHANT_DIM_NK
  ,MAX(MOD.MERCHANT) AS ""Merchant""
  FROM DATAADMIN.MERCHANT_DIM             MOD
    INNER JOIN DATAWAREHOUSE.MERCHANT_ORGANIZATION_XREF MOX
      ON MOD.MERCHANT_DIM_NK = MOX.MERCHANT_DIM_FK
        AND MOD.DW_ISCURRENTROW
        AND MOX.DW_ISCURRENTROW
    INNER JOIN DATAWAREHOUSE.ORGANIZATION_DIM           ORG
      ON ORG.ORGANIZATION_DIM_NK = MOX.ORGANIZATION_DIM_FK
        AND ORG.DW_ISCURRENTROW
    INNER JOIN DATAWAREHOUSE.LOCATION_DIM               LOC
      ON LOC.ORGANIZATION_DIM_FK = ORG.ORGANIZATION_DIM_NK
        AND LOC.DW_ISCURRENTROW
        AND LOCATION_DIM_NK in (SELECT table1.value 
        FROM table(split_to_table(:locationidS, '',''))  table1)
    GROUP BY MOD.MERCHANT_DIM_NK;

 CREATE TEMP TABLE TEMP_LOCS AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));  
     
--================================================================================================================================
reportSet := (   
    SELECT gcd.giftcard_dim_nk                                                     AS ""Support ID"" 
       ,''GCA-'' ||row_number() over (order by gcd.giftcard_dim_nk)                  AS ""Detail ID""  
--Status, category, level--------------------------------------------------------------------------------------------------------
--Geography-----------------------------------------------------------------------------------------------------------------------
--No location or revenue center since gift cards are at the merchant level
--Dates-------------------------------------------------------------------------------------------------------------------------
--Dates are utc since gift cards are at merchant level and a location time zone can''t be assigned
       ,IFNULL(TO_CHAR(gcd.CREATED_AT::DATE),''None'')                               AS ""Last Redeemed At""                    
       ,IFNULL(TO_CHAR(gcd.ISSUED_AT::DATE),''None'')                                AS ""Issued At""
       ,IFNULL(TO_CHAR(trn.""Last Reloaded At""::DATE),''None'')                       AS ""Last Reloaded At""  
       ,IFNULL(TO_CHAR(gcd.BALANCE_REQUESTED_AT::DATE),''None'')                     AS ""Last Balance Check At"" 
-- --Flags-----------------------------------------------------------------------------------------------------------------------  
        ,gcd.IS_LEGACY::boolean                                                    AS ""Is Imported""   
        ,IFNULL(gcd.GIFTCARD,''None'')                                               AS ""Gift Card Number"" 
        ,IFNULL(mer.""Merchant"",''None'')                                             AS ""Merchant""
-- --Facts-------------------------------------------------------------------------------------------------------------------------
        ,IFNULL(DATEDIFF(DAY,gcd.ISSUED_AT::date,CURRENT_DATE()::DATE),0)
        ::NUMBER(18,0)                                                             AS ""Days Old"" 
        ,IFNULL(GCD.BALANCE_REQUEST_COUNT,0)::NUMBER(18,0)                         AS ""Balance Check Count"" 
        ,IFNULL(gcd.START_BALANCE,0)::NUMBER(18,2)                                 AS ""Issued Amount""
        ,IFNULL(trn.""Reload Amount"",0)::NUMBER(18,2)                               AS ""Reload Amount""    
        ,IFNULL(trn.""Redeemed Amount"",0)::NUMBER(18,2)                             AS ""Redeemed Amount""   
        ,IFNULL(gcd.BALANCE,0)::NUMBER(18,2)                                       AS ""Balance Amount""                                     
---------------------------------------------------------------------------------------------------------------------------------
    FROM DATAWAREHOUSE.GIFTCARD_DIM                      gcd
      INNER JOIN TEMP_LOCS                               mer
        ON gcd.MERCHANT_DIM_FK = mer.MERCHANT_DIM_NK
          AND gcd.BALANCE > 0.000  
          AND gcd.IS_ISSUED
          AND gcd.DW_ISCURRENTROW
          AND NOT gcd.DW_ISDELETED

      LEFT JOIN (   --LOJ because not all cards will have an issuing transaction(legacy cards) or a relaod or redemption
      
              SELECT gcf.GIFTCARD_DIM_FK
                    ,SUM(CASE WHEN GCF.COMMAND IN (''Reload'',''VoidReload'') THEN 
                       CASE WHEN GCF.OPENING_BALANCE IS  NULL OR GCF.GIFTCARD_DIM_Fk = 1 THEN GCF.TRANSACTION_AMOUNT ELSE GCF.CLOSING_BALANCE - GCF.OPENING_BALANCE  END  ELSE 0 END )  
                                                                              AS ""Reload Amount""
                    ,MAX(CASE WHEN GCF.COMMAND IN (''Reload'',''VoidReload'') THEN CHF.FISCAL_DATE ELSE NULL END)          
                                                                              AS ""Last Reloaded At""  
                    ,SUM(CASE WHEN GCF.COMMAND IN (''Adjust'',''NoNSFSale'',''VoidSale'') THEN 
                          CASE WHEN GCF.OPENING_BALANCE IS NULL OR GCF.GIFTCARD_DIM_Fk = 1  
                            THEN GCF.TRANSACTION_AMOUNT * (-1) ELSE GCF.CLOSING_BALANCE - GCF.OPENING_BALANCE  END  ELSE 0 END )  
                                                                              AS ""Redeemed Amount""  
                    ,MAX(CASE WHEN GCF.COMMAND IN (''Adjust'',''NoNSFSale'',''VoidSale'') THEN CHF.FISCAL_DATE ELSE NULL END)          
                                                                              AS ""Last Redeemed At""                                                  
                  FROM DATAWAREHOUSE.GIFTCARD_DIM                             GCD
                    INNER JOIN TEMP_LOCS                                      LOC
                      ON LOC.MERCHANT_DIM_nK = GCD.MERCHANT_DIM_FK
                         AND GCD.DW_ISCURRENTROW
                         AND GCD.IS_ISSUED
                         AND GCD.BALANCE > 0.0000
                         AND NOT gcd.DW_ISDELETED
                    INNER JOIN DATAWAREHOUSE.GIFTCARDTRANSACTION_FACT          GCF  
                      ON GCD.GIFTCARD_DIM_NK = GCF.GIFTCARD_DIM_FK
                         AND GCF.DW_ISCURRENTROW
                         AND NOT GCF.DW_ISDELETED
                    INNER JOIN DATAWAREHOUSE.CHEQUE_FACT                       CHF
                      ON CHF.CHEQUE_FACT_NK = GCF.CHEQUE_FACT_FK
                          AND CHF.STATUS = ''Closed''
                          AND CHF.DW_ISCURRENTROW
                    GROUP BY gcf.GIFTCARD_DIM_FK
                                                                                        ) trn
                           ON trn.GIFTCARD_DIM_FK = gcd.GIFTCARD_DIM_NK
                               AND gcd.BALANCE > 0.000  
                               AND gcd.IS_ISSUED
                               AND gcd.DW_ISCURRENTROW
                               AND NOT gcd.DW_ISDELETED                    
); 

-----------------------------------------------------------------------------------------------------------------------------------
RETURN TABLE(reportSet);
--=================================================================================================================================
END';"
PROCEDURE,DATAADMIN,"SP_REPORT_LABOR(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_LABOR""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE  --count = 2914
  reportSet resultset;
  -- startdate timestamp_tz := ''2020-07-25'';  
  -- enddate timestamp_tz   := ''2030-07-25''; 
  -- locationid string      := ''[351]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');

-- ============================================================================================= 
-- GRANT usage ON procedure dataadmin.SP_REPORT_LABOR(timestamp_tz,timestamp_tz,string) TO ROLE DATA_REPLICATION_HOSPENG;
--CALL DATAADMIN.SP_REPORT_LABOR(''2024-07-25'',''2024-07-25'',''[351]'');
-- =============================================================================================
BEGIN
  DROP TABLE IF EXISTS TEMP_LABOR;
  DROP TABLE IF EXISTS TEMP_TIPGRAT;
  DROP TABLE IF EXISTS SHIFT_CTE;
  DROP TABLE IF EXISTS BREAK_CTE;
  DROP TABLE IF EXISTS RULE_CTE;

  -- WITH SHIFT_CTE AS (
    SELECT SHD.SHIFT_DIM_PK --|| overtime_fact_nk || fiscal day and week or date                                 
                                                               AS ""Support ID"" 
        ,SHD.SHIFT_DIM_NK                                      AS ""SHIFT_DIM_NK""
    --status, category, level------------------------------------------------------------------
        ,''Shift''                                               AS ""Level""
    --geography--------------------------------------------------------------------------------
        ,IFNULL(loc.LOCATIONNAME,''None'')                       AS ""Location""
        -- ,SHD.LOCATION_DIM_FK                                AS ""Location ID""  
        ,IFNULL(org.organization,''None'')                       AS ""Organization""
    --dates-------------------------------------------------------------------------------------
        ,LOC.TZ_NAME                                            AS ""Time Zone""
        ,TO_CHAR(DATE_PART(YEAR,SHD.CLOCKEDIN_AT::timestamp_ntz ))   
                                                               AS ""Year""
        ,to_char(LEFT(SHD.CLOCKEDIN_AT::timestamp_ntz,7))                     
                                                               AS ""Year and Month""
        ,SHD.CLOCKEDIN_AT::timestamp_ntz                             
                                                               AS ""Clocked In At""
        ,SHD.CLOCKEDOUT_AT::timestamp_ntz                                    
                                                               AS ""Clocked Out At""    
        ,IFNULL(DAYNAME(SHD.CLOCKEDIN_AT::timestamp_ntz),''None'')              
                                                               AS ""Day of Week""
        ,CASE WHEN DAYNAME(SHD.CLOCKEDIN_AT::timestamp_ntz) IN (''Sat'',''Sun'')  
            THEN TRUE ELSE FALSE END                           
                                                               AS ""Is Weekend""
        ,ORG.START_OF_PAYROLL_WEEK_INT                         AS ""Week Offset""
        ,NULL::VARCHAR(20)                                     AS ""Fiscal Week""  
        ,NULL::VARCHAR(20)                                     AS ""Fiscal Week Start"" 
        ,NULL::VARCHAR(20)                                     AS ""Fiscal Week End""
        ,SHD.FISCAL_DAY                                        AS ""Fiscal Day""  
        
        ,DATEADD(DAY,ORG.START_OF_PAYROLL_WEEK_INT 
          + case  ORG.START_OF_PAYROLL_WEEK_INT  when 0 then 1
           when 1 then -1 
           when 2 then -1
           when 3 then -2
           when 4 then -2
           when 5 then -2
           when 6 then -2
           
           else -1  end                                 
          ,SHD.FISCAL_DAY::DATE )                              AS ""Fiscal Day Offset""      
                                                                         
    --flags--------------------------------------------------------------------------------------
        ,SHD.IS_SHIFTCOMPLETE                                  AS ""Is Clocked Out""
        ,SHD.WAS_SYSTEM_CLOCKOUT                               AS ""Was System Clock Out""
        ,SHD.GETS_PAID_BREAK                                   AS ""Gets Paid Break""
    --people------------------------------------------------------------------------------------- 
        ,EMD.EMPLOYEE_NAME                                     AS ""Employee""
        ,EMD.EMPLOYEE_DIM_NK                                   AS ""Employee ID""
        ,SHD.JOBPOSITION_DIM_FK                                AS ""JOBPOSITION_DIM_FK""
        ,SHD.LOCATION_DIM_FK                                   AS ""LOCATION_DIM_FK""  
        ,EMD.PAYROLL_ID                                        AS ""Payroll ID""
        ,SHD.GENERAL_LEDGER                                    AS ""General Ledger Number""
     --Descriptors-------------------------------------------------------------------------------- 
       ,JBP.JOB_POSITION                                       AS ""Job Position""  --(i.e. Bartender, Cook, Server)    
       ,JCD.JOBCATEGORY                                        AS ""Job Category""
       ,SHD.SHIFT                                              AS ""Shift ID""  
       ,SHD.PAY_RATE_BASIS                                     AS ""Pay Basis""
     --Facts-----------------------------------------------------------------------------------------
        ,NULL                                                  AS ""Overtime Rule""
        ,NULL                                                  AS ""Hours Per Day""
        ,NULL                                                  AS ""Seconds Per Day""
        ,NULL                                                  AS ""Hours Per Week""
        ,NULL                                                  AS ""Seconds Per Week""
        ,to_number(1)                                          AS ""Shift Count""
        ,NULL                                                  AS ""Break Count""  
        ,COUNT(SHD.SHIFT) OVER (PARTITION BY SHD.LOCATION_DIM_FK,EMD.EMPLOYEE_DIM_NK,SHD.FISCAL_DAY)  
                                                               AS ""Shift Per Day Count""
        -- ,IFF( SHD.IS_SHIFTCOMPLETE,SHD.SHIFT_SECONDS, 
        --   ROUND(TIMEDIFF(second
        --        ,CONVERT_TIMEZONE(''UTC'',loc.TZ_NAME,shd.CLOCKEDIN_AT::timestamp_ntz )::timestamp
        --     -- ,SHD.CLOCKEDIN_AT::timestamp_ntz 
        --        ,CONVERT_TIMEZONE(''UTC'',loc.TZ_NAME,CURRENT_TIMESTAMP::timestamp_ntz )::timestamp
        --     -- ,CURRENT_TIMESTAMP::timestamp_ntz 
        --       )::Number(38,0),0))
        --                                                        AS ""Shift Seconds""


        ,IFF( SHD.IS_SHIFTCOMPLETE,SHD.SHIFT_SECONDS, 
          ROUND(TIMEDIFF(second
               ,SHD.CLOCKEDIN_AT::timestamp_ntz 
               ,CONVERT_TIMEZONE(''UTC'', CURRENT_TIMESTAMP())::timestamp_ntz
              )::Number(38,0),0))
                                                               AS ""Shift Seconds""

                                                               
        ,NULL                                                  AS ""Break Seconds""


        ,shd.REGULAR_RATE * 1.5::Number(18,2)             
                                                               AS ""Overtime Rate""
        ,shd.REGULAR_RATE::Number(18,2)                        AS ""Regular Rate""
 
        FROM DATAWAREHOUSE.SHIFT_DIM                               SHD
          INNER JOIN DATAWAREHOUSE.LOCATION_DIM                    LOC
             ON SHD.LOCATION_DIM_FK = LOC.LOCATION_DIM_NK
                AND LOC.DW_ISCURRENTROW
                AND SHD.DW_ISCURRENTROW
             
                AND NOT SHD.DW_ISDELETED
                AND NOT SHD.IS_ARCHIVED
                AND shd.fiscal_day::date
                   >= dateadd(DAY,-10,:startdate)::date --calculate data 10 days around selected dates so that  
                AND  shd.fiscal_day::date  
                  <= dateadd(DAY,10,:enddate)::date    --the data in the selected range calcs overtime for full fiscal week
                AND SHD.LOCATION_DIM_FK IN ( SELECT table1.value 
                           FROM table(split_to_table(:locationidS, '',''))  table1)
          INNER JOIN DATAWAREHOUSE.ORGANIZATION_DIM                ORG
            ON LOC.ORGANIZATION_DIM_FK = ORG.ORGANIZATION_DIM_NK
              AND ORG.DW_ISCURRENTROW
          INNER JOIN DATAWAREHOUSE.EMPLOYEE_DIM                    EMD
            ON SHD.EMPLOYEE_DIM_FK = EMD.EMPLOYEE_DIM_NK
              AND EMD.DW_ISCURRENTROW
          INNER JOIN DATAWAREHOUSE.JOBPOSITION_DIM                 JBP
            ON JBP.JOBPOSITION_DIM_NK = SHD.JOBPOSITION_DIM_FK 
              AND JBP.DW_ISCURRENTROW
          INNER JOIN DATAWAREHOUSE.JOBCATEGORY_DIM                 JCD
            ON JBP.JOBCATEGORY_DIM_FK = JCD.JOBCATEGORY_DIM_NK
              AND JCD.DW_ISCURRENTROW
         ORDER BY SHD.CLOCKEDIN_AT DESC ;  

 CREATE TEMP TABLE SHIFT_CTE AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));  
     
UPDATE SHIFT_CTE
  SET ""Fiscal Week Start"" = dateadd(day,dayofweek(""Fiscal Day"") * -1  + ""Week Offset"" - case when dayofweek(""Fiscal Day"") >= ""Week Offset"" then 0 else 7 end
                            ,""Fiscal Day"") 
    ,""Fiscal Week End""    = dateadd(day,6,
                           dateadd(day,dayofweek(""Fiscal Day"") * -1  + ""Week Offset"" - case 
                             when dayofweek(""Fiscal Day"") >= ""Week Offset"" then 0 else 7 end ,""Fiscal Day""))
;

UPDATE SHIFT_CTE
  SET ""Fiscal Week"" = YEAR(""Fiscal Week Start""::date) || ''-'' ||  RIGHT(''0'' || WEEKOFYEAR(""Fiscal Week Start""::date),2);
  
--===========================================================================================           
--    ,BREAK_CTE AS (
        SELECT SHD_1.""Support ID""                               AS ""Support ID"" 
        ,MAX(SHD_1.SHIFT_DIM_NK)                                AS ""SHIFT_DIM_NK""
    --status, category, level------------------------------------------------------------------
        ,''Break''                                                AS ""Level""
    --geography--------------------------------------------------------------------------------
        ,NULL                                                   AS ""Location""
        ,NULL                                                   AS ""Organization""
    -- --dates-------------------------------------------------------------------------------------
        ,MAX(SHD_1.""Time Zone"")                                 AS ""Time Zone""
        ,NULL                                                   AS ""Year""
        ,NULL                                                   AS ""Year and Month""
        ,NULL                                                   AS ""Clocked In At""
        ,NULL                                                   AS ""Clocked Out At""    
        ,NULL                                                   AS ""Day of Week""
        ,NULL                                                   AS ""Is Weekend""
        ,NULL                                                   AS ""Week Offset""
        ,MAX(SHD_1.""Fiscal Week"")                               AS ""Fiscal Week""     
        ,MAX(SHD_1.""Fiscal Week Start"")                         AS ""Fiscal Week Start"" 
        ,MAX(SHD_1.""Fiscal Week End"")                           AS ""Fiscal Week End""
        ,NULL                                                   AS ""Fiscal Day""
        ,NULL                                                   AS ""Fiscal Day Offset""           
    -- --flags--------------------------------------------------------------------------------------
        ,NULL                                                   AS ""Is Clocked Out""
        ,NULL                                                   AS ""Was System Clock Out""
        ,NULL                                                   AS ""Gets Paid Break""
    -- --people------------------------------------------------------------------------------------- 
        ,NULL                                                   AS ""Employee""
        ,NULL                                                   AS ""Employee ID""
        ,NULL                                                   AS JOBPOSITION_DIM_FK
        ,NULL                                                   AS LOCATION_DIM_FK  
        ,NULL                                                   AS ""Payroll ID""
        ,NULL                                                   AS ""General Ledger Number""        
    --  --Descriptors-------------------------------------------------------------------------------- 
        ,NULL                                                   AS ""Job Position""  
        ,NULL                                                   AS ""Job Category""        
        ,NULL                                                   AS ""Pay Basis""
        ,NULL                                                   AS ""Shift ID""  
    -- Facts-----------------------------------------------------------------------------------------
        ,NULL                                                   AS ""Overtime Rule""
        ,NULL                                                   AS ""Hours Per Day""
        ,NULL                                                   AS ""Seconds Per Day""
        ,NULL                                                   AS ""Hours Per Week""
        ,NULL                                                   AS ""Seconds Per Week""
        ,NULL                                                   AS ""Shift Count""
        ,1                                                      AS ""Break Count""   
        ,NULL                                                   AS ""Shift Per Day Count""
        ,0                                                      AS ""Shift Seconds""
        ,SUM(IFF( BRK_1.IS_BREAKCOMPLETE ,BRK_1.BREAK_SECONDS , 
          ROUND(TIMEDIFF(SECOND
            ,BRK_1.START_AT::timestamp_ntz 
            ,CURRENT_TIMESTAMP::timestamp_ntz 
                )::Number(38,0),0)) )                                                  
                                                                AS ""Break Seconds""
     
        ,NULL                                                   AS ""Overtime Rate""
        ,NULL                                                   AS ""Regular Rate""
          FROM SHIFT_CTE                                        SHD_1
            LEFT JOIN DATAWAREHOUSE.SHIFTBREAK_FACT             BRK_1
              ON SHD_1.SHIFT_DIM_NK = BRK_1.SHIFT_DIM_FK
                 AND BRK_1.DW_ISCURRENTROW
                 AND NOT BRK_1.DW_ISDELETED
            GROUP BY SHD_1.""Support ID""  
            ;
    -- )
    
 CREATE TEMP TABLE BREAK_CTE AS 
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));    

--=============================================================================================================     
  --  ,RULE_CTE AS (  ---NOTE:  THIS JOIN SHOULD NOT BE CURRENT ROW...IT SHOULD BE ROW WHERE TIME = SHIFT START
         SELECT SHD_2.""Support ID""                              AS ""Support ID"" 
        ,SHD_2.SHIFT_DIM_NK                                     AS ""SHIFT_DIM_NK""
    --status, category, level------------------------------------------------------------------
        ,''Rule''                                                 AS ""Level""
    --geography--------------------------------------------------------------------------------
        ,NULL                                                   AS ""Location""
        ,NULL                                                   AS ""Organization""
    -- --dates-------------------------------------------------------------------------------------
        ,NULL                                                   AS ""Time Zone""    
        ,NULL                                                   AS ""Year""
        ,NULL                                                   AS ""Year and Month""
        ,NULL                                                   AS ""Clocked In At""
        ,NULL                                                   AS ""Clocked Out At""    
        ,NULL                                                   AS ""Day of Week""
        ,NULL                                                   AS ""Is Weekend""
        ,NULL                                                   AS ""Week Offset""
        ,SHD_2.""Fiscal Week""                                    AS ""Fiscal Week""   
        ,SHD_2.""Fiscal Week Start""                              AS ""Fiscal Week Start"" 
        ,SHD_2.""Fiscal Week End""                                AS ""Fiscal Week End""        
        ,SHD_2.""Fiscal Day""                                     AS ""Fiscal Day""   
        ,SHD_2.""Fiscal Day Offset""                              AS ""Fiscal Day Offset""     
    -- --flags--------------------------------------------------------------------------------------
        ,NULL                                                   AS ""Is Clocked Out""
        ,NULL                                                   AS ""Was System Clock Out""
        ,NULL                                                   AS ""Gets Paid Break""
    -- --people------------------------------------------------------------------------------------- 
        ,NULL                                                   AS ""Employee""
        ,NULL                                                   AS ""Employee ID""        
        ,NULL                                                   AS JOBPOSITION_DIM_FK
        ,NULL                                                   AS LOCATION_DIM_FK 
        ,NULL                                                   AS ""Payroll ID""
        ,NULL                                                   AS ""General Ledger Number""        
    --  --Descriptors-------------------------------------------------------------------------------- 
       ,NULL                                                    AS ""Job Position""  --(i.e. Bartender, Cook, Server) 
       ,NULL                                                    AS ""Job Category""       
       ,NULL                                                    AS ""Pay Basis""
       ,NULL                                                    AS ""Shift ID""       
    -- Facts-----------------------------------------------------------------------------------------
        ,OLT.OVERTIMERULE                                       AS ""Overtime Rule""
        ,CASE WHEN OLT.HOURS_PER_DAY = 0 or :locationidS in (''[3]'',''[4]'',''[5]'')
            THEN 999999999 ELSE  OLT.HOURS_PER_DAY END                                      
                                                                AS ""Hours Per Day""
        ,CASE WHEN OLT.HOURS_PER_DAY = 0 or :locationidS in (''[3]'',''[4]'',''[5]'')
            THEN 999999999 ELSE  OLT.HOURS_PER_DAY END * 60 * 60                                 
                                                                AS ""Seconds Per Day""
                                                                
        ,CASE WHEN OLT.HOURS_PER_WEEK = 0  THEN 999999999 ELSE OLT.HOURS_PER_WEEK END                                     
                                                                AS ""Hours Per Week""

         ,CASE WHEN OLT.HOURS_PER_WEEK = 0  THEN 999999999 ELSE OLT.HOURS_PER_WEEK * 60 * 60 END                                                                  
                                                                AS ""Seconds Per Week""
        
        ,NULL                                                   AS ""Shift Count""
        ,0                                                      AS ""Break Count""   
        ,NULL                                                   AS ""Shift Per Day Count""
        ,0                                                      AS ""Shift Seconds""
        ,NULL                                                   AS ""Break Seconds""
     
        ,NULL                                                   AS ""Overtime Rate""
        ,NULL                                                   AS ""Regular Rate""
          FROM SHIFT_CTE                                        SHD_2
            INNER JOIN OVERTIMELABORRULE_JOBPOSITION_XREF       OJX
           ON OJX.JOBPOSITION_DIM_FK = SHD_2.JOBPOSITION_DIM_FK
             AND OJX.DW_ISCURRENTROW
         INNER JOIN DATAWAREHOUSE.OVERTIMELABORRULE_DIM             OLT
            ON SHD_2.LOCATION_DIM_FK = OLT.LOCATION_DIM_FK
              AND OLT.OVERTIMELABORRULE_DIM_NK = OJX.OVERTIMELABORRULE_DIM_FK
              AND OLT.DW_ISCURRENTROW  
              AND NOT OLT.DW_ISDELETED
              AND OLT.IS_ACTIVE
              ;
   -- )  --end of cte tables
 CREATE TEMP TABLE RULE_CTE AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));  
     
    --=========================================================================================
    SELECT to_char(UNI_2.""Support ID"")              as ""Support ID""
    , ''LAB-'' ||row_number() over (order by UNI_2.""Shift ID"") 
                                                    as ""Detail ID""  
    ,UNI_2.""Location""
    ,UNI_2.location_dim_fk                          as ""Location ID""
    ,UNI_2.""Time Zone""
    ,UNI_2.""Year""
    ,UNI_2.""Year and Month""
    ,CONVERT_TIMEZONE(''UTC'',UNI_2.""Time Zone"",UNI_2.""Clocked In At""::timestamp_ntz )::timestamp 
    --,UNI_2.""Clocked In At""
                                                     as ""Clocked In At""
    ,CONVERT_TIMEZONE(''UTC'',UNI_2.""Time Zone"",UNI_2.""Clocked Out At""::timestamp_ntz )::timestamp                                                      
    --,UNI_2.""Clocked Out At""
                                                     as ""Clocked Out At""

---------------------------------
    ,to_varchar(CONVERT_TIMEZONE(''UTC'',UNI_2.""Time Zone"",UNI_2.""Clocked In At""::timestamp_ntz )::timestamp,''HH12:MI:SS'')
                                                      as ""Clock In Time""
    ,to_varchar(CONVERT_TIMEZONE(''UTC'',UNI_2.""Time Zone"",UNI_2.""Clocked Out At""::timestamp_ntz )::timestamp,''HH12:MI:SS'')
                                                      as ""Clock Out Time""                                                      
---------------------------------
    ,UNI_2.""Day of Week""
    ,UNI_2.""Is Weekend""
    ,UNI_2.""Fiscal Week""
    ,UNI_2.""Fiscal Week Start""
    ,UNI_2.""Fiscal Week End""
    ,to_char(UNI_2.""Fiscal Day"")                      as ""Fiscal Day""
    ,UNI_2.""Is Clocked Out""
    ,UNI_2.""Was System Clock Out""
    ,UNI_2.""Employee""
    ,TO_VARCHAR(UNI_2.""Employee ID"")                  as ""Employee ID""
    ,UNI_2.""Payroll ID""                               as ""Payroll ID""
    ,UNI_2.""General Ledger Number""                    as ""General Ledger Number"" 
    ,UNI_2.""Job Position""
    ,UNI_2.""Job Category""
    ,UNI_2.""Pay Basis""
    ,''Shift '' ||UNI_2.""Shift ID""::decimal(18,0)       as ""Shift ID""
    ,UNI_2.""Overtime Rule""
    ,UNI_2.""Overtime Rate""::NUMBER(18,2)              as ""Overtime Rate""
    ,UNI_2.""Regular Rate"" ::NUMBER(18,2)              as ""Regular Rate""
    --=======================================================================  
    ,UNI_2.""Shift Seconds""::NUMBER(18,0)              as ""Shift Seconds""
    ,UNI_2.""Break Seconds""::NUMBER(18,0)              as ""Break Seconds""
    ,UNI_2.""Seconds Per Week""::NUMBER(18,0)           as ""Weekly Overtime Rule Seconds""
    ,UNI_2.""Seconds Per Day"" ::NUMBER(18,0)           as ""Daily Overtime Rule Seconds""
--===================== ====================================================================================
   -- ,UNI_2.""Shift Regular Seconds""::NUMBER(18,0)    as ""Regular Seconds""

   --    ,IFF(UNI_2.""Day Regular Seconds Running Total"" > UNI_2.""Seconds Per Week"" 
   --      AND UNI_2.""Seconds Per Week"" IS NOT NULL
   --          ,IFF(UNI_2.""Seconds Per Week"" <
   --               LAG(UNI_2.""Day Regular Seconds Running Total"") 
   --                 OVER (PARTITION BY  UNI_2.""Employee"", UNI_2.""Fiscal Week""  ORDER BY UNI_2.""Clocked In At"")
   --              ,UNI_2.""Shift Regular Seconds""
   --              ,UNI_2.""Day Regular Seconds Running Total"" - UNI_2.""Seconds Per Week""
   --              )   
   --          ,UNI_2.""Shift Day Overtime Seconds"") ::NUMBER(18,0)                                                      
   --                                                    as ""Overtime Seconds"" 

   ,UNI_2.""Shift Regular Seconds""::NUMBER(18,0)       
     -
    IFF(UNI_2.""Day Regular Seconds Running Total"" > UNI_2.""Seconds Per Week"" 
        AND UNI_2.""Seconds Per Week"" IS NOT NULL
            ,IFF(UNI_2.""Seconds Per Week"" <
                 LAG(UNI_2.""Day Regular Seconds Running Total"") 
                   OVER (PARTITION BY  UNI_2.""Employee"", UNI_2.""Fiscal Week""  ORDER BY UNI_2.""Clocked In At"")
                ,UNI_2.""Shift Regular Seconds""
                ,UNI_2.""Day Regular Seconds Running Total"" - UNI_2.""Seconds Per Week""
                )   
            ,UNI_2.""Shift Day Overtime Seconds"") ::NUMBER(18,0) 

     
       as ""Regular Seconds""
--=====================  ===================================================================================
   -- ,UNI_2.""Day Regular Seconds Running Total""
   -- -- -- ,UNI_2.""Shift Day Overtime Seconds""
   -- -- -- ,UNI_2.""Seconds Per Week""
   -- ,LAG(UNI_2.""Day Regular Seconds Running Total"") 
   --                 OVER (PARTITION BY  UNI_2.""Employee"", UNI_2.""Fiscal Week""  ORDER BY UNI_2.""Clocked In At"")           
   --                                                 as ""Last Running Total""
                                                   
   ,IFF(UNI_2.""Day Regular Seconds Running Total"" > UNI_2.""Seconds Per Week"" 
        AND UNI_2.""Seconds Per Week"" IS NOT NULL
            ,IFF(UNI_2.""Seconds Per Week"" <
                 LAG(UNI_2.""Day Regular Seconds Running Total"") 
                   OVER (PARTITION BY  UNI_2.""Employee"", UNI_2.""Fiscal Week""  ORDER BY UNI_2.""Clocked In At"")
                ,UNI_2.""Shift Regular Seconds""
                ,UNI_2.""Day Regular Seconds Running Total"" - UNI_2.""Seconds Per Week""
                )   
            ,UNI_2.""Shift Day Overtime Seconds"") ::NUMBER(18,0)                                                      
                                                      as ""Overtime Seconds"" 

--======================================================================================
 ,floor(UNI_2.""Shift Regular Seconds""/60/60/24) || '' D '' ||
       floor(UNI_2.""Shift Regular Seconds""/60/60%24) || '':'' ||
       floor(UNI_2.""Shift Regular Seconds""/60%60) || '':'' ||
       floor(UNI_2.""Shift Regular Seconds""%60)         as ""Regular D H:M:S""


 ,floor(IFF(UNI_2.""Day Regular Seconds Running Total"" > UNI_2.""Seconds Per Week"" 
                       AND UNI_2.""Seconds Per Week"" IS NOT NULL
                        ,UNI_2.""Day Regular Seconds Running Total"" - UNI_2.""Seconds Per Week""
                        ,UNI_2.""Shift Day Overtime Seconds"") ::NUMBER(18,0)/60/60/24) || '' D '' ||
       floor(IFF(UNI_2.""Day Regular Seconds Running Total"" > UNI_2.""Seconds Per Week"" 
                       AND UNI_2.""Seconds Per Week"" IS NOT NULL
                        ,UNI_2.""Day Regular Seconds Running Total"" - UNI_2.""Seconds Per Week""
                        ,UNI_2.""Shift Day Overtime Seconds"") ::NUMBER(18,0)/60/60%24) || '':'' ||
       floor(IFF(UNI_2.""Day Regular Seconds Running Total"" > UNI_2.""Seconds Per Week"" 
                       AND UNI_2.""Seconds Per Week"" IS NOT NULL
                        ,UNI_2.""Day Regular Seconds Running Total"" - UNI_2.""Seconds Per Week""
                        ,UNI_2.""Shift Day Overtime Seconds"") ::NUMBER(18,0)/60%60) || '':'' ||
       floor(IFF(UNI_2.""Day Regular Seconds Running Total"" > UNI_2.""Seconds Per Week"" 
                       AND UNI_2.""Seconds Per Week"" IS NOT NULL
                        ,UNI_2.""Day Regular Seconds Running Total"" - UNI_2.""Seconds Per Week""
                        ,UNI_2.""Shift Day Overtime Seconds"") ::NUMBER(18,0)%60)         as ""Overtime D H:M:S""  
  ,null ::NUMBER(18,2)                                                                  as ""Tips""           
  ,null ::NUMBER(18,2)                                                                  as ""Gratuities""        
--======================================================================================
      FROM(
            SELECT UNI_1.* 
                   ,SUM(IFF(UNI_1.""Shift Seconds"" < UNI_1.""Seconds Per Day""
                       OR UNI_1.""Seconds Per Day"" IS NULL
                        ,UNI_1.""Shift Seconds"" 
                        ,UNI_1.""Seconds Per Day"" )) 
                            OVER (PARTITION BY UNI_1.LOCATION_DIM_FK,UNI_1.""Employee ID"" ,UNI_1.""Fiscal Week"" ORDER BY UNI_1.""Shift ID"" 
                    )                                                             AS ""Day Regular Seconds Running Total"" 
                
                    ,IFF(UNI_1.""Seconds Per Day"" < UNI_1.""Shift Seconds""  
                         AND UNI_1.""Seconds Per Day"" IS NOT NULL
                        ,UNI_1.""Seconds Per Day""
                        ,UNI_1.""Shift Seconds"" 
                         )                                 AS ""Shift Regular Seconds"" 
                        
                    ,IFF(UNI_1.""Shift Seconds"" > UNI_1.""Seconds Per Day"" 
                       AND UNI_1.""Seconds Per Day"" IS NOT NULL
                        ,UNI_1.""Shift Seconds"" - UNI_1.""Seconds Per Day"" 
                        ,0)                                                        AS ""Shift Day Overtime Seconds"" 
                                                                                
              FROM (
              SELECT UNI_0.* 
               -- ,CASE WHEN UNI_0.""Shift Per Day Count"" > 1 
               --    THEN SUM(UNI_0.""Shift - Break Seconds"") 
               --       OVER (PARTITION BY LOCATION_DIM_FK,""Employee ID"" ,""Fiscal Day""   --see ""Running Total Each Fiscal Day Seconds""below
               --          ORDER BY ""Shift ID"") 
               --       ELSE UNI_0.""Shift - Break Seconds""   END                        AS ""Shift Seconds""

                      ,UNI_0.""Shift - Break Seconds""                                    AS ""Shift Seconds""    --mod 2024/09/09 yyy

                  ,SUM(UNI_0.""Shift - Break Seconds"") OVER (PARTITION BY LOCATION_DIM_FK,""Employee ID"" ,""Fiscal Day"" 
                        ORDER BY ""Shift ID"")                                                                                                                                                                                            AS ""Running Total Each Fiscal Day Seconds""
                 FROM (
                      SELECT  UNI.""Support ID""                                       AS ""Support ID"" 
                    --status, category, level------------------------------------------------------------------
                    --geography--------------------------------------------------------------------------------
                        ,MAX(UNI.""Location"")                                         AS ""Location""
                        ,MAX(UNI.""Organization"")                                     AS ""Organization""
                    -- --dates-----------------------------------------------------------------------------------
                        ,MAX(UNI.""Time Zone"")                                        AS ""Time Zone""
                        ,MAX(UNI.""Year"")                                             AS ""Year""
                        ,MAX(UNI.""Year and Month"")                                   AS ""Year and Month""
                        ,MAX(UNI.""Clocked In At"")                                    AS ""Clocked In At""
                        ,MAX(UNI.""Clocked Out At"")                                   AS ""Clocked Out At""    
                        ,MAX(UNI.""Day of Week"")                                      AS ""Day of Week""
                        ,MAX(UNI.""Is Weekend"")                                       AS ""Is Weekend""
                        ,MAX(UNI.""Week Offset"")                                      AS ""Week Offset""
                        ,MAX(UNI.""Fiscal Week"")                                      AS ""Fiscal Week""    
                        ,MAX(UNI.""Fiscal Week Start"")                                AS ""Fiscal Week Start""   
                        ,MAX(UNI.""Fiscal Week End"")                                  AS ""Fiscal Week End""   
                        ,MAX(UNI.""Fiscal Day"")                                       AS ""Fiscal Day""    
                    -- --flags--------------------------------------------------------------------------------------
                        ,MAX(UNI.""Is Clocked Out"")                                   AS ""Is Clocked Out""
                        ,MAX(UNI.""Was System Clock Out"")                             AS ""Was System Clock Out""
                        ,MAX(UNI.""Gets Paid Break"")                                  AS ""Gets Paid Break""
                        ,CASE WHEN MAX(UNI.""Overtime Rule"") IS NULL THEN FALSE ELSE TRUE END                     
                                                                                     AS ""Gets Overtime""        
                    -- --people------------------------------------------------------------------------------------- 
                        ,MAX(UNI.""Employee"")                                         AS ""Employee""
                        ,MAX(UNI.""Employee ID"")                                      AS ""Employee ID""
                        ,MAX(UNI.JOBPOSITION_DIM_FK)                                 AS JOBPOSITION_DIM_FK
                        ,MAX(UNI.LOCATION_DIM_FK)                                    AS LOCATION_DIM_FK    
                        ,MAX(UNI.""Payroll ID"")                                       AS ""Payroll ID""
                        ,MAX(UNI.""General Ledger Number"")                            AS ""General Ledger Number""
                    --  --Descriptors-------------------------------------------------------------------------------- 
                        ,MAX(UNI.""Job Position"")                                     AS ""Job Position""  --(i.e. Bartender, Cook, Server)   
                        ,MAX(UNI.""Job Category"")                                     AS ""Job Category""  --(i.e. Bartender, Cook, Server)                        
                        ,MAX(UNI.""Pay Basis"")                                        AS ""Pay Basis""
                        ,MAX(UNI.""Shift ID"")                                         AS ""Shift ID""  
                    -- Facts-----------------------------------------------------------------------------------------
                        ,IFNULL(MAX(UNI.""Overtime Rule""),''None'')                     AS ""Overtime Rule""
                        ,MAX(UNI.""Hours Per Day"")                                    AS ""Hours Per Day""
                        ,MAX(UNI.""Hours Per Week"")                                   AS ""Hours Per Week""
                        ,MAX(UNI.""Shift Count"")                                      AS ""Shift Count""
                        ,MAX(UNI.""Break Count"")                                      AS ""Break Count"" 

                        ,MAX(UNI.""Shift Per Day Count"")                              AS ""Shift Per Day Count""
          
                        ,IFNULL(MAX(UNI.""Break Seconds""),0)                          AS ""Break Seconds""
                        ,MAX(UNI.""Overtime Rate"")                                    AS ""Overtime Rate""
                        ,MAX(UNI.""Regular Rate"")                                     AS ""Regular Rate""
                        ,MAX(UNI.""Seconds Per Week"")                                 AS ""Seconds Per Week""
                        ,MAX(UNI.""Seconds Per Day"")                                  AS ""Seconds Per Day""                    
                        ,MAX(UNI.""Shift Seconds"")                                    AS ""Shift Total Seconds""
                        ,MAX(UNI.""Shift Seconds"") 
                           - IFF(MAX(UNI.""Gets Paid Break""),IFNULL(MAX(UNI.""Break Seconds""),0),0)                                    
                                                                                     AS ""Shift - Break Seconds""
                        FROM (
                            SELECT * FROM SHIFT_CTE 
                              UNION
                            SELECT * FROM BREAK_CTE  
                              UNION
                            SELECT * FROM RULE_CTE
                
                        )                                                   UNI
                        GROUP BY ""Support ID""
                                                                             ) UNI_0
                   
                                                                                )  UNI_1
                                                                                    
                                                                                        )UNI_2

  -- WHERE UNI_2.""Fiscal Day""::date
  --     >= :startdate::date --return only selected dates with ot calculated for a full fiscal week
  --   AND UNI_2.""Fiscal Day""::date
  --     <= :enddate::date 

;

--====================================================================================================================
CREATE TEMP TABLE TEMP_LABOR AS
             SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));  

ALTER TABLE TEMP_LABOR ADD COLUMN ""Net Sales"" SMALLINT DEFAULT 0;
             
--====================================================================================================================             
SELECT 
    TO_CHAR(INLT1.""Support ID"")                                    AS ""Support ID""
    ,''TGR-'' ||row_number() over (order by INLT1.""Support ID"")      AS ""Detail ID""
    ,IFNULL(INLT1.LOCATIONNAME,''None'')                             AS ""Location""
    ,INLT1.LOCATION_DIM_NK                                         AS ""Location ID""
    ,INLT1.TZ_NAME                                                 AS ""Time Zone""
    ,TO_CHAR(DATE_PART(YEAR,INLT1.FISCAL_DATE))                    AS ""Year""
    ,LEFT(TO_CHAR(INLT1.FISCAL_DATE),7)                            AS ""Year and Month""
    ,NULL                                                          AS ""Clocked In At""
    ,NULL                                                          AS ""Clocked Out At""
    ,NULL                                                          AS ""Clock In Time""
    ,NULL                                                          AS ""Clock Out Time""
    ,IFNULL(DAYNAME(INLT1.FISCAL_DATE::DATE),''None'')               AS ""Day of Week""
    ,CASE WHEN DAYNAME(INLT1.FISCAL_DATE::DATE) IN (''Sat'',''Sun'')  
                THEN TRUE ELSE FALSE END                           AS ""Is Weekend"" 
    ,YEAR(TIMESTAMPADD(DAY
        ,CASE WHEN INLT1.START_OF_PAYROLL_WEEK_INT = 0 
            THEN INLT1.START_OF_PAYROLL_WEEK_INT
            ELSE INLT1.START_OF_PAYROLL_WEEK_INT -1
         END
        ,INLT1.FISCAL_DATE::DATE)) || ''-'' ||
     WEEKOFYEAR(TIMESTAMPADD(DAY
         ,CASE WHEN INLT1.START_OF_PAYROLL_WEEK_INT = 0 
            THEN INLT1.START_OF_PAYROLL_WEEK_INT
            ELSE INLT1.START_OF_PAYROLL_WEEK_INT -1
         END
         ,INLT1.FISCAL_DATE::DATE))    
                                                                   AS ""Fiscal Week""
    ,NULL::date                                                    AS ""Fiscal Week Start""      
    ,NULL::date                                                    AS ""Fiscal Week End""    
    ,INLT1.START_OF_PAYROLL_WEEK_INT                               AS ""Week Offset""
    ,INLT1.FISCAL_DATE                                             AS ""Fiscal Day""
    ,NULL                                                          AS ""Is Clocked Out""
    ,NULL                                                          AS ""Was System Clock Out""
    ,INLT1.EMPLOYEE_NAME                                           AS ""Employee""
    ,INLT1.""Employee ID""                                           AS ""Employee ID""
    ,INLT1.""Payroll ID""                                            AS ""Payroll ID""
    ,INLT1.""General Ledger Number""                                 AS ""General Ledger Number"" 
    ,INLT1.""Job Position""                                          AS ""Job Position""
    ,INLT1.""Job Category""                                          AS ""Job Category""
    ,INLT1.""Pay Basis""                                             AS ""Pay Basis""
    ,to_char(INLT1.SHIFT)                                          AS ""Shift ID""
    ,NULL                                                          AS ""Overtime Rule""
    ,NULL::NUMBER(18,2)                                            AS ""Overtime Rate""
    ,NULL::NUMBER(18,2)                                            AS ""Regular Rate""
    ,NULL::NUMBER(18,0)                                            AS ""Shift Seconds""
    ,NULL::NUMBER(18,0)                                            AS ""Break Seconds""
    ,NULL::NUMBER(18,0)                                            AS aily
    ,NULL::NUMBER(18,0)                                            AS ""Daily Overtime Rule Seconds""
    ,NULL::NUMBER(18,0)                                            AS ""Regular Seconds""
    ,NULL::NUMBER(18,0)                                            AS ""Overtime Seconds""
    ,NULL                                                          AS ""Regular D H:M:S""
    ,NULL                                                          AS ""Overtime D H:M:S""
    ,INLT1.TIP::NUMBER(18,2)                                       AS ""Tips""
    ,INLT1.GRATUITIES::NUMBER(18,2)                                AS ""Gratuities""
    ,INLT1.""Net Sales"" ::NUMBER(18,2)                              AS ""Net Sales""    
    -------------------------------------------------------------------------------------------- 
    FROM (
    SELECT  TO_CHAR(MAX(chk.CHEQUE_FACT_NK))                      AS ""Support ID""
           ,CHK.FISCAL_DATE                                       AS FISCAL_DATE
           ,EMD.EMPLOYEE_NAME                                     AS EMPLOYEE_NAME
           ,EMD.EMPLOYEE_DIM_NK                                   AS ""Employee ID""
           ,EMD.PAYROLL_ID                                        AS ""Payroll ID""
           ,SHD.""General Ledger Number""                           AS ""General Ledger Number""
           ,SHD.""Job Position""                                    AS ""Job Position""
           ,SHD.""Job Category""                                    AS ""Job Category""
           ,SHD.""Pay Basis""                                       AS ""Pay Basis""
           
           ,LOC.TZ_NAME                                           AS TZ_NAME
           ,LOC.LOCATIONNAME                                      AS LOCATIONNAME
           ,LOC.LOCATION_DIM_NK                                   AS LOCATION_DIM_NK
           ,''Shift '' || SHD.""Shift ID""                            AS SHIFT
           ,MAX(ORG.START_OF_PAYROLL_WEEK_INT)                    AS START_OF_PAYROLL_WEEK_INT
           ,SUM(CHK.TIP)::NUMBER(18,2)                            AS TIP
           ,SUM(CHK.GRATUITIES)::NUMBER(18,2)                     AS GRATUITIES
           ,SUM(CHK.GROSS - CHK.DISCOUNT) ::NUMBER(18,2)          AS ""Net Sales""           

        FROM DATAWAREHOUSE.CHEQUE_FACT                                chk
             INNER JOIN DATAWAREHOUSE.LOCATION_DIM                    loc
                ON chk.LOCATION_DIM_FK = loc.LOCATION_DIM_NK
                    AND loc.DW_ISCURRENTROW
                    AND chk.STATUS = ''Closed''
                    AND NOT chk.IS_TRAINING
                    AND chk.DW_ISCURRENTROW  
                    AND NOT chk.DW_ISDELETED
                    AND NOT chk.IS_TRAINING
                    AND chk.FISCAL_DATE::date   >= :startdate::date
                    AND chk.FISCAL_DATE::date   <= :enddate::date
                    AND chk.LOCATION_DIM_FK IN ( SELECT table1.value 
                           FROM table(split_to_table(:locationidS, '',''))  table1)
              INNER JOIN DATAWAREHOUSE.ORGANIZATION_DIM                 ORG
                    ON LOC.ORGANIZATION_DIM_FK = ORG.ORGANIZATION_DIM_NK
                      AND ORG.DW_ISCURRENTROW
              INNER JOIN DATAWAREHOUSE.EMPLOYEE_DIM                     emd
                    ON emd.EMPLOYEE_DIM_NK = chk.EMPLOYEE_DIM_FK
                       AND emd.DW_ISCURRENTROW  
              LEFT JOIN SHIFT_CTE                                       shd
                    ON shd.""Shift ID"" = chk.shift_dim_fk
             GROUP BY CHK.FISCAL_DATE
                   ,EMD.EMPLOYEE_NAME
                   ,EMD.EMPLOYEE_DIM_NK
                   ,EMD.PAYROLL_ID
                   ,LOC.TZ_NAME
                   ,LOC.LOCATIONNAME
                   ,LOC.LOCATION_DIM_NK
                   ,SHD.""Shift ID""
                   ,SHD.""General Ledger Number"" 
                   ,SHD.""Job Position"" 
                   ,SHD.""Job Category""
                   ,SHD.""Pay Basis""
    ) INLT1        
;
--====================================================================================================================
CREATE TEMP TABLE TEMP_TIPGRAT AS
             SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID())); 
-- select* from TEMP_TIPGRAT
-- -------------------------------------------------------------------------------------------------------------------
UPDATE TEMP_TIPGRAT
  SET ""Fiscal Week Start"" = dateadd(day,dayofweek(""Fiscal Day"") * -1  + ""Week Offset"" - case when dayofweek(""Fiscal Day"") >= ""Week Offset"" then 0 else 7 end
                            ,""Fiscal Day"") 
    ,""Fiscal Week End""    = dateadd(day,6,
                           dateadd(day,dayofweek(""Fiscal Day"") * -1  + ""Week Offset"" - case 
                             when dayofweek(""Fiscal Day"") >= ""Week Offset"" then 0 else 7 end ,""Fiscal Day""))
;

UPDATE TEMP_TIPGRAT
  SET ""Fiscal Week"" = YEAR(""Fiscal Week Start""::date) || ''-'' ||  RIGHT(''0'' || WEEKOFYEAR(""Fiscal Week Start""::date),2);
  
-- ------------------------------------------------------------------------------------------------------------------- 

ALTER TABLE TEMP_TIPGRAT DROP COLUMN ""Week Offset"";

--====================================================================================================================
reportSet := (    

  SELECT MIN(""Support ID"")                    AS ""Support ID""
        ,MIN(""Detail ID"")                     AS ""Detail ID""
        ,""Location""                           AS ""Location""
        ,""Location ID"" ::DECIMAL(18,0)        AS ""Location ID""        
        ,MAX(""Time Zone"")                     AS ""Time Zone""
        ,MAX(""Year"")                          AS ""Year""
        ,MAX(""Year and Month"")                AS ""Year and Month""
        ,to_char(MAX(""Clocked In At""))        AS ""Clocked In At""
        ,to_char(MAX(""Clocked Out At""))       AS ""Clocked Out At""
        ,to_char(MAX(""Clock In Time""))        AS ""Clock In Time""
        ,to_char(MAX(""Clock Out Time""))       AS ""Clock Out Time""
        ,MAX(""Day of Week"")                   AS ""Day of Week""
        ,MAX(""Is Weekend"")                    AS ""Is Weekend""
        ,MAX(""Fiscal Week"")                   AS ""Fiscal Week""
        ,to_char(""Fiscal Day"")                AS ""Fiscal Day""

        ,MAX(""Is Clocked Out"")                AS ""Is Clocked Out""
        ,MAX(""Was System Clock Out"")          AS ""Was System Clock Out""
        ,""Employee""                           AS ""Employee""
        ,""Employee ID""::NUMBER(18,0)          AS ""Employee ID""
        ,""Payroll ID""                         AS ""Payroll ID""
        ,""General Ledger Number""              AS ""General Ledger Number""
        
        ,MAX(""Job Position"")                  AS ""Job Position""
        ,MAX(""Job Category"")                  AS ""Job Category""        
        ,MAX(""Pay Basis"")                     AS ""Pay Basis""
        ,""Shift ID""                           AS ""Shift ID""       
        ,MAX(""Overtime Rule"")                 AS ""Overtime Rule""
        ,MAX(""Overtime Rate"")                 AS ""Overtime Rate""
        ,MAX(""Regular Rate"")                  AS ""Regular Rate""
        ,SUM(""Shift Seconds"")::NUMBER(18,0)   AS ""Shift Seconds""
        ,SUM(""Break Seconds"")::NUMBER(18,0)   AS ""Break Seconds""
        ,MAX(""Weekly Overtime Rule Seconds"")  AS ""Weekly Overtime Rule Seconds""
        ,MAX(""Daily Overtime Rule Seconds"")   AS ""Daily Overtime Rule Seconds"" 
        ,SUM(""Regular Seconds"")::NUMBER(18,0) AS ""Regular Seconds""
        ,SUM(""Overtime Seconds"")::NUMBER(18,0)AS ""Overtime Seconds""
        ,MAX(""Regular D H:M:S"")               AS ""Regular D H:M:S""
        ,MAX(""Overtime D H:M:S"")              AS ""Overtime D H:M:S""
        ,SUM(IFNULL(""Net Sales"",0))::NUMBER(18,2)       AS ""Net Sales""
        ,SUM(IFNULL(""Tips"",0)) ::NUMBER(18,2)           AS ""Tips""
        ,SUM(IFNULL(""Gratuities"",0))::NUMBER(18,2)      AS ""Gratuities"" 
    FROM (
  SELECT * FROM TEMP_LABOR
    UNION ALL
  SELECT * FROM TEMP_TIPGRAT --where  ""Tips"" <> 0.0 or ""Gratuities"" <> 0.00
  )  
 
  WHERE ""Fiscal Day""::date
      >= :startdate::date --return only selected dates with ot calculated for a full fiscal week
    AND ""Fiscal Day""::date
      <= :enddate::date 
  GROUP BY ""Shift ID"",""Location"",""Location ID"",""Employee"",""Employee ID"",""Payroll ID"",""General Ledger Number"",""Fiscal Day"",""Support ID""
  ORDER BY ""Fiscal Day""
); 
----------------------------------------------------------------------------------------------------------------------
RETURN TABLE(reportSet);
--====================================================================================================================
END';"
PROCEDURE,DATAADMIN,"SP_REPORT_TIPGRAT(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_TIPGRAT""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS '
-- ========================================================================================
--Example Call Statement
-- CALL DATAADMIN.SP_REPORTDATAGROOM(''SP_REPORT_TIPGRAT'',365,351);--------------------
-- CALL DATAADMIN.SP_REPORT_TIPGRAT(''2000-11-20T14:48:37.661Z'',''2027-11-20T14:48:37.661Z'',''[351,400,403,352,501,357]'');
-- GRANT usage ON procedure dataadmin.SP_REPORT_TIPGRAT(timestamp_tz,timestamp_tz,string) TO ROLE DATA_REPLICATION_HOSPENG;
-- ========================================================fis=================================
DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2000-11-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2029-11-20T14:48:37.661Z''; 
  -- locationid string      := ''[351,352]'';
  locationidS string        :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--=========================================================================================
BEGIN
 reportSet:= (
SELECT CHEQUE_FACT_NK                                        as ""Support ID"" 
    , ''TIG-'' ||row_number() over (order by CHEQUE_FACT_NK) 
                                                          as ""Detail ID""  
--status, category, level-------------------------------------------------------------------
    -- ,IFNULL(chk.CHECKSTATUS,''None'')                       as ""Check Status""
    -- ,IFNULL(chk.ITEMSTATUS,''None'')                        as ""Item Status""
    -- ,IFNULL(meg.REPORTCATEGORY,''None'')                 as ""Category""
-- --geography-------------------------------------------------------------------------------- 
    ,IFNULL(loc.LOCATIONNAME,''None'')                      as ""Location""
    ,IFNULL(chk.REVENUECENTERNAME,''None'')                 as ""Revenue Center""
-- --dates-------------------------------------------------------------------------------------
    ,LOC.TZ_NAME                                          as ""Time Zone""
    ,to_char(LEFT(
    chk.CLOSED_AT::timestamp_ntz 
    ,4))                                                  as ""Year""
    ,to_char(LEFT(
    chk.CLOSED_AT::timestamp_ntz 
    ,7))                                                  as ""Year and Month""
    ,IFNULL(dad.DAYPART,''None'')                           as ""Daypart""
    ,chk.CLOSED_AT::timestamp_ntz 
                                                          as ""Closed At""
    ,chk.FISCAL_DATE::date 
                                                          as ""Fiscal Date""
    ,IFNULL(DAYNAME(
    chk.CLOSED_AT::timestamp_ntz 
    ),'' None'') 
                                                          as ""Day of Week""
    ,CASE WHEN DAYNAME(
    chk.CLOSED_AT::timestamp_ntz 
    ) IN (''Sat'',''Sun'')  
    THEN TRUE ELSE FALSE END                              as ""Is Weekend""
    ,YEAR(chk.CLOSED_AT) || ''- Week '' || WEEKOFYEAR(chk.CLOSED_AT)    as ""Year and Week"" 
-- --flags--------------------------------------------------------------------------------------
-- --people-------------------------------------------------------------------------------------
    ,emd.EMPLOYEE_NAME
-- --Descriptors-------------------------------------------------------------------------------- 
    ,IFNULL(chk.chequenumber ,''None'')                     as ""Check""
-- --Facts-----------------------------------------------------------------------------------------
    ,1::NUMBER(18,0)                                      as ""Count""
    ,IFNULL(chk.tip,0)::NUMBER(18,2)                      as ""Tip Amount""
    ,IFNULL(chk.GRATUITIES,0)::NUMBER(18,2)               as ""Gratuity Amount""
--------------------------------------------------------------------------------------------   
FROM DATAADMIN.CHEQUE_FACT                                chk
      INNER JOIN DATAADMIN.LOCATION_DIM                   loc
        ON chk.LOCATION_DIM_FK = loc.LOCATION_DIM_NK
          AND loc.DW_ISCURRENTROW
          AND chk.STATUS = ''Closed''
          AND chk.OPENED_AT is not null
          AND chk.DW_ISCURRENTROW  
          AND NOT chk.DW_ISDELETED
          AND NOT chk.IS_TRAINING
          AND chk.CLOSED_AT::timestamp_ntz 
              > :startdate::timestamp_ntz 
          AND chk.CLOSED_AT::timestamp_ntz 
              < :enddate::timestamp_ntz 
          AND chk.LOCATION_DIM_FK IN ( 
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)
      INNER JOIN DATAADMIN.DAYPART_DIM                      dad
        ON chk.daypart_dim_fk = dad.daypart_dim_pk
          AND dad.DW_ISCURRENTROW = TRUE
      INNER JOIN EMPLOYEE_DIM                               emd
        ON emd.EMPLOYEE_DIM_NK = chk.EMPLOYEE_DIM_FK
          AND emd.DW_ISCURRENTROW
      
--==========================================================================================
);
RETURN TABLE(reportSet); 
END;
';"
PROCEDURE,DATAADMIN,SP_STAGELOADADDRESS_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADADDRESS_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.ADDRESS_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.ADDRESS_DIM(   
          ADDRESS_DIM_NK, 
          ADDRESS, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          CREATED_AT, 
          UPDATED_AT, 
          GEO, 
          ZIP, 
          ZIP4, 
          COUNTRY, 
          INTERNAL, 
          LOCATION, 
          STREETNAME, 
          STREETTYPEABBREV, 
          PREDIRABBREV, 
          POSTDIRABBREV, 
          ADDRESS_ALPHANUMERIC 
) 
 SELECT   ADDRESS_DIM_NK  as   ADDRESS_DIM_NK,  
   ADDRESS  as   ADDRESS,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   GEO  as   GEO,  
   ZIP  as   ZIP,  
   ZIP4  as   ZIP4,  
   COUNTRY  as   COUNTRY,  
   INTERNAL  as   INTERNAL,  
   LOCATION  as   LOCATION,  
   STREETNAME  as   STREETNAME,  
   STREETTYPEABBREV  as   STREETTYPEABBREV,  
   PREDIRABBREV  as   PREDIRABBREV,  
   POSTDIRABBREV  as   POSTDIRABBREV,  
   ADDRESS_ALPHANUMERIC  as   ADDRESS_ALPHANUMERIC 
  FROM DATAADMIN.ADDRESS_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''ADDRESS_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''ADDRESS_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADMENUGROUP_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADMENUGROUP_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.MENUGROUP_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.MENUGROUP_DIM(   
          MENUGROUP_DIM_NK, 
          MENUGROUP, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          ORGANIZATION_DIM_FK, 
          CREATED_AT, 
          UPDATED_AT, 
          PARENT_ID 
) 
 SELECT   MENUGROUP_DIM_NK  as   MENUGROUP_DIM_NK,  
   MENUGROUP  as   MENUGROUP,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   ORGANIZATION_DIM_FK  as   ORGANIZATION_DIM_FK,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   PARENT_ID  as   PARENT_ID 
  FROM DATAADMIN.MENUGROUP_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''MENUGROUP_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''MENUGROUP_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADSHIFTBREAK_FACT(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADSHIFTBREAK_FACT""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.SHIFTBREAK_FACT),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.SHIFTBREAK_FACT(   
          SHIFTBREAK_FACT_NK, 
          SHIFTBREAK, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          SHIFT_DIM_FK, 
          IS_BREAKCOMPLETE, 
          IS_ARCHIVED, 
          CREATED_AT, 
          UPDATED_AT, 
          START_AT, 
          ORIG_BEGIN_AT, 
          END_AT_INT, 
          END_AT, 
          ORIG_END_AT, 
          TIME_RANGE, 
          BREAK_SECONDS, 
          BREAK_MINUTES, 
          BREAK_HOURS, 
          BREAK_DAYS 
) 
 SELECT   SHIFTBREAK_FACT_NK  as   SHIFTBREAK_FACT_NK,  
   SHIFTBREAK  as   SHIFTBREAK,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   SHIFT_DIM_FK  as   SHIFT_DIM_FK,  
   IS_BREAKCOMPLETE  as   IS_BREAKCOMPLETE,  
   IS_ARCHIVED  as   IS_ARCHIVED,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   START_AT  as   START_AT,  
   ORIG_BEGIN_AT  as   ORIG_BEGIN_AT,  
   END_AT_INT  as   END_AT_INT,  
   END_AT  as   END_AT,  
   ORIG_END_AT  as   ORIG_END_AT,  
   TIME_RANGE  as   TIME_RANGE,  
   BREAK_SECONDS  as   BREAK_SECONDS,  
   BREAK_MINUTES  as   BREAK_MINUTES,  
   BREAK_HOURS  as   BREAK_HOURS,  
   BREAK_DAYS  as   BREAK_DAYS 
  FROM DATAADMIN.SHIFTBREAK_FACT
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''SHIFTBREAK_FACT'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''SHIFTBREAK_FACT'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADTAXRATE_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADTAXRATE_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.TAXRATE_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.TAXRATE_DIM(   
          TAXRATE_DIM_NK, 
          TAXRATE, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          ORGANIZATION_DIM_FK, 
          IS_TAX_INCLUDED, 
          CREATED_AT, 
          UPDATED_AT, 
          PERCENT 
) 
 SELECT   TAXRATE_DIM_NK  as   TAXRATE_DIM_NK,  
   TAXRATE  as   TAXRATE,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   ORGANIZATION_DIM_FK  as   ORGANIZATION_DIM_FK,  
   IS_TAX_INCLUDED  as   IS_TAX_INCLUDED,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   PERCENT  as   PERCENT 
  FROM DATAADMIN.TAXRATE_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''TAXRATE_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''TAXRATE_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,"SP_LOAD_DATASHARE_CRAFTABLE_CHECK(VARCHAR, VARCHAR, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_DATASHARE_CRAFTABLE_CHECK""(""START_DATE"" VARCHAR, ""END_DATE"" VARCHAR, ""LOCATION_IDS"" VARCHAR)
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS CALLER
AS 'BEGIN
    -- Execute the source procedure that returns the data
    CALL DATAADMIN.SP_DATASHARE_CRAFTABLE_CHECK(:START_DATE, :END_DATE, :LOCATION_IDS);

    -- Insert the results into the target table
    INSERT INTO DATASHARE_DEV.CRAFTABLE_CHECK (
        ""Organization Name"",
        ""Organization ID"",
        ""Location Name"",
        ""Location ID"",
        ""Business Day"",
        ""Check Number"",
        ""Check ID"",
        ""Rev Center Name"",
        ""Rev Center ID"",
        ""Meal Period/Day Part Name"",
        ""Meal Period/Day Part ID"",
        ""Ticket Open"",
        ""Ticket Closed"",
        ""Order Type Name"",
        ""Order Type ID"",
        ""Server Name"",
        ""Server ID"",
        ""Check Total"",
        ""Check Total Tips"",
        ""Gratuity Total""
    )
    SELECT
        ""Organization Name"",
        ""Organization ID"",
        ""Location Name"",
        ""Location ID"",
        ""Business Day"",
        ""Check Number"",
        ""Check ID"",
        ""Rev Center Name"",
        ""Rev Center ID"",
        ""Meal Period/Day Part Name"",
        ""Meal Period/Day Part ID"",
        ""Ticket Open"",
        ""Ticket Closed"",
        ""Order Type Name"",
        ""Order Type ID"",
        ""Server Name"",
        ""Server ID"",
        ""Check Total"",
        ""Check Total Tips"",
        ""Gratuity Total""
    FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

    RETURN ''Success: Data loaded into DATASHARE_DEV.CRAFTABLE_CHECK.'';
END';"
PROCEDURE,DATAADMIN,"SP_REPORT_DISCOUNT_DIANESESSION(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_DISCOUNT_DIANESESSION""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2020-09-18T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2024-09-18T14:48:37.661Z''; 
  -- locationid string      := ''[351,352]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--======================================================================================================
BEGIN
 reportSet   := (
        SELECT CHF.DISCOUNTitem_FACT_NK             AS ""Support ID"" 
           , ''DISI-'' ||row_number() over (order by  CHF.DISCOUNTitem_FACT_NK ) 
                                                    AS ""Detail ID""
         --Status, categories and levels----------------------------------------------------------
            ,CHF.STATUS                             AS ""Status""
            ,CHF.DISCOUNTLEVEL                      AS ""Discount Level""
        --geography--------------------------------------------------------------------------------
            ,IFNULL(LOC.LOCATIONNAME ,''None'')       AS ""Location""
            ,CHF.LOCATION_DIM_FK::DECIMAL(36,0)     AS ""Location ID""
            ,IFNULL(CHF.revenueCenterName ,''None'')  AS ""Revenue Center""
        --dates-------------------------------------------------------------------------------------  
        
            ,LOC.TZ_NAME                            AS ""Time Zone""
            ,to_char(LEFT(CHF.FISCAL_DATE,4))       AS ""Year""
            ,to_char(YEAR(CHF.FISCAL_DATE)) || ''|'' || TO_CHAR(RIGHT(''0'' || MONTH(CHF.FISCAL_DATE),2))
                                                    AS ""Year and Month""
            ,IFNULL(dad.DAYPART,''None'')             AS ""Daypart""
            ,to_char(CHF.FISCAL_DATE)               AS ""Fiscal Date""
            ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHF.ADDED_AT::timestamp_ntz ))                           
                                                     AS ""Added At""

            ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHF.CREATED_AT::timestamp_ntz ))                                             
  
                                                    AS ""Created At""
            ,IFNULL(DAYNAME(CHF.FISCAL_DATE),''None'') 
                                                    AS ""Day of Week""
            ,CASE WHEN DAYNAME(CHF.FISCAL_DATE) IN (''Sat'',''Sun'')  
                THEN TRUE ELSE FALSE END            AS""Is Weekend""
    
        --flags-------------------------------------------------------------------------------------
        --people------------------------------------------------------------------------------------
            ,COALESCE(EMD_ADD.EMPLOYEE_NAME,''None'') AS ""Added By""
            ,COALESCE(EMD_APP.EMPLOYEE_NAME,''None'') AS ""Approved By""
        --Descriptors------------------------------------------------------------------------------
            ,STD.STANDARDDISCOUNTNAME               AS ""Discount Name""
            ,CHF.DISCOUNTREASON                     AS ""Discount Reason""
            ,CHF.PROMOCODE                          AS ""Promo Code"" 
            ,CHF.CHEQUENUMBER                       AS ""Check""  
            ,CHF.CHEQUE_FACT_FK                     AS ""Check ID""
            ,STD.DISCOUNTTYPE                       AS ""Discount Type""
            ,CHF.DISCOUNT_TYPE                      AS ""Application""  
        --Facts-----------------------------------------------------------------------------------------
            ,1::NUMBER(10,0)                        AS ""Count""   
            ,CHF.DISCOUNT_PERCENT::NUMBER(18,2)     AS ""Discount Percent""   
            ,CHF.NET             ::NUMBER(18,2)     AS ""Check Net Amount"" 
            ,CHF.GROSS           ::NUMBER(18,2)     AS ""Check Gross Amount""
            ,CHF.APPLIED_AMOUNT  ::NUMBER(18,2)     AS ""Discount Amount"" 
         
                                                    --Percentages must be calculated within pyarrow cube as numerator and denominator can be filtred dynamically
            -- ,NULL                                AS ""% of Total Discounts"" --ex: per discount id: total count / all discount count    
            -- ,NULL                                AS ""Discount % of Net Sales""  --example (total discount amount / net sales + total discount amount) * 100 
                                                    --This represents the presumed % of lost revenue
        --------------------------------------------------------------------------------------------------------
        FROM DATAWAREHOUSE.DISCOUNTITEM_FACT                      CHF
            INNER JOIN DATAWAREHOUSE.ITEM_FACT                    ITF
              ON CHF.ITEM_FACT_FK = ITF.ITEM_FACT_NK
                  AND ITF.ITEMSTATUS IN (''Added'',''Sent'')
                  AND NOT CHF.STATUS  = ''Disabled''
                  AND CHF.CHEQUESTATUS  IN (''Closed'')
                  AND CHF.FISCAL_DATE::date
                      >= :startdate::date
                  AND CHF.FISCAL_DATE::date   
                      <= :enddate ::date 
                  AND CHF.LOCATION_DIM_FK IN (
                     SELECT table1.value 
                       FROM table(split_to_table(:locationidS, '',''))  table1)
                  AND CHF.DW_ISCURRENTROW
                  AND ITF.DW_ISCURRENTROW
                  AND NOT CHF.DW_ISDELETED                
                  AND NOT CHF.IS_TRAINING
            INNER JOIN DATAWAREHOUSE.LOCATION_DIM                 LOC  
              ON CHF.LOCATION_DIM_FK = LOC.LOCATION_DIM_NK
                 AND LOC.DW_ISCURRENTROW  
            INNER JOIN DATAWAREHOUSE.STANDARDDISCOUNT_DIM         STD
               ON STD.STANDARDDISCOUNT_DIM_NK = CHF.STANDARDDISCOUNT_DIM_FK
                 AND STD.DW_ISCURRENTROW
            INNER JOIN DATAWAREHOUSE.DAYPART_DIM                  DAD
              ON CHF.DAYPART_DIM_FK = DAD.DAYPART_DIM_NK
                  AND DAD.DW_ISCURRENTROW
            LEFT JOIN DATAWAREHOUSE.EMPLOYEE_DIM                 EMD_ADD
              ON EMPLOYEE_DIM_FK_AS_ADDED_BY = EMD_ADD.EMPLOYEE_DIM_NK
                AND EMD_ADD.DW_ISCURRENTROW
            LEFT JOIN DATAWAREHOUSE.EMPLOYEE_DIM                 EMD_APP
              ON EMPLOYEE_DIM_FK_AS_APPROVED_BY = EMD_APP.EMPLOYEE_DIM_NK
                AND EMD_APP.DW_ISCURRENTROW
UNION ALL

        SELECT CHF.DISCOUNTCHECK_FACT_NK            AS ""Support ID"" 
                   ,''DISC-'' || row_number() over (order by  CHF.DISCOUNTCHECK_FACT_NK ) 
                                                    AS ""Detail ID""
         --Status, categories and levels----------------------------------------------------------
            ,CHF.STATUS                             AS ""Status""
            ,CHF.DISCOUNTLEVEL                      AS ""Discount Level""
        --geography--------------------------------------------------------------------------------
            ,IFNULL(LOC.LOCATIONNAME ,''None'')       AS ""Location""
            ,CHF.LOCATION_DIM_FK::DECIMAL(36,0)     AS ""Location ID""
            ,IFNULL(CHF.revenueCenterName ,''None'')  AS ""Revenue Center""
        --dates-------------------------------------------------------------------------------------  
            ,LOC.TZ_NAME                            AS ""Time Zone""        
            ,to_char(LEFT( CHF.FISCAL_DATE,4))      AS ""Year""
            ,to_char(YEAR(CHF.FISCAL_DATE)) || ''|'' || TO_CHAR(RIGHT(''0'' || MONTH(CHF.FISCAL_DATE),2))
                                                    AS ""Year and Month""
            ,IFNULL(dad.DAYPART,''None'')             AS ""Daypart""
            ,to_char(CHF.FISCAL_DATE)                      
                                                    AS ""Fiscal Date""
            ,to_char(CHF.ADDED_AT::timestamp_ntz)                            
                                                    AS ""Added At""
            ,to_char(CHF.CREATED_AT::timestamp_ntz)                          
                                                    AS ""Created At""
            ,IFNULL(DAYNAME(
            CHF.FISCAL_DATE 
            )
            ,''None'')                                AS ""Day of Week""
            ,CASE WHEN DAYNAME(
            CHF.FISCAL_DATE 
            ) IN (''Sat'',''Sun'')  
            THEN TRUE ELSE FALSE END                AS""Is Weekend""
        --flags-------------------------------------------------------------------------------------
        --people------------------------------------------------------------------------------------
            ,COALESCE(EMD_ADD.EMPLOYEE_NAME,''None'') AS ""Added By""
            ,COALESCE(EMD_APP.EMPLOYEE_NAME,''None'') AS ""proved By"" 
        --Descriptors------------------------------------------------------------------------------
            ,STD.STANDARDDISCOUNTNAME               AS ""Discount Name""
            ,CHF.DISCOUNTREASON                     AS ""Discount Reason""
            ,CHF.PROMOCODE                          AS ""Promo Code"" 
            ,CHF.CHEQUENUMBER                       AS ""Check"" 
            ,CHF.CHEQUE_FACT_FK                     AS ""Check ID""
            ,STD.DISCOUNTTYPE                       AS ""Discount Type""
            ,CHF.DISCOUNT_TYPE                      AS ""Application""  
        --Facts-----------------------------------------------------------------------------------------
            ,1                   ::NUMBER(10,0)     AS ""Count""          
            ,CHF.DISCOUNT_PERCENT::NUMBER(18,2)     AS ""Discount Percent""   
            ,CHF.NET             ::NUMBER(18,2)     AS ""Check Net Amount"" 
            ,CHF.GROSS           ::NUMBER(18,2)     AS ""Check Gross Amount""
            ,CHF.APPLIED_AMOUNT  ::NUMBER(18,2)     AS ""Discount Amount"" 
         
                                                    --Percentages must be calculated within pyarrow cube as numerator and denominator can be filtred dynamically
            -- ,NULL                                AS ""% of Total Discounts"" --ex: per discount id: total count / all discount count    
            -- ,NULL                                AS ""Discount % of Net Sales""  --example (total discount amount / net sales + total discount amount) * 100 
                                                    --This represents the presumed % of lost revenue
        --------------------------------------------------------------------------------------------------------
        FROM DATAWAREHOUSE.DISCOUNTCHECK_FACT                     CHF
            INNER JOIN DATAWAREHOUSE.LOCATION_DIM                 LOC
              ON CHF.LOCATION_DIM_FK = LOC.LOCATION_DIM_NK
                  AND CHF.FISCAL_DATE::date
                      >= :startdate::date
                  AND CHF.FISCAL_DATE::date   
                      <= :enddate ::date 
                  AND CHF.LOCATION_DIM_FK IN (
                     SELECT table1.value 
                       FROM table(split_to_table(:locationidS, '',''))  table1)
                  AND CHF.CHEQUESTATUS IN (''Closed'')
                  AND NOT CHF.STATUS = ''Disabled''
                  AND CHF.DW_ISCURRENTROW
                  AND NOT CHF.DW_ISDELETED
                  AND LOC.DW_ISCURRENTROW          
                  AND NOT CHF.IS_TRAINING
            INNER JOIN DATAWAREHOUSE.DAYPART_DIM                 DAD
              ON CHF.DAYPART_DIM_FK = DAD.DAYPART_DIM_NK
                  AND DAD.DW_ISCURRENTROW                  
            LEFT JOIN DATAWAREHOUSE.STANDARDDISCOUNT_DIM         STD
               ON STD.STANDARDDISCOUNT_DIM_NK = CHF.STANDARDDISCOUNT_DIM_FK
                 AND STD.DW_ISCURRENTROW
            LEFT JOIN DATAWAREHOUSE.EMPLOYEE_DIM                 EMD_ADD
              ON EMPLOYEE_DIM_FK_AS_ADDED_BY = EMD_ADD.EMPLOYEE_DIM_NK
                AND EMD_ADD.DW_ISCURRENTROW
            LEFT JOIN DATAWAREHOUSE.EMPLOYEE_DIM                 EMD_APP
              ON EMPLOYEE_DIM_FK_AS_APPROVED_BY = EMD_APP.EMPLOYEE_DIM_NK
                AND EMD_APP.DW_ISCURRENTROW        
--==========================================================================================
); 
 RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,"SP_REPORT_VOID_0001_NEW(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_VOID_0001_NEW""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2025-05-23'';  
  -- enddate timestamp_tz   := ''2025-05-23''; 
  -- locationid string      := ''[26]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
-- --===================================================================================================================
BEGIN

-------------------------------------------------------------------------------------------------------------------------
DROP TABLE IF EXISTS TEMP_ITEM;

-------------------------------------------------------------------------------------------------------------------------
SELECT iaf.ITEM_FACT_NK                                             AS ITEM_FACT_NK
   ,iaf.CHEQUE_FACT_FK                                              AS CHEQUE_FACT_FK
   ,max(vdr_item.VOIDREASON)                                        AS VOIDREASON
   ,max(iaf.PRICE)                                                  AS ITEMPRICE
   ,sum(imf.PRICE)                                                  AS MODIFIERPRICE
   ,(max(case when iaf.PRICE > 0.0000 THEN iaf.PRICE ELSE iaf.baseprice END)
     + sum(ifnull(imf.PRICE,0))) * max(iaf.QUANTITY)                AS PRICE
        FROM DATAWAREHOUSE.ITEM_FACT                                iaf
           LEFT JOIN  DATAWAREHOUSE.ITEMMODIFIER_DIM                imf
              ON iaf.ITEM_FACT_NK = imf.ITEM_FACT_FK
                  -- AND iaf.LOCATION_DIM_fK = 2
                AND iaf.LOCATION_DIM_fK IN (
                    SELECT table1.value 
                      FROM table(split_to_table(:locationidS, '',''))  table1)
                -- AND iaf.FISCAL_DATE = ''2024-09-29''
                AND iaf.FISCAL_DATE::date
                    >= :startdate::date 
                AND iaf.FISCAL_DATE::date  
                   <= :enddate::date 
                AND iaf.IS_VOID
                AND iaf.CHECKSTATUS <> ''MergeVoided''
                AND iaf.DW_ISCURRENTROW 
                AND imf.DW_ISCURRENTROW 
                AND NOT iaf.DW_ISDELETED
                AND NOT iaf.IS_TRAINING
        LEFT JOIN DATAWAREHOUSE.VoidReason_DIM                        vdr_item
             ON vdr_item.VOIDREASON_DIM_NK = iaf.VoidReason_DIM_FK
               AND vdr_item.DW_ISCURRENTROW       
WHERE iaf.IS_VOID
                AND iaf.CHECKSTATUS <> ''MergeVoided''
                AND iaf.DW_ISCURRENTROW 
                AND NOT iaf.DW_ISDELETED
                AND NOT iaf.IS_TRAINING 
                AND (imf.DW_ISCURRENTROW  OR imf.DW_ISCURRENTROW IS NULL)
                AND (vdr_item.DW_ISCURRENTROW OR vdr_item.DW_ISCURRENTROW IS NULL             )
GROUP BY iaf.item_fact_nk,iaf.cheque_fact_fk 
;
-- select * from TEMP_ITEM where CHEQUE_FACT_FK =243922 ;
-------------------------------------------------------------------------------------------------------------------------
 CREATE TEMP TABLE TEMP_ITEM AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));
  
-------------------------------------------------------------------------------------------------------------------------
 reportSet   := (
        SELECT to_char(act.activity_fact_nk)        AS ""Support ID"" 
          ,''VOID-'' ||row_number() over (order by act.activity_fact_nk) 
                                                    AS ""Detail ID""        
        --status, category, level-----------------------------------------------------------------------------------------
        ,CASE act.TYPE 
          WHEN ''ItemVoided'' 
            THEN ''Item'' 
          WHEN ''Voided'' 
            THEN ''Check''
            ELSE ''None'' 
          END 
                                                 AS ""Level""          --Values of Check or Item.
        --geography--------------------------------------------------------------------------------------------------------
        ,IFNULL(LOC.LOCATIONNAME ,''None'')        AS ""Location""
        ,LOC.LOCATION_DIM_NK                     AS ""Location ID""        
        ,IFNULL(CHK.revenueCenterName ,''None'')   AS ""Revenue Center""
        --dates------------------------------------------------------------------------------------------------------------- 
        ,LOC.TZ_NAME                                                               AS ""Time Zone""
        ,to_char(LEFT(chk.FISCAL_DATE,4))                                          AS ""Year""
        ,to_char(YEAR(chk.FISCAL_DATE)) || ''|'' || TO_CHAR(RIGHT(''0'' || MONTH(chk.FISCAL_DATE),2))                                       
                                                                                   AS ""Year and Month""
        ,IFNULL(dad.DAYPART,''None'')                                                AS ""Daypart""
        ,to_char(chk.FISCAL_DATE)                                                  AS ""Fiscal Date""
        
        --,chk.OPENED_AT::timestamp_ntz 
         ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHK.OPENED_AT::timestamp_ntz )::timestamp )
                                                                                   AS ""Check Opened At""     
        --,chk.CREATED_AT::timestamp_ntz 
        ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHK.CREATED_AT::timestamp_ntz )::timestamp) 
                                                                                   AS ""Item Ordered At""    
        -- ,act.PERFORMED_AT::timestamp_ntz 
        ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,act.PERFORMED_AT::timestamp_ntz )::timestamp) 
                                                                                   AS ""Voided At""
        
        ,dad.DAYPART                                                               AS ""Day Part""              
        ,IFNULL(DAYNAME(chk.FISCAL_DATE),''None'')                                   AS ""Day of Week""
        ,CASE WHEN DAYNAME(chk.FISCAL_DATE) IN (''Sat'',''Sun'')  
           THEN TRUE ELSE FALSE END                                                AS ""Is Weekend""
        
        ,TIMESTAMPDIFF(second ,chk.OPENED_AT,act.PERFORMED_AT)::NUMBER(18,0) 
                                                                                   AS ""Seconds to Void""
        ,TIMESTAMPDIFF(minute ,chk.OPENED_AT,act.PERFORMED_AT) ::NUMBER(18,0)
                                                                                   AS ""Minutes to Void""                                                 
        --Flags---------------------------------------------------------------------------------------------------------
        --People--------------------------------------------------------------------------------------------------------
        ,IFNULL(amd_asperf.EMPLOYEE_NAME,''None'') AS ""Voider""
        ,IFNULL(amd_asapp.EMPLOYEE_NAME,''None'')  AS ""Approver""   
        --Descriptors----------------------------------------------------------------------------------------------------
        ,chk.CHEQUENUMBER                        AS ""Check""
        ,chk.CHEQUE_FACT_NK                      AS ""Check ID""
        ,IFNULL(COALESCE(itf.VOIDREASON,
         vdr_check.VOIDREASON),''None'')           AS ""Reason""
        
          
        ,IFNULL(act.MENUITEMNAME,''None'')         AS ""Item""
        ,itf.ITEM_FACT_NK                        AS ""Item ID""    

        --Facts-----------------------------------------------------------------------------------------------------------
        ,1::NUMBER(18,0)                         AS ""Count""  
        ,CASE WHEN act.TYPE = ''ItemVoided'' 
            THEN itf.PRICE 
         -- ELSE chk.NET END::NUMBER(18,2)
          ELSE chk.GROSS END::NUMBER(18,2)
                                                 AS ""Amount""                   
        FROM DATAWAREHOUSE.ACTIVITY_FACT                                  act
           INNER JOIN  DATAWAREHOUSE.LOCATION_DIM                         loc
              ON act.LOCATION_DIM_FK = loc.LOCATION_DIM_NK
                AND act.LOCATION_DIM_fK IN (
                    SELECT table1.value 
                      FROM table(split_to_table(:locationidS, '',''))  table1)
                AND loc.DW_ISCURRENTROW 
                AND NOT loc.DW_ISDELETED
            INNER JOIN DATAWAREHOUSE.CHEQUE_FACT                          chk
              ON act.CHEQUE_FACT_FK = chk.CHEQUE_FACT_NK
                AND act.IS_VOID
                AND act.DW_ISCURRENTROW 
                AND chk.FISCAL_DATE::date >= :startdate::date 
                AND chk.FISCAL_DATE::date <= :enddate::date  
                AND NOT act.DW_ISDELETED
                AND chK.DW_ISCURRENTROW 
                AND NOT chk.DW_ISDELETED
                AND NOT chk.IS_TRAINING
            INNER JOIN DATAWAREHOUSE.DAYPART_DIM                          dad
              ON chk.DAYPART_DIM_FK = dad.daypart_dim_Nk
                AND dad.DW_ISCURRENTROW 
                AND NOT dad.DW_ISDELETED
           
            LEFT JOIN DATAWAREHOUSE.EMPLOYEE_DIM                          amd_asperf
              ON act.EMPLOYEE_DIM_FK_AS_PERFORMING_EMPLOYEE 
                  = amd_asperf.EMPLOYEE_DIM_NK
                AND amd_asperf.DW_ISCURRENTROW 
                AND NOT amd_asperf.DW_ISDELETED 
            LEFT JOIN DATAWAREHOUSE.EMPLOYEE_DIM                          amd_asapp
              ON act.EMPLOYEE_DIM_FK_AS_APPROVING_EMPLOYEE 
                  = amd_asapp.EMPLOYEE_DIM_NK
                AND amd_asapp.DW_ISCURRENTROW 
                AND NOT amd_asapp.DW_ISDELETED   
            LEFT JOIN DATAWAREHOUSE.VoidReason_DIM                        vdr_check
             ON vdr_check.VOIDREASON_DIM_NK = CHK.VoidReason_DIM_FK
               AND vdr_check.DW_ISCURRENTROW 
               AND NOT vdr_check.DW_ISDELETED
            LEFT JOIN TEMP_ITEM                                              itf
              ON itf.Item_fact_NK = act.Item_fact_fk    
              
--=================================================================================================================
); 
 RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,SP_STAGELOADCCTRANSACTION_FACT(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADCCTRANSACTION_FACT""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.CCTRANSACTION_FACT),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.CCTRANSACTION_FACT(   
          CCTRANSACTION_FACT_NK, 
          TRANSACTION_NUMBER, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          BATCH_DIM_FK, 
          LOCATION_DIM_FK, 
          EMPLOYEE_DIM_FK, 
          PAYMENTMETHOD_DIM_FK, 
          CHEQUE_FACT_FK, 
          ISCARDPRESENT, 
          ISFIRSTTRANSACTION, 
          FISCAL_DAY, 
          AUTH_TRAN_GMT, 
          CREATED_AT, 
          UPDATED_AT, 
          AUTH_TRAN_ID, 
          BATCH_ID, 
          AUTH_BRIC, 
          CARDHOLDER_LOCATION, 
          CARD_ENTRY_METHOD, 
          BATCH_NUMBER, 
          AUTHORIZATION, 
          AUTHORIZATION_CODE, 
          APPROVAL, 
          POS_TERMINAL_ID, 
          MASKED_CC_NUMBER, 
          CARDHOLDER_NAME, 
          CARD_TYPE, 
          CARD_TYPE_RAW, 
          REFERENCE_NUMBER, 
          COMMAND, 
          STATUS, 
          AUTHAMOUNTREQUESTED, 
          AUTH_AMOUNT, 
          TOTAL_INCREMENT, 
          TIP_INCREMENT, 
          TOTAL, 
          TIP 
) 
 SELECT   CCTRANSACTION_FACT_NK  as   CCTRANSACTION_FACT_NK,  
   TRANSACTION_NUMBER  as   TRANSACTION_NUMBER,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   BATCH_DIM_FK  as   BATCH_DIM_FK,  
   LOCATION_DIM_FK  as   LOCATION_DIM_FK,  
   EMPLOYEE_DIM_FK  as   EMPLOYEE_DIM_FK,  
   PAYMENTMETHOD_DIM_FK  as   PAYMENTMETHOD_DIM_FK,  
   CHEQUE_FACT_FK  as   CHEQUE_FACT_FK,  
   ISCARDPRESENT  as   ISCARDPRESENT,  
   ISFIRSTTRANSACTION  as   ISFIRSTTRANSACTION,  
   FISCAL_DAY  as   FISCAL_DAY,  
   AUTH_TRAN_GMT  as   AUTH_TRAN_GMT,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   AUTH_TRAN_ID  as   AUTH_TRAN_ID,  
   BATCH_ID  as   BATCH_ID,  
   AUTH_BRIC  as   AUTH_BRIC,  
   CARDHOLDER_LOCATION  as   CARDHOLDER_LOCATION,  
   CARD_ENTRY_METHOD  as   CARD_ENTRY_METHOD,  
   BATCH_NUMBER  as   BATCH_NUMBER,  
   AUTHORIZATION  as   AUTHORIZATION,  
   AUTHORIZATION_CODE  as   AUTHORIZATION_CODE,  
   APPROVAL  as   APPROVAL,  
   POS_TERMINAL_ID  as   POS_TERMINAL_ID,  
   MASKED_CC_NUMBER  as   MASKED_CC_NUMBER,  
   CARDHOLDER_NAME  as   CARDHOLDER_NAME,  
   CARD_TYPE  as   CARD_TYPE,  
   CARD_TYPE_RAW  as   CARD_TYPE_RAW,  
   REFERENCE_NUMBER  as   REFERENCE_NUMBER,  
   COMMAND  as   COMMAND,  
   STATUS  as   STATUS,  
   AUTHAMOUNTREQUESTED  as   AUTHAMOUNTREQUESTED,  
   AUTH_AMOUNT  as   AUTH_AMOUNT,  
   TOTAL_INCREMENT  as   TOTAL_INCREMENT,  
   TIP_INCREMENT  as   TIP_INCREMENT,  
   TOTAL  as   TOTAL,  
   TIP  as   TIP 
  FROM DATAADMIN.CCTRANSACTION_FACT
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''CCTRANSACTION_FACT'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''CCTRANSACTION_FACT'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADGIFTCARDTRANSACTION_FACT(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADGIFTCARDTRANSACTION_FACT""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.GIFTCARDTRANSACTION_FACT),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.GIFTCARDTRANSACTION_FACT(   
          GIFTCARDTRANSACTION_FACT_NK, 
          TRANSACTION, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          GIFTCARD_DIM_FK, 
          CHEQUE_FACT_FK, 
          LOCATION_DIM_FK, 
          ADJUSTED_BY_ID, 
          ADJUSTS_ID, 
          ADJUSTER, 
          IS_VOIDED, 
          IS_ADJUSTED, 
          CREATED_AT, 
          UPDATED_AT, 
          AUTH_GUID, 
          COMMAND, 
          CARD_ENTRY_METHOD, 
          CURRENCY_CODE, 
          AMOUNT, 
          ADJUSTED_AMOUNT, 
          TRANSACTION_AMOUNT, 
          TIP, 
          TOTAL, 
          BALANCE, 
          OPENING_BALANCE, 
          CLOSING_BALANCE 
) 
 SELECT   GIFTCARDTRANSACTION_FACT_NK  as   GIFTCARDTRANSACTION_FACT_NK,  
   TRANSACTION  as   TRANSACTION,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   GIFTCARD_DIM_FK  as   GIFTCARD_DIM_FK,  
   CHEQUE_FACT_FK  as   CHEQUE_FACT_FK,  
   LOCATION_DIM_FK  as   LOCATION_DIM_FK,  
   ADJUSTED_BY_ID  as   ADJUSTED_BY_ID,  
   ADJUSTS_ID  as   ADJUSTS_ID,  
   ADJUSTER  as   ADJUSTER,  
   IS_VOIDED  as   IS_VOIDED,  
   IS_ADJUSTED  as   IS_ADJUSTED,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   AUTH_GUID  as   AUTH_GUID,  
   COMMAND  as   COMMAND,  
   CARD_ENTRY_METHOD  as   CARD_ENTRY_METHOD,  
   CURRENCY_CODE  as   CURRENCY_CODE,  
   AMOUNT  as   AMOUNT,  
   ADJUSTED_AMOUNT  as   ADJUSTED_AMOUNT,  
   TRANSACTION_AMOUNT  as   TRANSACTION_AMOUNT,  
   TIP  as   TIP,  
   TOTAL  as   TOTAL,  
   BALANCE  as   BALANCE,  
   OPENING_BALANCE  as   OPENING_BALANCE,  
   CLOSING_BALANCE  as   CLOSING_BALANCE 
  FROM DATAADMIN.GIFTCARDTRANSACTION_FACT
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''GIFTCARDTRANSACTION_FACT'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''GIFTCARDTRANSACTION_FACT'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADMENUITEMNAME_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADMENUITEMNAME_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.MENUITEMNAME_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.MENUITEMNAME_DIM(   
          MENUITEMNAME_DIM_NK, 
          MENUITEMNAME, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          ORGANIZATION_DIM_FK, 
          REPORTCATEGORY_DIM_FK, 
          ARCHIVED, 
          ARCHIVED_AT, 
          CREATED_AT, 
          UPDATED_AT 
) 
 SELECT   MENUITEMNAME_DIM_NK  as   MENUITEMNAME_DIM_NK,  
   MENUITEMNAME  as   MENUITEMNAME,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   ORGANIZATION_DIM_FK  as   ORGANIZATION_DIM_FK,  
   REPORTCATEGORY_DIM_FK  as   REPORTCATEGORY_DIM_FK,  
   ARCHIVED  as   ARCHIVED,  
   ARCHIVED_AT  as   ARCHIVED_AT,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT 
  FROM DATAADMIN.MENUITEMNAME_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''MENUITEMNAME_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''MENUITEMNAME_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADREVENUECENTER_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADREVENUECENTER_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.REVENUECENTER_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.REVENUECENTER_DIM(   
          REVENUECENTER_DIM_NK, 
          REVENUECENTER, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          CREATED_AT, 
          UPDATED_AT, 
          RECEIPT_FOOTER 
) 
 SELECT   REVENUECENTER_DIM_NK  as   REVENUECENTER_DIM_NK,  
   REVENUECENTER  as   REVENUECENTER,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   RECEIPT_FOOTER  as   RECEIPT_FOOTER 
  FROM DATAADMIN.REVENUECENTER_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''REVENUECENTER_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''REVENUECENTER_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADSURCHARGE_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADSURCHARGE_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.SURCHARGE_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.SURCHARGE_DIM(   
          SURCHARGE_DIM_NK, 
          SURCHARGE, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          ORGANIZATION_DIM_FK, 
          IS_ARCHIVED, 
          IS_ENABLED, 
          IS_PRINT_ON_RECEIPT, 
          IS_TAXABLE, 
          IS_GRATUITY, 
          CREATED_AT, 
          UPDATED_AT, 
          DESCRIPTION, 
          POS_NAME, 
          RECEIPT_DISPLAY_NAME, 
          TYPE, 
          MIN_GUESTS, 
          MIN_CHECK_AMOUNT, 
          FIXED_VALUE 
) 
 SELECT   SURCHARGE_DIM_NK  as   SURCHARGE_DIM_NK,  
   SURCHARGE  as   SURCHARGE,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   ORGANIZATION_DIM_FK  as   ORGANIZATION_DIM_FK,  
   IS_ARCHIVED  as   IS_ARCHIVED,  
   IS_ENABLED  as   IS_ENABLED,  
   IS_PRINT_ON_RECEIPT  as   IS_PRINT_ON_RECEIPT,  
   IS_TAXABLE  as   IS_TAXABLE,  
   IS_GRATUITY  as   IS_GRATUITY,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   DESCRIPTION  as   DESCRIPTION,  
   POS_NAME  as   POS_NAME,  
   RECEIPT_DISPLAY_NAME  as   RECEIPT_DISPLAY_NAME,  
   TYPE  as   TYPE,  
   MIN_GUESTS  as   MIN_GUESTS,  
   MIN_CHECK_AMOUNT  as   MIN_CHECK_AMOUNT,  
   FIXED_VALUE  as   FIXED_VALUE 
  FROM DATAADMIN.SURCHARGE_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''SURCHARGE_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''SURCHARGE_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADSURCHARGE_FACT(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADSURCHARGE_FACT""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.SURCHARGE_FACT),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.SURCHARGE_FACT(   
          SURCHARGE_FACT_NK, 
          SURCHARGENAME, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          CHEQUE_FACT_FK, 
          DAYPART_DIM_FK, 
          EMPLOYEE_DIM_FK, 
          LOCATION_DIM_FK, 
          SURCHARGE_DIM_NK, 
          IS_AUTOAPPLIED, 
          IS_GRATUITY, 
          IS_TAXABLE, 
          IS_TRAINING, 
          IS_PRINTONRECEIPT, 
          CREATED_AT, 
          FISCAL_DATE, 
          OPENED_AT, 
          UPDATED_AT, 
          STATUS, 
          CHEQUENUMBER, 
          SURCHARGE_TYPE, 
          QUANTITY, 
          AMOUNT, 
          APPLIEDAMOUNT 
) 
 SELECT   SURCHARGE_FACT_NK  as   SURCHARGE_FACT_NK,  
   SURCHARGENAME  as   SURCHARGENAME,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   CHEQUE_FACT_FK  as   CHEQUE_FACT_FK,  
   DAYPART_DIM_FK  as   DAYPART_DIM_FK,  
   EMPLOYEE_DIM_FK  as   EMPLOYEE_DIM_FK,  
   LOCATION_DIM_FK  as   LOCATION_DIM_FK,  
   SURCHARGE_DIM_NK  as   SURCHARGE_DIM_NK,  
   IS_AUTOAPPLIED  as   IS_AUTOAPPLIED,  
   IS_GRATUITY  as   IS_GRATUITY,  
   IS_TAXABLE  as   IS_TAXABLE,  
   IS_TRAINING  as   IS_TRAINING,  
   IS_PRINTONRECEIPT  as   IS_PRINTONRECEIPT,  
   CREATED_AT  as   CREATED_AT,  
   FISCAL_DATE  as   FISCAL_DATE,  
   OPENED_AT  as   OPENED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   STATUS  as   STATUS,  
   CHEQUENUMBER  as   CHEQUENUMBER,  
   SURCHARGE_TYPE  as   SURCHARGE_TYPE,  
   QUANTITY  as   QUANTITY,  
   AMOUNT  as   AMOUNT,  
   APPLIEDAMOUNT  as   APPLIEDAMOUNT 
  FROM DATAADMIN.SURCHARGE_FACT
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''SURCHARGE_FACT'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''SURCHARGE_FACT'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADVARIANT_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADVARIANT_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.VARIANT_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.VARIANT_DIM(   
          VARIANT_DIM_NK, 
          VARIANT, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          ORGANIZATION_DIM_FK, 
          VTYPE 
) 
 SELECT   VARIANT_DIM_NK  as   VARIANT_DIM_NK,  
   VARIANT  as   VARIANT,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   ORGANIZATION_DIM_FK  as   ORGANIZATION_DIM_FK,  
   VTYPE  as   VTYPE 
  FROM DATAADMIN.VARIANT_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''VARIANT_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''VARIANT_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,"SP_TEST_LABOR(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_TEST_LABOR""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE  --count = 2914
  reportSet resultset;
  -- startdate timestamp_tz := ''2000-11-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2025-06-01T14:48:37.661Z''; 
  -- locationid string      := ''[26]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');

-- ============================================================================================= 
-- GRANT usage ON procedure dataadmin.SP_REPORT_LABOR(timestamp_tz,timestamp_tz,string) TO ROLE DATA_REPLICATION_HOSPENG;
--CALL DATAADMIN.SP_REPORT_LABOR(''2000-11-20T14:48:37.661Z'',''2027-11-20T14:48:37.661Z'',''[3,2,351]'');
-- =============================================================================================
BEGIN
  DROP TABLE IF EXISTS TEMP_LABOR;
  DROP TABLE IF EXISTS TEMP_TIPGRAT;
  DROP TABLE IF EXISTS SHIFT_CTE;
  DROP TABLE IF EXISTS BREAK_CTE;
  DROP TABLE IF EXISTS RULE_CTE;

  -- WITH SHIFT_CTE AS (
    SELECT SHD.SHIFT_DIM_PK --|| overtime_fact_nk || fiscal day and week or date                                 
                                                               AS ""Support ID"" 
        ,SHD.SHIFT_DIM_NK                                      AS ""SHIFT_DIM_NK""
    --status, category, level------------------------------------------------------------------
        ,''Shift''                                               AS ""Level""
    --geography--------------------------------------------------------------------------------
        ,IFNULL(loc.LOCATIONNAME,''None'')                       AS ""Location""
        -- ,SHD.LOCATION_DIM_FK                                AS ""Location ID""  
        ,IFNULL(org.organization,''None'')                       AS ""Organization""
    --dates-------------------------------------------------------------------------------------
        ,LOC.TZ_NAME                                            AS ""Time Zone""
        ,TO_CHAR(DATE_PART(YEAR,SHD.CLOCKEDIN_AT::timestamp_ntz ))   
                                                               AS ""Year""
        ,to_char(LEFT(SHD.CLOCKEDIN_AT::timestamp_ntz,7))                     
                                                               AS ""Year and Month""
        ,SHD.CLOCKEDIN_AT::timestamp_ntz                             
                                                               AS ""Clocked In At""
        ,SHD.CLOCKEDOUT_AT::timestamp_ntz                                    
                                                               AS ""Clocked Out At""    
        ,IFNULL(DAYNAME(SHD.CLOCKEDIN_AT::timestamp_ntz),''None'')              
                                                               AS ""Day of Week""
        ,CASE WHEN DAYNAME(SHD.CLOCKEDIN_AT::timestamp_ntz) IN (''Sat'',''Sun'')  
            THEN TRUE ELSE FALSE END                           
                                                               AS ""Is Weekend""
        ,ORG.START_OF_PAYROLL_WEEK_INT                         AS ""Week Offset""
        ,NULL::VARCHAR(20)                                     AS ""Fiscal Week""  
        ,NULL::VARCHAR(20)                                     AS ""Fiscal Week Start"" 
        ,NULL::VARCHAR(20)                                     AS ""Fiscal Week End""
        ,SHD.FISCAL_DAY                                        AS ""Fiscal Day""  
        
        ,DATEADD(DAY,ORG.START_OF_PAYROLL_WEEK_INT 
          + case  ORG.START_OF_PAYROLL_WEEK_INT  when 0 then 1
           when 1 then -1 
           when 2 then -1
           when 3 then -2
           when 4 then -2
           when 5 then -2
           when 6 then -2
           
           else -1  end                                 
          ,SHD.FISCAL_DAY::DATE )                              AS ""Fiscal Day Offset""      
                                                                         
    --flags--------------------------------------------------------------------------------------
        ,SHD.IS_SHIFTCOMPLETE                                  AS ""Is Clocked Out""
        ,SHD.WAS_SYSTEM_CLOCKOUT                               AS ""Was System Clock Out""
        ,SHD.GETS_PAID_BREAK                                   AS ""Gets Paid Break""
    --people------------------------------------------------------------------------------------- 
        ,EMD.EMPLOYEE_NAME                                     AS ""Employee""
        ,EMD.EMPLOYEE_DIM_NK                                   AS ""Employee ID""
        ,SHD.JOBPOSITION_DIM_FK                                AS ""JOBPOSITION_DIM_FK""
        ,SHD.LOCATION_DIM_FK                                   AS ""LOCATION_DIM_FK""  
        ,EMD.PAYROLL_ID                                        AS ""Payroll ID""
        ,SHD.GENERAL_LEDGER                                    AS ""General Ledger Number""
     --Descriptors-------------------------------------------------------------------------------- 
       ,JBP.JOB_POSITION                                       AS ""Job Position""  --(i.e. Bartender, Cook, Server)    
       ,JCD.JOBCATEGORY                                        AS ""Job Category""
       ,SHD.SHIFT                                              AS ""Shift ID""  
       ,SHD.PAY_RATE_BASIS                                     AS ""Pay Basis""
     --Facts-----------------------------------------------------------------------------------------
        ,NULL                                                  AS ""Overtime Rule""
        ,NULL                                                  AS ""Hours Per Day""
        ,NULL                                                  AS ""Seconds Per Day""
        ,NULL                                                  AS ""Hours Per Week""
        ,NULL                                                  AS ""Seconds Per Week""
        ,to_number(1)                                          AS ""Shift Count""
        ,NULL                                                  AS ""Break Count""  
        ,COUNT(SHD.SHIFT) OVER (PARTITION BY SHD.LOCATION_DIM_FK,EMD.EMPLOYEE_DIM_NK,SHD.FISCAL_DAY)  
                                                               AS ""Shift Per Day Count""
        -- ,IFF( SHD.IS_SHIFTCOMPLETE,SHD.SHIFT_SECONDS, 
        --   ROUND(TIMEDIFF(second
        --        ,CONVERT_TIMEZONE(''UTC'',loc.TZ_NAME,shd.CLOCKEDIN_AT::timestamp_ntz )::timestamp
        --     -- ,SHD.CLOCKEDIN_AT::timestamp_ntz 
        --        ,CONVERT_TIMEZONE(''UTC'',loc.TZ_NAME,CURRENT_TIMESTAMP::timestamp_ntz )::timestamp
        --     -- ,CURRENT_TIMESTAMP::timestamp_ntz 
        --       )::Number(38,0),0))
        --                                                        AS ""Shift Seconds""


        ,IFF( SHD.IS_SHIFTCOMPLETE,SHD.SHIFT_SECONDS, 
          ROUND(TIMEDIFF(second
               ,SHD.CLOCKEDIN_AT::timestamp_ntz 
               ,CONVERT_TIMEZONE(''UTC'', CURRENT_TIMESTAMP())::timestamp_ntz
              )::Number(38,0),0))
                                                               AS ""Shift Seconds""

                                                               
        ,NULL                                                  AS ""Break Seconds""


        ,shd.REGULAR_RATE * 1.5::Number(18,2)             
                                                               AS ""Overtime Rate""
        ,shd.REGULAR_RATE::Number(18,2)                        AS ""Regular Rate""
 
        FROM DATAWAREHOUSE.SHIFT_DIM                               SHD
          INNER JOIN DATAWAREHOUSE.LOCATION_DIM                    LOC
             ON SHD.LOCATION_DIM_FK = LOC.LOCATION_DIM_NK
                AND LOC.DW_ISCURRENTROW
                AND SHD.DW_ISCURRENTROW
             
                AND NOT SHD.DW_ISDELETED
                AND NOT SHD.IS_ARCHIVED
                AND shd.fiscal_day::date
                   >= dateadd(DAY,-10,:startdate)::date --calculate data 10 days around selected dates so that  
                AND  shd.fiscal_day::date  
                  <= dateadd(DAY,10,:enddate)::date    --the data in the selected range calcs overtime for full fiscal week
                AND SHD.LOCATION_DIM_FK IN ( SELECT table1.value 
                           FROM table(split_to_table(:locationidS, '',''))  table1)
          INNER JOIN DATAWAREHOUSE.ORGANIZATION_DIM                ORG
            ON LOC.ORGANIZATION_DIM_FK = ORG.ORGANIZATION_DIM_NK
              AND ORG.DW_ISCURRENTROW
          INNER JOIN DATAWAREHOUSE.EMPLOYEE_DIM                    EMD
            ON SHD.EMPLOYEE_DIM_FK = EMD.EMPLOYEE_DIM_NK
              AND EMD.DW_ISCURRENTROW
          INNER JOIN DATAWAREHOUSE.JOBPOSITION_DIM                 JBP
            ON JBP.JOBPOSITION_DIM_NK = SHD.JOBPOSITION_DIM_FK 
              AND JBP.DW_ISCURRENTROW
          INNER JOIN DATAWAREHOUSE.JOBCATEGORY_DIM                 JCD
            ON JBP.JOBCATEGORY_DIM_FK = JCD.JOBCATEGORY_DIM_NK
              AND JCD.DW_ISCURRENTROW
         ORDER BY SHD.CLOCKEDIN_AT DESC ;  

 CREATE TEMP TABLE SHIFT_CTE AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));  
     
UPDATE SHIFT_CTE
  SET ""Fiscal Week Start"" = dateadd(day,dayofweek(""Fiscal Day"") * -1  + ""Week Offset"" - case when dayofweek(""Fiscal Day"") >= ""Week Offset"" then 0 else 7 end
                            ,""Fiscal Day"") 
    ,""Fiscal Week End""    = dateadd(day,6,
                           dateadd(day,dayofweek(""Fiscal Day"") * -1  + ""Week Offset"" - case 
                             when dayofweek(""Fiscal Day"") >= ""Week Offset"" then 0 else 7 end ,""Fiscal Day""))
;

UPDATE SHIFT_CTE
  SET ""Fiscal Week"" = YEAR(""Fiscal Week Start""::date) || ''-'' ||  RIGHT(''0'' || WEEKOFYEAR(""Fiscal Week Start""::date),2);
  
--===========================================================================================           
--    ,BREAK_CTE AS (
        SELECT SHD_1.""Support ID""                               AS ""Support ID"" 
        ,MAX(SHD_1.SHIFT_DIM_NK)                                AS ""SHIFT_DIM_NK""
    --status, category, level------------------------------------------------------------------
        ,''Break''                                                AS ""Level""
    --geography--------------------------------------------------------------------------------
        ,NULL                                                   AS ""Location""
        ,NULL                                                   AS ""Organization""
    -- --dates-------------------------------------------------------------------------------------
        ,MAX(SHD_1.""Time Zone"")                                 AS ""Time Zone""
        ,NULL                                                   AS ""Year""
        ,NULL                                                   AS ""Year and Month""
        ,NULL                                                   AS ""Clocked In At""
        ,NULL                                                   AS ""Clocked Out At""    
        ,NULL                                                   AS ""Day of Week""
        ,NULL                                                   AS ""Is Weekend""
        ,NULL                                                   AS ""Week Offset""
        ,MAX(SHD_1.""Fiscal Week"")                               AS ""Fiscal Week""     
        ,MAX(SHD_1.""Fiscal Week Start"")                         AS ""Fiscal Week Start"" 
        ,MAX(SHD_1.""Fiscal Week End"")                           AS ""Fiscal Week End""
        ,NULL                                                   AS ""Fiscal Day""
        ,NULL                                                   AS ""Fiscal Day Offset""           
    -- --flags--------------------------------------------------------------------------------------
        ,NULL                                                   AS ""Is Clocked Out""
        ,NULL                                                   AS ""Was System Clock Out""
        ,NULL                                                   AS ""Gets Paid Break""
    -- --people------------------------------------------------------------------------------------- 
        ,NULL                                                   AS ""Employee""
        ,NULL                                                   AS ""Employee ID""
        ,NULL                                                   AS JOBPOSITION_DIM_FK
        ,NULL                                                   AS LOCATION_DIM_FK  
        ,NULL                                                   AS ""Payroll ID""
        ,NULL                                                   AS ""General Ledger Number""        
    --  --Descriptors-------------------------------------------------------------------------------- 
        ,NULL                                                   AS ""Job Position""  
        ,NULL                                                   AS ""Job Category""        
        ,NULL                                                   AS ""Pay Basis""
        ,NULL                                                   AS ""Shift ID""  
    -- Facts-----------------------------------------------------------------------------------------
        ,NULL                                                   AS ""Overtime Rule""
        ,NULL                                                   AS ""Hours Per Day""
        ,NULL                                                   AS ""Seconds Per Day""
        ,NULL                                                   AS ""Hours Per Week""
        ,NULL                                                   AS ""Seconds Per Week""
        ,NULL                                                   AS ""Shift Count""
        ,1                                                      AS ""Break Count""   
        ,NULL                                                   AS ""Shift Per Day Count""
        ,0                                                      AS ""Shift Seconds""
        ,SUM(IFF( BRK_1.IS_BREAKCOMPLETE ,BRK_1.BREAK_SECONDS , 
          ROUND(TIMEDIFF(SECOND
            ,BRK_1.START_AT::timestamp_ntz 
            ,CURRENT_TIMESTAMP::timestamp_ntz 
                )::Number(38,0),0)) )                                                  
                                                                AS ""Break Seconds""
     
        ,NULL                                                   AS ""Overtime Rate""
        ,NULL                                                   AS ""Regular Rate""
          FROM SHIFT_CTE                                        SHD_1
            LEFT JOIN DATAWAREHOUSE.SHIFTBREAK_FACT             BRK_1
              ON SHD_1.SHIFT_DIM_NK = BRK_1.SHIFT_DIM_FK
                 AND BRK_1.DW_ISCURRENTROW
                 AND NOT BRK_1.DW_ISDELETED
            GROUP BY SHD_1.""Support ID""  
            ;
    -- )
    
 CREATE TEMP TABLE BREAK_CTE AS 
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));    
     
--=============================================================================================================     
  --  ,RULE_CTE AS (  ---NOTE:  THIS JOIN SHOULD NOT BE CURRENT ROW...IT SHOULD BE ROW WHERE TIME = SHIFT START
         SELECT SHD_2.""Support ID""                              AS ""Support ID"" 
        ,SHD_2.SHIFT_DIM_NK                                     AS ""SHIFT_DIM_NK""
    --status, category, level------------------------------------------------------------------
        ,''Rule''                                                 AS ""Level""
    --geography--------------------------------------------------------------------------------
        ,NULL                                                   AS ""Location""
        ,NULL                                                   AS ""Organization""
    -- --dates-------------------------------------------------------------------------------------
        ,NULL                                                   AS ""Time Zone""    
        ,NULL                                                   AS ""Year""
        ,NULL                                                   AS ""Year and Month""
        ,NULL                                                   AS ""Clocked In At""
        ,NULL                                                   AS ""Clocked Out At""    
        ,NULL                                                   AS ""Day of Week""
        ,NULL                                                   AS ""Is Weekend""
        ,NULL                                                   AS ""Week Offset""
        ,SHD_2.""Fiscal Week""                                    AS ""Fiscal Week""   
        ,SHD_2.""Fiscal Week Start""                              AS ""Fiscal Week Start"" 
        ,SHD_2.""Fiscal Week End""                                AS ""Fiscal Week End""        
        ,SHD_2.""Fiscal Day""                                     AS ""Fiscal Day""   
        ,SHD_2.""Fiscal Day Offset""                              AS ""Fiscal Day Offset""     
    -- --flags--------------------------------------------------------------------------------------
        ,NULL                                                   AS ""Is Clocked Out""
        ,NULL                                                   AS ""Was System Clock Out""
        ,NULL                                                   AS ""Gets Paid Break""
    -- --people------------------------------------------------------------------------------------- 
        ,NULL                                                   AS ""Employee""
        ,NULL                                                   AS ""Employee ID""        
        ,NULL                                                   AS JOBPOSITION_DIM_FK
        ,NULL                                                   AS LOCATION_DIM_FK 
        ,NULL                                                   AS ""Payroll ID""
        ,NULL                                                   AS ""General Ledger Number""        
    --  --Descriptors-------------------------------------------------------------------------------- 
       ,NULL                                                    AS ""Job Position""  --(i.e. Bartender, Cook, Server) 
       ,NULL                                                    AS ""Job Category""       
       ,NULL                                                    AS ""Pay Basis""
       ,NULL                                                    AS ""Shift ID""       
    -- Facts-----------------------------------------------------------------------------------------
        ,OLT.OVERTIMERULE                                       AS ""Overtime Rule""
        ,CASE WHEN OLT.HOURS_PER_DAY = 0 or :locationidS in (''[3]'',''[4]'',''[5]'')
            THEN 999999999 ELSE  OLT.HOURS_PER_DAY END                                      
                                                                AS ""Hours Per Day""
        ,CASE WHEN OLT.HOURS_PER_DAY = 0 or :locationidS in (''[3]'',''[4]'',''[5]'')
            THEN 999999999 ELSE  OLT.HOURS_PER_DAY END * 60 * 60                                 
                                                                AS ""Seconds Per Day""
                                                                
        ,CASE WHEN OLT.HOURS_PER_WEEK = 0  THEN 999999999 ELSE OLT.HOURS_PER_WEEK END                                     
                                                                AS ""Hours Per Week""

         ,CASE WHEN OLT.HOURS_PER_WEEK = 0  THEN 999999999 ELSE OLT.HOURS_PER_WEEK * 60 * 60 END                                                                  
                                                                AS ""Seconds Per Week""
        
        ,NULL                                                   AS ""Shift Count""
        ,0                                                      AS ""Break Count""   
        ,NULL                                                   AS ""Shift Per Day Count""
        ,0                                                      AS ""Shift Seconds""
        ,NULL                                                   AS ""Break Seconds""
     
        ,NULL                                                   AS ""Overtime Rate""
        ,NULL                                                   AS ""Regular Rate""
          FROM SHIFT_CTE                                        SHD_2
            INNER JOIN OVERTIMELABORRULE_JOBPOSITION_XREF       OJX
           ON OJX.JOBPOSITION_DIM_FK = SHD_2.JOBPOSITION_DIM_FK
             AND OJX.DW_ISCURRENTROW
         INNER JOIN DATAWAREHOUSE.OVERTIMELABORRULE_DIM             OLT
            ON SHD_2.LOCATION_DIM_FK = OLT.LOCATION_DIM_FK
              AND OLT.OVERTIMELABORRULE_DIM_NK = OJX.OVERTIMELABORRULE_DIM_FK
              AND OLT.DW_ISCURRENTROW  
              AND NOT OLT.DW_ISDELETED
              AND OLT.IS_ACTIVE
              ;
   -- )  --end of cte tables
 CREATE TEMP TABLE RULE_CTE AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));  
     
    --=========================================================================================
    SELECT to_char(UNI_2.""Support ID"")              as ""Support ID""
    , ''LAB-'' ||row_number() over (order by UNI_2.""Shift ID"") 
                                                    as ""Detail ID""  
    ,UNI_2.""Location""
    ,UNI_2.location_dim_fk                          as ""Location ID""
    ,UNI_2.""Time Zone""
    ,UNI_2.""Year""
    ,UNI_2.""Year and Month""
    ,CONVERT_TIMEZONE(''UTC'',UNI_2.""Time Zone"",UNI_2.""Clocked In At""::timestamp_ntz )::timestamp 
    --,UNI_2.""Clocked In At""
                                                     as ""Clocked In At""
    ,CONVERT_TIMEZONE(''UTC'',UNI_2.""Time Zone"",UNI_2.""Clocked Out At""::timestamp_ntz )::timestamp                                                      
    --,UNI_2.""Clocked Out At""
                                                     as ""Clocked Out At""

---------------------------------
    ,to_varchar(CONVERT_TIMEZONE(''UTC'',UNI_2.""Time Zone"",UNI_2.""Clocked In At""::timestamp_ntz )::timestamp,''HH12:MI:SS'')
                                                      as ""Clock In Time""
    ,to_varchar(CONVERT_TIMEZONE(''UTC'',UNI_2.""Time Zone"",UNI_2.""Clocked Out At""::timestamp_ntz )::timestamp,''HH12:MI:SS'')
                                                      as ""Clock Out Time""                                                      
---------------------------------
    ,UNI_2.""Day of Week""
    ,UNI_2.""Is Weekend""
    ,UNI_2.""Fiscal Week""
    ,UNI_2.""Fiscal Week Start""
    ,UNI_2.""Fiscal Week End""
    ,to_char(UNI_2.""Fiscal Day"")                      as ""Fiscal Day""
    ,UNI_2.""Is Clocked Out""
    ,UNI_2.""Was System Clock Out""
    ,UNI_2.""Employee""
    ,TO_VARCHAR(UNI_2.""Employee ID"")                  as ""Employee ID""
    ,UNI_2.""Payroll ID""                               as ""Payroll ID""
    ,UNI_2.""General Ledger Number""                    as ""General Ledger Number"" 
    ,UNI_2.""Job Position""
    ,UNI_2.""Job Category""
    ,UNI_2.""Pay Basis""
    ,''Shift '' ||UNI_2.""Shift ID""::decimal(18,0)       as ""Shift ID""
    ,UNI_2.""Overtime Rule""
    ,UNI_2.""Overtime Rate""::NUMBER(18,2)              as ""Overtime Rate""
    ,UNI_2.""Regular Rate"" ::NUMBER(18,2)              as ""Regular Rate""
    --=======================================================================  
    ,UNI_2.""Shift Seconds""::NUMBER(18,0)              as ""Shift Seconds""
    ,UNI_2.""Break Seconds""::NUMBER(18,0)              as ""Break Seconds""
    ,UNI_2.""Seconds Per Week""::NUMBER(18,0)           as ""Weekly Overtime Rule Seconds""
    ,UNI_2.""Seconds Per Day"" ::NUMBER(18,0)           as ""Daily Overtime Rule Seconds""
--===================== ====================================================================================
   -- ,UNI_2.""Shift Regular Seconds""::NUMBER(18,0)    as ""Regular Seconds""

   --    ,IFF(UNI_2.""Day Regular Seconds Running Total"" > UNI_2.""Seconds Per Week"" 
   --      AND UNI_2.""Seconds Per Week"" IS NOT NULL
   --          ,IFF(UNI_2.""Seconds Per Week"" <
   --               LAG(UNI_2.""Day Regular Seconds Running Total"") 
   --                 OVER (PARTITION BY  UNI_2.""Employee"", UNI_2.""Fiscal Week""  ORDER BY UNI_2.""Clocked In At"")
   --              ,UNI_2.""Shift Regular Seconds""
   --              ,UNI_2.""Day Regular Seconds Running Total"" - UNI_2.""Seconds Per Week""
   --              )   
   --          ,UNI_2.""Shift Day Overtime Seconds"") ::NUMBER(18,0)                                                      
   --                                                    as ""Overtime Seconds"" 

   ,UNI_2.""Shift Regular Seconds""::NUMBER(18,0)       
     -
    IFF(UNI_2.""Day Regular Seconds Running Total"" > UNI_2.""Seconds Per Week"" 
        AND UNI_2.""Seconds Per Week"" IS NOT NULL
            ,IFF(UNI_2.""Seconds Per Week"" <
                 LAG(UNI_2.""Day Regular Seconds Running Total"") 
                   OVER (PARTITION BY  UNI_2.""Employee"", UNI_2.""Fiscal Week""  ORDER BY UNI_2.""Clocked In At"")
                ,UNI_2.""Shift Regular Seconds""
                ,UNI_2.""Day Regular Seconds Running Total"" - UNI_2.""Seconds Per Week""
                )   
            ,UNI_2.""Shift Day Overtime Seconds"") ::NUMBER(18,0) 

     
       as ""Regular Seconds""
--=====================  ===================================================================================
   -- ,UNI_2.""Day Regular Seconds Running Total""
   -- -- -- ,UNI_2.""Shift Day Overtime Seconds""
   -- -- -- ,UNI_2.""Seconds Per Week""
   -- ,LAG(UNI_2.""Day Regular Seconds Running Total"") 
   --                 OVER (PARTITION BY  UNI_2.""Employee"", UNI_2.""Fiscal Week""  ORDER BY UNI_2.""Clocked In At"")           
   --                                                 as ""Last Running Total""
                                                   
   ,IFF(UNI_2.""Day Regular Seconds Running Total"" > UNI_2.""Seconds Per Week"" 
        AND UNI_2.""Seconds Per Week"" IS NOT NULL
            ,IFF(UNI_2.""Seconds Per Week"" <
                 LAG(UNI_2.""Day Regular Seconds Running Total"") 
                   OVER (PARTITION BY  UNI_2.""Employee"", UNI_2.""Fiscal Week""  ORDER BY UNI_2.""Clocked In At"")
                ,UNI_2.""Shift Regular Seconds""
                ,UNI_2.""Day Regular Seconds Running Total"" - UNI_2.""Seconds Per Week""
                )   
            ,UNI_2.""Shift Day Overtime Seconds"") ::NUMBER(18,0)                                                      
                                                      as ""Overtime Seconds"" 

--======================================================================================
 ,floor(UNI_2.""Shift Regular Seconds""/60/60/24) || '' D '' ||
       floor(UNI_2.""Shift Regular Seconds""/60/60%24) || '':'' ||
       floor(UNI_2.""Shift Regular Seconds""/60%60) || '':'' ||
       floor(UNI_2.""Shift Regular Seconds""%60)         as ""Regular D H:M:S""


 ,floor(IFF(UNI_2.""Day Regular Seconds Running Total"" > UNI_2.""Seconds Per Week"" 
                       AND UNI_2.""Seconds Per Week"" IS NOT NULL
                        ,UNI_2.""Day Regular Seconds Running Total"" - UNI_2.""Seconds Per Week""
                        ,UNI_2.""Shift Day Overtime Seconds"") ::NUMBER(18,0)/60/60/24) || '' D '' ||
       floor(IFF(UNI_2.""Day Regular Seconds Running Total"" > UNI_2.""Seconds Per Week"" 
                       AND UNI_2.""Seconds Per Week"" IS NOT NULL
                        ,UNI_2.""Day Regular Seconds Running Total"" - UNI_2.""Seconds Per Week""
                        ,UNI_2.""Shift Day Overtime Seconds"") ::NUMBER(18,0)/60/60%24) || '':'' ||
       floor(IFF(UNI_2.""Day Regular Seconds Running Total"" > UNI_2.""Seconds Per Week"" 
                       AND UNI_2.""Seconds Per Week"" IS NOT NULL
                        ,UNI_2.""Day Regular Seconds Running Total"" - UNI_2.""Seconds Per Week""
                        ,UNI_2.""Shift Day Overtime Seconds"") ::NUMBER(18,0)/60%60) || '':'' ||
       floor(IFF(UNI_2.""Day Regular Seconds Running Total"" > UNI_2.""Seconds Per Week"" 
                       AND UNI_2.""Seconds Per Week"" IS NOT NULL
                        ,UNI_2.""Day Regular Seconds Running Total"" - UNI_2.""Seconds Per Week""
                        ,UNI_2.""Shift Day Overtime Seconds"") ::NUMBER(18,0)%60)         as ""Overtime D H:M:S""  
  ,null ::NUMBER(18,2)                                                                  as ""Tips""           
  ,null ::NUMBER(18,2)                                                                  as ""Gratuities""        
--======================================================================================
      FROM(
            SELECT UNI_1.* 
                   ,SUM(IFF(UNI_1.""Shift Seconds"" < UNI_1.""Seconds Per Day""
                       OR UNI_1.""Seconds Per Day"" IS NULL
                        ,UNI_1.""Shift Seconds"" 
                        ,UNI_1.""Seconds Per Day"" )) 
                            OVER (PARTITION BY UNI_1.LOCATION_DIM_FK,UNI_1.""Employee ID"" ,UNI_1.""Fiscal Week"" ORDER BY UNI_1.""Shift ID"" 
                    )                                                             AS ""Day Regular Seconds Running Total"" 
                
                    ,IFF(UNI_1.""Seconds Per Day"" < UNI_1.""Shift Seconds""  
                         AND UNI_1.""Seconds Per Day"" IS NOT NULL
                        ,UNI_1.""Seconds Per Day""
                        ,UNI_1.""Shift Seconds"" 
                         )                                 AS ""Shift Regular Seconds"" 
                        
                    ,IFF(UNI_1.""Shift Seconds"" > UNI_1.""Seconds Per Day"" 
                       AND UNI_1.""Seconds Per Day"" IS NOT NULL
                        ,UNI_1.""Shift Seconds"" - UNI_1.""Seconds Per Day"" 
                        ,0)                                                        AS ""Shift Day Overtime Seconds"" 
                                                                                
              FROM (
              SELECT UNI_0.* 
               -- ,CASE WHEN UNI_0.""Shift Per Day Count"" > 1 
               --    THEN SUM(UNI_0.""Shift - Break Seconds"") 
               --       OVER (PARTITION BY LOCATION_DIM_FK,""Employee ID"" ,""Fiscal Day""   --see ""Running Total Each Fiscal Day Seconds""below
               --          ORDER BY ""Shift ID"") 
               --       ELSE UNI_0.""Shift - Break Seconds""   END                        AS ""Shift Seconds""

                      ,UNI_0.""Shift - Break Seconds""                                    AS ""Shift Seconds""    --mod 2024/09/09 yyy

                  ,SUM(UNI_0.""Shift - Break Seconds"") OVER (PARTITION BY LOCATION_DIM_FK,""Employee ID"" ,""Fiscal Day"" 
                        ORDER BY ""Shift ID"")                                                                                                                                                                                            AS ""Running Total Each Fiscal Day Seconds""
                 FROM (
                      SELECT  UNI.""Support ID""                                       AS ""Support ID"" 
                    --status, category, level------------------------------------------------------------------
                    --geography--------------------------------------------------------------------------------
                        ,MAX(UNI.""Location"")                                         AS ""Location""
                        ,MAX(UNI.""Organization"")                                     AS ""Organization""
                    -- --dates-----------------------------------------------------------------------------------
                        ,MAX(UNI.""Time Zone"")                                        AS ""Time Zone""
                        ,MAX(UNI.""Year"")                                             AS ""Year""
                        ,MAX(UNI.""Year and Month"")                                   AS ""Year and Month""
                        ,MAX(UNI.""Clocked In At"")                                    AS ""Clocked In At""
                        ,MAX(UNI.""Clocked Out At"")                                   AS ""Clocked Out At""    
                        ,MAX(UNI.""Day of Week"")                                      AS ""Day of Week""
                        ,MAX(UNI.""Is Weekend"")                                       AS ""Is Weekend""
                        ,MAX(UNI.""Week Offset"")                                      AS ""Week Offset""
                        ,MAX(UNI.""Fiscal Week"")                                      AS ""Fiscal Week""    
                        ,MAX(UNI.""Fiscal Week Start"")                                AS ""Fiscal Week Start""   
                        ,MAX(UNI.""Fiscal Week End"")                                  AS ""Fiscal Week End""   
                        ,MAX(UNI.""Fiscal Day"")                                       AS ""Fiscal Day""    
                    -- --flags--------------------------------------------------------------------------------------
                        ,MAX(UNI.""Is Clocked Out"")                                   AS ""Is Clocked Out""
                        ,MAX(UNI.""Was System Clock Out"")                             AS ""Was System Clock Out""
                        ,MAX(UNI.""Gets Paid Break"")                                  AS ""Gets Paid Break""
                        ,CASE WHEN MAX(UNI.""Overtime Rule"") IS NULL THEN FALSE ELSE TRUE END                     
                                                                                     AS ""Gets Overtime""        
                    -- --people------------------------------------------------------------------------------------- 
                        ,MAX(UNI.""Employee"")                                         AS ""Employee""
                        ,MAX(UNI.""Employee ID"")                                      AS ""Employee ID""
                        ,MAX(UNI.JOBPOSITION_DIM_FK)                                 AS JOBPOSITION_DIM_FK
                        ,MAX(UNI.LOCATION_DIM_FK)                                    AS LOCATION_DIM_FK    
                        ,MAX(UNI.""Payroll ID"")                                       AS ""Payroll ID""
                        ,MAX(UNI.""General Ledger Number"")                            AS ""General Ledger Number""
                    --  --Descriptors-------------------------------------------------------------------------------- 
                        ,MAX(UNI.""Job Position"")                                     AS ""Job Position""  --(i.e. Bartender, Cook, Server)   
                        ,MAX(UNI.""Job Category"")                                     AS ""Job Category""  --(i.e. Bartender, Cook, Server)                        
                        ,MAX(UNI.""Pay Basis"")                                        AS ""Pay Basis""
                        ,MAX(UNI.""Shift ID"")                                         AS ""Shift ID""  
                    -- Facts-----------------------------------------------------------------------------------------
                        ,IFNULL(MAX(UNI.""Overtime Rule""),''None'')                     AS ""Overtime Rule""
                        ,MAX(UNI.""Hours Per Day"")                                    AS ""Hours Per Day""
                        ,MAX(UNI.""Hours Per Week"")                                   AS ""Hours Per Week""
                        ,MAX(UNI.""Shift Count"")                                      AS ""Shift Count""
                        ,MAX(UNI.""Break Count"")                                      AS ""Break Count"" 

                        ,MAX(UNI.""Shift Per Day Count"")                              AS ""Shift Per Day Count""
          
                        ,IFNULL(MAX(UNI.""Break Seconds""),0)                          AS ""Break Seconds""
                        ,MAX(UNI.""Overtime Rate"")                                    AS ""Overtime Rate""
                        ,MAX(UNI.""Regular Rate"")                                     AS ""Regular Rate""
                        ,MAX(UNI.""Seconds Per Week"")                                 AS ""Seconds Per Week""
                        ,MAX(UNI.""Seconds Per Day"")                                  AS ""Seconds Per Day""                    
                        ,MAX(UNI.""Shift Seconds"")                                    AS ""Shift Total Seconds""
                        ,MAX(UNI.""Shift Seconds"") 
                           - IFF(MAX(UNI.""Gets Paid Break""),IFNULL(MAX(UNI.""Break Seconds""),0),0)                                    
                                                                                     AS ""Shift - Break Seconds""
                        FROM (
                            SELECT * FROM SHIFT_CTE 
                              UNION
                            SELECT * FROM BREAK_CTE  
                              UNION
                            SELECT * FROM RULE_CTE
                
                        )                                                   UNI
                        GROUP BY ""Support ID""
                                                                             ) UNI_0
                   
                                                                                )  UNI_1
                                                                                    
                                                                                        )UNI_2

  -- WHERE UNI_2.""Fiscal Day""::date
  --     >= :startdate::date --return only selected dates with ot calculated for a full fiscal week
  --   AND UNI_2.""Fiscal Day""::date
  --     <= :enddate::date 

;

--====================================================================================================================
CREATE TEMP TABLE TEMP_LABOR AS
             SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));  
             
--====================================================================================================================             
SELECT 
    TO_CHAR(INLT1.""Support ID"")                                    AS ""Support ID""
    ,''TGR-'' ||row_number() over (order by INLT1.""Support ID"")      AS ""Detail ID""
    ,IFNULL(INLT1.LOCATIONNAME,''None'')                             AS ""Location""
    ,INLT1.LOCATION_DIM_NK                                         AS ""Location ID""
    ,INLT1.TZ_NAME                                                 AS ""Time Zone""
    ,TO_CHAR(DATE_PART(YEAR,INLT1.FISCAL_DATE))                    AS ""Year""
    ,LEFT(TO_CHAR(INLT1.FISCAL_DATE),7)                            AS ""Year and Month""
    ,NULL                                                          AS ""Clocked In At""
    ,NULL                                                          AS ""Clocked Out At""
    ,NULL                                                          AS ""Clock In Time""
    ,NULL                                                          AS ""Clock Out Time""
    ,IFNULL(DAYNAME(INLT1.FISCAL_DATE::DATE),''None'')               AS ""Day of Week""
    ,CASE WHEN DAYNAME(INLT1.FISCAL_DATE::DATE) IN (''Sat'',''Sun'')  
                THEN TRUE ELSE FALSE END                           AS ""Is Weekend"" 
    ,YEAR(TIMESTAMPADD(DAY
        ,CASE WHEN INLT1.START_OF_PAYROLL_WEEK_INT = 0 
            THEN INLT1.START_OF_PAYROLL_WEEK_INT
            ELSE INLT1.START_OF_PAYROLL_WEEK_INT -1
         END
        ,INLT1.FISCAL_DATE::DATE)) || ''-'' ||
     WEEKOFYEAR(TIMESTAMPADD(DAY
         ,CASE WHEN INLT1.START_OF_PAYROLL_WEEK_INT = 0 
            THEN INLT1.START_OF_PAYROLL_WEEK_INT
            ELSE INLT1.START_OF_PAYROLL_WEEK_INT -1
         END
         ,INLT1.FISCAL_DATE::DATE))    
                                                                   AS ""Fiscal Week""
    ,NULL::date                                                    AS ""Fiscal Week Start""      
    ,NULL::date                                                    AS ""Fiscal Week End""    
    ,INLT1.START_OF_PAYROLL_WEEK_INT                               AS ""Week Offset""
    ,INLT1.FISCAL_DATE                                             AS ""Fiscal Day""
    ,NULL                                                          AS ""Is Clocked Out""
    ,NULL                                                          AS ""Was System Clock Out""
    ,INLT1.EMPLOYEE_NAME                                           AS ""Employee""
    ,INLT1.""Employee ID""                                           AS ""Employee ID""
    ,INLT1.""Payroll ID""                                            AS ""Payroll ID""
    ,INLT1.""General Ledger Number""                                 AS ""General Ledger Number"" 
    ,INLT1.""Job Position""                                          AS ""Job Position""
    ,INLT1.""Job Category""                                          AS ""Job Category""
    ,INLT1.""Pay Basis""                                             AS ""Pay Basis""
    ,to_char(INLT1.SHIFT)                                          AS ""Shift ID""
    ,NULL                                                          AS ""Overtime Rule""
    ,NULL::NUMBER(18,2)                                            AS ""Overtime Rate""
    ,NULL::NUMBER(18,2)                                            AS ""Regular Rate""
    ,NULL::NUMBER(18,0)                                            AS ""Shift Seconds""
    ,NULL::NUMBER(18,0)                                            AS ""Break Seconds""
    ,NULL::NUMBER(18,0)                                            AS aily
    ,NULL::NUMBER(18,0)                                            AS ""Daily Overtime Rule Seconds""
    ,NULL::NUMBER(18,0)                                            AS ""Regular Seconds""
    ,NULL::NUMBER(18,0)                                            AS ""Overtime Seconds""
    ,NULL                                                          AS ""Regular D H:M:S""
    ,NULL                                                          AS ""Overtime D H:M:S""
    ,INLT1.TIP::NUMBER(18,2)                                       AS ""Tips""
    ,INLT1.GRATUITIES::NUMBER(18,2)                                AS ""Gratuities""
    -------------------------------------------------------------------------------------------- 
    FROM (
    SELECT  TO_CHAR(MAX(chk.CHEQUE_FACT_NK))                      AS ""Support ID""
           ,CHK.FISCAL_DATE                                       AS FISCAL_DATE
           ,EMD.EMPLOYEE_NAME                                     AS EMPLOYEE_NAME
           ,EMD.EMPLOYEE_DIM_NK                                   AS ""Employee ID""
           ,EMD.PAYROLL_ID                                        AS ""Payroll ID""
           ,SHD.""General Ledger Number""                           AS ""General Ledger Number""
           ,SHD.""Job Position""                                    AS ""Job Position""
           ,SHD.""Job Category""                                    AS ""Job Category""
           ,SHD.""Pay Basis""                                       AS ""Pay Basis""
           
           ,LOC.TZ_NAME                                           AS TZ_NAME
           ,LOC.LOCATIONNAME                                      AS LOCATIONNAME
           ,LOC.LOCATION_DIM_NK                                   AS LOCATION_DIM_NK
           ,''Shift '' || SHD.""Shift ID""                            AS SHIFT
           ,MAX(ORG.START_OF_PAYROLL_WEEK_INT)                    AS START_OF_PAYROLL_WEEK_INT
           ,SUM(CHK.TIP)::NUMBER(18,2)                            AS TIP
           ,SUM(CHK.GRATUITIES)::NUMBER(18,2)                     AS GRATUITIES

        FROM DATAWAREHOUSE.CHEQUE_FACT                                chk
             INNER JOIN DATAWAREHOUSE.LOCATION_DIM                    loc
                ON chk.LOCATION_DIM_FK = loc.LOCATION_DIM_NK
                    AND loc.DW_ISCURRENTROW
                    AND chk.STATUS = ''Closed''
                    AND NOT chk.IS_TRAINING
                    AND chk.DW_ISCURRENTROW  
                    AND NOT chk.DW_ISDELETED
                    AND NOT chk.IS_TRAINING
                    AND chk.FISCAL_DATE::date   >= :startdate::date
                    AND chk.FISCAL_DATE::date   <= :enddate::date
                    AND chk.LOCATION_DIM_FK IN ( SELECT table1.value 
                           FROM table(split_to_table(:locationidS, '',''))  table1)
              INNER JOIN DATAWAREHOUSE.ORGANIZATION_DIM                 ORG
                    ON LOC.ORGANIZATION_DIM_FK = ORG.ORGANIZATION_DIM_NK
                      AND ORG.DW_ISCURRENTROW
              INNER JOIN DATAWAREHOUSE.EMPLOYEE_DIM                     emd
                    ON emd.EMPLOYEE_DIM_NK = chk.EMPLOYEE_DIM_FK
                       AND emd.DW_ISCURRENTROW  
              LEFT JOIN SHIFT_CTE                                       shd
                    ON shd.""Shift ID"" = chk.shift_dim_fk
             GROUP BY CHK.FISCAL_DATE
                   ,EMD.EMPLOYEE_NAME
                   ,EMD.EMPLOYEE_DIM_NK
                   ,EMD.PAYROLL_ID
                   ,LOC.TZ_NAME
                   ,LOC.LOCATIONNAME
                   ,LOC.LOCATION_DIM_NK
                   ,SHD.""Shift ID""
                   ,SHD.""General Ledger Number"" 
                   ,SHD.""Job Position"" 
                   ,SHD.""Job Category""
                   ,SHD.""Pay Basis""
    ) INLT1        
;
--====================================================================================================================
CREATE TEMP TABLE TEMP_TIPGRAT AS
             SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID())); 

-- -------------------------------------------------------------------------------------------------------------------
UPDATE TEMP_TIPGRAT
  SET ""Fiscal Week Start"" = dateadd(day,dayofweek(""Fiscal Day"") * -1  + ""Week Offset"" - case when dayofweek(""Fiscal Day"") >= ""Week Offset"" then 0 else 7 end
                            ,""Fiscal Day"") 
    ,""Fiscal Week End""    = dateadd(day,6,
                           dateadd(day,dayofweek(""Fiscal Day"") * -1  + ""Week Offset"" - case 
                             when dayofweek(""Fiscal Day"") >= ""Week Offset"" then 0 else 7 end ,""Fiscal Day""))
;

UPDATE TEMP_TIPGRAT
  SET ""Fiscal Week"" = YEAR(""Fiscal Week Start""::date) || ''-'' ||  RIGHT(''0'' || WEEKOFYEAR(""Fiscal Week Start""::date),2);
  
-- ------------------------------------------------------------------------------------------------------------------- 

ALTER TABLE TEMP_TIPGRAT DROP COLUMN ""Week Offset"";

--====================================================================================================================
reportSet := (    
  SELECT MIN(""Support ID"")                    AS ""Support ID""
        ,MIN(""Detail ID"")                     AS ""Detail ID""
        ,""Location""                           AS ""Location""
        ,""Location ID"" ::DECIMAL(18,0)        AS ""Location ID""        
        ,MAX(""Time Zone"")                     AS ""Time Zone""
        ,MAX(""Year"")                          AS ""Year""
        ,MAX(""Year and Month"")                AS ""Year and Month""
        ,to_char(MAX(""Clocked In At""))        AS ""Clocked In At""
        ,to_char(MAX(""Clocked Out At""))       AS ""Clocked Out At""
        ,to_char(MAX(""Clock In Time""))        AS ""Clock In Time""
        ,to_char(MAX(""Clock Out Time""))       AS ""Clock Out Time""
        ,MAX(""Day of Week"")                   AS ""Day of Week""
        ,MAX(""Is Weekend"")                    AS ""Is Weekend""
        ,MAX(""Fiscal Week"")                   AS ""Fiscal Week""
        -- ,MAX(""Fiscal Week Start"")             AS ""Fiscal Week Start""
        -- ,MAX(""Fiscal Week End"")               AS ""Fiscal Week End""
        ,to_char(MAX(""Fiscal Day""))           AS ""Fiscal Day""

        ,MAX(""Is Clocked Out"")                AS ""Is Clocked Out""
        ,MAX(""Was System Clock Out"")          AS ""Was System Clock Out""
        ,""Employee""                           AS ""Employee""
        ,""Employee ID""::NUMBER(18,0)          AS ""Employee ID""
        ,""Payroll ID""                         AS ""Payroll ID""
        ,""General Ledger Number""              AS ""General Ledger Number""
        
        ,MAX(""Job Position"")                  AS ""Job Position""
        ,MAX(""Job Category"")                  AS ""Job Category""        
        ,MAX(""Pay Basis"")                     AS ""Pay Basis""
        ,""Shift ID""                           AS ""Shift ID""       
        ,MAX(""Overtime Rule"")                 AS ""Overtime Rule""
        ,MAX(""Overtime Rate"")                 AS ""Overtime Rate""
        ,MAX(""Regular Rate"")                  AS ""Regular Rate""
        ,SUM(""Shift Seconds"")::NUMBER(18,0)   AS ""Shift Seconds""
        ,SUM(""Break Seconds"")::NUMBER(18,0)   AS ""Break Seconds""
        ,MAX(""Weekly Overtime Rule Seconds"")  AS ""Weekly Overtime Rule Seconds""
        ,MAX(""Daily Overtime Rule Seconds"")   AS ""Daily Overtime Rule Seconds"" 
        ,SUM(""Regular Seconds"")::NUMBER(18,0) AS ""Regular Seconds""
        ,SUM(""Overtime Seconds"")::NUMBER(18,0)AS ""Overtime Seconds""
        ,MAX(""Regular D H:M:S"")               AS ""Regular D H:M:S""
        ,MAX(""Overtime D H:M:S"")              AS ""Overtime D H:M:S""
        ,SUM(""Tips"") ::NUMBER(18,2)           AS ""Tips""
        ,SUM(""Gratuities"")::NUMBER(18,2)      AS ""Gratuities"" 
    FROM (
  SELECT * FROM TEMP_LABOR
    UNION
  SELECT * FROM TEMP_TIPGRAT where ""Tips"" <> 0.0 or ""Gratuities"" <> 0.00
  )  
  
  WHERE ""Fiscal Day""::date
      >= :startdate::date --return only selected dates with ot calculated for a full fiscal week
    AND ""Fiscal Day""::date
      <= :enddate::date 
  GROUP BY ""Shift ID"",""Location"",""Location ID"",""Employee"",""Employee ID"",""Payroll ID"",""General Ledger Number""
  ORDER BY ""Fiscal Day""
); 
----------------------------------------------------------------------------------------------------------------------
RETURN TABLE(reportSet);
--====================================================================================================================
END';"
PROCEDURE,DATAADMIN,SP_STAGELOADMODIFIEROPTIONS_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADMODIFIEROPTIONS_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.MODIFIEROPTIONS_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.MODIFIEROPTIONS_DIM(   
          MODIFIEROPTIONS_DIM_NK, 
          MODIFIEROPTION, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          MODIFIER_DIM_FK, 
          MODIFIER_COMMAND_DIM_FK, 
          CREATED_AT, 
          UPDATED_AT, 
          PRICE 
) 
 SELECT   MODIFIEROPTIONS_DIM_NK  as   MODIFIEROPTIONS_DIM_NK,  
   MODIFIEROPTION  as   MODIFIEROPTION,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   MODIFIER_DIM_FK  as   MODIFIER_DIM_FK,  
   MODIFIER_COMMAND_DIM_FK  as   MODIFIER_COMMAND_DIM_FK,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   PRICE  as   PRICE 
  FROM DATAADMIN.MODIFIEROPTIONS_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''MODIFIEROPTIONS_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''MODIFIEROPTIONS_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADTAXASSOCIATION_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADTAXASSOCIATION_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.TAXASSOCIATION_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.TAXASSOCIATION_DIM(   
          TAXASSOCIATION_DIM_NK, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_ISCURRENTROW, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          LOCATION_DIM_FK, 
          LOCATIONGROUP_DIM_FK, 
          ORDERTYPE_DIM_FK, 
          IS_VETO, 
          CREATED_AT, 
          UPDATED_AT 
) 
 SELECT   TAXASSOCIATION_DIM_NK  as   TAXASSOCIATION_DIM_NK,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   LOCATION_DIM_FK  as   LOCATION_DIM_FK,  
   LOCATIONGROUP_DIM_FK  as   LOCATIONGROUP_DIM_FK,  
   ORDERTYPE_DIM_FK  as   ORDERTYPE_DIM_FK,  
   IS_VETO  as   IS_VETO,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT 
  FROM DATAADMIN.TAXASSOCIATION_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''TAXASSOCIATION_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''TAXASSOCIATION_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,"SP_ACCOUNTINGSUMMARY_PAYMENTS_BOTTOM(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_ACCOUNTINGSUMMARY_PAYMENTS_BOTTOM""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet           resultset;
  -- startdate string    := ''2025-06-11'';  
  -- enddate string      := ''2025-06-11''; 
  -- locationid string   := ''[351]'';
  locationidS string  :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--=========================================================================================
BEGIN
  DROP TABLE IF EXISTS TEMP_TABLE1;

------------------------------------------------------------------------------------------------  
CALL DATAADMIN.SP_REPORT_ACCOUNTSUMMARY_PAYMENTS(:startdate,:enddate,:locationid);
CREATE TEMP TABLE TEMP_TABLE1 AS SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

SELECT ROW_NUMBER() OVER (ORDER BY ""Location ID"")  AS ""Support ID""   , *

 FROM (
  SELECT ""Location ID""                             AS ""Location ID""
    ,''Total Payments''                              AS ""Group 2""

    ,SUM(""Total"")                                  AS ""Total"" 
FROM TEMP_TABLE1
    WHERE ""Group 1"" = ( ''Total Payments'') 
         AND  ""Group 2"" in (''Tips2'',''Surcharges'',''Net Sales'',''Gift Card Sales'',''Taxes'',''Unpaid'',''Deposits'',''PayInOut'',''Refunds'')  --should include Net Sales
GROUP BY ""Location ID""

UNION

SELECT   ""Location ID""                             AS ""Location ID""
    ,REPLACE(""Group 2"",''Tips2'',''Tips'')             AS ""Group 2""

    ,SUM(""Total"") * -1                             AS ""Total"" 
FROM TEMP_TABLE1
    WHERE ""Group 1"" = ( ''Total Payments'') 
         AND  ""Group 2"" in (''Tips2'',''Surcharges'',''Gift Card Sales'',''Taxes'',''Unpaid'',''Deposits'',''PayInOut'',''Refunds'') --Should not include net sals
GROUP BY ""Group 1"",""Group 2"",""Location ID""
)
     ;    
     
--=========================================================================================
 reportSet:= (
   SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))
);

--===========================================================================================
RETURN TABLE(reportSet); 

END';"
PROCEDURE,DATAADMIN,"SP_CHECKFORFOREIGNKEY(VARCHAR, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_CHECKFORFOREIGNKEY""(""REPORTTYPE"" VARCHAR(1), ""TABLENAME"" VARCHAR(50))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
        -- REPORTTYPE VARCHAR(1)  := ''L'';
        -- TABLENAME VARCHAR      := ''ADDRESS_DIM'';     --no foreign keys
        -- TABLENAME VARCHAR      := ''ACTIVITY_FACT'';  --HAS NULL VALUES

        SCHEMANAME VARCHAR(075):= CASE UPPER(REPORTTYPE) 
                                        WHEN ''L'' THEN ''DATAADMIN'' 
                                        WHEN ''P'' THEN ''DATAWAREHOUSE''
                                        WHEN ''S'' THEN ''DATAWAREHOUSE_TEMP''
                                        ELSE ''WRONG'' END;
        HAS_RESULTS int;
        FK_RESULTS resultset;
        FK_NORESULTS resultset;
        SQLStmt resultset;
        SQLTextOut varchar;
        THIS_COLUMN varchar;

BEGIN
   DROP TABLE IF EXISTS dwtable_lists; 
   DROP TABLE IF EXISTS REPORT_OUTPUT;  
    
   CREATE TABLE REPORT_OUTPUT (
     ""TABLE"" varchar
     ,""COLUMN"" varchar
     ,""COUNT""  int
    );

    SELECT c.table_name                 as TABLE_NAME
        ,c.column_name                  as NATURAL_KEY
    FROM information_schema.columns c
         WHERE c.table_name   = c.table_name
            AND c.table_schema = :SCHEMANAME
            AND c.table_name   = :TABLENAME
            AND c.column_name  ilike ''%_FK''
        ;
        
    CREATE TABLE dwtable_lists AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));
     
    FK_NORESULTS := (
      SELECT :TABLENAME                   as ""TABLE""
        ,''This table has NO Foreign Keys'' as ""COLUMN""
        ,0                                as ""COUNT""
      );
    HAS_RESULTS:=(SELECT COUNT(*) FROM dwtable_lists);

    SQLStmt := (select * from dwtable_lists);

  --loop through all rows that create the load stored proceedure 1 per table
      BEGIN
          FOR record IN SQLStmt DO
      
            THIS_COLUMN := record.NATURAL_KEY;
            
            SELECT :TABLENAME as ""Table""
               ,:THIS_COLUMN  as ""Column""
               ,SUM(case when identifier(:THIS_COLUMN) IS NULL THEN 1 ELSE 0 END) as ""Count"" 
            FROM identifier(:TABLENAME) ;

            INSERT INTO REPORT_OUTPUT(""TABLE"",""COLUMN"",""COUNT"") 
                SELECT ""Table"",""Column"",""Count"" FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));
            
          END FOR;
            
     END;

FK_RESULTS := (SELECT * from REPORT_OUTPUT);   

IF (:HAS_RESULTS > 0)  --Has primary key
    THEN
      RETURN TABLE(FK_RESULTS); 
    ELSE
      RETURN TABLE(FK_NORESULTS);
  END IF;
                    
END';"
PROCEDURE,DATAADMIN,"SP_DATASHARE_CRAFTABLE_VOID(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_DATASHARE_CRAFTABLE_VOID""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE
  reportSet resultset;
  -- startdate timestamp_tz      := ''2020-08-20T14:48:37.661Z'';
  -- enddate timestamp_tz        := ''2029-08-20T14:48:37.661Z'';
  -- locationid string           := ''[35]'';
  locationidS string          :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
  today char(11)              := CURRENT_DATE()::date::VARCHAR(10);
-----------------------------------------------------------------------------------------------------------------------
BEGIN
DROP TABLE if exists VOID_DATA_TEMP;

CALL DATAADMIN.SP_REPORT_VOID_0001(:startdate,:enddate,:locationidS);
CREATE TEMP TABLE VOID_DATA_TEMP AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));
;
-----------------------------------------------------------------------------------------------------------------------
     reportSet := (
         SELECT 
             ORG.ORGANIZATION          AS ""Organization Name""
            ,ORG.ORGANIZATION_DIM_NK   AS ""Organization ID""
            ,VDT.""Location""            AS ""Location Name""
            ,VDT.""Location ID""         AS ""Location ID""
            ,VDT.""Fiscal Date""         AS ""Business Day""
            ,VDT.""Support ID""          AS ""Void ID""
            ,VDT.""Level""               AS ""Void Level""
            ,VDT.""Reason""              AS ""Void Reason""
            ,VDT.""Check""               AS ""Check Number""  
            ,VDT.""Check ID""            AS ""Check ID""
            ,VDT.""Item""                AS ""Item Name""
            ,VDT.""Item ID""             AS ""Item ID""
            ,null                      AS ""Item Amount"" --TODO do we need this? the void report is using the item price to set the void amount, so how can this number be different than the void amount?
            ,VDT.""Approver""            AS ""Employee for Void (approver)""
            ,VDT.""Amount""              AS ""Void Amount"" --TODO there are 0 and null void amounts. why?
         FROM 
         VOID_DATA_TEMP                                     VDT
         LEFT JOIN DATAWAREHOUSE.ORGANIZATION_DIM           ORG
            ON VDT.""Location ID"" = ORG.ORGANIZATION_DIM_NK
            AND ORG.DW_ISCURRENTROW
     );
--=====================================================================================================================
RETURN TABLE(reportSet);
END';"
PROCEDURE,DATAADMIN,"SP_LOAD_COMPEAT_XML(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_COMPEAT_XML""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz      := ''2025-06-05'';
  -- enddate timestamp_tz        := ''2025-06-05'';
  -- locationid string           := ''[26]'';
  startdatelabor timestamp_tz := DATEADD(DAY,-30, to_char(:startdate::DATE));
  locationidS string          := REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
  pollDate string             := to_varchar(:startdate,''MM/DD/YYYY'');

---------------------------------------------------------------------------------------------------------------------------
  tagOpen1 string        := ''<?xml version=""1.0""?><PollData CompanyID=""2159"" LocationID=""'' || ''17'' || ''"" PollDate=""'' || :pollDate ||''""><Configuration>'';
  tagConfigClose string  := ''</Configuration>'';
  tagClose1 string       := ''</PollData>'';  
-- tagCheckOpen   string := ''<Check Number=""%Checkno%""><CloseTime>%CloseTime%</CloseTime><DaypartName>%DayPart%</DaypartName> <EmployeeNumber>%EmpNo%</EmployeeNumber><GuestCount>%GuestCount%</GuestCount><OpenTime>%OpenTime%</OpenTime><OrderModeName>%OrderType%</OrderModeName><RevenueCenterName>%RevCenter%</RevenueCenterName>'';  
  tagItem string         := ''<Item Number=""%ItemNumber%"" Name=""%ItemName%""></Item>'';
  tagCategoryOpen string := ''<Category Name=""%CategoryName%""><Items>'';
  tagEmployee string     := ''<Employee Number=""%EmpID%"" FirstName=""%FirstName%"" LastName=""%LastName%"">'';
  tagTender string       := ''<Tender Number=""%TenderId%"" Name=""%Name%"" Type=""%NonCash%"" />'';  
  tagTax string          := ''<Tax Number=""%TaxNumber%"" Name=""%TaxName%""><Rate>%TaxRate%</Rate></Tax>'';
  tagCheckOpen    string := ''<Check Number=""%Checkno%""><CloseTime>%CloseTime%</CloseTime><DaypartName>%DayPart%</DaypartName> <EmployeeNumber>%EmpNo%</EmployeeNumber><GuestCount>%GuestCount%</GuestCount><OpenTime>%OpenTime%</OpenTime><OrderModeName>%OrderType%</OrderModeName><RevenueCenterName>%RevCenter%</RevenueCenterName>'';
  tagCheckClose   string := ''<Check>'';
   -- tagItemsale string := ''<ItemSale Quantity=""%Quantity%"" GrossAmount=""%GrossAmount%""><CloseTime>%CloseTime%</CloseTime><DaypartName>%DayPart%</DaypartName> <EmployeeNumber>%EmpNo%</EmployeeNumber><GuestCount>%GuestCount%</GuestCount><OpenTime>%OpenTime%</OpenTime><OrderModeName>%OrderType%</OrderModeName><RevenueCenterName>%RevCenter%</RevenueCenterName><ItemNumber>%ItemNumber%</ItemNumber>%Promo%</ItemSale>'';
  tagItemsale       string := ''<ItemSale Quantity=""%Quantity%"" GrossAmount=""%GrossAmount%""><DaypartName>%DayPart%</DaypartName><Time>%Time%</Time><EmployeeNumber>%EmpNo%</EmployeeNumber><OrderModeName>%OrderType%</OrderModeName><RevenueCenterName>%RevCenter%</RevenueCenterName><ItemNumber>%ItemNumber%</ItemNumber>%Promo%</ItemSale>''; 
  tagPayment        string := ''<Payment BaseAmount=""%BaseAmount%""><TenderNumber>%TenderNumber%</TenderNumber></Payment>'';

  tagGiftCard       string := ''<GCSale GrossAmount=""%Amount%""></GCSale>'';
  tagSurcharges     string := ''<Surcharge Amount=""%SurchargeAmount%"" ><SurchargeName>%SurchargeName%</SurchargeName><OrderModeName>%OrderType%</OrderModeName><RevenueCenterName>%RevCenter%</RevenueCenterName><DaypartName>%DayPart%</DaypartName><Time>%Time%</Time></Surcharge>'';  


  
  tagExclusiveTaxes string := ''<ExclusiveTax Amount=""%Amount%""><TaxNumber>%TaxNumber%</TaxNumber><Time>%Time%</Time><OrderModeName>%OrderType%</OrderModeName><RevenueCenterName>%RevCenter%</RevenueCenterName><DaypartName>%DayPart%</DaypartName></ExclusiveTax>'';
  -- daypart, order mode, and revenue center
  tagCheckPromo     string := ''<Promo Amount=""%Amount%""><PromoName>%PromoName%</PromoName><DaypartName>%DayPart%</DaypartName><OrderModeName>%OrderType%</OrderModeName><RevenueCenterName>%RevCenter%</RevenueCenterName><Time>%Time%</Time></Promo>'';
  tagRefunds        string :=''<Refund Amount=""%Amount%"" Quantity=""%Quantity%""></Refund>'';
  tagVoids          string :=''<Void Amount=""%Amount%"" Quantity=""%Quantity%""><ItemNumber>%ItemNumber%</ItemNumber><VoidName>%VoidName%</VoidName><Time>%Time%</Time></Void>'';
  -- tagShift       string :=''<Shift ShiftNumber=""%ShiftNumber%"" ClockInDate=""%ClockInDate%"" ClockInTime=""%ClockInTime%""> <EmployeeNumber>%EmployeeNumber%</EmployeeNumber><ClockOutTime>%ClockOutTime%</ClockOutTime><JobName>%JobName%</JobName> <PayRate>%PayRate%</PayRate><RegularHours>%RegularHours%</RegularHours> <OvertimeHours>%OvertimeHours%</OvertimeHours><OvertimePayRate>%OvertimePayRate%</OvertimePayRate></Shift>'';
  tagPaidInOut      string:=''<PaidInOut Amount=""%PaidInOut%"" AffectsCash=""True""><PaidInOutName>%PaidInOutName%</PaidInOutName> </PaidInOut>'';
tagDeposits         string:=''<Deposit DateOfBusiness=""%FiscalDay%"" Amount=""%Amount%""> </Deposit>'';
 
--==========================================================================================================================
BEGIN
  DROP TABLE IF EXISTS TEMP_salesdetail; 
  DROP TABLE IF EXISTS TEMP_salesdetail_all;
                                             --<Configuration>
  DROP TABLE IF EXISTS TEMP_catitem;         --  <Category><Item>
  DROP TABLE IF EXISTS TEMP_employees;       --  <Employee>
  DROP TABLE IF EXISTS TEMP_tender;          --  <Tender>
  DROP TABLE IF EXISTS TEMP_taxdetail;       --  <Tax>    --are we using this???check on it
                                             --</Configuration>

  DROP TABLE IF EXISTS TEMP_checksummary;    --Summary Check Data
  DROP TABLE IF EXISTS TEMP_discountSummary; --Summary Discount Data  
  DROP TABLE IF EXISTS TEMP_paidInOutSummary;--Summary Payin Pay out
  
  DROP TABLE IF EXISTS TEMP_check;           --<Check>
  DROP TABLE IF EXISTS TEMP_itemsale;        --  <ItemSales>
  DROP TABLE IF EXISTS TEMP_itemPromo;       --    <Promo>
  DROP TABLE IF EXISTS TEMP_payments;        --  <Payments>
  DROP TABLE IF EXISTS TEMP_refunds;         --  <Refunds>
  DROP TABLE IF EXISTS TEMP_surcharges;      --  <Surcharges>  
  DROP TABLE IF EXISTS TEMP_voids;           --  <Voids>
  DROP TABLE IF EXISTS TEMP_exclusiveTaxes;  --  <ExclusiveTaxes>
  DROP TABLE IF EXISTS TEMP_checkPromo;      --  <Promo>
  DROP TABLE IF EXISTS TEMP_checkitem;
  DROP TABLE IF EXISTS TEMP_gcsales;         --  <GiftCardSales>
                                             --</Check>
                                             
  DROP TABLE IF EXISTS TEMP_PaidInOuts;      --<PaidInOuts>
  DROP TABLE IF EXISTS TEMP_Deposits;        --<Deposits>  
  DROP TABLE IF EXISTS TEMP_shifts;          --<Shifts>

  DROP TABLE IF EXISTS TEMP_allShifts;
  DROP TABLE IF EXISTS TEMP_item;
  DROP TABLE IF EXISTS TEMP_items;
  DROP TABLE IF EXISTS TEMP_voids_all;
  DROP TABLE IF EXISTS TEMP_xml;  
  
---------------------------------------------------------------------------------------------------------------------------
--Menu and Category
CALL dataadmin.SP_LOAD_COMPEAT_MENUITEMS(:startdate,:enddate,:locationid);
-- CALL dataadmin.SP_LOAD_365_MENUITEMS(''2020-04-27'',''2029-04-27'',''[26]'');
SELECT DISTINCT REPLACE(:tagCategoryOpen,''%CategoryName%'',IFNULL(REPLACE(""''CATEGORYNAME''"",'','',''''),''None'') )
  || LISTAGG(REPLACE(REPLACE(:tagItem,''%ItemNumber%'',IFNULL(REPLACE(""''ITEMNUMBER''"",'','',''''),''None''))
    ,''%ItemName%'',IFNULL(REPLACE(REPLACE(REPLACE(
    regexp_replace(""''ITEMNAME''"", ''[^a-zA-Z,_,0-9, ]+'', '''') 
    ,'','',''''),''""'',''''),'''',''''),''None''))) OVER (PARTITION BY ""''CATEGORYNAME''"")
  || ''</Items></Category>''  AS XMLTEXT
  FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))
  WHERE ""''ITEMNUMBER''"" <> ''ItemNumber''  --REMOVE THE HEADER
  ;

CREATE TEMP TABLE TEMP_catitem AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID())); 

-- The item numbers (323, 537, & 630) are not defined in the configuration section.
--     SELECT * FROM TEMP_catitem
---------------------------------------------------------------------------------------------------------------------------
--Employees
CALL dataadmin.SP_LOAD_365_EMPLOYEES(:startdatelabor,:enddate,:locationid);
--tagEmployee string     := ''<Employee Number=""%EmpID%"" FirstName=""%FirstName%"" LastName=""%LastName%""/>'';
CREATE TEMP TABLE TEMP_employees AS
SELECT ''<Employees>''
    || LISTAGG(
       REPLACE( 
          REPLACE(
           REPLACE(:tagEmployee,''%EmpID%'',EMPLOYEEID),
             ''%FirstName%'',FIRSTNAME
             ),''%LastName%'',LASTNAME
             )
            || ''</Employee>''
        )
     || ''</Employees>''
         AS XMLTEXT
       FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));
       
---------------------------------------------------------------------------------------------------------------------------
--Tender
CALL dataadmin.SP_LOAD_365_TENDERS(:startdate,:enddate,:locationid);

-- --tagTender string     := ''<Tender Number=""%TenderId%"" Name=""%Name%"" Type=""%NonCash%"" />'';
CREATE TEMP TABLE TEMP_tender AS
SELECT ''<Tenders>''
    || LISTAGG(
       REPLACE( 
          REPLACE(
           REPLACE(:tagTender,''%TenderId%'',NUMBER),
             ''%Name%'',NAME
             ),''%NonCash%'',TYPE
             )
        )
     || ''</Tenders>''
         AS XMLTEXT
FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

---------------------------------------------------------------------------------------------------------------------------
--Tax
-- tagTax string := ''<Tax Number=""%TaxNumber%"" Name=""%TaxName%""><Rate>%TaxRate%</Rate></Tax>'';
--select * From TEMP_taxdetail
CREATE TEMP TABLE TEMP_taxdetail AS
SELECT  LISTAGG(
       REPLACE(REPLACE(REPLACE(
          :tagTax
             ,''%TaxNumber%'',TRD.TAXRATE_DIM_NK),
             ''%TaxName%'',TRD.TAXRATE),
             ''%TaxRate%'',TRD.PERCENT::DECIMAL(36,2))  
        )
         AS XMLTEXT
  FROM DATAWAREHOUSE.TAXRATE_DIM              TRD
    INNER JOIN DATAWAREHOUSE.ORGANIZATION_DIM ORG
      ON TRD.ORGANIZATION_DIM_FK = ORG.ORGANIZATION_DIM_NK 
        AND TRD.DW_ISCURRENTROW
        AND ORG.DW_ISCURRENTROW
    INNER JOIN DATAWAREHOUSE.LOCATION_DIM      LOC
      ON LOC.ORGANIZATION_DIM_FK = ORG.ORGANIZATION_DIM_NK
      AND LOC.DW_ISCURRENTROW
      AND (LOC.LOCATION_DIM_NK IN (
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)   
            OR TRD.TAXRATE_DIM_NK = -1    )
    GROUP BY TRD.TAXRATE_DIM_NK,TRD.TAXRATE
; 

---------------------------------------------------------------------------------------------------------------------------
--Check Level Information
CREATE TEMP TABLE TEMP_checksummary AS
SELECT CHK.cheque_fact_nk                                               AS Checkno
    ,chk.STATUS                                                         AS CheckStatus
    ,TO_CHAR(TO_TIMESTAMP(CHK.CLOSED_AT),''MM/DD/YYYY HH24:MI:SS'')       AS CloseTime
    ,DPD.DAYPART                                                        AS DayPart
    ,CHK.EMPLOYEE_DIM_FK                                                AS EmpNo
    ,CHK.PARTY_COUNT                                                    AS GuestCount
    ,TO_CHAR(TO_TIMESTAMP(CHK.OPENED_AT),''MM/DD/YYYY HH24:MI:SS'')       AS OpenTime
    ,OTD.ORDER_TYPE                                                     AS OrderType
    ,CHK.REVENUECENTERNAME                                              AS RevCenter 
    ,CHK.TAX                                                            AS ExclusiveTax
FROM DATAWAREHOUSE.CHEQUE_FACT                                          chk
  INNER JOIN DATAWAREHOUSE.ORDERTYPE_DIM                                otd
     ON chk.ORDERTYPE_DIM_FK = otd.ORDERTYPE_DIM_NK
       AND otd.DW_ISCURRENTROW
       AND chk.DW_ISCURRENTROW       
       AND chk.STATUS in (''Closed''/*,''Voided''*/)
       AND (chk.UNPAID = 0 /* OR chk.STATUS = ''Voided''*/)
       AND NOT chk.IS_TRAINING
       AND NOT chk.DW_ISDELETED
       AND chk.CLOSED_AT is not null
       AND (chk.FISCAL_DATE::date   >= :startdate::date 
          AND chk.FISCAL_DATE::date <= :enddate::date)
       AND chk.LOCATION_DIM_FK IN (
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)          
    INNER JOIN DATAWAREHOUSE.DAYPART_DIM                                 dpd
      ON chk.DAYPART_DIM_FK = dpd.DAYPART_DIM_NK
        AND dpd.DW_ISCURRENTROW
;

CREATE TEMP TABLE TEMP_check AS
SELECT Checkno
       ,REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE( REPLACE(:tagCheckOpen,''%Checkno%'',Checkno),
             ''%CloseTime%'',CloseTime),
             ''%DayPart%'',DayPart),
             ''%EmpNo%'',EmpNo),
             ''%GuestCount%'',GuestCount::DECIMAL(36,0)),
             ''%OpenTime%'',OpenTime),
             ''%OrderType%'',OrderType),
             ''%RevCenter%'',RevCenter),
             ''%ExclusiveTax%'',ExclusiveTax::DECIMAL(36,2))
         AS XMLTEXT
FROM TEMP_checksummary
; 

----------------------------------------------------------------------------------------------------------------------------
--Discount Summary
--TEMP_discountSummary
CALL DATAADMIN.SP_REPORT_DISCOUNT(:startdate,:enddate,:locationid);
-- CALL dataadmin.SP_REPORT_DISCOUNT(''2020-12-17'',''2029-12-17'',''[351]'');
CREATE TEMP TABLE TEMP_discountSummary AS
SELECT *
FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))
; 

----------------------------------------------------------------------------------------------------------------------------
--Item level Info  
CREATE TEMP TABLE TEMP_salesdetail_all 
  AS
SELECT to_char(CHK.cheque_fact_nk)                                 AS CheckNumber --* string
    ,itf.ITEMSTATUS                                                AS ITEMSTATUS
    ,itf.MENUITEMNAME_DIM_FK                                       AS ""Menu Item ID""
    ,TO_CHAR(TO_TIMESTAMP(CHK.CLOSED_AT),''MM/DD/YYYY HH24:MI:SS'')  AS CloseTime  --* DateTime(mm/dd/yyyy hh:mm:ss)
    ,TO_CHAR(row_number() OVER (ORDER BY itf.ITEM_FACT_NK)::NUMBER(18,0))                   
                                                                   AS ItemSale_TicketItemNumber  --* integer  
    ,itf.ITEM_FACT_NK                                              AS Item_Fact_NK                              
    ,TO_CHAR(itf.MENUITEMNAME_DIM_FK)                              AS ItemSale_ItemNumber  --* string 
    ,TO_CHAR((itf.GROSS -  IFNULL(itf.INCLUSIVETAX,0)) ::DECIMAL(18,2))     
                                                                   AS ItemSale_GrossAmount --* decimal
    ,TO_CHAR(1)                                                    AS ItemSale_Modifiers_ItemNumber --**string this is an fk 
    ,TO_CHAR(0)                                                    AS ItemSale_Modifiers_Quantity --int
    ,TO_CHAR(0)                                                    AS ItemSale_Modfiers_GrossAmount --** int
    ,''None''                                                        AS ItemSale_Comp_CompName --* string name of discount  
    ,TO_CHAR(0.00)                                                 AS ItemSale_Comp_Amount  --*decimal amount subtracted from tota
    ,''None''                                                        AS ItemSale_Promo_PromoName --*string  promo name
    ,TO_CHAR(itf.DiscountItem::decimal(18,2))                      AS ItemSale_Promo_Amount --*amount subtracted from total 
    ,IFNULL(REPLACE(itf.REVENUECENTERNAME,'','',''''),''None'')          AS ItemSale_RevenueCenterName  --string
    ,TO_CHAR(IFNULL(itf.QUANTITY,0)::number(18,0))                 AS ItemSale_Quantity           --int

    FROM DATAWAREHOUSE.ITEM_FACT                                   itf
     INNER JOIN DATAWAREHOUSE.MENUITEMNAME_DIM                     med
       ON med.MENUITEMNAME_DIM_NK = itf.MENUITEMNAME_DIM_FK
          AND itf.ITEMSTATUS IN (''Added'',''Sent'',''Voided'')
          AND itf.CHECKSTATUS IN (''Closed'')
          AND itf.DW_ISCURRENTROW  
          AND med.DW_ISCURRENTROW  
          AND NOT itf.DW_ISDELETED
          AND NOT itf.IS_TRAINING
          AND itf.LOCATION_DIM_FK IN (--351,352
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)
      INNER JOIN DATAWAREHOUSE.CHEQUE_FACT                          chk
        ON chk.CHEQUE_FACT_NK = itf.CHEQUE_FACT_FK
          AND chk.DW_ISCURRENTROW
          AND chk.STATUS in (''Closed'')
          AND itf.ITEMSTATUS IN (''Added'',''Sent'',''Voided'')
          AND chk.UNPAID = 0
          AND chk.CLOSED_AT is not null
          AND (chk.FISCAL_DATE::date >= :startdate::date 
                AND chk.FISCAL_DATE::date  <= :enddate::date)
      INNER JOIN DATAWAREHOUSE.REPORTCATEGORY_DIM                    meg
        ON med.REPORTCATEGORY_DIM_FK = meg.REPORTCATEGORY_DIM_NK
          AND meg.DW_ISCURRENTROW = TRUE
      INNER JOIN DATAWAREHOUSE.COGSCATEGORY_DIM                      ccd
        ON ccd.COGSCATEGORY_DIM_NK = meg.COGSCATEGORY_DIM_FK    
          AND ccd.DW_ISCURRENTROW         
     ORDER BY CHK.CLOSED_AT DESC;  
  
CREATE TEMP TABLE TEMP_itemsale  AS
SELECT DISTINCT ITM.CHECKNUMBER  AS Checkno
  ,ITM.ItemSale_TicketItemNumber AS ItemNO
  , LISTAGG(
       REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
        :tagItemsale,''%Quantity%'',TO_CHAR(IFNULL(ITM.ITEMSALE_QUANTITY,0)::number(18,0))),
             ''%GrossAmount%'',ITM.ITEMSALE_GROSSAMOUNT ::DECIMAL(18,2)),
             ''%ItemNumber%'',ITM.ITEMSALE_ITEMNUMBER),
             ''%CloseTime%'',ITM.CloseTime),
             ''%DayPart%'',CHK.DayPart),
             ''%EmpNo%'',CHK.EmpNo),
             ''%GuestCount%'',CHK.GuestCount::DECIMAL(36,0)),
             ''%OpenTime%'',CHK.OpenTime),
             ''%OrderType%'',CHK.OrderType),
             ''%Time%'',CHK.OpenTime),
             ''%RevCenter%'',CHK.RevCenter),
             ''%ExclusiveTax%'',ExclusiveTax::DECIMAL(36,2))
             ) OVER (PARTITION BY ITM.CHECKNUMBER,ITM.ItemSale_TicketItemNumber)
         AS XMLTEXT   
FROM TEMP_SALESDETAIL_ALL                             ITM
  INNER JOIN TEMP_CHECKSUMMARY                        CHK
    ON TO_CHAR(ITM.CHECKNUMBER) = TO_CHAR(CHK.CHECKNO)
      AND ITM.ITEMSTATUS <> ''Voided''
; 

---------------------------------------------------------------------------------------------------------------------------          
--GiftCardSales

-- select * from TEMP_gcsales  where  ""Check ID"" = 266298;
CREATE TEMP TABLE TEMP_gcsales                                       AS
SELECT   DISTINCT CHF.CHEQUE_FACT_NK                                 AS Checkno        
 ,CHF.CHEQUE_FACT_NK                                                 AS ""Check ID""
 ,''<GiftCardSales>''  ||
  LISTAGG( replace(:tagGiftCard,''%Amount%'',GCD.START_BALANCE::decimal(18,2) )
   ) OVER (PARTITION BY CHF.CHEQUE_FACT_NK)       
   || ''</GiftCardSales>''
                                                                     AS XMLTEXT
   FROM GIFTCARD_DIM                                                 GCD
     INNER JOIN DATAWAREHOUSE.GIFTCARDTRANSACTION_FACT               GCF
       ON GCD.GIFTCARD_DIM_NK = GCF.GIFTCARD_DIM_FK
          AND GCF.DW_ISCURRENTROW
          AND GCD.DW_ISCURRENTROW
          AND GCD.IS_ISSUED
          AND NOT GCD.DW_ISDELETED
          AND GCD.DW_ISCURRENTROW
          AND GCF.COMMAND = ''Issue'' 
      INNER JOIN DATAWAREHOUSE.CHEQUE_FACT                       CHF
        ON CHF.CHEQUE_FACT_NK = GCf.CHEQUE_FACT_FK
          AND CHF.DW_ISCURRENTROW
          AND CHF.STATUS = ''Closed''
          AND CHF.FISCAL_DATE::date >= :startdate::date
          AND CHF.FISCAL_DATE::date <= :enddate::date  
          AND CHF.LOCATION_DIM_FK IN (
                     SELECT table1.value 
                       FROM table(split_to_table(:locationidS, '',''))  table1)    
          ;
          
---------------------------------------------------------------------------------------------------------------------------
--Payments
CALL dataadmin.SP_LOAD_365_PAYMENTS(:startdate,:enddate,:locationid);
-- -- CALL dataadmin.SP_LOAD_365_PAYMENTS(''2020-12-17'',''2029-12-17'',''[351]'');
-- -- --tagPayment string:=''<Payment BaseAmount=""%BaseAmount%""><TenderNumber>%TenderNumber%</TenderNumber></Payment>'';
CREATE TEMP TABLE TEMP_payments AS
SELECT DISTINCT SPLIT_PART(""''PAYMENT_CHECKNUMBER''"",''.'',2) AS Checkno
   ,''<Payments>''
    || LISTAGG(
          REPLACE(REPLACE(
             :tagPayment,''%BaseAmount%'',""''PAYMENT_BASEAMOUNT''""),
             ''%TenderNumber%'',""''PAYMENT_TENDERNUMBER''"")
        ) OVER (PARTITION BY ""''PAYMENT_CHECKNUMBER''"")
     || ''</Payments>''
         AS XMLTEXT
FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))
  WHERE ""''PAYMENT_CHECKNUMBER''"" <> ''Payment_CheckNumber'';

----------------------------------------------------------------------------------------------------------------------------
--Promo Check Level (aka Discount)
--select * From TEMP_discountSummary
CREATE TEMP TABLE TEMP_checkPromo AS
SELECT DISTINCT ""Check ID"" AS Checkno
   ,''<Promos>''
    || LISTAGG(
          REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
             :tagCheckPromo
               ,''%Amount%'',""Discount Amount""),
               ''%PromoName%'',""Discount Name""),

               ''%DayPart%'',""Daypart""),
               ''%OrderType%'',ORDERTYPE),
               ''%Time%'',CLOSETIME),               
               ''%RevCenter%'',""Revenue Center"")

        ) OVER (PARTITION BY ""Check ID"" )
     || ''</Promos>''
         AS XMLTEXT
FROM TEMP_discountSummary                 DIS
  LEFT JOIN TEMP_checkSummary             CHK
    ON DIS.""Check ID"" = CHK.CHECKNO
  WHERE ""Discount Level"" = ''Check'';

----------------------------------------------------------------------------------------------------------------------------
--Promo Item Level (aka Discount)
CREATE TEMP TABLE TEMP_itemPromo AS
SELECT DISTINCT tis.ItemSale_TicketItemNumber AS Itemno
   ,''<Promos>''
    || LISTAGG(
          REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
          :tagCheckPromo
            ,''%Amount%'',""Discount Amount""),
            ''%PromoName%'',""Discount Name""),
            ''%Time%'',CHK.CLOSETIME),
            ''%DayPart%'',""Daypart""),
            ''%OrderType%'',ORDERTYPE),
            ''%RevCenter%'',""Revenue Center"")

        ) OVER (PARTITION BY  ""Check ID"" || ''.''|| SPLIT_PART(""Support ID"",''.'',2)  ) 
     || ''</Promos>''
         AS XMLTEXT
FROM TEMP_discountSummary                DIS
  INNER JOIN TEMP_salesdetail_all        TIS
     ON dis.""Check ID"" || ''.'' || SPLIT_PART(dis.""Support ID"",''.'',2) = tis.Item_Fact_NK 
       AND ""Discount Level"" = ''Item''
  LEFT JOIN TEMP_checkSummary             CHK
    ON DIS.""Check ID"" = CHK.CHECKNO
       ;

----------------------------------------------------------------------------------------------------------------------------
--surcharges
CALL dataadmin.SP_LOAD_365_SURCHARGES(:startdate,:enddate,:locationid);
-- CALL dataadmin.SP_LOAD_365_SURCHARGES(''2020-12-17'',''2029-12-17'',''[26]'');
CREATE TEMP TABLE TEMP_surcharges AS
SELECT DISTINCT SPLIT_PART(SURCHARGE_CHECKNUMBER,''.'',2) AS Checkno
   ,''<Surcharges>''
    || LISTAGG(
          REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
             :tagSurcharges,
              ''%SurchargeAmount%'',SURCHARGE_AMOUNT),
              ''%SurchargeName%'',SURCHARGE_NAME),
              ''%DayPart%'',DAYPART),
              ''%OrderType%'',ORDERTYPE),
              ''%RevCenter%'',REVCENTER),
              ''%Time%'',CLOSETIME)    
              
        ) OVER (PARTITION BY SURCHARGE_CHECKNUMBER)
     || ''</Surcharges>''
         AS XMLTEXT
FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))  SUR
  INNER JOIN TEMP_checksummary            CHK
    ON TO_CHAR(CHK.CHECKNO) = SPLIT_PART(SUR.SURCHARGE_CHECKNUMBER,''.'',2)
;

----------------------------------------------------------------------------------------------------------------------------
--refunds
CALL dataadmin.SP_REPORT_REFUNDS(:startdate,:enddate,:locationid);
-- CALL dataadmin.SP_REPORT_REFUNDS(''2020-12-17'',''2029-12-17'',''[351]'');
-- tagRefunds string:=''<Refund Amount=""%Amount%"" Quantity=""%Quantity%""></Refund>'';
CREATE TEMP TABLE TEMP_refunds AS
SELECT DISTINCT  ""Check ID"" AS Checkno
   ,''<Refunds>''
    || LISTAGG(
          REPLACE( REPLACE(
            :tagRefunds,''%Amount%'',""Refund Amount""),
            ''%Quantity%'',1)
        ) OVER (PARTITION BY ""Check ID"")
     || ''</Refunds>''
         AS XMLTEXT
FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))
;

----------------------------------------------------------------------------------------------------------------------------
--voids
-- select ""Item ID"",""Amount"",* From TEMP_voids_all where ""Item ID"" = 199434.72209527-74ad-4a90-a5c6-250249db5ab5
CALL DATAADMIN.SP_REPORT_VOID_0001(:startdate,:enddate,:locationid);
CREATE TEMP TABLE TEMP_voids_all AS
SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

CREATE TEMP TABLE TEMP_voids AS
SELECT DISTINCT VOD.""Check ID""                  AS Checkno
   ,''<Voids>''
    || LISTAGG(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
          :tagVoids,''%Amount%'',VOD.""Amount""),
          ''%Quantity%'',VOD.""Count""),
          ''%VoidName%'',VOD.""Reason""),
          ''%Time%'',TSD.CLOSETIME),
          ''%ItemNumber%'',IFNULL(TO_CHAR(TSD.""Menu Item ID""),'' ''))
        ) OVER (PARTITION BY ""Check ID"")
     || ''</Voids>''                               AS XMLTEXT
FROM TEMP_voids_all                              VOD
   LEFT JOIN TEMP_salesdetail_all                TSD
     ON (VOD.""Item ID"" = TSD.ITEM_FACT_NK
       AND VOD.""Level"" = ''Item'')
;

-- select * from TEMP_salesdetail_all;
----------------------------------------------------------------------------------------------------------------------------
--PaidInOut Summary
--TEMP_PaidInOutSummary
CALL DATAADMIN.SP_REPORT_PAYINOUT(:startdate,:enddate,:locationid);
-- CALL DATAADMIN.SP_REPORT_PAYINOUT(''2024-08-02T14:48:37.661Z'',''2025-08-02T14:48:37.661Z'',''[351]'');

CREATE TEMP TABLE TEMP_paidInOutSummary AS
SELECT *
FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))
; 

----------------------------------------------------------------------------------------------------------------------------
--PaidInOut
--tagPaidInOut string:=''<PaidInOut Amount=""%PaidInOut%"" AffectsCash=""True""><PaidInOutName>%PaidInOutName%</PaidInOutName> </PaidInOut>'';
CREATE TEMP TABLE TEMP_PaidInOuts AS
SELECT ''<PaidInOuts>''
    || LISTAGG(
          REPLACE(REPLACE(
             :tagPaidInOut,''%PaidInOut%'',""Amount"" * CASE WHEN ""Pay Type"" = ''Pay Out'' THEN -1 ELSE 1 END ),
             ''%PaidInOutName%'',""Reason"")
        ) 
     || ''</PaidInOuts>''
         AS XMLTEXT
FROM TEMP_paidInOutSummary 
;

----------------------------------------------------------------------------------------------------------------------------
--Deposits
CALL DATAADMIN.SP_REPORT_CASH(:startdate,:enddate,:locationid);
-- CALL DATAADMIN.SP_REPORT_CASH(''2020-12-17'',''2029-12-17'',''[351]'');
--tagDeposits string:=''<Deposit DateOfBusiness=%FiscalDay% Amount=%Amount%> </Deposit>'';

CREATE TEMP TABLE TEMP_Deposits AS
SELECT ''<Deposits>''
    || LISTAGG(
          REPLACE(REPLACE(
             :tagDeposits,''%FiscalDay%'',TO_VARCHAR(TO_DATE(""Fiscal Day""),''MM/DD/YYYY'')),
             ''%Amount%'',""Deposit"")
        ) 
     || ''</Deposits>''
         AS XMLTEXT
FROM TABLE(RESULT_SCAN(LAST_QUERY_ID())) 
  WHERE ""Event Type""=''Deposit''
;

----------------------------------------------------------------------------------------------------------------------------
--labor
CALL DATAADMIN.SP_REPORT_LABOR(:startdatelabor,:enddate,:locationid);
-- CALL DATAADMIN.SP_REPORT_LABOR(''2020-03-20'',''2025-04-26'',''[351]'');
CREATE TEMP TABLE TEMP_allShifts AS
  SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

CREATE TEMP TABLE TEMP_shifts AS
SELECT    REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
        -- :tagShift,
        ''<Shift ShiftNumber=""%ShiftNumber%"" ClockInDate=""%ClockInDate%"" ClockInTime=""%ClockInTime%""> <EmployeeNumber>%EmployeeNumber%</EmployeeNumber><ClockOutTime>%ClockOutTime%</ClockOutTime><JobName>%JobName%</JobName> <PayRate>%PayRate%</PayRate><RegularHours>%RegularHours%</RegularHours> <OvertimeHours>%OvertimeHours%</OvertimeHours><OvertimePayRate>%OvertimePayRate%</OvertimePayRate></Shift>'',
          ''%ShiftNumber%'',ROW_NUMBER()OVER(PARTITION BY ""Fiscal Day"",""Employee ID"" ORDER BY ""Shift ID"" )
          ),   
          ''%ClockInDate%'',TO_VARCHAR(TO_DATE(""Clocked In At""),''MM/DD/YYYY'')),   
          ''%ClockInTime%'',TO_VARCHAR(TO_TIMESTAMP(""Clocked In At""),''MM/DD/YYYY hh:MI:SS'')),
          ''%EmployeeNumber%'',""Employee ID""),
          ''%ClockOutTime%'',TO_VARCHAR(TO_TIMESTAMP(""Clocked Out At""),''MM/DD/YYYY hh:MI:SS'')),
          ''%JobName%'',""Job Position""),
          ''%PayRate%'',""Regular Rate""),
          ''%RegularHours%'',(""Regular Seconds""/3600)::DECIMAL(18,2)),
          ''%OvertimeHours%'',(""Overtime Seconds""/3600)::DECIMAL(18,2)),  
          ''%OvertimePayRate%'',""Overtime Rate"")                                                                              
         AS XMLTEXT
FROM TEMP_allShifts
;

----------------------------------------------------------------------------------------------------------------------------
-- --exclusive Taxes
CALL dataadmin.SP_LOAD_365_TAXDETAILS(:startdate,:enddate,:locationid);
-- -- call dataadmin.SP_LOAD_365_TAXDETAILS(''2020-12-17'',''2029-12-17'',''[26]'');
-- -- tagExclusiveTaxes string:=''<ExclusiveTax Amount=""%Amount%""><TaxNumber>%TaxNumber%</TaxNumber>'';
CREATE TEMP TABLE TEMP_exclusiveTaxes AS
SELECT DISTINCT SPLIT_PART(""CheckNumber"",''.'',2) AS Checkno
   ,''<ExclusiveTaxes>''
    || LISTAGG(
          REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
            :tagExclusiveTaxes,
              ''%Amount%'',""Tax_Amount""),
              ''%TaxNumber%'',""Tax_TaxNumber""),
              ''%DayPart%'',CHK.DAYPART),
              ''%OrderType%'',CHK.ORDERTYPE),
              ''%RevCenter%'',CHK.REVCENTER),
              ''%Time%'',CHK.OPENTIME)
        ) OVER (PARTITION BY SPLIT_PART(""CheckNumber"",''.'',2))
     || ''</ExclusiveTaxes>''                      AS XMLTEXT
FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))         TAX
  INNER JOIN TEMP_checksummary                   CHK
    ON TO_CHAR(CHK.CHECKNO) = TO_CHAR(SPLIT_PART(TAX.""CheckNumber"",''.'',2))
      AND ""CheckNumber"" <> ''CheckNumber'';

--------------------------------------------------------------------------------------------------------------------------- 
CREATE TEMP TABLE TEMP_items
AS
SELECT  DISTINCT CheckNO                                                           AS CheckNO
  ,''<ItemSales>'' || LISTAGG(XMLTEXT) OVER (PARTITION BY CheckNO) || ''</ItemSales>'' AS XMLTEXT
FROM (  
    SELECT TIS.CheckNo                                                          AS CheckNo
          ,REPLACE(IFNULL(TIS.XMLTEXT,'' ''),''%Promo%'',IFNULL(TIP.XMLTEXT,'' ''))   AS XMLTEXT
    FROM TEMP_itemsale              TIS        
      LEFT JOIN TEMP_itemPromo      TIP
        ON TIS.itemNO = TIP.itemNO
)  ORDER BY CheckNO
;
 
----------------------------------------------------------------------------------------------------------------------------
--select * From TEMP_checkitem where xmltext ilike (''%266298%'');
CREATE TEMP TABLE TEMP_checkitem 
AS
SELECT TIS.XMLTEXT                --CHECK
  || IFNULL(TCP.XMLTEXT,'' '')      --CHECK PROMO
  || IFNULL(STX.XMLTEXT,'' '')      --TAXES
  || IFNULL(TCS.XMLTEXT,'' '')      --ITEMS
  || IFNULL(TGC.XMLTEXT,'' '')      --GIFTCARD
  || IFNULL(TPS.XMLTEXT,'' '')      --PAYMENTS
  || IFNULL(TVS.XMLTEXT,'' '')      --VOIDS 
  || IFNULL(RTS.XMLTEXT,'' '')      --REFUNDS
  || IFNULL(SPS.XMLTEXT,'' '')      --SURCHARGES
  || ''</Check>''                   AS XMLTEXT
  FROM TEMP_check                 TIS
    LEFT JOIN TEMP_checkPromo     TCP
      ON TIS.Checkno = TCP.Checkno   
    LEFT JOIN TEMP_exclusiveTaxes STX
      ON TIS.Checkno  = STX.Checkno  
    LEFT JOIN TEMP_items          TCS
      ON TIS.Checkno  = TCS.Checkno
    LEFT JOIN TEMP_payments       TPS   
      ON TIS.Checkno  = TPS.Checkno
    LEFT JOIN TEMP_surcharges     SPS
      ON TIS.Checkno  = SPS.Checkno
    LEFT JOIN TEMP_refunds         RTS
      ON TIS.Checkno  = RTS.Checkno 
    LEFT JOIN TEMP_voids           TVS
       ON TIS.Checkno  = TVS.Checkno 
    LEFT JOIN TEMP_gcSales         TGC
       ON TIS.Checkno  = TGC.Checkno 
;

--==========================================================================================================================
SELECT listagg(XMLTEXT) WITHIN GROUP(ORDER BY RID )
                                        AS XMLTEXT
  FROM (
        SELECT :tagOpen1 as XMLTEXT      ,0005 as RID
          UNION
        SELECT ''<Categories>'' as XMLTEXT ,0010 as RID
          UNION                                           
        SELECT XMLTEXT                   ,0015 as RID
        FROM TEMP_catitem
          UNION
        SELECT ''</Categories>''as XMLTEXT  ,0020 as RID
          UNION
        SELECT XMLTEXT                    ,0025 as RID
        FROM TEMP_employees
          UNION
        SELECT XMLTEXT                    ,0030 as RID
        FROM TEMP_tender
          UNION
        SELECT ''<Taxes>'' as XMLTEXT       ,0035 as RID
          UNION
        SELECT XMLTEXT                    ,0040 as RID
        FROM TEMP_taxdetail 
          UNION
        SELECT ''</Taxes>'' as XMLTEXT      ,0045 as RID
          UNION
        SELECT :tagConfigClose as XMLTEXT ,0050 as RID
          UNION
        SELECT ''<SalesDetail>'' as XMLTEXT ,0060 as RID
          UNION
        SELECT ''<Checks>'' as XMLTEXT      ,0070 as RID
          UNION
        SELECT LISTAGG(XMLTEXT)           ,0080 as RID
        FROM TEMP_checkitem
          UNION
        SELECT ''</Checks>''      AS XMLTEXT,0090 as RID
          UNION
        SELECT XMLTEXT          AS XMLTEXT,0095 as RID
          FROM TEMP_PaidInOuts
          UNION
        SELECT XMLTEXT          AS XMLTEXT,0099 as RID
          FROM TEMP_Deposits
          UNION
        SELECT ''</SalesDetail>'' AS XMLTEXT,0100 as RID
          UNION
        SELECT ''<LaborDetail>''  AS XMLTEXT,0110 as RID
          UNION
        SELECT ''<Shifts>''||LISTAGG(XMLTEXT)||''</Shifts>'' AS XMLTEXT,0120 as RID
        FROM TEMP_shifts
          UNION
        SELECT ''</LaborDetail>'' AS XMLTEXT,0130 as RID
          UNION
        SELECT :tagClose1       AS XMLTEXT,1000 as RID
        );
--select * From TEMP_xml
CREATE TEMP TABLE TEMP_xml AS
  SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));  
  
--=========================================================================================================================
reportSet := (  
 select parse_xml(XMLTEXT) AS XMLTEXT From TEMP_xml
);

RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,"SP_LOAD_DATASHARE_CRAFTABLE_LABOR(VARCHAR, VARCHAR, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_DATASHARE_CRAFTABLE_LABOR""(""START_DATE"" VARCHAR, ""END_DATE"" VARCHAR, ""LOCATION_IDS"" VARCHAR)
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS CALLER
AS 'BEGIN
    -- Execute the source procedure that returns the data
    CALL DATAADMIN.SP_DATASHARE_CRAFTABLE_LABOR(:START_DATE, :END_DATE, :LOCATION_IDS);

    -- Insert the results into the target table
    INSERT INTO DATASHARE_DEV.CRAFTABLE_LABOR (
        ""Organization Name"",
        ""Organization ID"",
        ""Location Name"",
        ""Location ID"",
        ""Business Day"",
        ""Shift ID"",
        ""Time In"",
        ""Time Out"",
        ""Department"",
        ""Job Title"",
        ""Employee No"",
        ""Employee Name"",
        ""Regular Hours"",
        ""Overtime Hours"",
        ""Hourly wage"",
        ""Break Seconds""
    )
    SELECT
        ""Organization Name"",
        ""Organization ID"",
        ""Location Name"",
        ""Location ID"",
        ""Business Day"",
        ""Shift ID"",
        ""Time In"",
        ""Time Out"",
        ""Department"",
        ""Job Title"",
        ""Employee No"",
        ""Employee Name"",
        ""Regular Hours"",
        ""Overtime Hours"",
        ""Hourly wage"",
        ""Break Seconds""
    FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

    RETURN ''Success: Data loaded into DATASHARE_DEV.CRAFTABLE_LABOR.'';
END';"
PROCEDURE,DATAADMIN,"SP_REPORT_CASH(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_CASH""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2000-11-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2026-11-20T14:48:37.661Z''; 
  -- locationid string      :=  ''[1,2,3,4,351]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
-- =============================================================================================================
--Expected Amount Totals Documented Here
--https://github.com/nabancard/pos-api/blob/master/db/migrations/20231120103333_enhance_cash_trackability.sql#L62
-- ============================================================================================================
BEGIN

DROP TABLE IF EXISTS TEMP_SHIFT;

--Temp Table to  FILTER both payments and Cashbank Events with the same Shift 
--  acts as a filter on location, time frame, and employee
  SELECT SHD_cte.SHIFT_DIM_NK                                         AS SHIFT_DIM_NK
    ,SHD_cte.fiscal_day                                               AS FISCAL_DAY
    ,SHD_cte.CLOCKEDIN_AT::timestamp_ntz                              AS CLOCKEDIN_AT
    ,SHD_cte.CLOCKEDOUT_AT::timestamp_ntz                             AS CLOCKEDOUT_AT
    ,SHD_cte.EMPLOYEE_DIM_FK                                          AS EMPLOYEE_DIM_FK
    ,SHD_cte.SHIFT_START_AT                                           AS SHIFT_START_AT
    ,SHD_cte.SHIFT_END_AT                                             AS SHIFT_END_AT
    ,EMD.EMPLOYEE_NAME                                                AS EMPLOYEE_NAME
    ,LOC.LOCATIONNAME                                                 AS LOCATIONNAME
    ,LOC.LOCATION_DIM_NK                                              AS ""Location ID""  
    ,LOC.LOCATION_DIM_NK                                              AS ""TESTING COLUMN""       
    ,LOC.TZ_NAME                                                      AS ""Time Zone""
    ,CBD.CASHBANK                                                     AS ""Cashbank ID""
    ,cbd.open_amount < cbd.close_amount                               AS IS_OPENHIGHERTHANCLOSE
    ,IFNULL(cbd.open_amount,0.0000) - IFNULL(cbd.close_amount,0.0000) AS OPENDELTA_AMOUNT
    ,IFNULL(cbd.EXPECTED_AMOUNT,0.0000)                               AS EXPECTED_AMOUNT
    ,IFNULL(cbd.open_amount,0.0000)                                   AS OPEN_AMOUNT
    ,IFNULL(cbd.close_amount,0.0000)                                  AS CLOSE_AMOUNT
    ,CBD.CASHBANK_DIM_NK                                              AS CASHBANK_DIM_NK
    ,cbd.status                                                       AS STATUS
    ,SHD_cte.FISCAL_DAY                                               AS ""Fiscal Day"" 
    FROM SHIFT_DIM                                        SHD_cte
      INNER JOIN DATAWAREHOUSE.LOCATION_DIM                   LOC
         ON SHD_cte.LOCATION_DIM_FK = LOC.LOCATION_DIM_NK
            AND LOC.DW_ISCURRENTROW
            AND SHD_cte.DW_ISCURRENTROW
            AND NOT SHD_cte.DW_ISDELETED
            ----------------------------------------------------------------------------------------------
            AND SHD_cte.fiscal_day
                   >= :startdate::date 
            AND  SHD_cte.fiscal_day  
                  <= :enddate::date    
            AND SHD_cte.LOCATION_DIM_FK IN (SELECT table1.value 
                   FROM table(split_to_table(:locationidS, '',''))  table1)
            ----------------------------------------------------------------------------------------------
          
      INNER JOIN DATAWAREHOUSE.EMPLOYEE_DIM                   EMD
        ON SHD_cte.EMPLOYEE_DIM_FK = EMD.EMPLOYEE_DIM_NK
          AND EMD.DW_ISCURRENTROW    
          
      LEFT JOIN DATAWAREHOUSE.CASHBANK_DIM                   CBD
        ON CBD.SHIFT_DIM_FK = SHD_cte.SHIFT_DIM_NK
          AND CBD.DW_ISCURRENTROW
          AND NOT CBD.DW_ISDELETED

;

CREATE TEMP TABLE TEMP_SHIFT AS
             SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));       
;


reportSet   := (
SELECT INLT.""Support ID""                            AS ""Support ID""
, ''CSH-'' ||row_number() over (order by INLT.""Support ID"") 
                                                    AS ""Detail ID""   
--status, category, level------------------------------------------------------------------------------
,INLT.""Status""                                      AS ""Status""
--geography--------------------------------------------------------------------------------------------
,INLT.""Location""                                    AS ""Location""
,INLT.""Location ID""                                 as ""Location ID""
--dates------------------------------------------------------------------------------------------------
,INLT.""Time Zone""                                   AS ""Time Zone""
,to_char(LEFT(INLT.""Fiscal Day"",4))                 AS ""Year""
,to_char(YEAR(INLT.""Fiscal Day"")) || ''|'' || TO_CHAR(RIGHT(''0'' || MONTH(INLT.""Fiscal Day""),2))                                       
                                                    AS ""Year and Month""
,to_char(INLT.""Fiscal Day"")                         AS ""Fiscal Day""
,IFNULL(INLT.""Daypart"",''None'')                      AS ""Daypart""
-- ,INLT.""Transaction Date""::timestamp_ntz                        ------------------------ 
,to_char(CONVERT_TIMEZONE(''UTC'',INLT.""Time Zone"" ,INLT.""Transaction Date""::timestamp_ntz )::timestamp)        
                                                    AS ""Transacted At""
 ,IFNULL(DAYNAME(INLT.""Fiscal Day""),''None'')         AS""Day of Week""
    ,CASE WHEN DAYNAME(INLT.""Fiscal Day"") IN (''Sat'',''Sun'')  
             THEN TRUE ELSE FALSE END               AS ""Is Weekend""

,to_char(CONVERT_TIMEZONE(''UTC'',INLT.""Time Zone"" ,INLT.""Paid At""::timestamp_ntz )::timestamp )            
-- ,INLT.""Paid At""::timestamp_ntz                                      
                                                    AS ""Paid At""

,to_char(CONVERT_TIMEZONE(''UTC'',INLT.""Time Zone"" ,INLT.""Clocked In At""::timestamp_ntz )::timestamp )                                                    
-- ,INLT.""Clocked In At""::timestamp_ntz                               
                                                    AS ""Clocked In At""

,to_char(CONVERT_TIMEZONE(''UTC'',INLT.""Time Zone"" ,INLT.""Clocked Out At""::timestamp_ntz )::timestamp )                                                    
-- ,INLT.""Clocked Out At""::timestamp_ntz                              
                                                    AS ""Clocked Out At""
--flags------------------------------------------------------------------------------------------------
--people-----------------------------------------------------------------------------------------------
,INLT.""Employee Name""               AS ""Employee""
--Descriptors------------------------------------------------------------------------------------------ 
,INLT.""Cash Drawer ID""              AS ""Cash Drawer ID"" 
,to_char(INLT.""Cashbank ID"")        AS ""Cashbank ID""
,INLT.""Check ID""                    AS ""Check ID""
,INLT.""Check NO""                    AS ""Check NO""
,INLT.""Payment ID""                  AS ""Payment ID""        
,''Shift '' || to_varchar(INLT.""Shift ID"")  
                                    AS ""Shift ID""
,INLT.""Event Type""                  AS ""Event Type""
,INLT.""Notes""                       AS ""Notes""
,INLT.""Payment Method""              AS ""Payment Method""
,INLT.""Payment Type""                AS ""Payment Type""
,INLT.""Terminal""                    AS ""Terminal""
,INLT.""Reason""                      AS ""Reason""
--Facts------------------------------------------------------------------------------------------------
 ,1::NUMBER(18,0)                                 AS ""Count""
 ,INLT.""Adjusted Cash Open Amount""::NUMBER(18,2)  AS ""Adjusted Cash Open Amount""--The opening amount of cash  
 ,INLT.""Cash Close Amount""::NUMBER(18,2)          AS ""Cash Close Amount""--The closing amount of cash
 ,INLT.""Cash Open Amount""::NUMBER(18,2)           AS ""Cash Open Amount""--The opening amount of cash
 ,INLT.""Cash ReOpen Amount""::NUMBER(18,2)         AS ""Cash ReOpen Amount""
 ,INLT.""Deposit""::NUMBER(18,2)                    AS ""Deposit""--The opening amount of cash
 ,INLT.""Withdrawl""::NUMBER(18,2)                  AS ""Withdrawl""--The opening amount of cash   
 ,INLT.open_amount::NUMBER(18,2)                  AS ""Open Amount""
 ,INLT.close_amount::NUMBER(18,2)                 AS ""Close Amount""
 ,INLT.""Cash Due""::NUMBER(18,2)                   AS ""Cash Due""
 ,INLT.""Expected Amount""::NUMBER(18,2)            AS ""Expected Amount""
 ,INLT.""Cash Change Amount""::NUMBER(18,2)         AS ""Cash Change Amount""    
 ,INLT.""Cash Tendered Amount""::NUMBER(18,2)       AS ""Cash Tendered Amount"" 
 ,INLT.""Cash Payment Amount""::NUMBER(18,2)        AS ""Cash Payment Amount"" 
-- ,0.0000  AS ""Non Cash Payments""---This could be gift certificate or some other  per davis put on hold
-- ,0.0000  AS ""All Payments""--sum cash PLUS non cash  --Possibly removed from requirements?
 ,INLT.""Cash Tip Amount""::NUMBER(18,2)            AS ""Cash Tip Amount"" 
 ,INLT.""Pay In Amount""::NUMBER(18,2)              AS ""Pay In Amount""
 ,INLT.""Pay Out Amount""::NUMBER(18,2)             AS ""Pay Out Amount""
-------------------------------------------------------------------------------------------------------
  FROM (
        SELECT ''CBE:'' || TO_CHAR(CHF.CASHBANKEVENT_FACT_PK) AS ""Support ID""    --unique id not for displayeing id
        ,shd.""Cashbank ID""                        AS ""Cashbank ID""
        ,shd.EMPLOYEE_NAME                        AS ""Employee Name""
        ,shd.""Fiscal Day""                         AS ""Fiscal Day""
        ,chf.EVENT_TYPE                           AS ""Event Type""
        ,shd.SHIFT_DIM_NK                         AS ""Shift ID""
        ,''None''                                   AS ""Check ID""
        ,''None''                                   AS ""Check NO""
        ,shd.STATUS                               AS ""Status""
        ,''None''                                   AS ""Payment Method""
        ,''None''                                   AS ""Payment Type""
        ,''None''                                   AS ""Terminal""
        ,IFNULL(chf.notes,''None'')                 AS ""Notes""
        ,''None''                                   AS ""Reason""
        ,''None''                                   AS ""Payment ID""

        ,shd.""Time Zone""                          AS ""Time Zone""  
        ,CASE chf.EVENT_TYPE 
          WHEN ''BankOpened'' THEN shd.CLOCKEDIN_AT
          WHEN ''BankClosed'' THEN shd.CLOCKEDOUT_AT
          ELSE chf.dw_startdate END
                                                  AS ""Transaction Date""
        ,''None''                                   AS ""Daypart""
        ,''None''                                   AS ""Cash Drawer ID"" --OPTIONAL
        ,shd.LOCATIONNAME                         AS ""Location""
        ,shd.""Location ID""                        AS ""Location ID""
        ,chf.CREATED_AT                           AS ""Paid At""
        ,shd.CLOCKEDIN_AT                         AS ""Clocked In At""
        ,shd.CLOCKEDOUT_AT                        AS ""Clocked Out At""
        --===================================================================================
        ,CASE WHEN chf.EVENT_TYPE = ''AdjustedOpenAmount'' 
          THEN IFNULL(chf.AMOUNT,0.0000) 
          ELSE 0.0000 END                         AS ""Adjusted Cash Open Amount""--The opening amount of cash  
        ,CASE WHEN chf.EVENT_TYPE = ''BankClosed'' 
          THEN IFNULL(chf.AMOUNT,0.0000)
          ELSE 0.0000 END                         AS ""Cash Close Amount""--The closing amount of cash
        ,CASE WHEN chf.EVENT_TYPE = ''BankOpened'' 
          THEN IFNULL(chf.AMOUNT ,0.0000)
          ELSE 0.0000 END 
                                                  AS ""Cash Open Amount""--The opening amount of cash
        ,CASE WHEN chf.EVENT_TYPE = ''BankReopened''
          THEN IFNULL(chf.AMOUNT ,0.0000)
          ELSE 0.0000 END 
                                                  AS ""Cash ReOpen Amount""
        ,CASE WHEN chf.EVENT_TYPE = ''Deposit'' 
          THEN IFNULL(chf.AMOUNT ,0.0000)
          ELSE 0.0000 END                         AS ""Deposit""--The opening amount of cash
        ,CASE WHEN chf.EVENT_TYPE = ''Withdrawal'' 
          THEN IFNULL(chf.AMOUNT,0.0000) 
          ELSE 0.0000 END                         AS ""Withdrawl""--The opening amount of cash
        
          ,shd.open_amount, shd.close_amount
        ,CASE WHEN chf.EVENT_TYPE = ''BankClosed'' AND shd.IS_OPENHIGHERTHANCLOSE   
          THEN IFNULL(shd.OPENDELTA_AMOUNT,0.0000)
         ELSE 0.00 END                            AS ""Cash Due""--If the opening amount is less than closing amou            --NOTE:  1ST half of union is the open and close amounts so all 
         --=================
         --EXPECTED_AMOUNT
         ,CASE WHEN chf.EVENT_TYPE = ''BankOpened''    
          THEN IFNULL(shd.EXPECTED_AMOUNT,0.0000)
          ELSE 0.0000 END                         AS ""Expected Amount""
        --===================================================================================
        ,0.0000                                   AS ""Cash Change Amount""    
        ,0.0000                                   AS ""Cash Tendered Amount"" 
        ,0.0000                                   AS ""Cash Payment Amount""  --Total Payments in Cash Received
        -- ,0.0000  AS ""Non Cash Payments""---This could be gift certificate or some other  per davis put on hold
        -- ,0.0000  AS ""All Payments""--sum cash PLUS non cash  --Possibly removed from requirements?
        ,0.0000                                   AS ""Cash Tip Amount"" 
        ,0.0000                                   AS ""Pay In Amount""
        ,0.0000                                   AS ""Pay Out Amount""
         -----------------------------------------------------------------------------------------  
        FROM TEMP_SHIFT                                        SHD
            INNER JOIN DATAWAREHOUSE.CASHBANKEVENT_FACT            CHF
              ON SHD.CASHBANK_DIM_NK = CHF.CASHBANK_DIM_FK
                  AND CHF.DW_ISCURRENTROW
                  AND NOT CHF.DW_ISDELETED
                  --AND CBD.STATUS <> ''Open''
--         -----------------------------------------------------------------------------------------
         UNION ALL
--         -- -----------------------------------------------------------------------------------------
        SELECT ''PAY:'' || TO_CHAR(pay.PAYMENTS_FACT_PK)               AS ""Support ID""    --unique id 
        ,SHD.""Cashbank ID""                        AS ""Cashbank ID""
        ,shd.EMPLOYEE_NAME                        AS ""Employee Name""
        ,shd.""Fiscal Day""                         AS ""Fiscal Day""
        ,''Cash Payment''                           AS ""Event Type""
        ,shd.SHIFT_DIM_NK                         AS ""Shift ID""
        ,to_char(pay.cheque_fact_fk)              AS ""Check ID""
        ,to_char(pay.CHEQUENUMBER)                AS ""Check""
        ,shd.STATUS                               AS ""Status""
        ,pmd.PAYMENTMETHODNAME                    AS ""Payment Method""
        ,pmd.PAYMENTMETHODTYPE                    AS ""Payment Type""
        ,TED.TERMINALNAME                         AS ""Terminal""
        ,''None''                                   AS ""Notes""
        ,''None''                                   AS ""Reason""
        ,TO_CHAR(pay.PAYMENTS_FACT_NK)            AS ""Payment ID""
        ,shd.""Time Zone""                          AS ""Time Zone""          
        ,pay.PAID_AT::timestamp_ntz 
                                                  AS ""Transaction Date""
        ,dpd.DAYPART                              AS ""Daypart""
        ,null                                     AS ""Cash Drawer ID"" --OPTIONAL
        ,shd.LOCATIONNAME                         AS ""Location""
        ,shd.""Location ID""                        AS ""Location ID""
        ,pay.PAID_AT::timestamp_ntz                              
                                                  AS ""Paid At""
        ,shd.CLOCKEDIN_AT                         AS ""Clocked In At""
        ,shd.CLOCKEDOUT_AT                        AS ""Clocked Out At""
        --===================================================================================
        ,0.0000                                   AS ""Adjusted Cash Open Amount""
        ,0.0000   
        AS ""Cash Close Amount""--The closing amount of cash
        ,0.0000                                   AS ""Cash Open Amount""--The opening amount of cash
        ,0.0000                                   AS ""Cash ReOpen Amount""
        ,0.0000                                   AS ""Deposit""--The opening amount of cash
        ,0.0000                                   AS ""Withdrawl""--The opening amount of cash
        
        ,shd.open_amount
        , shd.close_amount
        ,0.0000                                   AS ""Cash Due""
        ,0.0000                                   AS ""Expected Amount""
        --===================================================================================
        ,IFNULL(CPL.AMOUNT_CHANGED,0.0000)         AS ""Cash Change Amount""    
        ,IFNULL(CPL.AMOUNT_TENDERED,0.0000)       AS ""Cash Tendered Amount""     
        ,IFNULL(PAY.TOTAL,0.0000)                 AS ""Cash Payment Amount""  --Total Payments in Cash Received
        -- ,NULL AS ""Non Cash Payments""---This could be gift certificate or some other per davis put on hold
        -- ,NULL AS ""All Payments""--sum cash PLUS non cash
        ,IFNULL(PAY.TIP,0.0000)                    AS ""Cash Tip Amount"" 
        ,0.0000                                    AS ""Pay In Amount""
        ,0.0000                                    AS ""Pay Out Amount""
         ----------------------------------------------------------------------------------------- 
           FROM TEMP_SHIFT                                       SHD
            INNER JOIN  CHECKCASHPAYMENTLEDGER_FACT              CPL
              ON SHD.SHIFT_DIM_NK = CPL.SHIFT_DIM_FK
                AND CPL.DW_ISCURRENTROW
                AND NOT CPL.DW_ISDELETED
                AND NOT CPL.IS_VOID
            INNER JOIN DATAWAREHOUSE.PAYMENTS_FACT                   PAY    --465
              ON PAY.PAYMENTS_FACT_NK = CPL.PAYMENTS_FACT_FK
                -- AND pay.PAYMENTSTATUS = ''Success''    --No need to check payment method for cash as all ledger rows are cash
                AND pay.DW_ISCURRENTROW
                AND NOT pay.IS_TRAINING
            INNER JOIN DATAWAREHOUSE.PAYMENTMETHOD_DIM                PMD
               ON PMD.PAYMENTMETHOD_DIM_NK = PAY.PAYMENTMETHOD_DIM_FK
                AND PAY.DW_ISCURRENTROW
            INNER JOIN DATAWAREHOUSE.DAYPART_DIM                       DPD
               ON dpd.DAYPART_DIM_NK = pay.DAYPART_DIM_FK
                 AND dpd.dw_iscurrentrow
            LEFT JOIN DATAWAREHOUSE.TERMINAL_DIM                       TED
                ON TED.TERMINAL_DIM_NK = PAY.TERMINAL_DIM_FK
                  AND TED.DW_ISCURRENTROW
        -- -----------------------------------------------------------------------------------------
        UNION ALL
        -- -----------------------------------------------------------------------------------------
        SELECT ''PIO:'' || TO_CHAR(PIO.PAYINOUT_FACT_PK)      AS ""Support ID""   
        ,shd.""Cashbank ID""                        AS ""Cashbank ID""
        ,shd.EMPLOYEE_NAME                        AS ""Employee Name""
        ,shd.""Fiscal Day""                         AS ""Fiscal Day""
        ,CASE WHEN PAR.IS_PAY_IN THEN ''Pay In''
          ELSE ''Pay Out'' END                      AS ""Event Type""
        ,shd.SHIFT_DIM_NK                         AS ""Shift ID""
        ,''None''                                   AS ""Check ID""
        ,''None''                                   AS ""Check NO""
        ,PIO.STATUS                               AS ""Status""
        ,pmd.PAYMENTMETHODNAME                    AS ""Payment Method""
        ,pmd.PAYMENTMETHODTYPE                    AS ""Payment Type""
        ,''None''                                   AS ""Terminal""
        ,IFNULL(pio.NOTES,''None'')                 AS ""Notes""
        ,IFNULL(par.PAYINPAYOUTREASON,''None'')     AS ""Reason"" 
        ,''None''                                   AS ""Payment ID""
         ,shd.""Time Zone""                         AS ""Time Zone""          
        ,pio.dw_startdate                         AS ""Transaction Date""
        ,''None''                                   AS ""Daypart""
        ,''None''                                   AS ""Cash Drawer ID"" 
        ,shd.LOCATIONNAME                         AS ""Location""
        ,shd.""Location ID""                        AS ""Location ID""
        ,pio.CREATED_AT::timestamp_ntz                           
                                                  AS ""Paid At""
        ,shd.CLOCKEDIN_AT                         AS ""Clocked In At""
        ,shd.CLOCKEDOUT_AT                        AS ""Clocked Out At""
        --===================================================================================
        ,0.0000                                   AS ""Adjusted Cash Open Amount""
        ,0.0000                                   AS ""Cash Close Amount""
        ,0.0000                                   AS ""Cash Open Amount""
        ,0.0000                                   AS ""Cash ReOpen Amount""
        ,0.0000                                   AS ""Deposit""
        ,0.0000                                   AS ""Withdrawl""
        ,NULL, NULL
        ,0.0000                                   AS ""Cash Due""--If the opening amount is less than closing amou  
        ,0.0000                                   AS ""Expected Amount""
        --===================================================================================
        ,0.0000                                   AS ""Cash Change Amount""    
        ,0.0000                                   AS ""Cash Tendered Amount"" 
        ,0.0000                                   AS ""Cash Payment Amount""
        ,0.0000                                   AS ""Cash Tip Amount""
        ,CASE WHEN PAR.IS_PAY_IN THEN PIO.AMOUNT 
          ELSE 0.0000 END                         AS ""Pay In Amount""  --Total Payments in Cash Received
        ,CASE WHEN NOT PAR.IS_PAY_IN THEN PIO.AMOUNT 
          ELSE 0.0000 END                         AS ""Pay Out Amount"" 
         -----------------------------------------------------------------------------------------  
        FROM TEMP_SHIFT                                        SHD
            INNER JOIN DATAWAREHOUSE.PAYINOUT_FACT                 PIO
              ON SHD.SHIFT_DIM_NK = PIO.SHIFT_DIM_FK
                  AND PIO.DW_ISCURRENTROW
                  AND NOT PIO.DW_ISDELETED
                  AND NOT PIO.IS_VOID
                  AND PIO.STATUS = ''Success''
            INNER JOIN DATAWAREHOUSE.PAYMENTMETHOD_DIM             PMD
              ON PMD.PAYMENTMETHOD_DIM_NK = PIO.PAYMENTMETHOD_DIM_FK
                  AND PMD.DW_ISCURRENTROW
                  AND PMD.PAYMENTMETHODTYPE = ''Cash''
                  -- AND PMD.PAYMENTMETHODNAME <> ''Error''
            INNER JOIN DATAWAREHOUSE.PAYINPAYOUTREASON_DIM         PAR
              ON PAR.PAYINPAYOUTREASON_DIM_NK = PIO.PAYINPAYOUTREASON_DIM_FK
                  AND PAR.DW_ISCURRENTROW
                  
           ) INLT
-- =================================================================================================================
); 
 RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,SP_CHECKNEGONE_ALL(),"CREATE OR REPLACE PROCEDURE ""SP_CHECKNEGONE_ALL""()
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
    SQLStmt resultset;
    ScriptIns varchar;
    SQLTextOut varchar;
    SQLIns varchar;
    SCRIPT resultset;
    BIGSCRIPTS resultset;

-----------------------------------------------------------------------------------------------------------
BEGIN
   --drop temp tables if they exist
   drop table if exists dwtable_lists; 
   drop table if exists dwtable_scripts; 

   create table dwtable_scripts (
     nameval varchar (100) 
     ,countval number
  );
  -- SELECT ''ADDRESS_DIM'' AS NAMEVAL,COUNT(*) AS COUNTVAL FROM  DATAWAREHOUSE.ADDRESS_DIM WHERE ADDRESS_DIM_pk = -1;
  --create a table containing rows with the call statements to create the load stored procedures
SELECT REPLACE(''SELECT \\''<TABLENAME>\\'' AS NAMEVAL,COUNT(*) AS COUNTVAL FROM  DATAWAREHOUSE.<TABLENAME> WHERE <TABLENAME>_pk = -1;''
       ,''<TABLENAME>'',TABLE_NAME) AS sqltext
  FROM information_schema.tables 
   WHERE TABLE_SCHEMA = ''DATAWAREHOUSE''
     AND TABLE_TYPE = ''BASE TABLE''
     AND TABLE_NAME ILIKE ''%_DIM''
     AND TABLE_NAME NOT IN  (''DATASHARETEST_DIM'',''DATE_DIM'',''ORDER_SUMMARY'',''ERRORDWDATE_DIM'');
   
   CREATE TABLE dwtable_lists AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));


  SQLStmt := (select * from dwtable_lists);

  --loop through all rows that create the load stored proceedure 1 per table
      BEGIN
          FOR record IN SQLStmt DO
            SQLTextOut := record.sqltext;
            SCRIPT := (EXECUTE IMMEDIATE record.sqltext);           
            INSERT INTO dwtable_scripts(nameval,countval) 
                    SELECT NAMEVAL,COUNTVAL FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));
          END FOR;
     END;

  BIGSCRIPTS := (SELECT * from dwtable_scripts order by countval desc);   
  RETURN TABLE(BIGSCRIPTS);
  
END';"
PROCEDURE,DATAADMIN,"SP_DATASHARE_CRAFTABLE_PAYMENTS(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_DATASHARE_CRAFTABLE_PAYMENTS""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz      := ''2020-08-20T14:48:37.661Z'';  
  -- enddate timestamp_tz        := ''2029-08-20T14:48:37.661Z''; 
  -- locationid string           := ''[35]'';
  locationidS string          :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
   -- GRANT usage ON procedure dataadmin.SP_REPORT_MODIFIER(timestamp_tz,timestamp_tz,string) TO ROLE DATA_REPLICATION_HOSPENG;
-----------------------------------------------------------------------------------------------------------------------
  BEGIN
    --drop temp tables
    DROP TABLE IF EXISTS REPORT_DATA;

-----------------------------------------------------------------------------------------------------------------------
  CREATE  TEMPORARY TABLE REPORT_DATA
    AS
  SELECT 
           org.ORGANIZATION                                                                                 AS ""Organization Name""
          ,org.ORGANIZATION_DIM_NK                                                                          AS ""Organization ID""
          ,loc.LOCATIONNAME                                                                                 AS ""Location Name""
          ,pay.LOCATION_DIM_FK                                                                              AS ""Location ID""
          ,pay.FISCALDATE::DATE                                                                             AS ""Business Day""
          ,pay.CHEQUE_FACT_FK                                                                               AS ""Check ID""

-- FROM WILL Payment Type: Credit Card, Payment Method: Visa
         ,PAYMENTTYPE                                                                                       AS ""Tender Type""

         
        ,IFNULL(case pay.cardbrand when '''' 
             THEN ''Not a Credit Card'' 
            else pay.cardbrand end,''None'')                                                                  AS ""Tender Name""



        
        ,CASE WHEN pay.PAYMENTTYPE = ''Cash'' THEN pay.AMOUNTAPPLIEDTOCHECK::DECIMAL(18,2) 
                  else pay.TOTAL::DECIMAL(18,2) end                                                         AS ""Tender Amount""


          ,IFNULL(pay.cardholderName,''None'')                                                                AS ""Cardholder Name""
          ,IFNULL(pay.LASTFOURCCNUMBER,''None'')                                                              AS ""Cender Number (last 4)""                  

          FROM DATAWAREHOUSE.payments_FACT                                                                  pay
          INNER JOIN DATAWAREHOUSE.location_DIM                                                             loc
            ON pay.location_DIM_FK = loc.location_DIM_NK
              AND pay.FISCALDATE::date >= :startdate::date 
              AND pay.FISCALDATE::date <= :enddate::date  
              AND pay.LOCATION_DIM_FK in (
                SELECT table1.value 
                   FROM table(split_to_table(:locationidS, '',''))  table1) 
              AND pay.dw_iscurrentrow
              AND loc.dw_iscurrentrow
              AND NOT pay.IS_TRAINING
              AND NOT pay.dw_isdeleted
              AND pay.PAYMENTSTATUS = ''Success''
          INNER JOIN DATAWAREHOUSE.PaymentMethod_DIM                       ptd      
            ON pay.PaymentMethod_DIM_FK = ptd.PaymentMethod_DIM_NK
              AND ptd.dw_iscurrentrow
              AND NOT ptd.dw_isdeleted
              
          INNER JOIN DATAWAREHOUSE.organization_dim                     org
            ON loc.organization_DIM_FK = org.organization_DIM_NK
              AND org.dw_iscurrentrow
              AND NOT org.dw_isdeleted
          -- INNER JOIN DATAWAREHOUSE.daypart_dim                           dpd
          --   ON pay.daypart_dim_fk = dpd.daypart_dim_nk
          --     AND dpd.dw_iscurrentrow
          --     AND NOT dpd.dw_isdeleted
          -- INNER JOIN DATAWAREHOUSE.ORDERTYPE_DIM                         otd
          --   ON otd.Ordertype_DIM_nK = pay.Ordertype_DIM_FK
          --     AND otd.dw_iscurrentrow
          -- LEFT JOIN DATAWAREHOUSE.employee_DIM                           emd
          --   ON emd.employee_DIM_NK = pay.EMPLOYEE_DIM_FK_AS_PAYEE
          --     AND emd.dw_iscurrentrow 
          -- LEFT JOIN DATAWAREHOUSE.CCTransaction_FACT                      cct   
          --   ON cct.cctransaction_fact_nk = pay.TRANSACTION_FACT_FK                     
          --     AND cct.dw_iscurrentrow                                                                
          --     AND cct.TRANSACTION_NUMBER = 1                             
    ORDER BY loc.locationname
    
    ;
    
-----------------------------------------------------------------------------------------------------------------------    
    --return values from the sproc with validated columns only  
     reportSet := (
         SELECT * FROM REPORT_DATA
     );

--=====================================================================================================================
RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,SP_LOADDIMENSIONNONEROW(VARCHAR),"CREATE OR REPLACE PROCEDURE ""SP_LOADDIMENSIONNONEROW""(""TABLENAME"" VARCHAR(50))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
        -- TABLENAME VARCHAR(50) := ''ITEMMODIFIER_DIM'';
        -- TABLENAME VARCHAR(50) := ''EMPLOYEE_DIM'';
        --TABLENAME VARCHAR(50) := ''ACTIVITY_FACT'';
        -- TABLENAME VARCHAR(50) := ''LOCATION_DIM'';

        
        NK_NAME VARCHAR := :TABLENAME || ''_NK'';

        TABLENAME_SCHEMA VARCHAR(100) := ''DATAWAREHOUSE.'' || :TABLENAME;
        SQLOUT RESULTSET;
        ROWTEXT VARCHAR:= ''------------------------------------------------------------------------------------------------------------------\\n'';
        HEADERTEXT VARCHAR := ''--Load Placeholder Row for '' || :TABLENAME || ''\\n'';
        -- COUNTSQL := ''SELECT COUNT(*) AS ROWCOUNTNUM FROM '' || TABLENAME_SCHEMA || '' WHERE to_char('' || NK_NAME || '') = -1'';
        COUNTROW_NUM NUMBER := (SELECT COUNT(*) AS ROWCOUNTNUM FROM IDENTIFIER(:TABLENAME) WHERE to_char(IDENTIFIER(:NK_NAME)) = to_char(-1));
        ERRORMESSAGE_1 resultset:= (SELECT ''--'' || :TABLENAME || '' is not a dimension table.  Only Dimension tables require this row.\\n'' as MESSAGE);
        ERRORMESSAGE_2 resultset:= (SELECT ''--The table '' || :TABLENAME || '' already has a missing row with a count of '' 
             || :COUNTROW_NUM || '' .\\n''  as MESSAGE);
BEGIN
 DROP TABLE IF EXISTS all_cols_temp; 
 -- select * from all_cols_temp;
 
 IF (:COUNTROW_NUM = 0  AND :TABLENAME_SCHEMA ilike ''%_DIM'') 
   THEN
         CREATE TEMP TABLE all_cols_temp AS
              select   ''  '' || case when c.column_name ilike ''%PK'' then ''-1''
                          when c.column_name ilike ''%NK'' then ''-1'' 
                          when c.column_name ilike ''%FK'' and c.data_type = ''NUMBER'' then ''-1'' 
                          when c.column_name ilike ''%FK'' and c.data_type <> ''NUMBER'' then ''''''-1''''''
                          -- when c.ordinal_position = 3 then ''''''None''''''
                          when c.column_name = ''DW_STARTDATE'' THEN ''''''1900-01-01 01:01:11.111''''''
                          when c.column_name = ''DW_ENDDATE'' THEN   ''''''9999-09-09 09:09:08.999''''''
                          when c.column_name = ''DW_ISDELETED'' then ''FALSE''
                          when c.column_name = ''DW_INSERTDATETIME'' then '''''''' || TO_CHAR(GETDATE()::timestamp_ntz)|| ''''''''
                          when c.column_name = ''DW_UPDATETIME'' then ''NULL'' 
                          when c.column_name = ''DW_ISCURRENTROW'' then ''TRUE''
                          when c.column_name = ''MTLN_CDC_LAST_CHANGE_TYPE'' then ''''''n''''''
                          when c.column_name = ''MTLN_CDC_LAST_COMMIT_TIMESTAMP'' then ''-1''
                          when c.column_name = ''MTLN_CDC_SEQUENCE_NUMBER'' then ''-1''
                          when c.column_name = ''MTLN_CDC_LOAD_BATCH_ID'' then ''-1''
                          when c.column_name = ''MTLN_CDC_PROCESSED_DATE_HOUR'' then ''NULL''
                          when c.column_name = ''MTLN_CDC_LOAD_TIMESTAMP'' then ''''''1900-01-01 01:01:11.111''''''
                          when c.column_name = ''MTLN_CDC_SRC_VERSION'' then ''-1''
                          when c.column_name = ''MTLN_CDC_FILENAME'' then ''''''n''''''
                          when c.column_name = ''MTLN_CDC_FILEPATH'' then ''''''None''''''
                          when c.column_name = ''MTLN_CDC_SRC_DATABASE'' then ''''''None''''''
                          when c.column_name = ''MTLN_CDC_SRC_SCHEMA'' then ''''''None''''''
                          when c.column_name = ''MTLN_CDC_SRC_TABLE'' then ''''''None''''''
                          when c.column_name = ''CREATED_AT'' then '''''''' || TO_CHAR(GETDATE()::timestamp_ntz)|| ''''''''
                          when c.column_name = ''UPDATED_AT'' then ''NULL''
                          when c.data_type IN (''TEXT'') then ''''''None''''''
                          when c.data_type IN (''NUMBER'') then ''-1''
                          when c.data_type IN (''VARIANT'',''BOOLEAN'',''TIMESTAMP_TZ'',''TIMESTAMP_NTZ'',''DATE'') 
                            then ''NULL''  
                          else ''NULL''
                         end
                      || ''/*'' || c.column_name || '':'' || c.data_type || ''*/''
                      || case when c.ordinal_position = max(ordinal_position) over (partition by 1)
                             then '' ''
                           else '', ''
                           end as column_name
                      ,ordinal_position
              from information_schema.tables t
                 inner join information_schema.columns c
                    on t.table_schema      = c.table_schema
                        and t.table_name   = c.table_name
                        and t.table_type   = ''BASE TABLE''
                        and t.table_schema = ''DATAWAREHOUSE''
                        and t.table_name   = :TABLENAME
                    order by c.ordinal_position;
        
            SQLOUT := (
            SELECT LISTAGG(SQLTEXT)  WITHIN GROUP (ORDER BY ORDINAL)
                    FROM (
                       SELECT :ROWTEXT AS SQLTEXT, 1 AS ORDINAL
                           UNION
                       SELECT :HEADERTEXT AS SQLTEXT, 2 AS ORDINAL
                           UNION  
                       SELECT :ROWTEXT AS SQLTEXT, 3 AS ORDINAL
                           UNION                   
                       SELECT ''INSERT INTO DATAWAREHOUSE.'' || :TABLENAME || '' VALUES ( '' AS SQLTEXT , 4 AS ORDINAL
                           UNION
                       SELECT LISTAGG(COLUMN_NAME) WITHIN GROUP (ORDER BY ordinal_position) || ''\\n'' AS SQLTEXT , 5 AS ORDINAL 
                         FROM ALL_COLS_TEMP
                           UNION
                       SELECT '');\\n'' AS SQLTEXT, 6 AS ORDINAL
                            UNION  
                       SELECT :ROWTEXT AS SQLTEXT, 7 AS ORDINAL
         
                     )  
                ORDER BY ORDINAL
             
            );

END IF;--END IF THERE IS NOT ALREADY A -1 ROW
  -----------------------------------------------------------------------------------------------------------
 IF (:TABLENAME NOT ilike ''%_DIM'') 
    THEN
      RETURN TABLE(ERRORMESSAGE_1);
    ELSEIF (:COUNTROW_NUM > 0)  
    THEN
      RETURN TABLE(ERRORMESSAGE_2);      
    ELSE
       RETURN TABLE(SQLOUT);
  END IF;
  
  -----------------------------------------------------------------------------------------------------------
END';"
PROCEDURE,DATAADMIN,"SP_LOAD_365_DISCOUNTS(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_365_DISCOUNTS""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2020-08-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2029-08-20T14:48:37.661Z''; 
  -- locationid string      := ''[351]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');

--=================================================================================================================================
BEGIN
--=================================================================================================================================
reportSet := (  
------------------------------------------------------------------------------------------------------------------------------------
    SELECT TO_CHAR(CHF.chequenumber) || ''.'' || TO_CHAR(CHF.cheque_fact_Fk)
                                                               AS CompPromo_CheckNumber--* String
      ,IFNULL(CASE WHEN length(STANDARDDISCOUNTNAME) > 0 THEN STD.STANDARDDISCOUNTNAME ELSE ''None'' END,''None'')        
                                                               AS Comp_CompName       --* String name of discount
      ,IFNULL(CHF.APPLIED_AMOUNT ::NUMBER(18,2),0.00)          AS Comp_Amount         --* Amount subtracted from the total due todiscount.
      ,IFNULL(CHF.PROMOCODE,''None'')                            AS Promo_PromoName     --* String name of promotion
      ,0.00 ::NUMBER(18,2)                                     AS Promo_Amount        --* Amount subtracted from the total due to discount.
   FROM DATAWAREHOUSE.DISCOUNTCHECK_FACT                       CHF
            INNER JOIN DATAWAREHOUSE.CHEQUE_FACT               CHK
              ON CHF.CHEQUE_FACT_FK = CHK.CHEQUE_FACT_NK
                AND CHF.DW_ISCURRENTROW
                AND CHK.DW_ISCURRENTROW
                AND NOT CHK.IS_TRAINING
                AND CHK.STATUS = ''Closed''
                AND NOT CHF.STATUS  = ''Disabled''
                AND 
            INNER JOIN DATAWAREHOUSE.LOCATION_DIM              LOC
              ON CHF.LOCATION_DIM_FK = LOC.LOCATION_DIM_NK
                  AND CHF.FISCAL_DATE::date
                     >= :startdate::date
                  AND CHF.FISCAL_DATE::date   
                     <= :enddate ::date 
                  AND CHF.LOCATION_DIM_FK IN (
                     SELECT table1.value 
                       FROM table(split_to_table(:locationidS, '',''))  table1)
                  AND CHF.CHEQUESTATUS IN (''Closed'')
                  AND CHF.DW_ISCURRENTROW
                  AND NOT CHF.DW_ISDELETED
                  AND LOC.DW_ISCURRENTROW          
                  AND NOT CHF.IS_TRAINING 
         LEFT JOIN DATAWAREHOUSE.STANDARDDISCOUNT_DIM         STD
               ON STD.STANDARDDISCOUNT_DIM_NK = CHF.STANDARDDISCOUNT_DIM_FK
                 AND STD.DW_ISCURRENTROW                  
--=================================================================================================================================
);
RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,"SP_LOAD_365_LABORDETAIL(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_365_LABORDETAIL""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2020-08-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2029-08-20T14:48:37.661Z''; 
  -- locationid string      := ''[2,3,4,351,352]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--================================================================================================================================
--ISSUES
--No column in layout for Fiscal Day this should be Business Day
--No column in layout for Overtime Hours
--Should this be only hourly employees?
--=================================================================================================================================
BEGIN
--=================================================================================================================================
CALL DATAADMIN.SP_REPORT_LABOR(:startdate,:enddate,:locationid);

reportSet := (  
------------------------------------------------------------------------------------------------------------------------------------
SELECT  REPLACE(IFNULL(NULL,""Employee ID""),'','','' '')                  AS ""EmployeeNumber"" --*string  --employee id in R365.
-- ,TO_NUMBER(REPLACE(LRS.""Shift ID"",''Shift '',''''))                      AS ""ShiftNumber""    --*intege ra single business 
,ROW_NUMBER() over (PARTITION BY ""Employee ID"" ORDER BY LRS.""Shift ID"")                   
                                                                   AS ""ShiftNumber""    --*intege ra single business 
,TO_CHAR(TO_TIMESTAMP(LRS.""Clocked In At""), ''MM/DD/YYYY'')            AS ""ClockInDate""    --*DateTime(mm/dd/yyyy hh:mm:ss)
,TO_CHAR(TO_TIMESTAMP(LRS.""Clocked In At""), ''MM/DD/YYYY HH24:MI:SS'') AS ""ClockInTime""    --*DateTime(mm/dd/yyyy hh:mm:ss)
,TO_CHAR(TO_TIMESTAMP(LRS.""Clocked Out At""),''MM/DD/YYYY HH24:MI:SS'') AS ""ClockOutTime""   --*DateTime(mm/dd/yyyy hh:mm:ss)
,REPLACE(IFNULL(LRS.""Job Position"",''None''),'','','' '')                  AS ""JobName""        --string--Name of the job that 
,LRS.""Regular Rate""::NUMBER(18,2)                                    AS ""PayRate""        --decimal
,(LRS.""Regular Seconds""/60/60)::NUMBER(18,6)                         AS ""RegularHours""   --decimal
--------------------------------------
  --NOT   ,""Employee""                AS ""Employee""
  --ADDED ,""Job Position""            AS ""Job Title"" --should this be only hourly employees???????  if custom--add tips and
  -- ,""Regular Seconds""              AS ""Hours""    ---is this an integer?  int.dec  same as ''OVertime''
  --ADDED  ,""Regular Rate""           AS ""Pay Rate""
  --NOT    , NULL                    AS ""Total""    ----what is this?  
  --NOT    ,""Fiscal Day""             AS ""Date""
  --ADDED  ,""Clocked In At""          AS ""Start DateTime""
  --ADDED  ,""Clocked Out At""         AS ""End DateTime""
  --       ,""Overtime Seconds""       AS ""Overtime"" ------intger?  hours?  same as ''Hours''
  --ADDED  ,""Shift ID""               AS ""POS ID""
FROM TABLE(RESULT_SCAN(LAST_QUERY_ID())) LRS 
  WHERE ""Detail ID"" not like (''TGR%'')  --don''t include gratuity totals from stored proceedure
    AND ""Pay Basis"" = ''hourly''
    AND LRS.""Clocked Out At"" IS NOT NULL
--=================================================================================================================================
);
RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,"SP_LOAD_365_PAYMENTS(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_365_PAYMENTS""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2024-03-26'';
  -- enddate timestamp_tz   := ''2025-01-26'';
  -- locationid string      := ''[2,3,4,351,352]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
  --https://docs.restaurant365.com/docs/pos-data-export-file-guide  <====file layout
--=================================================================================================================================
--ISSUES
--Grats not separated out on payment
--no business day on spec for fiscal day
--=================================================================================================================================
BEGIN
  DROP TABLE IF EXISTS TEMP_pay; 
  DROP TABLE IF EXISTS TEMP_header; 

-----------------------------------------------------------------------------------------------------------------------------------
--create the zero value data so that an ''empty'' file is created when there is no data for that fiscal day
SELECT ''Payment_CheckNumber''   --* string
,''Payment_BaseAmount''          --* decimal Amount for the payment, not including tips or gratuity.
,''Payment_TenderNumber''        --*string  
,''Payment_RevenueCenterName''   --string
,''Payment_Time''                --DateTime(mm/dd/yyyy hh:mm:ss)
;

CREATE TEMP TABLE TEMP_header AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

-----------------------------------------------------------------------------------------------------------------------------------
SELECT to_char(PAY.chequenumber) || ''.'' || to_char(PAY.cheque_fact_fk)              
                                      AS Payment_CheckNumber  --* string
,TO_CHAR(IFNULL((CASE WHEN pay.PAYMENTTYPE = ''Cash'' 
          THEN pay.AMOUNTAPPLIEDTOCHECK
      ELSE pay.TOTAL END  - PAY.TIP),0.00) ::DECIMAL(18,2))
                                      AS Payment_BaseAmount   --* decimal Amount for the payment, not including tips or gratuity.
,TO_CHAR(PAY.PAYMENTMETHOD_DIM_FK)    AS Payment_TenderNumber --*string  
,IFNULL(REPLACE(PAY.REVENUECENTERNAME,'','','' ''),''None'') 
                                      AS Payment_RevenueCenterName --string
,TO_CHAR(TO_TIMESTAMP(PAY.PAID_AT),''MM/DD/YYYY HH24:MI:SS'') 
                                      AS Payment_Time     --DateTime(mm/dd/yyyy hh:mm:ss)

FROM DATAWAREHOUSE.payments_FACT                               pay
   WHERE pay.dw_iscurrentrow
     AND NOT pay.IS_TRAINING
     AND NOT pay.dw_isdeleted
     AND pay.PAYMENTSTATUS = ''Success''    
     AND pay.FISCALDATE::date >= :startdate::date 
     AND pay.FISCALDATE::date <= :enddate::date       
     AND pay.LOCATION_DIM_FK in (SELECT table1.value 
        FROM table(split_to_table(:locationidS, '',''))  table1) 
; 

CREATE TEMP TABLE TEMP_pay AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));
--=================================================================================================================================
reportSet := (  

   SELECT * FROM TEMP_header
     UNION ALL
   SELECT * FROM TEMP_pay

);

RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,"SP_LOAD_DATASHARE_ITEMS(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_DATASHARE_ITEMS""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS '
-- -- =====================================================================================
-- Example Call Statement
-- CALL DATAWAREHOUSE.SP_LOAD_DATASHARE_ITEMS(''2000-11-20T14:48:37.661Z'',''2026-11-20T14:48:37.661Z'',''[351]'');
-- GRANT usage ON procedure DATAWAREHOUSE.SP_LOAD_DATASHARE_ITEMS(timestamp_tz,timestamp_tz,string) TO ROLE DATA_REPLICATION_HOSPENG;
-- --=========================================================================================
DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2020-08-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2029-08-20T14:48:37.661Z''; 
  -- locationid string      := ''[351,352]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--=========================================================================================
BEGIN
 reportSet:= (
SELECT itf.ITEM_FACT_NK                                   as ""Support ID"" 
--status, category, level-------------------------------------------------------------------
    ,IFNULL(ccd.COGSCATEGORY,''None'')                      as ""Category Name""
    ,IFNULL(ccd.cogscategory_dim_nk,0)                    as ""Category ID""
-- --geography--------------------------------------------------------------------------------
    ,IFNULL(loc.LOCATIONNAME,''None'')                      as ""Location Name""
    ,IFNULL(loc.LOCATION_DIM_NK,''None'')                   as ""Location ID""
    ,IFNULL(itf.REVENUECENTERNAME,''None'')                 as ""Revenue Center Name""
-- --dates-------------------------------------------------------------------------------------
    ,LOC.TZ_NAME                                          as ""Time Zone""
    ,to_char(LEFT(chk.FISCAL_DATE,4))                     as ""Year""
    ,to_char(YEAR(chk.FISCAL_DATE)) || ''|'' || TO_CHAR(LEFT(''0'' || MONTH(chk.FISCAL_DATE),2))                                       
                                                          as ""Year and Month""
    ,IFNULL(dad.DAYPART,''None'')                           as ""Daypart""
    ,to_char(chk.FISCAL_DATE)                             as ""Fiscal Date""
    ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,chk.OPENED_AT::timestamp_ntz )::timestamp )                                                                           
                                                          as ""Opened At""                                                           
    ,IFNULL(DAYNAME(chk.FISCAL_DATE),''None'')              as ""Day of Week""
    ,CASE WHEN DAYNAME(chk.FISCAL_DATE) IN (''Sat'',''Sun'')  
             THEN TRUE ELSE FALSE END                     as ""Is Weekend""
-- --flags--------------------------------------------------------------------------------------
    ,IFNULL(itf.HASMODIFIERS,FALSE)                       as ""Has Modifiers""
-- --Descriptors-------------------------------------------------------------------------------- 
    ,IFNULL(itf.chequenumber ,''None'')                     as ""Check""
    ,IFNULL(itf.CHEQUE_FACT_FK ,''None'')                   as ""Check ID""    
    ,IFNULL(med.MENUITEMNAME,'' None'')                     as ""Item Name""
    ,IFNULL(med.MENUITEMNAME,'' None'')                     as ""Item Code""
    ,IFNULL(itf.COMBINEDNAME,''Regular'')                   as ""Variant Name""     
-- --Facts-----------------------------------------------------------------------------------------
    ,IFNULL(itf.QUANTITY::NUMBER(10,0),0)                 as ""Count""   
    ,IFNULL(itf.APPLIEDAMOUNT::NUMBER(18,2),0)            as ""Net Amount""
    ,IFNULL(itf.GROSS::NUMBER(18,2),0)                    as ""Gross Amount"" 
    ,IFNULL(itf.BASEPRICE::NUMBER(18,2),0)                as ""Base Price""
    ,IFNULL(itf.PRICE::NUMBER(18,2),0)                    as ""Price""
    ,IFNULL(dis.""Item Discount Amount""::NUMBER(18,2),0)   as ""Item Discount Amount""
    ,IFNULL(itf.INCLUSIVETAX::NUMBER(18,2),0)             as ""Inclusive Tax Amount""    
    ,IFNULL(itf.TAX::NUMBER(18,2),0)                      as ""Tax Amount""
--------------------------------------------------------------------------------------------   
FROM DATAWAREHOUSE.ITEM_FACT                              itf
     INNER JOIN DATAWAREHOUSE.MENUITEMNAME_DIM            med
       ON med.MENUITEMNAME_DIM_NK = itf.MENUITEMNAME_DIM_FK
          AND itf.ITEMSTATUS IN (''Added'',''Sent'')
          AND itf.CHECKSTATUS = ''Closed''
          AND itf.DW_ISCURRENTROW  
          AND med.DW_ISCURRENTROW  
          AND NOT itf.DW_ISDELETED
          AND NOT itf.IS_TRAINING
          AND itf.LOCATION_DIM_FK IN (--351,352
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)
      INNER JOIN DATAWAREHOUSE.CHEQUE_FACT                                chk
        ON chk.CHEQUE_FACT_NK = itf.CHEQUE_FACT_FK
          AND chk.DW_ISCURRENTROW
          AND chk.STATUS = ''Closed''
          AND itf.ITEMSTATUS IN (''Added'',''Sent'')
          AND (chk.FISCAL_DATE::date >= :startdate::date 
                AND chk.FISCAL_DATE::date  <= :enddate::date)
      INNER JOIN DATAWAREHOUSE.LOCATION_DIM                     loc
        ON itf.LOCATION_DIM_FK = loc.LOCATION_DIM_NK
          AND loc.DW_ISCURRENTROW
      INNER JOIN DATAWAREHOUSE.DAYPART_DIM                      dad
        ON itf.daypart_dim_fk = dad.daypart_dim_nk
          AND dad.DW_ISCURRENTROW = TRUE         
      INNER JOIN DATAWAREHOUSE.REPORTCATEGORY_DIM               meg
        ON med.REPORTCATEGORY_DIM_FK = meg.REPORTCATEGORY_DIM_NK
          AND meg.DW_ISCURRENTROW = TRUE
      INNER JOIN DATAWAREHOUSE.COGSCATEGORY_DIM                  ccd
        ON ccd.COGSCATEGORY_DIM_NK = meg.COGSCATEGORY_DIM_FK    
          AND ccd.DW_ISCURRENTROW
      LEFT JOIN (
          SELECT daf.ITEM_FACT_FK, SUM(daf.APPLIED_AMOUNT) AS ""Item Discount Amount""
              FROM DATAWAREHOUSE.DISCOUNTITEM_FACT daf
                WHERE daf.DW_ISCURRENTROW 
                  AND (daf.FISCAL_DATE::date >= :startdate::date 
                  AND daf.FISCAL_DATE::date  <= :enddate::date)
                  AND daf.LOCATION_DIM_FK IN (--351,352
                     SELECT table1.value 
                        FROM table(split_to_table(:locationidS, '',''))  table1)
                  AND NOT daf.IS_TRAINING
                GROUP BY daf.ITEM_FACT_FK
                                                          )dis 
            ON dis.ITEM_FACT_FK = itf.ITEM_FACT_NK
          
--==========================================================================================
);
RETURN TABLE(reportSet); 
END;
-- ';"
PROCEDURE,DATAADMIN,"SP_REPORT_ACCOUNTSUMMARY_PAYMENTS_GIFTCARDS(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_ACCOUNTSUMMARY_PAYMENTS_GIFTCARDS""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet           resultset;
  -- startdate string    := ''2020-07-10'';  
  -- enddate string      := ''2029-07-10''; 
  -- locationid string   := ''[351]'';
  locationidS string  :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--=========================================================================================
BEGIN
  DROP TABLE IF EXISTS TEMP_TABLE1;

 -- -------------------------------------------------------------------------------------------
   CREATE TEMP TABLE TEMP_TABLE1
      AS
    SELECT CHF.LOCATION_DIM_FK                                                AS ""Location ID""
                    ,CHF.FISCAL_DATE                                          AS ""Fiscal Day""
                    ,GCD.IS_LEGACY
                    ,(CASE WHEN GCF.COMMAND IN (''Reload'',''VoidReload'') THEN 
                       CASE WHEN GCF.OPENING_BALANCE IS  NULL OR GCF.GIFTCARD_DIM_Fk = 1 THEN GCF.TRANSACTION_AMOUNT 
                          ELSE GCF.CLOSING_BALANCE - GCF.OPENING_BALANCE  END  ELSE 0 END )::DECIMAL(36,2)
                                                                              AS ""Reload Amount"" 
                    ,(CASE WHEN GCF.COMMAND IN (''Adjust'',''NoNSFSale'',''VoidSale'') THEN 
                          CASE WHEN GCF.OPENING_BALANCE IS NULL OR GCF.GIFTCARD_DIM_Fk = 1  
                            THEN GCF.TRANSACTION_AMOUNT * (-1) ELSE GCF.CLOSING_BALANCE - GCF.OPENING_BALANCE  END  ELSE 0 END )  ::DECIMAL(36,2)
                                                                              AS ""Redeemed Amount""  
                                                 
                FROM DATAWAREHOUSE.GIFTCARDTRANSACTION_FACT                   GCF  
                    INNER JOIN DATAWAREHOUSE.CHEQUE_FACT                      CHF
                      ON CHF.CHEQUE_FACT_NK = GCF.CHEQUE_FACT_FK
                          AND CHF.FISCAL_DATE::date >= :startdate::date 
                          AND CHF.FISCAL_DATE::date <= :enddate::date  
                          AND CHF.LOCATION_DIM_FK in (
                             SELECT table1.value 
                               FROM table(split_to_table(:locationidS, '',''))  table1) 
                          AND CHF.STATUS = ''Closed''
                          AND GCF.DW_ISCURRENTROW
                          AND NOT GCF.DW_ISDELETED     
                          AND CHF.DW_ISCURRENTROW
                     INNER JOIN DATAWAREHOUSE.GIFTCARD_DIM                     GCD
                       ON GCD.GIFTCARD_DIM_NK = GCF.GIFTCARD_DIM_FK
                          AND GCD.DW_ISCURRENTROW
                          AND GCD.IS_ISSUED
                          AND NOT GCD.DW_ISDELETED  ;
  

--=========================================================================================
 reportSet:= (
 SELECT * from TEMP_TABLE1
);

--===========================================================================================
RETURN TABLE(reportSet); 

END';"
PROCEDURE,DATAADMIN,"SP_REPORT_REFUNDS(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_REFUNDS""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2000-11-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2029-11-20T14:48:37.661Z''; 
  -- locationid string      := ''[3,2,351]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');

--===================================================================================================================
BEGIN
 reportSet   := (
 
        SELECT ref.refunds_fact_nk                      as ""Support ID"" 
         , ''REF-'' ||row_number() over (order by ref.refunds_fact_nk) 
                                                        as ""Detail ID""        
--status, category, level-------------------------------------------------------------------
--geography---------------------------------------------------------------------------------   
          ,IFNULL(loc.locationname,''None'')              as ""Location""
          ,loc.location_dim_nk                          as ""Location ID""          
          ,IFNULL(ref.revenuecentername ,''None'')        as ""Revenue Center""
 --dates-------------------------------------------------------------------------------------
           ,LOC.TZ_NAME                                 as ""Time Zone"" 
  ,to_char(LEFT(chk.FISCAL_DATE,4))                     as ""Year""
          ,to_char(YEAR(chk.FISCAL_DATE)) || ''|'' || TO_CHAR(RIGHT(''0'' || MONTH(chk.FISCAL_DATE),2))                                       
                                                        as ""Year and Month""
          ,IFNULL(dpd.DAYPART,''None'')                   as ""Daypart""
          ,to_char(chk.FISCAL_DATE)                     as ""Fiscal Date""
          ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,ref.REFUNDED_AT::timestamp_ntz )::timestamp) 
                                                        as ""Refunded At""
          ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,ref.OPENED_AT::timestamp_ntz )::timestamp)                                                                            
                                                        as ""Opened At""                                                           
          ,IFNULL(DAYNAME(chk.FISCAL_DATE),''None'')      as""Day of Week""
          ,CASE WHEN DAYNAME(chk.FISCAL_DATE) IN (''Sat'',''Sun'')  
             THEN TRUE ELSE FALSE END                   as ""Is Weekend""
--people-------------------------------------------------------------------------------------
          ,IFNULL(replace(
            substring(ref.REFUNDED_BY,1,charindex(''('',ref.REFUNDED_BY) - 1)
          ,''User '',''''),''None'')               
                                                        as ""Refunded By""    
                                                   
--Descriptors--------------------------------------------------------------------------------        
          ,IFNULL(ptd.paymentmethodname ,''None'')        as ""Payment Method""
          ,BATCHNUMBER                                  as ""Batch Number""
          ,IFNULL(ref.cardholderName,''None'')            as ""Cardholder Name""
          ,IFNULL(ref.LASTFOURCCNUMBER,''None'')          as ""Card Last 4 Digits""
          ,IFNULL(case ref.cardbrand when '''' 
             THEN ''Not a Credit Card'' 
            else ref.cardbrand end,''None'')  
                                                        as ""Card Brand"" 
         ,ref.CHEQUENUMBER                              as ""Check""
         ,chk.CHEQUE_FACT_NK                            as ""Check ID""         
 --Facts--------------------------------------------------------------------------------------  
         ,1::NUMBER(10,0)                               as ""Count""
         ,TIP::DECIMAL(18,2)                            as ""Tip Amount""    
         ,CHECK_TOTAL_AMOUNT::DECIMAL(18,2)             as ""Check Amount""           
         ,REFUND_AMOUNT::DECIMAL(18,2)                  as ""Refund Amount""  
        FROM DATAWAREHOUSE.REFUNDS_FACT                                 ref
          INNER JOIN DATAWAREHOUSE.location_DIM                         loc
            ON ref.location_DIM_FK = loc.location_DIM_NK
              -- AND ref.opened_at::timestamp_ntz  >= :startdate::timestamp_ntz 
              -- AND ref.opened_at::timestamp_ntz  <= :enddate::timestamp_ntz 
              AND ref.LOCATION_DIM_FK in (
                SELECT table1.value
                   FROM table(split_to_table(:locationidS, '',''))  table1) 
              AND ref.dw_iscurrentrow
              AND loc.dw_iscurrentrow
              AND NOT ref.IS_TRAINING
              AND NOT ref.dw_isdeleted
              AND ref.PAYMENTSTATUS = ''Success''
          INNER JOIN DATAWAREHOUSE.CHEQUE_FACT                           chk
            ON chk.CHEQUE_FACT_NK = ref.CHEQUE_FACT_FK
              AND chk.DW_ISCURRENTROW
              AND NOT chk.dw_isdeleted
              AND chk.STATUS = ''Closed''
              AND (chk.FISCAL_DATE::date >= :startdate::date 
                AND chk.FISCAL_DATE::date  <= :enddate::date)
          INNER JOIN DATAWAREHOUSE.LOCATION_DIM                          lod
             ON lod.LOCATION_DIM_NK = chk.LOCATION_DIM_FK
               AND lod.DW_ISCURRENTROW
          INNER JOIN DATAWAREHOUSE.PaymentMethod_DIM                     ptd      
            ON ref.PaymentMethod_DIM_FK = ptd.PaymentMethod_DIM_NK
              AND ptd.dw_iscurrentrow
              AND NOT ptd.dw_isdeleted
          INNER JOIN DATAWAREHOUSE.organization_dim                      org
            ON loc.organization_DIM_FK = org.organization_DIM_NK
              AND org.dw_iscurrentrow
              AND NOT org.dw_isdeleted
          INNER JOIN DATAWAREHOUSE.daypart_dim                           dpd
            ON ref.daypart_dim_fk = dpd.daypart_dim_nk
              AND dpd.dw_iscurrentrow
              AND NOT dpd.dw_isdeleted
          -- LEFT JOIN DATAADMIN.employee_DIM                            emd
          --   ON emd.SYSTEM_ID = ref.EMPLOYEE_ID_REFUNDER
          --     AND emd.dw_iscurrentrow 
          --     AND NOT emd.dw_isdeleted
--====================================================================================================================
); 
 RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,SP_STAGELOADORDERTYPE_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADORDERTYPE_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.ORDERTYPE_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.ORDERTYPE_DIM(   
          ORDERTYPE_DIM_NK, 
          ORDER_TYPE, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          ORGANIZATION_DIM_FK, 
          IS_GUEST_REQUIRED, 
          IS_DELIVERY_ADDRESS_REQUIRED, 
          IS_ORDER_ALERT_REQUIRED, 
          CAN_BE_SCHEDULED, 
          CREATED_AT, 
          UPDATED_AT, 
          PREP_TIME_SECONDS 
) 
 SELECT   ORDERTYPE_DIM_NK  as   ORDERTYPE_DIM_NK,  
   ORDER_TYPE  as   ORDER_TYPE,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   ORGANIZATION_DIM_FK  as   ORGANIZATION_DIM_FK,  
   IS_GUEST_REQUIRED  as   IS_GUEST_REQUIRED,  
   IS_DELIVERY_ADDRESS_REQUIRED  as   IS_DELIVERY_ADDRESS_REQUIRED,  
   IS_ORDER_ALERT_REQUIRED  as   IS_ORDER_ALERT_REQUIRED,  
   CAN_BE_SCHEDULED  as   CAN_BE_SCHEDULED,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   PREP_TIME_SECONDS  as   PREP_TIME_SECONDS 
  FROM DATAADMIN.ORDERTYPE_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''ORDERTYPE_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''ORDERTYPE_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADPAYMENTMETHOD_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADPAYMENTMETHOD_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.PAYMENTMETHOD_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.PAYMENTMETHOD_DIM(   
          PAYMENTMETHOD_DIM_NK, 
          PAYMENTMETHODNAME, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          ORGANIZATION_DIM_FK, 
          ARCHIVED, 
          IS_ENABLED, 
          IS_TIPPABLE, 
          ARCHIVED_AT, 
          CREATED_AT, 
          UPDATED_AT, 
          PAYMENTMETHODTYPE 
) 
 SELECT   PAYMENTMETHOD_DIM_NK  as   PAYMENTMETHOD_DIM_NK,  
   PAYMENTMETHODNAME  as   PAYMENTMETHODNAME,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   ORGANIZATION_DIM_FK  as   ORGANIZATION_DIM_FK,  
   ARCHIVED  as   ARCHIVED,  
   IS_ENABLED  as   IS_ENABLED,  
   IS_TIPPABLE  as   IS_TIPPABLE,  
   ARCHIVED_AT  as   ARCHIVED_AT,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   PAYMENTMETHODTYPE  as   PAYMENTMETHODTYPE 
  FROM DATAADMIN.PAYMENTMETHOD_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''PAYMENTMETHOD_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''PAYMENTMETHOD_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADPHONENUMBER_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADPHONENUMBER_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.PHONENUMBER_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.PHONENUMBER_DIM(   
          PHONENUMBER_DIM_NK, 
          PHONE, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          CREATED_AT, 
          UPDATED_AT, 
          KIND, 
          REGION, 
          EXTENSION, 
          COUNTRY_CODE, 
          FUZZY_VECTOR 
) 
 SELECT   PHONENUMBER_DIM_NK  as   PHONENUMBER_DIM_NK,  
   PHONE  as   PHONE,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   KIND  as   KIND,  
   REGION  as   REGION,  
   EXTENSION  as   EXTENSION,  
   COUNTRY_CODE  as   COUNTRY_CODE,  
   FUZZY_VECTOR  as   FUZZY_VECTOR 
  FROM DATAADMIN.PHONENUMBER_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''PHONENUMBER_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''PHONENUMBER_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADTAXSETTINGS_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADTAXSETTINGS_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.TAXSETTINGS_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.TAXSETTINGS_DIM(   
          TAXSETTINGS_DIM_NK, 
          TAXSETTINGS_ID, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          LOCATION_DIM_FK, 
          LOCATIONGROUP_DIM_FK, 
          TRACK_TAXES_ON_COMPS, 
          CREATED_AT, 
          UPDATED_AT, 
          TAX_TRACKING, 
          RECEIPT_OPTIONS, 
          ROUNDING_METHOD, 
          COMBINED_RECEIPT_NAME 
) 
 SELECT   TAXSETTINGS_DIM_NK  as   TAXSETTINGS_DIM_NK,  
   TAXSETTINGS_ID  as   TAXSETTINGS_ID,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   LOCATION_DIM_FK  as   LOCATION_DIM_FK,  
   LOCATIONGROUP_DIM_FK  as   LOCATIONGROUP_DIM_FK,  
   TRACK_TAXES_ON_COMPS  as   TRACK_TAXES_ON_COMPS,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   TAX_TRACKING  as   TAX_TRACKING,  
   RECEIPT_OPTIONS  as   RECEIPT_OPTIONS,  
   ROUNDING_METHOD  as   ROUNDING_METHOD,  
   COMBINED_RECEIPT_NAME  as   COMBINED_RECEIPT_NAME 
  FROM DATAADMIN.TAXSETTINGS_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''TAXSETTINGS_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''TAXSETTINGS_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_UTILITY_DEPENDENCIES(),"CREATE OR REPLACE PROCEDURE ""SP_UTILITY_DEPENDENCIES""()
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS '
--============================================================================================
--Procedure to pull the dependent tables of all the views in public ending with _DIM/_FACT/_XREF
declare
--Declaring variables
  select_statement varchar;
  res resultset;
begin
--Sql statement to pull the dependent tables of all the views in public ending with _DIM/_FACT/_XREF
select_statement := (SELECT listagg(stmt, '''') as statment_text FROM (SELECT
     ''SELECT * from table(get_object_references(database_name=>\\''DEV_HOSPENG_REPORTING\\'', schema_name=>\\''DATAADMIN\\'', object_name=> \\'''' || table_name || ''\\''))''
      || CASE WHEN row_num < max(row_num) over()
            THEN '' UNION ''
        ELSE '' ''
      END as stmt
      FROM (SELECT TABLE_NAME
            ,rank() over (ORDER BY table_name) as row_num
            FROM INFORMATION_SCHEMA.TABLES
            WHERE TABLE_SCHEMA = ''DATAADMIN'' and
                  (TABLE_NAME like ''%_DIM'' or
                  TABLE_NAME like ''%_FACT'' or
                  TABLE_NAME like ''%_XREF''))));
--Executing the variable which is the sql statement
res := (execute immediate : select_statement);
--Returning the variable which is the result of sql statement
return table(res);
end;
';"
PROCEDURE,DATAADMIN,SP_GET_DAG_RUN_METADATA(VARCHAR),"CREATE OR REPLACE PROCEDURE ""SP_GET_DAG_RUN_METADATA""(""PARENT_QUERY_ID"" VARCHAR)
RETURNS VARIANT
LANGUAGE SQL
EXECUTE AS OWNER
AS '
DECLARE
    -- Local variables
    graph_run_group_id VARCHAR;
    task_name VARCHAR;
    run_attempt_number NUMBER;
    session_id VARCHAR;
    metadata_obj VARIANT;
BEGIN
    session_id := COALESCE(CURRENT_SESSION(), ''NOT_FOUND'');

    -- GET RUNTIME INFO
    BEGIN
        graph_run_group_id := SYSTEM$TASK_RUNTIME_INFO(''CURRENT_TASK_GRAPH_RUN_GROUP_ID'');
        task_name := SYSTEM$CURRENT_USER_TASK_NAME();
    EXCEPTION
        WHEN OTHER THEN
            graph_run_group_id := ''MANUAL_RUN'';
            task_name := null;
    END;

    -- GET ATTEMPT NUMBER
    IF (task_name IS NULL) THEN
        run_attempt_number := 1; -- Manual run is always attempt 1
    ELSE
        BEGIN
            SELECT COALESCE(MAX(attempt_number), 1)
            INTO :run_attempt_number
            FROM TABLE(information_schema.task_history(
                scheduled_time_range_start => dateadd(''hour'', -1, current_timestamp()),
                task_name => :task_name
            ))
            WHERE graph_run_group_id = :graph_run_group_id;
        EXCEPTION
            WHEN OTHER THEN
                run_attempt_number := 1; -- Fallback on permission/other error
        END;
    END IF;

    -- Construct a VARIANT object to return all metadata
    metadata_obj := OBJECT_CONSTRUCT(
        ''parent_query_id'', :PARENT_QUERY_ID,
        ''graph_run_group_id'', :graph_run_group_id,
        ''task_name'', :task_name,
        ''run_attempt_number'', :run_attempt_number,
        ''session_id'', :session_id
    );

    RETURN metadata_obj;
END;
';"
PROCEDURE,DATAADMIN,"SP_LOAD_DATASHARE_CRAFTABLE_FEE(VARCHAR, VARCHAR, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_DATASHARE_CRAFTABLE_FEE""(""START_DATE"" VARCHAR, ""END_DATE"" VARCHAR, ""LOCATION_IDS"" VARCHAR)
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS CALLER
AS 'BEGIN
    -- Execute the source procedure that returns the data
    CALL DATAADMIN.SP_DATASHARE_CRAFTABLE_FEES(:START_DATE, :END_DATE, :LOCATION_IDS);

    -- Insert the results into the target table
    INSERT INTO DATASHARE_DEV.CRAFTABLE_FEE (
        ""Organization Name"",
        ""Organization ID"",
        ""Location Name"",
        ""Location ID"",
        ""Business Day"",
        ""Check Number"",
        ""Check ID"",
        ""Fee Name"",
        ""Fee ID"",
        ""Fee Amount"",
        ""Fee Tax""
    )
    SELECT
        ""Organization Name"",
        ""Organization ID"",
        ""Location Name"",
        ""Location ID"",
        ""Business Day"",
        ""Check Number"",
        ""Check ID"",
        ""Fee Name"",
        ""Fee ID"",
        ""Fee Amount"",
        ""Fee Tax""
    FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

    RETURN ''Success: Data loaded into DATASHARE_DEV.CRAFTABLE_FEE.'';
END';"
PROCEDURE,DATAADMIN,"SP_REPORT_ACCOUNTSUMMARY_PAYMENTS_PAYINOUT(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_ACCOUNTSUMMARY_PAYMENTS_PAYINOUT""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2020-08-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2029-08-20T14:48:37.661Z''; 
  -- locationid string      := ''[351,2,3,4]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--=========================================================================================
BEGIN

 reportSet:= (
   SELECT TO_CHAR(ROW_NUMBER() OVER (ORDER BY ""Location ID""))  AS  ""Support ID"" 
     ,INLT_1.""Location ID""  as ""Location ID""
     ,INLT_1.""Type""         as ""Type""
     ,SUM(INLT_1.""Count"")   as ""Count""
     ,SUM(INLT_1.""Cash"")    as ""Cash""
     ,SUM(INLT_1.""Credit"")  as ""Credit""
     ,SUM(INLT_1.""Total"")   as ""Total""
     
   FROM (
      SELECT SHD.LOCATION_DIM_FK::decimal(36,0)                                   as ""Location ID""  
        ,CASE WHEN PAR.IS_PAY_IN THEN ''Pay In'' ELSE ''Pay Out''END                  as ""Type""  
        ,SUM(1::NUMBER(18,0))                                                     as ""Count""
       ,(CASE WHEN PMD.PAYMENTMETHODTYPE = ''Cash'' THEN 
         SUM( PIO.AMOUNT * CASE WHEN PAR.IS_PAY_IN THEN 1 ELSE -1 END
              ) ELSE 0 END )::DECIMAL(36,2)                                       as ""Cash"" 
    
        ,(CASE WHEN PMD.PAYMENTMETHODTYPE <> ''Cash'' THEN 
          SUM( PIO.AMOUNT * CASE WHEN PAR.IS_PAY_IN THEN 1 ELSE -1 END
             ) ELSE 0 END ) ::DECIMAL(36,2)                                       as ""Credit""           
        ,SUM( PIO.AMOUNT * CASE WHEN PAR.IS_PAY_IN THEN 1 ELSE -1 END
              ) ::DECIMAL(36,2)                                                   as ""Total"" 
           FROM DATAWAREHOUSE.PAYINOUT_FACT                                       PIO  
                INNER JOIN DATAWAREHOUSE.SHIFT_DIM                                SHD
                  ON PIO.SHIFT_DIM_FK = SHD.SHIFT_DIM_NK
                      AND SHD.DW_ISCURRENTROW
                      AND PIO.DW_ISCURRENTROW
                      AND NOT PIO.DW_ISDELETED
                      AND NOT PIO.IS_VOID
                      AND PIO.STATUS = ''Success''
                      AND SHD.FISCAL_DAY::date >= :startdate::date 
                      AND SHD.FISCAL_DAY::date <= :enddate::date  
                      AND SHD.LOCATION_DIM_FK in (
                        SELECT table1.value 
                          FROM table(split_to_table(:locationidS, '',''))  table1) 
                INNER JOIN DATAWAREHOUSE.PAYMENTMETHOD_DIM                         PMD
                  ON PMD.PAYMENTMETHOD_DIM_NK = PIO.PAYMENTMETHOD_DIM_FK
                      AND PMD.DW_ISCURRENTROW
                INNER JOIN DATAWAREHOUSE.PAYINPAYOUTREASON_DIM                     PAR
                  ON PAR.PAYINPAYOUTREASON_DIM_NK = PIO.PAYINPAYOUTREASON_DIM_FK
                      AND PAR.DW_ISCURRENTROW
                GROUP BY ""Location ID""  
                    ,""Type""
                    ,PMD.PAYMENTMETHODTYPE
                    
  )  INLT_1
     GROUP BY  ""Location ID""
     ,""Type""    
);

--===========================================================================================
RETURN TABLE(reportSet); 

END';"
PROCEDURE,DATAADMIN,"SP_REPORT_LABOR_NEW(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_LABOR_NEW""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE  --count = 2914
  reportSet resultset;
  -- startdate timestamp_tz := ''2020-07-25'';  
  -- enddate timestamp_tz   := ''2030-07-25''; 
  -- locationid string      := ''[351]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');

-- ============================================================================================= 
-- GRANT usage ON procedure dataadmin.SP_REPORT_LABOR(timestamp_tz,timestamp_tz,string) TO ROLE DATA_REPLICATION_HOSPENG;
--CALL DATAADMIN.SP_REPORT_LABOR_NEW(''2024-07-25'',''2024-07-25'',''[351]'');
-- =============================================================================================
BEGIN
  DROP TABLE IF EXISTS TEMP_LABOR;
  DROP TABLE IF EXISTS TEMP_TIPGRAT;
  DROP TABLE IF EXISTS SHIFT_CTE;
  DROP TABLE IF EXISTS BREAK_CTE;
  DROP TABLE IF EXISTS RULE_CTE;

  -- WITH SHIFT_CTE AS (
    SELECT SHD.SHIFT_DIM_PK --|| overtime_fact_nk || fiscal day and week or date                                 
                                                               AS ""Support ID"" 
        ,SHD.SHIFT_DIM_NK                                      AS ""SHIFT_DIM_NK""
    --status, category, level------------------------------------------------------------------
        ,''Shift''                                               AS ""Level""
    --geography--------------------------------------------------------------------------------
        ,IFNULL(loc.LOCATIONNAME,''None'')                       AS ""Location""
        -- ,SHD.LOCATION_DIM_FK                                AS ""Location ID""  
        ,IFNULL(org.organization,''None'')                       AS ""Organization""
    --dates-------------------------------------------------------------------------------------
        ,LOC.TZ_NAME                                            AS ""Time Zone""
        ,TO_CHAR(DATE_PART(YEAR,SHD.CLOCKEDIN_AT::timestamp_ntz ))   
                                                               AS ""Year""
        ,to_char(LEFT(SHD.CLOCKEDIN_AT::timestamp_ntz,7))                     
                                                               AS ""Year and Month""
        ,SHD.CLOCKEDIN_AT::timestamp_ntz                             
                                                               AS ""Clocked In At""
        ,SHD.CLOCKEDOUT_AT::timestamp_ntz                                    
                                                               AS ""Clocked Out At""    
        ,IFNULL(DAYNAME(SHD.CLOCKEDIN_AT::timestamp_ntz),''None'')              
                                                               AS ""Day of Week""
        ,CASE WHEN DAYNAME(SHD.CLOCKEDIN_AT::timestamp_ntz) IN (''Sat'',''Sun'')  
            THEN TRUE ELSE FALSE END                           
                                                               AS ""Is Weekend""
        ,ORG.START_OF_PAYROLL_WEEK_INT                         AS ""Week Offset""
        ,NULL::VARCHAR(20)                                     AS ""Fiscal Week""  
        ,NULL::VARCHAR(20)                                     AS ""Fiscal Week Start"" 
        ,NULL::VARCHAR(20)                                     AS ""Fiscal Week End""
        ,SHD.FISCAL_DAY                                        AS ""Fiscal Day""  
        
        ,DATEADD(DAY,ORG.START_OF_PAYROLL_WEEK_INT 
          + case  ORG.START_OF_PAYROLL_WEEK_INT  when 0 then 1
           when 1 then -1 
           when 2 then -1
           when 3 then -2
           when 4 then -2
           when 5 then -2
           when 6 then -2
           
           else -1  end                                 
          ,SHD.FISCAL_DAY::DATE )                              AS ""Fiscal Day Offset""      
                                                                         
    --flags--------------------------------------------------------------------------------------
        ,SHD.IS_SHIFTCOMPLETE                                  AS ""Is Clocked Out""
        ,SHD.WAS_SYSTEM_CLOCKOUT                               AS ""Was System Clock Out""
        ,SHD.GETS_PAID_BREAK                                   AS ""Gets Paid Break""
    --people------------------------------------------------------------------------------------- 
        ,EMD.EMPLOYEE_NAME                                     AS ""Employee""
        ,EMD.EMPLOYEE_DIM_NK                                   AS ""Employee ID""
        ,SHD.JOBPOSITION_DIM_FK                                AS ""JOBPOSITION_DIM_FK""
        ,SHD.LOCATION_DIM_FK                                   AS ""LOCATION_DIM_FK""  
        ,EMD.PAYROLL_ID                                        AS ""Payroll ID""
        ,SHD.GENERAL_LEDGER                                    AS ""General Ledger Number""
     --Descriptors-------------------------------------------------------------------------------- 
       ,JBP.JOB_POSITION                                       AS ""Job Position""  --(i.e. Bartender, Cook, Server)    
       ,JCD.JOBCATEGORY                                        AS ""Job Category""
       ,SHD.SHIFT                                              AS ""Shift ID""  
       ,SHD.PAY_RATE_BASIS                                     AS ""Pay Basis""
     --Facts-----------------------------------------------------------------------------------------
        ,NULL                                                  AS ""Overtime Rule""
        ,NULL                                                  AS ""Hours Per Day""
        ,NULL                                                  AS ""Seconds Per Day""
        ,NULL                                                  AS ""Hours Per Week""
        ,NULL                                                  AS ""Seconds Per Week""
        ,to_number(1)                                          AS ""Shift Count""
        ,NULL                                                  AS ""Break Count""  
        ,COUNT(SHD.SHIFT) OVER (PARTITION BY SHD.LOCATION_DIM_FK,EMD.EMPLOYEE_DIM_NK,SHD.FISCAL_DAY)  
                                                               AS ""Shift Per Day Count""
        -- ,IFF( SHD.IS_SHIFTCOMPLETE,SHD.SHIFT_SECONDS, 
        --   ROUND(TIMEDIFF(second
        --        ,CONVERT_TIMEZONE(''UTC'',loc.TZ_NAME,shd.CLOCKEDIN_AT::timestamp_ntz )::timestamp
        --     -- ,SHD.CLOCKEDIN_AT::timestamp_ntz 
        --        ,CONVERT_TIMEZONE(''UTC'',loc.TZ_NAME,CURRENT_TIMESTAMP::timestamp_ntz )::timestamp
        --     -- ,CURRENT_TIMESTAMP::timestamp_ntz 
        --       )::Number(38,0),0))
        --                                                        AS ""Shift Seconds""


        ,IFF( SHD.IS_SHIFTCOMPLETE,SHD.SHIFT_SECONDS, 
          ROUND(TIMEDIFF(second
               ,SHD.CLOCKEDIN_AT::timestamp_ntz 
               ,CONVERT_TIMEZONE(''UTC'', CURRENT_TIMESTAMP())::timestamp_ntz
              )::Number(38,0),0))
                                                               AS ""Shift Seconds""

                                                               
        ,NULL                                                  AS ""Break Seconds""


        ,shd.REGULAR_RATE * 1.5::Number(18,2)             
                                                               AS ""Overtime Rate""
        ,shd.REGULAR_RATE::Number(18,2)                        AS ""Regular Rate""
 
        FROM DATAWAREHOUSE.SHIFT_DIM                               SHD
          INNER JOIN DATAWAREHOUSE.LOCATION_DIM                    LOC
             ON SHD.LOCATION_DIM_FK = LOC.LOCATION_DIM_NK
                AND LOC.DW_ISCURRENTROW
                AND SHD.DW_ISCURRENTROW
             
                AND NOT SHD.DW_ISDELETED
                AND NOT SHD.IS_ARCHIVED
                AND shd.fiscal_day::date
                   >= dateadd(DAY,-10,:startdate)::date --calculate data 10 days around selected dates so that  
                AND  shd.fiscal_day::date  
                  <= dateadd(DAY,10,:enddate)::date    --the data in the selected range calcs overtime for full fiscal week
                AND SHD.LOCATION_DIM_FK IN ( SELECT table1.value 
                           FROM table(split_to_table(:locationidS, '',''))  table1)
          INNER JOIN DATAWAREHOUSE.ORGANIZATION_DIM                ORG
            ON LOC.ORGANIZATION_DIM_FK = ORG.ORGANIZATION_DIM_NK
              AND ORG.DW_ISCURRENTROW
          INNER JOIN DATAWAREHOUSE.EMPLOYEE_DIM                    EMD
            ON SHD.EMPLOYEE_DIM_FK = EMD.EMPLOYEE_DIM_NK
              AND EMD.DW_ISCURRENTROW
          INNER JOIN DATAWAREHOUSE.JOBPOSITION_DIM                 JBP
            ON JBP.JOBPOSITION_DIM_NK = SHD.JOBPOSITION_DIM_FK 
              AND JBP.DW_ISCURRENTROW
          INNER JOIN DATAWAREHOUSE.JOBCATEGORY_DIM                 JCD
            ON JBP.JOBCATEGORY_DIM_FK = JCD.JOBCATEGORY_DIM_NK
              AND JCD.DW_ISCURRENTROW
         ORDER BY SHD.CLOCKEDIN_AT DESC ;  

 CREATE TEMP TABLE SHIFT_CTE AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));  
     
UPDATE SHIFT_CTE
  SET ""Fiscal Week Start"" = dateadd(day,dayofweek(""Fiscal Day"") * -1  + ""Week Offset"" - case when dayofweek(""Fiscal Day"") >= ""Week Offset"" then 0 else 7 end
                            ,""Fiscal Day"") 
    ,""Fiscal Week End""    = dateadd(day,6,
                           dateadd(day,dayofweek(""Fiscal Day"") * -1  + ""Week Offset"" - case 
                             when dayofweek(""Fiscal Day"") >= ""Week Offset"" then 0 else 7 end ,""Fiscal Day""))
;

UPDATE SHIFT_CTE
  SET ""Fiscal Week"" = YEAR(""Fiscal Week Start""::date) || ''-'' ||  RIGHT(''0'' || WEEKOFYEAR(""Fiscal Week Start""::date),2);
  
--===========================================================================================           
--    ,BREAK_CTE AS (
        SELECT SHD_1.""Support ID""                               AS ""Support ID"" 
        ,MAX(SHD_1.SHIFT_DIM_NK)                                AS ""SHIFT_DIM_NK""
    --status, category, level------------------------------------------------------------------
        ,''Break''                                                AS ""Level""
    --geography--------------------------------------------------------------------------------
        ,NULL                                                   AS ""Location""
        ,NULL                                                   AS ""Organization""
    -- --dates-------------------------------------------------------------------------------------
        ,MAX(SHD_1.""Time Zone"")                                 AS ""Time Zone""
        ,NULL                                                   AS ""Year""
        ,NULL                                                   AS ""Year and Month""
        ,NULL                                                   AS ""Clocked In At""
        ,NULL                                                   AS ""Clocked Out At""    
        ,NULL                                                   AS ""Day of Week""
        ,NULL                                                   AS ""Is Weekend""
        ,NULL                                                   AS ""Week Offset""
        ,MAX(SHD_1.""Fiscal Week"")                               AS ""Fiscal Week""     
        ,MAX(SHD_1.""Fiscal Week Start"")                         AS ""Fiscal Week Start"" 
        ,MAX(SHD_1.""Fiscal Week End"")                           AS ""Fiscal Week End""
        ,NULL                                                   AS ""Fiscal Day""
        ,NULL                                                   AS ""Fiscal Day Offset""           
    -- --flags--------------------------------------------------------------------------------------
        ,NULL                                                   AS ""Is Clocked Out""
        ,NULL                                                   AS ""Was System Clock Out""
        ,NULL                                                   AS ""Gets Paid Break""
    -- --people------------------------------------------------------------------------------------- 
        ,NULL                                                   AS ""Employee""
        ,NULL                                                   AS ""Employee ID""
        ,NULL                                                   AS JOBPOSITION_DIM_FK
        ,NULL                                                   AS LOCATION_DIM_FK  
        ,NULL                                                   AS ""Payroll ID""
        ,NULL                                                   AS ""General Ledger Number""        
    --  --Descriptors-------------------------------------------------------------------------------- 
        ,NULL                                                   AS ""Job Position""  
        ,NULL                                                   AS ""Job Category""        
        ,NULL                                                   AS ""Pay Basis""
        ,NULL                                                   AS ""Shift ID""  
    -- Facts-----------------------------------------------------------------------------------------
        ,NULL                                                   AS ""Overtime Rule""
        ,NULL                                                   AS ""Hours Per Day""
        ,NULL                                                   AS ""Seconds Per Day""
        ,NULL                                                   AS ""Hours Per Week""
        ,NULL                                                   AS ""Seconds Per Week""
        ,NULL                                                   AS ""Shift Count""
        ,1                                                      AS ""Break Count""   
        ,NULL                                                   AS ""Shift Per Day Count""
        ,0                                                      AS ""Shift Seconds""
        ,SUM(IFF( BRK_1.IS_BREAKCOMPLETE ,BRK_1.BREAK_SECONDS , 
          ROUND(TIMEDIFF(SECOND
            ,BRK_1.START_AT::timestamp_ntz 
            ,CURRENT_TIMESTAMP::timestamp_ntz 
                )::Number(38,0),0)) )                                                  
                                                                AS ""Break Seconds""
     
        ,NULL                                                   AS ""Overtime Rate""
        ,NULL                                                   AS ""Regular Rate""
          FROM SHIFT_CTE                                        SHD_1
            LEFT JOIN DATAWAREHOUSE.SHIFTBREAK_FACT             BRK_1
              ON SHD_1.SHIFT_DIM_NK = BRK_1.SHIFT_DIM_FK
                 AND BRK_1.DW_ISCURRENTROW
                 AND NOT BRK_1.DW_ISDELETED
            GROUP BY SHD_1.""Support ID""  
            ;
    -- )
    
 CREATE TEMP TABLE BREAK_CTE AS 
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));    

--=============================================================================================================     
  --  ,RULE_CTE AS (  ---NOTE:  THIS JOIN SHOULD NOT BE CURRENT ROW...IT SHOULD BE ROW WHERE TIME = SHIFT START
         SELECT SHD_2.""Support ID""                              AS ""Support ID"" 
        ,SHD_2.SHIFT_DIM_NK                                     AS ""SHIFT_DIM_NK""
    --status, category, level------------------------------------------------------------------
        ,''Rule''                                                 AS ""Level""
    --geography--------------------------------------------------------------------------------
        ,NULL                                                   AS ""Location""
        ,NULL                                                   AS ""Organization""
    -- --dates-------------------------------------------------------------------------------------
        ,NULL                                                   AS ""Time Zone""    
        ,NULL                                                   AS ""Year""
        ,NULL                                                   AS ""Year and Month""
        ,NULL                                                   AS ""Clocked In At""
        ,NULL                                                   AS ""Clocked Out At""    
        ,NULL                                                   AS ""Day of Week""
        ,NULL                                                   AS ""Is Weekend""
        ,NULL                                                   AS ""Week Offset""
        ,SHD_2.""Fiscal Week""                                    AS ""Fiscal Week""   
        ,SHD_2.""Fiscal Week Start""                              AS ""Fiscal Week Start"" 
        ,SHD_2.""Fiscal Week End""                                AS ""Fiscal Week End""        
        ,SHD_2.""Fiscal Day""                                     AS ""Fiscal Day""   
        ,SHD_2.""Fiscal Day Offset""                              AS ""Fiscal Day Offset""     
    -- --flags--------------------------------------------------------------------------------------
        ,NULL                                                   AS ""Is Clocked Out""
        ,NULL                                                   AS ""Was System Clock Out""
        ,NULL                                                   AS ""Gets Paid Break""
    -- --people------------------------------------------------------------------------------------- 
        ,NULL                                                   AS ""Employee""
        ,NULL                                                   AS ""Employee ID""        
        ,NULL                                                   AS JOBPOSITION_DIM_FK
        ,NULL                                                   AS LOCATION_DIM_FK 
        ,NULL                                                   AS ""Payroll ID""
        ,NULL                                                   AS ""General Ledger Number""        
    --  --Descriptors-------------------------------------------------------------------------------- 
       ,NULL                                                    AS ""Job Position""  --(i.e. Bartender, Cook, Server) 
       ,NULL                                                    AS ""Job Category""       
       ,NULL                                                    AS ""Pay Basis""
       ,NULL                                                    AS ""Shift ID""       
    -- Facts-----------------------------------------------------------------------------------------
        ,OLT.OVERTIMERULE                                       AS ""Overtime Rule""
        ,CASE WHEN OLT.HOURS_PER_DAY = 0 or :locationidS in (''[3]'',''[4]'',''[5]'')
            THEN 999999999 ELSE  OLT.HOURS_PER_DAY END                                      
                                                                AS ""Hours Per Day""
        ,CASE WHEN OLT.HOURS_PER_DAY = 0 or :locationidS in (''[3]'',''[4]'',''[5]'')
            THEN 999999999 ELSE  OLT.HOURS_PER_DAY END * 60 * 60                                 
                                                                AS ""Seconds Per Day""
                                                                
        ,CASE WHEN OLT.HOURS_PER_WEEK = 0  THEN 999999999 ELSE OLT.HOURS_PER_WEEK END                                     
                                                                AS ""Hours Per Week""

         ,CASE WHEN OLT.HOURS_PER_WEEK = 0  THEN 999999999 ELSE OLT.HOURS_PER_WEEK * 60 * 60 END                                                                  
                                                                AS ""Seconds Per Week""
        
        ,NULL                                                   AS ""Shift Count""
        ,0                                                      AS ""Break Count""   
        ,NULL                                                   AS ""Shift Per Day Count""
        ,0                                                      AS ""Shift Seconds""
        ,NULL                                                   AS ""Break Seconds""
     
        ,NULL                                                   AS ""Overtime Rate""
        ,NULL                                                   AS ""Regular Rate""
          FROM SHIFT_CTE                                        SHD_2
            INNER JOIN OVERTIMELABORRULE_JOBPOSITION_XREF       OJX
           ON OJX.JOBPOSITION_DIM_FK = SHD_2.JOBPOSITION_DIM_FK
             AND OJX.DW_ISCURRENTROW
         INNER JOIN DATAWAREHOUSE.OVERTIMELABORRULE_DIM             OLT
            ON SHD_2.LOCATION_DIM_FK = OLT.LOCATION_DIM_FK
              AND OLT.OVERTIMELABORRULE_DIM_NK = OJX.OVERTIMELABORRULE_DIM_FK
              AND OLT.DW_ISCURRENTROW  
              AND NOT OLT.DW_ISDELETED
              AND OLT.IS_ACTIVE
              ;
   -- )  --end of cte tables
 CREATE TEMP TABLE RULE_CTE AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));  
     
    --=========================================================================================
    SELECT to_char(UNI_2.""Support ID"")              as ""Support ID""
    , ''LAB-'' ||row_number() over (order by UNI_2.""Shift ID"") 
                                                    as ""Detail ID""  
    ,UNI_2.""Location""
    ,UNI_2.location_dim_fk                          as ""Location ID""
    ,UNI_2.""Time Zone""
    ,UNI_2.""Year""
    ,UNI_2.""Year and Month""
    ,CONVERT_TIMEZONE(''UTC'',UNI_2.""Time Zone"",UNI_2.""Clocked In At""::timestamp_ntz )::timestamp 
    --,UNI_2.""Clocked In At""
                                                     as ""Clocked In At""
    ,CONVERT_TIMEZONE(''UTC'',UNI_2.""Time Zone"",UNI_2.""Clocked Out At""::timestamp_ntz )::timestamp                                                      
    --,UNI_2.""Clocked Out At""
                                                     as ""Clocked Out At""

---------------------------------
    ,to_varchar(CONVERT_TIMEZONE(''UTC'',UNI_2.""Time Zone"",UNI_2.""Clocked In At""::timestamp_ntz )::timestamp,''HH12:MI:SS'')
                                                      as ""Clock In Time""
    ,to_varchar(CONVERT_TIMEZONE(''UTC'',UNI_2.""Time Zone"",UNI_2.""Clocked Out At""::timestamp_ntz )::timestamp,''HH12:MI:SS'')
                                                      as ""Clock Out Time""                                                      
---------------------------------
    ,UNI_2.""Day of Week""
    ,UNI_2.""Is Weekend""
    ,UNI_2.""Fiscal Week""
    ,UNI_2.""Fiscal Week Start""
    ,UNI_2.""Fiscal Week End""
    ,to_char(UNI_2.""Fiscal Day"")                      as ""Fiscal Day""
    ,UNI_2.""Is Clocked Out""
    ,UNI_2.""Was System Clock Out""
    ,UNI_2.""Employee""
    ,TO_VARCHAR(UNI_2.""Employee ID"")                  as ""Employee ID""
    ,UNI_2.""Payroll ID""                               as ""Payroll ID""
    ,UNI_2.""General Ledger Number""                    as ""General Ledger Number"" 
    ,UNI_2.""Job Position""
    ,UNI_2.""Job Category""
    ,UNI_2.""Pay Basis""
    ,''Shift '' ||UNI_2.""Shift ID""::decimal(18,0)       as ""Shift ID""
    ,UNI_2.""Overtime Rule""
    ,UNI_2.""Overtime Rate""::NUMBER(18,2)              as ""Overtime Rate""
    ,UNI_2.""Regular Rate"" ::NUMBER(18,2)              as ""Regular Rate""
    --=======================================================================  
    ,UNI_2.""Shift Seconds""::NUMBER(18,0)              as ""Shift Seconds""
    ,UNI_2.""Break Seconds""::NUMBER(18,0)              as ""Break Seconds""
    ,UNI_2.""Seconds Per Week""::NUMBER(18,0)           as ""Weekly Overtime Rule Seconds""
    ,UNI_2.""Seconds Per Day"" ::NUMBER(18,0)           as ""Daily Overtime Rule Seconds""
--===================== ====================================================================================
   -- ,UNI_2.""Shift Regular Seconds""::NUMBER(18,0)    as ""Regular Seconds""

   --    ,IFF(UNI_2.""Day Regular Seconds Running Total"" > UNI_2.""Seconds Per Week"" 
   --      AND UNI_2.""Seconds Per Week"" IS NOT NULL
   --          ,IFF(UNI_2.""Seconds Per Week"" <
   --               LAG(UNI_2.""Day Regular Seconds Running Total"") 
   --                 OVER (PARTITION BY  UNI_2.""Employee"", UNI_2.""Fiscal Week""  ORDER BY UNI_2.""Clocked In At"")
   --              ,UNI_2.""Shift Regular Seconds""
   --              ,UNI_2.""Day Regular Seconds Running Total"" - UNI_2.""Seconds Per Week""
   --              )   
   --          ,UNI_2.""Shift Day Overtime Seconds"") ::NUMBER(18,0)                                                      
   --                                                    as ""Overtime Seconds"" 

   ,UNI_2.""Shift Regular Seconds""::NUMBER(18,0)       
     -
    IFF(UNI_2.""Day Regular Seconds Running Total"" > UNI_2.""Seconds Per Week"" 
        AND UNI_2.""Seconds Per Week"" IS NOT NULL
            ,IFF(UNI_2.""Seconds Per Week"" <
                 LAG(UNI_2.""Day Regular Seconds Running Total"") 
                   OVER (PARTITION BY  UNI_2.""Employee"", UNI_2.""Fiscal Week""  ORDER BY UNI_2.""Clocked In At"")
                ,UNI_2.""Shift Regular Seconds""
                ,UNI_2.""Day Regular Seconds Running Total"" - UNI_2.""Seconds Per Week""
                )   
            ,UNI_2.""Shift Day Overtime Seconds"") ::NUMBER(18,0) 

     
       as ""Regular Seconds""
--=====================  ===================================================================================
   -- ,UNI_2.""Day Regular Seconds Running Total""
   -- -- -- ,UNI_2.""Shift Day Overtime Seconds""
   -- -- -- ,UNI_2.""Seconds Per Week""
   -- ,LAG(UNI_2.""Day Regular Seconds Running Total"") 
   --                 OVER (PARTITION BY  UNI_2.""Employee"", UNI_2.""Fiscal Week""  ORDER BY UNI_2.""Clocked In At"")           
   --                                                 as ""Last Running Total""
                                                   
   ,IFF(UNI_2.""Day Regular Seconds Running Total"" > UNI_2.""Seconds Per Week"" 
        AND UNI_2.""Seconds Per Week"" IS NOT NULL
            ,IFF(UNI_2.""Seconds Per Week"" <
                 LAG(UNI_2.""Day Regular Seconds Running Total"") 
                   OVER (PARTITION BY  UNI_2.""Employee"", UNI_2.""Fiscal Week""  ORDER BY UNI_2.""Clocked In At"")
                ,UNI_2.""Shift Regular Seconds""
                ,UNI_2.""Day Regular Seconds Running Total"" - UNI_2.""Seconds Per Week""
                )   
            ,UNI_2.""Shift Day Overtime Seconds"") ::NUMBER(18,0)                                                      
                                                      as ""Overtime Seconds"" 

--======================================================================================
 ,floor(UNI_2.""Shift Regular Seconds""/60/60/24) || '' D '' ||
       floor(UNI_2.""Shift Regular Seconds""/60/60%24) || '':'' ||
       floor(UNI_2.""Shift Regular Seconds""/60%60) || '':'' ||
       floor(UNI_2.""Shift Regular Seconds""%60)         as ""Regular D H:M:S""


 ,floor(IFF(UNI_2.""Day Regular Seconds Running Total"" > UNI_2.""Seconds Per Week"" 
                       AND UNI_2.""Seconds Per Week"" IS NOT NULL
                        ,UNI_2.""Day Regular Seconds Running Total"" - UNI_2.""Seconds Per Week""
                        ,UNI_2.""Shift Day Overtime Seconds"") ::NUMBER(18,0)/60/60/24) || '' D '' ||
       floor(IFF(UNI_2.""Day Regular Seconds Running Total"" > UNI_2.""Seconds Per Week"" 
                       AND UNI_2.""Seconds Per Week"" IS NOT NULL
                        ,UNI_2.""Day Regular Seconds Running Total"" - UNI_2.""Seconds Per Week""
                        ,UNI_2.""Shift Day Overtime Seconds"") ::NUMBER(18,0)/60/60%24) || '':'' ||
       floor(IFF(UNI_2.""Day Regular Seconds Running Total"" > UNI_2.""Seconds Per Week"" 
                       AND UNI_2.""Seconds Per Week"" IS NOT NULL
                        ,UNI_2.""Day Regular Seconds Running Total"" - UNI_2.""Seconds Per Week""
                        ,UNI_2.""Shift Day Overtime Seconds"") ::NUMBER(18,0)/60%60) || '':'' ||
       floor(IFF(UNI_2.""Day Regular Seconds Running Total"" > UNI_2.""Seconds Per Week"" 
                       AND UNI_2.""Seconds Per Week"" IS NOT NULL
                        ,UNI_2.""Day Regular Seconds Running Total"" - UNI_2.""Seconds Per Week""
                        ,UNI_2.""Shift Day Overtime Seconds"") ::NUMBER(18,0)%60)         as ""Overtime D H:M:S""  
  ,null ::NUMBER(18,2)                                                                  as ""Tips""           
  ,null ::NUMBER(18,2)                                                                  as ""Gratuities""        
--======================================================================================
      FROM(
            SELECT UNI_1.* 
                   ,SUM(IFF(UNI_1.""Shift Seconds"" < UNI_1.""Seconds Per Day""
                       OR UNI_1.""Seconds Per Day"" IS NULL
                        ,UNI_1.""Shift Seconds"" 
                        ,UNI_1.""Seconds Per Day"" )) 
                            OVER (PARTITION BY UNI_1.LOCATION_DIM_FK,UNI_1.""Employee ID"" ,UNI_1.""Fiscal Week"" ORDER BY UNI_1.""Shift ID"" 
                    )                                                             AS ""Day Regular Seconds Running Total"" 
                
                    ,IFF(UNI_1.""Seconds Per Day"" < UNI_1.""Shift Seconds""  
                         AND UNI_1.""Seconds Per Day"" IS NOT NULL
                        ,UNI_1.""Seconds Per Day""
                        ,UNI_1.""Shift Seconds"" 
                         )                                 AS ""Shift Regular Seconds"" 
                        
                    ,IFF(UNI_1.""Shift Seconds"" > UNI_1.""Seconds Per Day"" 
                       AND UNI_1.""Seconds Per Day"" IS NOT NULL
                        ,UNI_1.""Shift Seconds"" - UNI_1.""Seconds Per Day"" 
                        ,0)                                                        AS ""Shift Day Overtime Seconds"" 
                                                                                
              FROM (
              SELECT UNI_0.* 
               -- ,CASE WHEN UNI_0.""Shift Per Day Count"" > 1 
               --    THEN SUM(UNI_0.""Shift - Break Seconds"") 
               --       OVER (PARTITION BY LOCATION_DIM_FK,""Employee ID"" ,""Fiscal Day""   --see ""Running Total Each Fiscal Day Seconds""below
               --          ORDER BY ""Shift ID"") 
               --       ELSE UNI_0.""Shift - Break Seconds""   END                        AS ""Shift Seconds""

                      ,UNI_0.""Shift - Break Seconds""                                    AS ""Shift Seconds""    --mod 2024/09/09 yyy

                  ,SUM(UNI_0.""Shift - Break Seconds"") OVER (PARTITION BY LOCATION_DIM_FK,""Employee ID"" ,""Fiscal Day"" 
                        ORDER BY ""Shift ID"")                                                                                                                                                                                            AS ""Running Total Each Fiscal Day Seconds""
                 FROM (
                      SELECT  UNI.""Support ID""                                       AS ""Support ID"" 
                    --status, category, level------------------------------------------------------------------
                    --geography--------------------------------------------------------------------------------
                        ,MAX(UNI.""Location"")                                         AS ""Location""
                        ,MAX(UNI.""Organization"")                                     AS ""Organization""
                    -- --dates-----------------------------------------------------------------------------------
                        ,MAX(UNI.""Time Zone"")                                        AS ""Time Zone""
                        ,MAX(UNI.""Year"")                                             AS ""Year""
                        ,MAX(UNI.""Year and Month"")                                   AS ""Year and Month""
                        ,MAX(UNI.""Clocked In At"")                                    AS ""Clocked In At""
                        ,MAX(UNI.""Clocked Out At"")                                   AS ""Clocked Out At""    
                        ,MAX(UNI.""Day of Week"")                                      AS ""Day of Week""
                        ,MAX(UNI.""Is Weekend"")                                       AS ""Is Weekend""
                        ,MAX(UNI.""Week Offset"")                                      AS ""Week Offset""
                        ,MAX(UNI.""Fiscal Week"")                                      AS ""Fiscal Week""    
                        ,MAX(UNI.""Fiscal Week Start"")                                AS ""Fiscal Week Start""   
                        ,MAX(UNI.""Fiscal Week End"")                                  AS ""Fiscal Week End""   
                        ,MAX(UNI.""Fiscal Day"")                                       AS ""Fiscal Day""    
                    -- --flags--------------------------------------------------------------------------------------
                        ,MAX(UNI.""Is Clocked Out"")                                   AS ""Is Clocked Out""
                        ,MAX(UNI.""Was System Clock Out"")                             AS ""Was System Clock Out""
                        ,MAX(UNI.""Gets Paid Break"")                                  AS ""Gets Paid Break""
                        ,CASE WHEN MAX(UNI.""Overtime Rule"") IS NULL THEN FALSE ELSE TRUE END                     
                                                                                     AS ""Gets Overtime""        
                    -- --people------------------------------------------------------------------------------------- 
                        ,MAX(UNI.""Employee"")                                         AS ""Employee""
                        ,MAX(UNI.""Employee ID"")                                      AS ""Employee ID""
                        ,MAX(UNI.JOBPOSITION_DIM_FK)                                 AS JOBPOSITION_DIM_FK
                        ,MAX(UNI.LOCATION_DIM_FK)                                    AS LOCATION_DIM_FK    
                        ,MAX(UNI.""Payroll ID"")                                       AS ""Payroll ID""
                        ,MAX(UNI.""General Ledger Number"")                            AS ""General Ledger Number""
                    --  --Descriptors-------------------------------------------------------------------------------- 
                        ,MAX(UNI.""Job Position"")                                     AS ""Job Position""  --(i.e. Bartender, Cook, Server)   
                        ,MAX(UNI.""Job Category"")                                     AS ""Job Category""  --(i.e. Bartender, Cook, Server)                        
                        ,MAX(UNI.""Pay Basis"")                                        AS ""Pay Basis""
                        ,MAX(UNI.""Shift ID"")                                         AS ""Shift ID""  
                    -- Facts-----------------------------------------------------------------------------------------
                        ,IFNULL(MAX(UNI.""Overtime Rule""),''None'')                     AS ""Overtime Rule""
                        ,MAX(UNI.""Hours Per Day"")                                    AS ""Hours Per Day""
                        ,MAX(UNI.""Hours Per Week"")                                   AS ""Hours Per Week""
                        ,MAX(UNI.""Shift Count"")                                      AS ""Shift Count""
                        ,MAX(UNI.""Break Count"")                                      AS ""Break Count"" 

                        ,MAX(UNI.""Shift Per Day Count"")                              AS ""Shift Per Day Count""
          
                        ,IFNULL(MAX(UNI.""Break Seconds""),0)                          AS ""Break Seconds""
                        ,MAX(UNI.""Overtime Rate"")                                    AS ""Overtime Rate""
                        ,MAX(UNI.""Regular Rate"")                                     AS ""Regular Rate""
                        ,MAX(UNI.""Seconds Per Week"")                                 AS ""Seconds Per Week""
                        ,MAX(UNI.""Seconds Per Day"")                                  AS ""Seconds Per Day""                    
                        ,MAX(UNI.""Shift Seconds"")                                    AS ""Shift Total Seconds""
                        ,MAX(UNI.""Shift Seconds"") 
                           - IFF(MAX(UNI.""Gets Paid Break""),IFNULL(MAX(UNI.""Break Seconds""),0),0)                                    
                                                                                     AS ""Shift - Break Seconds""
                        FROM (
                            SELECT * FROM SHIFT_CTE 
                              UNION
                            SELECT * FROM BREAK_CTE  
                              UNION
                            SELECT * FROM RULE_CTE
                
                        )                                                   UNI
                        GROUP BY ""Support ID""
                                                                             ) UNI_0
                   
                                                                                )  UNI_1
                                                                                    
                                                                                        )UNI_2

  -- WHERE UNI_2.""Fiscal Day""::date
  --     >= :startdate::date --return only selected dates with ot calculated for a full fiscal week
  --   AND UNI_2.""Fiscal Day""::date
  --     <= :enddate::date 

;

--====================================================================================================================
CREATE TEMP TABLE TEMP_LABOR AS
             SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));  

ALTER TABLE TEMP_LABOR ADD COLUMN ""Net Sales"" SMALLINT DEFAULT 0;
             
--====================================================================================================================             
SELECT 
    TO_CHAR(INLT1.""Support ID"")                                    AS ""Support ID""
    ,''TGR-'' ||row_number() over (order by INLT1.""Support ID"")      AS ""Detail ID""
    ,IFNULL(INLT1.LOCATIONNAME,''None'')                             AS ""Location""
    ,INLT1.LOCATION_DIM_NK                                         AS ""Location ID""
    ,INLT1.TZ_NAME                                                 AS ""Time Zone""
    ,TO_CHAR(DATE_PART(YEAR,INLT1.FISCAL_DATE))                    AS ""Year""
    ,LEFT(TO_CHAR(INLT1.FISCAL_DATE),7)                            AS ""Year and Month""
    ,NULL                                                          AS ""Clocked In At""
    ,NULL                                                          AS ""Clocked Out At""
    ,NULL                                                          AS ""Clock In Time""
    ,NULL                                                          AS ""Clock Out Time""
    ,IFNULL(DAYNAME(INLT1.FISCAL_DATE::DATE),''None'')               AS ""Day of Week""
    ,CASE WHEN DAYNAME(INLT1.FISCAL_DATE::DATE) IN (''Sat'',''Sun'')  
                THEN TRUE ELSE FALSE END                           AS ""Is Weekend"" 
    ,YEAR(TIMESTAMPADD(DAY
        ,CASE WHEN INLT1.START_OF_PAYROLL_WEEK_INT = 0 
            THEN INLT1.START_OF_PAYROLL_WEEK_INT
            ELSE INLT1.START_OF_PAYROLL_WEEK_INT -1
         END
        ,INLT1.FISCAL_DATE::DATE)) || ''-'' ||
     WEEKOFYEAR(TIMESTAMPADD(DAY
         ,CASE WHEN INLT1.START_OF_PAYROLL_WEEK_INT = 0 
            THEN INLT1.START_OF_PAYROLL_WEEK_INT
            ELSE INLT1.START_OF_PAYROLL_WEEK_INT -1
         END
         ,INLT1.FISCAL_DATE::DATE))    
                                                                   AS ""Fiscal Week""
    ,NULL::date                                                    AS ""Fiscal Week Start""      
    ,NULL::date                                                    AS ""Fiscal Week End""    
    ,INLT1.START_OF_PAYROLL_WEEK_INT                               AS ""Week Offset""
    ,INLT1.FISCAL_DATE                                             AS ""Fiscal Day""
    ,NULL                                                          AS ""Is Clocked Out""
    ,NULL                                                          AS ""Was System Clock Out""
    ,INLT1.EMPLOYEE_NAME                                           AS ""Employee""
    ,INLT1.""Employee ID""                                           AS ""Employee ID""
    ,INLT1.""Payroll ID""                                            AS ""Payroll ID""
    ,INLT1.""General Ledger Number""                                 AS ""General Ledger Number"" 
    ,INLT1.""Job Position""                                          AS ""Job Position""
    ,INLT1.""Job Category""                                          AS ""Job Category""
    ,INLT1.""Pay Basis""                                             AS ""Pay Basis""
    ,to_char(INLT1.SHIFT)                                          AS ""Shift ID""
    ,NULL                                                          AS ""Overtime Rule""
    ,NULL::NUMBER(18,2)                                            AS ""Overtime Rate""
    ,NULL::NUMBER(18,2)                                            AS ""Regular Rate""
    ,NULL::NUMBER(18,0)                                            AS ""Shift Seconds""
    ,NULL::NUMBER(18,0)                                            AS ""Break Seconds""
    ,NULL::NUMBER(18,0)                                            AS aily
    ,NULL::NUMBER(18,0)                                            AS ""Daily Overtime Rule Seconds""
    ,NULL::NUMBER(18,0)                                            AS ""Regular Seconds""
    ,NULL::NUMBER(18,0)                                            AS ""Overtime Seconds""
    ,NULL                                                          AS ""Regular D H:M:S""
    ,NULL                                                          AS ""Overtime D H:M:S""
    ,INLT1.TIP::NUMBER(18,2)                                       AS ""Tips""
    ,INLT1.GRATUITIES::NUMBER(18,2)                                AS ""Gratuities""
    ,INLT1.""Net Sales"" ::NUMBER(18,2)                              AS ""Net Sales""    
    -------------------------------------------------------------------------------------------- 
    FROM (
    SELECT  TO_CHAR(MAX(chk.CHEQUE_FACT_NK))                      AS ""Support ID""
           ,CHK.FISCAL_DATE                                       AS FISCAL_DATE
           ,EMD.EMPLOYEE_NAME                                     AS EMPLOYEE_NAME
           ,EMD.EMPLOYEE_DIM_NK                                   AS ""Employee ID""
           ,EMD.PAYROLL_ID                                        AS ""Payroll ID""
           ,SHD.""General Ledger Number""                           AS ""General Ledger Number""
           ,SHD.""Job Position""                                    AS ""Job Position""
           ,SHD.""Job Category""                                    AS ""Job Category""
           ,SHD.""Pay Basis""                                       AS ""Pay Basis""
           
           ,LOC.TZ_NAME                                           AS TZ_NAME
           ,LOC.LOCATIONNAME                                      AS LOCATIONNAME
           ,LOC.LOCATION_DIM_NK                                   AS LOCATION_DIM_NK
           ,''Shift '' || SHD.""Shift ID""                            AS SHIFT
           ,MAX(ORG.START_OF_PAYROLL_WEEK_INT)                    AS START_OF_PAYROLL_WEEK_INT
           ,SUM(CHK.TIP)::NUMBER(18,2)                            AS TIP
           ,SUM(CHK.GRATUITIES)::NUMBER(18,2)                     AS GRATUITIES
           ,SUM(CHK.GROSS - CHK.DISCOUNT) ::NUMBER(18,2)          AS ""Net Sales""           

        FROM DATAWAREHOUSE.CHEQUE_FACT                                chk
             INNER JOIN DATAWAREHOUSE.LOCATION_DIM                    loc
                ON chk.LOCATION_DIM_FK = loc.LOCATION_DIM_NK
                    AND loc.DW_ISCURRENTROW
                    AND chk.STATUS = ''Closed''
                    AND NOT chk.IS_TRAINING
                    AND chk.DW_ISCURRENTROW  
                    AND NOT chk.DW_ISDELETED
                    AND NOT chk.IS_TRAINING
                    AND chk.FISCAL_DATE::date   >= :startdate::date
                    AND chk.FISCAL_DATE::date   <= :enddate::date
                    AND chk.LOCATION_DIM_FK IN ( SELECT table1.value 
                           FROM table(split_to_table(:locationidS, '',''))  table1)
              INNER JOIN DATAWAREHOUSE.ORGANIZATION_DIM                 ORG
                    ON LOC.ORGANIZATION_DIM_FK = ORG.ORGANIZATION_DIM_NK
                      AND ORG.DW_ISCURRENTROW
              INNER JOIN DATAWAREHOUSE.EMPLOYEE_DIM                     emd
                    ON emd.EMPLOYEE_DIM_NK = chk.EMPLOYEE_DIM_FK
                       AND emd.DW_ISCURRENTROW  
              LEFT JOIN SHIFT_CTE                                       shd
                    ON shd.""Shift ID"" = chk.shift_dim_fk
             GROUP BY CHK.FISCAL_DATE
                   ,EMD.EMPLOYEE_NAME
                   ,EMD.EMPLOYEE_DIM_NK
                   ,EMD.PAYROLL_ID
                   ,LOC.TZ_NAME
                   ,LOC.LOCATIONNAME
                   ,LOC.LOCATION_DIM_NK
                   ,SHD.""Shift ID""
                   ,SHD.""General Ledger Number"" 
                   ,SHD.""Job Position"" 
                   ,SHD.""Job Category""
                   ,SHD.""Pay Basis""
    ) INLT1        
;
--====================================================================================================================
CREATE TEMP TABLE TEMP_TIPGRAT AS
             SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID())); 
-- select* from TEMP_TIPGRAT
-- -------------------------------------------------------------------------------------------------------------------
UPDATE TEMP_TIPGRAT
  SET ""Fiscal Week Start"" = dateadd(day,dayofweek(""Fiscal Day"") * -1  + ""Week Offset"" - case when dayofweek(""Fiscal Day"") >= ""Week Offset"" then 0 else 7 end
                            ,""Fiscal Day"") 
    ,""Fiscal Week End""    = dateadd(day,6,
                           dateadd(day,dayofweek(""Fiscal Day"") * -1  + ""Week Offset"" - case 
                             when dayofweek(""Fiscal Day"") >= ""Week Offset"" then 0 else 7 end ,""Fiscal Day""))
;

UPDATE TEMP_TIPGRAT
  SET ""Fiscal Week"" = YEAR(""Fiscal Week Start""::date) || ''-'' ||  RIGHT(''0'' || WEEKOFYEAR(""Fiscal Week Start""::date),2);
  
-- ------------------------------------------------------------------------------------------------------------------- 

ALTER TABLE TEMP_TIPGRAT DROP COLUMN ""Week Offset"";

--====================================================================================================================
reportSet := (    

  SELECT MIN(""Support ID"")                    AS ""Support ID""
        ,MIN(""Detail ID"")                     AS ""Detail ID""
        ,""Location""                           AS ""Location""
        ,""Location ID"" ::DECIMAL(18,0)        AS ""Location ID""        
        ,MAX(""Time Zone"")                     AS ""Time Zone""
        ,MAX(""Year"")                          AS ""Year""
        ,MAX(""Year and Month"")                AS ""Year and Month""
        ,to_char(MAX(""Clocked In At""))        AS ""Clocked In At""
        ,to_char(MAX(""Clocked Out At""))       AS ""Clocked Out At""
        ,to_char(MAX(""Clock In Time""))        AS ""Clock In Time""
        ,to_char(MAX(""Clock Out Time""))       AS ""Clock Out Time""
        ,MAX(""Day of Week"")                   AS ""Day of Week""
        ,MAX(""Is Weekend"")                    AS ""Is Weekend""
        ,MAX(""Fiscal Week"")                   AS ""Fiscal Week""
        ,to_char(""Fiscal Day"")                AS ""Fiscal Day""

        ,MAX(""Is Clocked Out"")                AS ""Is Clocked Out""
        ,MAX(""Was System Clock Out"")          AS ""Was System Clock Out""
        ,""Employee""                           AS ""Employee""
        ,""Employee ID""::NUMBER(18,0)          AS ""Employee ID""
        ,""Payroll ID""                         AS ""Payroll ID""
        ,""General Ledger Number""              AS ""General Ledger Number""
        
        ,MAX(""Job Position"")                  AS ""Job Position""
        ,MAX(""Job Category"")                  AS ""Job Category""        
        ,MAX(""Pay Basis"")                     AS ""Pay Basis""
        -- ,""Shift ID""                           AS ""Shift ID""       
        ,MAX(""Overtime Rule"")                 AS ""Overtime Rule""
        ,MAX(""Overtime Rate"")                 AS ""Overtime Rate""
        ,MAX(""Regular Rate"")                  AS ""Regular Rate""
        ,SUM(""Shift Seconds"")::NUMBER(18,0)   AS ""Shift Seconds""
        ,SUM(""Break Seconds"")::NUMBER(18,0)   AS ""Break Seconds""
        ,MAX(""Weekly Overtime Rule Seconds"")  AS ""Weekly Overtime Rule Seconds""
        ,MAX(""Daily Overtime Rule Seconds"")   AS ""Daily Overtime Rule Seconds"" 
        ,SUM(""Regular Seconds"")::NUMBER(18,0) AS ""Regular Seconds""
        ,SUM(""Overtime Seconds"")::NUMBER(18,0)AS ""Overtime Seconds""
        ,MAX(""Regular D H:M:S"")               AS ""Regular D H:M:S""
        ,MAX(""Overtime D H:M:S"")              AS ""Overtime D H:M:S""
        ,SUM(IFNULL(""Net Sales"",0))::NUMBER(18,2)       AS ""Net Sales""
        ,SUM(IFNULL(""Tips"",0)) ::NUMBER(18,2)           AS ""Tips""
        ,SUM(IFNULL(""Gratuities"",0))::NUMBER(18,2)      AS ""Gratuities"" 
    FROM (
  SELECT * FROM TEMP_LABOR
    UNION ALL
  SELECT * FROM TEMP_TIPGRAT --where  ""Tips"" <> 0.0 or ""Gratuities"" <> 0.00
  )  
 
  WHERE ""Fiscal Day""::date
      >= :startdate::date --return only selected dates with ot calculated for a full fiscal week
    AND ""Fiscal Day""::date
      <= :enddate::date 
  GROUP BY ""Shift ID"",""Location"",""Location ID"",""Employee"",""Employee ID"",""Payroll ID"",""General Ledger Number"",""Fiscal Day"",""Support ID""
  ORDER BY ""Fiscal Day""
); 
----------------------------------------------------------------------------------------------------------------------
RETURN TABLE(reportSet);
--====================================================================================================================
END';"
PROCEDURE,DATAADMIN,"SP_REPORT_TENDER_0001(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_TENDER_0001""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS '
-- ====================================================================================================================
DECLARE 
  reportSet resultset;
  numeric_value number(38,2) := 0;
  -- startdate timestamp_tz := ''2000-11-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2029-11-20T14:48:37.661Z''; 
  -- locationid string      := ''[351,352]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
 
-- -- --==========================================================================================
-- --ISSUE 1:  HOW DO WE DETERMINE IF SOMETHING IS AN NFC PAYMENT???
-- --ISSUE 2:  Location groups look like there may be many groups per location.  That could throw off totals..how to pick one?
-- --ISSUE 3:  What status to use?  Success only?   
-- --QUEST 1:  DO WE FILTER OUT SOME STATUSES?  SHOW SUCCESS ONLY? compare check.payments to check.paid ---see cheque.id = 4320 and example below  ref-> WORKBOOK:  Payment sum to cheque paid
-- --==========================================================================================
BEGIN
 reportSet   := (
 
        SELECT pay.payments_fact_nk                     as ""Support ID"" 
         , ''TEN-'' ||row_number() over (order by pay.payments_fact_nk) 
                                                    AS ""Detail ID""        
--status, category, level-------------------------------------------------------------------
          ,IFNULL(pay.paymentstatus,''None'')             as ""Status""
--geography--------------------------------------------------------------------------------      
          ,IFNULL(loc.locationname,''None'')              as ""Location""
          ,IFNULL(pay.revenuecentername ,''None'')        as ""Revenue Center""
 --dates-------------------------------------------------------------------------------------
           ,LOC.TZ_NAME                                 as ""Time Zone"" 
          ,to_char(LEFT(
          CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,pay.OPENED_AT::timestamp_ntz )
          ,4))                                          as ""Year""
          ,to_char(LEFT(
          CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,pay.OPENED_AT::timestamp_ntz )
          ,7))                                          as ""Year and Month""
          ,IFNULL(dpd.DAYPART,''None'')                   as ""Daypart""
          ,CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,pay.OPENED_AT::timestamp_ntz )                               
                                                        as ""Paid At""
          ,IFNULL(DAYNAME(
          CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,pay.OPENED_AT::timestamp_ntz )
          ),''None'')                                     as ""Day of Week""
          ,CASE WHEN DAYNAME(
          CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,pay.OPENED_AT::timestamp_ntz )
          ) IN (''Sat'',''Sun'')  
           THEN TRUE ELSE FALSE END                     as ""Is Weekend""
--people-------------------------------------------------------------------------------------
          ,IFNULL(emd.EMPLOYEE_NAME,''None'')             as ""Employee""
--Descriptors--------------------------------------------------------------------------------        
          ,IFNULL(ptd.paymentmethodname ,''None'')        as ""Payment Method""
          ,IFNULL(pay.cardholderName,''None'')            as ""Cardholder Name""
          ,IFNULL(pay.LASTFOURCCNUMBER,''None'')          as ""Card Last 4 Digits""
          ,IFNULL(case pay.cardbrand when '''' 
             THEN ''Not a Credit Card'' 
            else pay.cardbrand end,''None'')  
                                                        as ""Card Brand"" 
         ,pay.LOCATION_DIM_FK                           as ""Location ID""
 --Facts--------------------------------------------------------------------------------------  
         ,1::NUMBER(18,0)                               as ""Count""
          ,case ptd.paymentmethodtype when ''Cash''  
              then pay.total end::DECIMAL(18,2)         as ""Cash Sales"" 
          ,case ptd.paymentmethodtype when ''EPX''   
              then pay.total end::DECIMAL(18,2)         as ""Credit Card Sales""   --Gross of credit card trans
          ,case ptd.paymentmethodtype when ''Other'' 
              then pay.total end::DECIMAL(18,2)         as ""Other Sales""         --Gross of other trans
          ,case pay.cardbrand when ''Visa'' 
               then pay.total end::DECIMAL(18,2)        as ""Visa Sales""           --Gross sales of a
          ,case pay.cardbrand when ''Amex'' 
               then pay.total end::DECIMAL(18,2)        as ""Amex Sales""           --Gross sales of alIl Amex transactions
          ,case pay.cardbrand when ''Mastercard'' 
              then pay.total end::DECIMAL(18,2)         as ""Mastercard Sales""     --Gross sales of all Mastercard transactions
          ,case pay.cardbrand when ''Discover'' 
            then pay.total end::DECIMAL(18,2)           as ""Discover Sales""       --Gross sales of all Discover transactions
          -- -----------------
          ,IFF(cct.ISCARDPRESENT,pay.Total 
            ,0.00 )::DECIMAL(18,2)                      as ""Card Present Sales""   
          --Gross sales of all transactions where the processor identified the card as present (swiped, dipped, tapped)
          ,IFF(NOT cct.ISCARDPRESENT,pay.Total 
            ,0.00 )::DECIMAL(18,2)                      as ""Card Not Present Sales"" --Total Card Not Present Sales
          -- -----------------
          -- ,0.00::DECIMAL(18,2)                       as ""NFC Sales""           
                                                        --Gross of tran where the processor identified the card  NO FIELD IN PRODUCTIO
          --                                                     --from an NFC devi.00ce (Apple Pay, Google Pay, Samsung Pay, etc.) or NFC card 
          ,pay.Refunds::DECIMAL(18,2)                    as ""Refunds""  
          ,pay.Total::DECIMAL(18,2)                      as ""Amount""  

        
        FROM DATAADMIN.payments_FACT                                pay
          INNER JOIN DATAADMIN.location_DIM                         loc
            ON pay.location_DIM_FK = loc.location_DIM_PK
              AND CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,pay.opened_at::timestamp_ntz ) > CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,:startdate::timestamp_ntz )
              AND CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,pay.opened_at::timestamp_ntz ) < CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,:enddate::timestamp_ntz )
              AND pay.LOCATION_DIM_FK in (
                SELECT table1.value 
                   FROM table(split_to_table(:locationidS, '',''))  table1) 
              AND pay.dw_iscurrentrow
              AND loc.dw_iscurrentrow
              AND NOT pay.IS_TRAINING
              AND NOT pay.dw_isdeleted
              AND pay.PAYMENTSTATUS = ''Success''
          INNER JOIN DATAADMIN.PaymentMethod_DIM                     ptd      
            ON pay.PaymentMethod_DIM_FK = ptd.PaymentMethod_DIM_PK
              AND ptd.dw_iscurrentrow
              AND NOT ptd.dw_isdeleted
          INNER JOIN DATAADMIN.organization_dim                      org
            ON loc.organization_DIM_FK = org.organization_DIM_NK
              AND org.dw_iscurrentrow
              AND NOT org.dw_isdeleted
          INNER JOIN DATAADMIN.daypart_dim                           dpd
            ON pay.daypart_dim_fk = dpd.daypart_dim_nk
              AND dpd.dw_iscurrentrow
              AND NOT dpd.dw_isdeleted
          INNER JOIN DATAADMIN.employee_DIM                          emd
            ON emd.employee_DIM_PK = pay.EMPLOYEE_DIM_FK_AS_PAYEE
              AND emd.dw_iscurrentrow 
              AND NOT emd.dw_isdeleted
          LEFT JOIN DATAADMIN.CCTransaction_FACT                    cct   --only need to get is present and nfc
            ON cct.cheque_fact_fk = pay.cheque_fact_fk                    --question:  can this data be put on 
              AND cct.dw_iscurrentrow                                     --payments so we don''t need to join thi                           
              AND cct.TRANSACTION_NUMBER = 1                              --huge table?
    ORDER BY loc.locationname
--============================================================================
); 
 RETURN TABLE(reportSet); 
END;
-- ';"
PROCEDURE,DATAADMIN,"SP_REPORT_VOID(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_VOID""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS '
-- ====================================================================================================================
--Example Call Statement
--CALL DATAADMIN.SP_REPORT_VOID(''2000-01-20T14:48:37.661Z'',''2023-11-20T14:48:37.661Z'',''[351,352]'');
-- ====================================================================================================================
DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2000-11-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2029-11-20T14:48:37.661Z''; 
  -- locationid string      := ''[351,352]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--======================================================================================================
--ISSUE 1:  Activity price is void for item only...For a check void, is the void amount the net amount, gross amount???
--ISSUE 4:  How to Cast to local time?
--QUESTION 2:  If time passed between order/open and void...do we want to highlight that?  top 10 log discrepency?
--QUESTION 1:  Can we put the reason id onto the activity?  This would mean 3 fewer joins
-- --==========================================================================================
BEGIN
 reportSet   := (
        SELECT act.activity_fact_nk                AS ""Support ID"" 
        --status, category, level----------------------------------------------------------------------
        ,CASE act.TYPE 
          WHEN ''ItemVoided'' 
            THEN ''Item'' 
          WHEN ''Voided'' 
            THEN ''Check''
            ELSE ''None'' 
          END 
                                                 AS ""Level""          --Values of Check or Item.
        --geography------------------------------------------------------------------------------------
        ,IFNULL(LOC.LOCATIONNAME ,''None'')        AS ""Location""
        ,IFNULL(CHK.revenueCenterName ,''None'')   AS ""Revenue Center""
        --dates----------------------------------------------------------------------------------------     
        ,to_char(LEFT(
        CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,act.PERFORMED_AT::timestamp_ntz )
        ,4))       AS ""Year""
        ,to_char(LEFT(
        CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,act.PERFORMED_AT::timestamp_ntz )
        ,7))       AS ""Year and Month""
        ,IFNULL(dad.DAYPART,''None'')              AS ""Daypart""
        ,CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,chk.FISCAL_DATE::timestamp_ntz )       AS ""Fiscal Date""
        ,CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,chk.OPENED_AT::timestamp_ntz )         AS ""Check Opened At""     
        ,CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,chk.CREATED_AT::timestamp_ntz )        AS ""Item Ordered At""    
        ,CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,act.PERFORMED_AT::timestamp_ntz )      AS ""Voided At""          
       ,dad.DAYPART                                                                AS ""Day Part""              
        ,IFNULL(DAYNAME(
        CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,act.PERFORMED_AT::timestamp_ntz )
        ),''None'')                               AS""Day of Week""
        ,CASE WHEN DAYNAME(
        CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,act.PERFORMED_AT::timestamp_ntz )
        ) IN (''Sat'',''Sun'')  
        THEN TRUE ELSE FALSE END                 AS ""Is Weekend""
        
        ,TIMESTAMPDIFF(second ,chk.OPENED_AT,act.PERFORMED_AT) 
                                                 AS ""Seconds to Void""
        ,TIMESTAMPDIFF(second ,chk.OPENED_AT,act.PERFORMED_AT) 
                                                 AS ""Minutes to Void""                                                 
        --Flags-------------------------------------------------------------------------------------
        --People------------------------------------------------------------------------------------
        ,IFNULL(amd_asperf.EMPLOYEE_NAME,''None'') AS ""Voider""
        ,IFNULL(amd_asapp.EMPLOYEE_NAME,''None'')  AS ""Approver""   
        --Descriptors---------------------------------------------------------------------------------
        ,chk.CHEQUENUMBER                        AS ""Check""
        ,IFNULL(COALESCE(vdr_item.VOIDREASON,
         vdr_check.VOIDREASON),''None'')           AS ""Reason""
        
          
        ,IFNULL(act.MENUITEMNAME,''None'')         AS ""Item""
        --Facts---------------------------------------------------------------------------------------
        ,1::NUMBER(18,0)                         AS ""Count""                 
        ,CASE WHEN act.TYPE = ''ItemVoided'' 
            THEN act.PRICE 
          ELSE chk.TOTAL END::NUMBER(18,2)
                                                 AS ""Amount""           
        FROM DATAADMIN.ACTIVITY_FACT                                  act
           INNER JOIN  DATAADMIN.LOCATION_DIM                         loc
              ON act.LOCATION_DIM_FK = loc.LOCATION_DIM_NK
                AND CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,act.PERFORMED_AT::timestamp_ntz ) 
                    > CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,:startdate::timestamp_ntz ) 
                AND CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,act.PERFORMED_AT::timestamp_ntz ) 
                    < CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,:enddate::timestamp_ntz ) 
                AND act.LOCATION_DIM_fK IN (
                    SELECT table1.value 
                      FROM table(split_to_table(:locationidS, '',''))  table1)
                AND loc.DW_ISCURRENTROW 
                AND NOT loc.DW_ISDELETED
            INNER JOIN DATAADMIN.CHEQUE_FACT                          chk
              ON act.CHEQUE_FACT_FK = chk.CHEQUE_FACT_NK
                AND act.IS_VOID
                AND act.DW_ISCURRENTROW 
                AND NOT act.DW_ISDELETED
                AND chK.DW_ISCURRENTROW 
                AND NOT chk.DW_ISDELETED
                AND NOT chk.IS_TRAINING
            INNER JOIN DATAADMIN.DAYPART_DIM                           dad
              ON chk.DAYPART_DIM_FK = dad.daypart_dim_pk
                AND dad.DW_ISCURRENTROW 
                AND NOT dad.DW_ISDELETED
           
            LEFT JOIN EMPLOYEE_DIM                                    amd_asperf
              ON act.EMPLOYEE_DIM_FK_AS_PERFORMING_EMPLOYEE 
                  = amd_asperf.EMPLOYEE_DIM_NK
                AND amd_asperf.DW_ISCURRENTROW 
                AND NOT amd_asperf.DW_ISDELETED 
            LEFT JOIN EMPLOYEE_DIM                                    amd_asapp
              ON act.EMPLOYEE_DIM_FK_AS_APPROVING_EMPLOYEE 
                  = amd_asapp.EMPLOYEE_DIM_NK
                AND amd_asapp.DW_ISCURRENTROW 
                AND NOT amd_asapp.DW_ISDELETED   
            LEFT JOIN DATAADMIN.VoidReason_DIM                        vdr_check
             ON vdr_check.VOIDREASON_DIM_NK = CHK.VoidReason_DIM_FK
               AND vdr_check.DW_ISCURRENTROW 
               AND NOT vdr_check.DW_ISDELETED
            LEFT JOIN DATAADMIN.ITEM_FACT                             itf
             ON itf.Item_fact_NK = act.Item_fact_fk
               AND itf.DW_ISCURRENTROW 
               AND NOT itf.DW_ISDELETED        
            LEFT JOIN DATAADMIN.VoidReason_DIM                        vdr_item
             ON vdr_item.VOIDREASON_DIM_NK = itf.VoidReason_DIM_FK
               AND vdr_item.DW_ISCURRENTROW 
               AND NOT vdr_item.DW_ISDELETED     
--==========================================================================================
); 
 RETURN TABLE(reportSet); 
END;
';"
PROCEDURE,DATAADMIN,SP_STAGELOADDRAWER_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADDRAWER_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.DRAWER_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.DRAWER_DIM(   
          DRAWER_DIM_NK, 
          DRAWER, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          EMPLOYEE_DIM_FK, 
          LOCATION_DIM_FK, 
          TERMINAL_DIM_FK, 
          CREATED_AT, 
          UPDATED_AT 
) 
 SELECT   DRAWER_DIM_NK  as   DRAWER_DIM_NK,  
   DRAWER  as   DRAWER,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   EMPLOYEE_DIM_FK  as   EMPLOYEE_DIM_FK,  
   LOCATION_DIM_FK  as   LOCATION_DIM_FK,  
   TERMINAL_DIM_FK  as   TERMINAL_DIM_FK,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT 
  FROM DATAADMIN.DRAWER_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''DRAWER_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''DRAWER_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADINTEGRATIONTYPE_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADINTEGRATIONTYPE_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.INTEGRATIONTYPE_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.INTEGRATIONTYPE_DIM(   
          INTEGRATIONTYPE_DIM_NK, 
          INTEGRATIONTYPE, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          CREATED_AT, 
          UPDATED_AT 
) 
 SELECT   INTEGRATIONTYPE_DIM_NK  as   INTEGRATIONTYPE_DIM_NK,  
   INTEGRATIONTYPE  as   INTEGRATIONTYPE,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT 
  FROM DATAADMIN.INTEGRATIONTYPE_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''INTEGRATIONTYPE_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''INTEGRATIONTYPE_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADMERCHANT_ORGANIZATION_XREF(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADMERCHANT_ORGANIZATION_XREF""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.MERCHANT_ORGANIZATION_XREF),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.MERCHANT_ORGANIZATION_XREF(   
          MERCHANT_ORGANIZATION_XREF_NK, 
          MERCHANT_ORGANIZATION, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          MERCHANT_DIM_FK, 
          ORGANIZATION_DIM_FK, 
          CREATED_AT, 
          UPDATED_AT 
) 
 SELECT   MERCHANT_ORGANIZATION_XREF_NK  as   MERCHANT_ORGANIZATION_XREF_NK,  
   MERCHANT_ORGANIZATION  as   MERCHANT_ORGANIZATION,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   MERCHANT_DIM_FK  as   MERCHANT_DIM_FK,  
   ORGANIZATION_DIM_FK  as   ORGANIZATION_DIM_FK,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT 
  FROM DATAADMIN.MERCHANT_ORGANIZATION_XREF
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''MERCHANT_ORGANIZATION_XREF'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''MERCHANT_ORGANIZATION_XREF'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADSHIFT_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADSHIFT_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.SHIFT_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.SHIFT_DIM(   
          SHIFT_DIM_NK, 
          SHIFT, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          EMPLOYEE_DIM_FK, 
          LOCATION_DIM_FK, 
          JOBPOSITION_DIM_FK, 
          WAS_SYSTEM_CLOCKOUT, 
          IS_ARCHIVED, 
          IS_SHIFTCOMPLETE, 
          PAY_RATE_BASIS, 
          GETS_PAID_BREAK, 
          CREATED_AT, 
          UPDATED_AT, 
          ORIGINAL_CLOCKIN_AT, 
          FISCAL_DAY, 
          CLOCKEDIN_AT, 
          CLOCKEDOUT_AT, 
          ARCHIVED_AT, 
          SHIFT_START_AT, 
          SHIFT_END_AT, 
          GENERAL_LEDGER, 
          REGULAR_RATE, 
          SHIFT_SECONDS, 
          SHIFT_MINUTES, 
          SHIFT_HOURS, 
          SHIFT_DAYS 
) 
 SELECT   SHIFT_DIM_NK  as   SHIFT_DIM_NK,  
   SHIFT  as   SHIFT,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   EMPLOYEE_DIM_FK  as   EMPLOYEE_DIM_FK,  
   LOCATION_DIM_FK  as   LOCATION_DIM_FK,  
   JOBPOSITION_DIM_FK  as   JOBPOSITION_DIM_FK,  
   WAS_SYSTEM_CLOCKOUT  as   WAS_SYSTEM_CLOCKOUT,  
   IS_ARCHIVED  as   IS_ARCHIVED,  
   IS_SHIFTCOMPLETE  as   IS_SHIFTCOMPLETE,  
   PAY_RATE_BASIS  as   PAY_RATE_BASIS,  
   GETS_PAID_BREAK  as   GETS_PAID_BREAK,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   ORIGINAL_CLOCKIN_AT  as   ORIGINAL_CLOCKIN_AT,  
   FISCAL_DAY  as   FISCAL_DAY,  
   CLOCKEDIN_AT  as   CLOCKEDIN_AT,  
   CLOCKEDOUT_AT  as   CLOCKEDOUT_AT,  
   ARCHIVED_AT  as   ARCHIVED_AT,  
   SHIFT_START_AT  as   SHIFT_START_AT,  
   SHIFT_END_AT  as   SHIFT_END_AT,  
   GENERAL_LEDGER  as   GENERAL_LEDGER,  
   REGULAR_RATE  as   REGULAR_RATE,  
   SHIFT_SECONDS  as   SHIFT_SECONDS,  
   SHIFT_MINUTES  as   SHIFT_MINUTES,  
   SHIFT_HOURS  as   SHIFT_HOURS,  
   SHIFT_DAYS  as   SHIFT_DAYS 
  FROM DATAADMIN.SHIFT_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''SHIFT_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''SHIFT_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADDAYPARTSCHEDULE_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADDAYPARTSCHEDULE_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.DAYPARTSCHEDULE_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.DAYPARTSCHEDULE_DIM(   
          DAYPARTSCHEDULE_DIM_NK, 
          DAYPARTSCHEDULE, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          DAYPART_DIM_FK, 
          LOCATION_DIM_FK, 
          CREATED_AT, 
          UPDATED_AT, 
          TXID, 
          DAY_OF_WEEK, 
          START_TIME, 
          SYS_PERIOD 
) 
 SELECT   DAYPARTSCHEDULE_DIM_NK  as   DAYPARTSCHEDULE_DIM_NK,  
   DAYPARTSCHEDULE  as   DAYPARTSCHEDULE,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   DAYPART_DIM_FK  as   DAYPART_DIM_FK,  
   LOCATION_DIM_FK  as   LOCATION_DIM_FK,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   TXID  as   TXID,  
   DAY_OF_WEEK  as   DAY_OF_WEEK,  
   START_TIME  as   START_TIME,  
   SYS_PERIOD  as   SYS_PERIOD 
  FROM DATAADMIN.DAYPARTSCHEDULE_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''DAYPARTSCHEDULE_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''DAYPARTSCHEDULE_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,"GET_ENTIRE_ROW_DUPLICATES(VARCHAR, VARCHAR, ARRAY, BOOLEAN)","CREATE OR REPLACE PROCEDURE ""GET_ENTIRE_ROW_DUPLICATES""(""DB_NAME"" VARCHAR, ""SCHEMA_NAME"" VARCHAR, ""TARGET_TABLES"" ARRAY, ""EVALUATE_PK"" BOOLEAN)
RETURNS TABLE (""DATABASE_NAME"" VARCHAR, ""SCHEMA_NAME"" VARCHAR, ""TABLE_NAME"" VARCHAR, ""DUP_COUNT"" NUMBER(38,0), ""MTLN_CDC_LOAD_TIMESTAMP"" TIMESTAMP_LTZ(9), ""ROW_DATA"" VARIANT)
LANGUAGE SQL
EXECUTE AS OWNER
AS '
DECLARE
    object_list CURSOR FOR SELECT ""name"" FROM temp_object_list;
    table_name VARCHAR;
    column_list VARCHAR;
    dynamic_sql VARCHAR;
    info_schema_path VARCHAR;
    schema_identifier VARCHAR;
    evaluate_pk_effective BOOLEAN;
    final_results RESULTSET;

BEGIN
    CREATE OR REPLACE TEMPORARY TABLE temp_object_list (""name"" VARCHAR);
    
    --  Added DUP_COUNT to the temp table definition
    CREATE OR REPLACE TEMPORARY TABLE temp_duplicate_results (
        DATABASE_NAME VARCHAR,
        SCHEMA_NAME VARCHAR,
        TABLE_NAME VARCHAR,
        DUP_COUNT INTEGER,
        MTLN_CDC_LOAD_TIMESTAMP TIMESTAMP_LTZ,
        ROW_DATA VARIANT
    );

    evaluate_pk_effective := COALESCE(:EVALUATE_PK, TRUE);
    schema_identifier := :DB_NAME || ''.'' || :SCHEMA_NAME;

    SHOW TABLES IN SCHEMA IDENTIFIER(:schema_identifier);
    INSERT INTO temp_object_list (""name"")
    SELECT ""name"" FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

    SHOW VIEWS IN SCHEMA IDENTIFIER(:schema_identifier);
    INSERT INTO temp_object_list (""name"")
    SELECT ""name"" FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

    FOR rec IN object_list DO
        table_name := rec.""name"";

        IF (TARGET_TABLES IS NULL OR ARRAY_SIZE(TARGET_TABLES) = 0 OR ARRAY_CONTAINS(:table_name::VARIANT, TARGET_TABLES)) THEN

            info_schema_path := :DB_NAME || ''.INFORMATION_SCHEMA.COLUMNS'';

            SELECT
                LISTAGG(IFF(REGEXP_LIKE(column_name, ''^[a-zA-Z0-9_]+$''), column_name, ''""'' || column_name || ''""''), '', '')
            INTO column_list
            FROM IDENTIFIER(:info_schema_path)
            WHERE
                table_schema = :SCHEMA_NAME
                AND table_name = :table_name
                AND (:evaluate_pk_effective = TRUE OR NOT ENDSWITH(UPPER(column_name), ''_PK''));

            IF (column_list IS NOT NULL AND column_list != '''') THEN
                --  Modified to use QUALIFY to select one instance and get the count
                dynamic_sql := ''
                    INSERT INTO temp_duplicate_results (DATABASE_NAME, SCHEMA_NAME, TABLE_NAME, DUP_COUNT, MTLN_CDC_LOAD_TIMESTAMP, ROW_DATA)
                    SELECT
                        '''''' || DB_NAME || '''''',
                        '''''' || SCHEMA_NAME || '''''',
                        '''''' || table_name || '''''',
                        COUNT(*) OVER (PARTITION BY '' || column_list || ''),
                        MTLN_CDC_LOAD_TIMESTAMP,
                        OBJECT_CONSTRUCT(*)
                    FROM '' || DB_NAME || ''.'' || SCHEMA_NAME || ''.""'' || table_name || ''""
                    QUALIFY COUNT(*) OVER (PARTITION BY '' || column_list || '') > 1
                        AND ROW_NUMBER() OVER (PARTITION BY '' || column_list || '' ORDER BY MTLN_CDC_LOAD_TIMESTAMP DESC) = 1;
                '';

                EXECUTE IMMEDIATE dynamic_sql;
            END IF;
        END IF;
    END FOR;

    --  Updated final select to include DUP_COUNT
    final_results := (
        SELECT DATABASE_NAME, SCHEMA_NAME, TABLE_NAME, DUP_COUNT, MTLN_CDC_LOAD_TIMESTAMP, ROW_DATA
        FROM temp_duplicate_results
        ORDER BY MTLN_CDC_LOAD_TIMESTAMP DESC
    );

    RETURN TABLE(final_results);

END;
';"
PROCEDURE,DATAADMIN,"SP_CHECKFORNK(VARCHAR, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_CHECKFORNK""(""REPORTTYPE"" VARCHAR(1), ""TABLENAME"" VARCHAR(50))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
        -- TABLENAME VARCHAR       := ''ADDRESS_DIM'';
        -- --TABLENAME VARCHAR       := ''ORDER_SUMMARY'';        
        -- REPORTTYPE VARCHAR(1)   := ''L'';  --valid values {L,P,S}

        NK_COLUMN VARCHAR       := :TABLENAME || ''_NK'';
        SCHEMANAME VARCHAR(075) := CASE UPPER(REPORTTYPE) 
                                        WHEN ''L'' THEN ''DATAADMIN'' 
                                        WHEN ''P'' THEN ''DATAWAREHOUSE''
                                        WHEN ''S'' THEN ''DATAWAREHOUSE_TEMP''
                                        ELSE ''WRONG'' END;
        HAS_RESULTS int;
        NK_RESULTS resultset    ;
        NK_NORESULTS resultset    ;

BEGIN
   DROP TABLE IF EXISTS dwtable_lists;  

    SELECT c.table_name                 as TABLE_NAME
        ,c.column_name                  as NATURAL_KEY
        ,TRUE                           as HAS_PK
        ,''This table has a primary key'' as MESSAGE
    FROM information_schema.columns c
         WHERE c.table_name   = c.table_name
            AND c.table_schema = :SCHEMANAME
            AND c.table_name   = :TABLENAME
            AND c.column_name  = :NK_COLUMN
        ;
        
   CREATE TABLE dwtable_lists AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

    NK_RESULTS   := (select * from dwtable_lists);
    NK_NORESULTS := (
      SELECT :TABLENAME                  as TABLE_NAME
        ,:NK_COLUMN                      as NATURAL_KEY
        ,FALSE                           as HAS_PK
        ,''This table has NO primary key'' as MESSAGE);
    HAS_RESULTS:=(SELECT COUNT(*) FROM dwtable_lists);

IF (:HAS_RESULTS > 0)  --Has primary key
    THEN
      RETURN TABLE(NK_RESULTS); 
    ELSE
      RETURN TABLE(NK_NORESULTS);
  END IF;
                    
END';"
PROCEDURE,DATAADMIN,SP_CREATEDWTABLELOAD(VARCHAR),"CREATE OR REPLACE PROCEDURE ""SP_CREATEDWTABLELOAD""(""TABLENAME"" VARCHAR(500))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
        -- DBNAME VARCHAR(45)    := ''DEV_HOSPENG_REPORTING'';--''CHEQUE_FACT'';--
        -- SCHEMANAME VARCHAR(45):= ''DATASTAGE'';--''CHEQUE_FACT'';--
        -- TABLENAME VARCHAR(50) := ''CHEQUE_FACT'';

        IsTableName            VARCHAR(50);
        col_list               RESULTSET;
        res                    RESULTSET;
        select_statement       VARCHAR;
        all_sqltext            VARCHAR;
        ErrorMessage resultset:= (SELECT ''Invalid Table or View Name'' AS ""Error Message"");
        db_name varchar       := UPPER(DBNAME);
        schema_name varchar   := UPPER(SCHEMANAME);
        table_name varchar    := UPPER(TABLENAME);
        sqlText1    varchar   := (SELECT LISTAGG( REPLACE(REPLACE(DST.SQLTEXTVALUE || ''\\n'',''<TABLENAME>''
                                  ,:table_name),''<DBNAME>'',:db_name))WITHIN GROUP (ORDER BY DST.SQLTEXTORDINAL)
                                  FROM DW_SQLText DST
                                    WHERE DST.SQLTEXTGROUP = ''SP_CREATEDATAWAREHOUSETABLELOAD''
                                      AND DST.SQLTEXTNAME = ''SQLTEXT1''
                                      AND DST.ISCURRENTVERSION
                                      AND NOT DST.ISDELETED
                                  ORDER BY DST.SQLTEXTORDINAL);
                                  

        sqlTextB    varchar  := (SELECT LISTAGG(REPLACE(REPLACE(DST.SQLTEXTVALUE || ''\\n'',''<TABLENAME>''
                                  ,:table_name),''<DBNAME>'',:db_name)) WITHIN GROUP (ORDER BY DST.SQLTEXTORDINAL)
                                  FROM DW_SQLText DST
                                    WHERE DST.SQLTEXTGROUP = ''SP_CREATEDATAWAREHOUSETABLELOAD''
                                      AND DST.SQLTEXTNAME = ''SQLTEXTB''
                                      AND DST.ISCURRENTVERSION
                                      AND NOT DST.ISDELETED
                                  ORDER BY DST.SQLTEXTORDINAL);


        
-----------------------------------------------------------------------------------------
begin
  drop table if exists all_cols_temp; 
  drop table if exists all_sql_temp;
  
  create temp table all_sql_temp (
    ordinal int
    ,sqlText varchar
  );

------------------------------------------------------------------------------------
  create temp table all_cols_temp as
      select  ''  ''
              || c.column_name 
              || case when c.ordinal_position = max(ordinal_position) over (partition by 1)
                     then '' ''
                   else '', ''
                   end as column_name
              ,c.ordinal_position
              ,min(c.ordinal_position) over(partition by 1) as minOrdinal
              ,max(c.ordinal_position) over(partition by 1) as maxOrdinal
      from information_schema.tables t
         inner join information_schema.columns c
            on t.table_schema      = c.table_schema
                and t.table_name   = c.table_name
                and t.table_type   = ''BASE TABLE''
                and t.table_schema = ''DATAWAREHOUSE''
                and t.table_name   = :table_name
                and c.column_name not in (''DW_UPDATETIME'',''DW_INSERTDATETIME'')  
                and NOT c.column_name ilike(''%_PK'')
                
            order by c.ordinal_position;
            
------------------------------------------------------------------------------------
--If the table is not found in the catalouge - retern an error message
IsTableName := (CASE WHEN (SELECT count(*)  FROM all_cols_temp t) = 0 THEN FALSE ELSE TRUE END) ;  
            
-----------------------------------------------------------------------------------------           
  insert into all_sql_temp (ordinal,sqlText)
     select  1 as ordinal
       ,:sqlText1 || listagg(''        '' || column_name || ''\\n'') within group (order by ordinal_position) 
         || '')'' as sqlText
        from all_cols_temp;

------------------------------------------------------------------------------------
col_list := (
  SELECT LISTAGG(sqlText) WITHIN GROUP (ORDER BY inlt1.ORDINAL)
    FROM (
      SELECT sqlText || '' \\n '' as sqlText, 1 AS ORDINAL 
      FROM all_sql_temp   
        UNION
      SELECT LISTAGG(case when ordinal_position = minordinal 
         then ''SELECT ''
         else '' '' 
         end
        || replace(column_name,'','') 
        || '' as '' 
        || case when ordinal_position = maxordinal 
             then replace(column_name,'','') || :sqlTextB
            else column_name
            end  || '' \\n'') WITHIN GROUP (ORDER BY ordinal_position) 
        as output_text
      , 2 AS ORDINAL 
      from all_cols_temp 
    ) inlt1
);
  
--======================================================================================  
 IF (:IsTableName IS NULL)  --ONLY RETURN RESULTS IF INPUT IS VALID TABLE NAME
    THEN
      RETURN TABLE(ErrorMessage);
    ELSE
      RETURN TABLE(col_list);
  END IF;

END';"
PROCEDURE,DATAADMIN,SP_DQ_TAX_ARRAY_ISSUE(),"CREATE OR REPLACE PROCEDURE ""SP_DQ_TAX_ARRAY_ISSUE""()
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS OWNER
AS '
DECLARE
    -- Runtime metadata
    run_metadata VARIANT;
    parent_query_id VARCHAR;
    task_run_group_id VARCHAR;
    attempt_number NUMBER;
    session_id VARCHAR;
    task_name VARCHAR;

    -- Procedure specific variables
    yesterday_date DATE;
    validation_query_id VARCHAR;
    row_count NUMBER;
    error_message VARCHAR;

BEGIN
    -- Get runtime metadata for logging and traceability
    CALL dataadmin.sp_get_dag_run_metadata(COALESCE(last_query_id(), ''NOT_FOUND'')) INTO :run_metadata;
    parent_query_id := :run_metadata:parent_query_id::VARCHAR;
    task_run_group_id := :run_metadata:graph_run_group_id::VARCHAR;
    attempt_number := :run_metadata:run_attempt_number::NUMBER;
    session_id := :run_metadata:session_id::VARCHAR;
    task_name := COALESCE(:run_metadata:task_name::VARCHAR, ''sp_dq_tax_array_issue'');

    -- Set the target date for the validation
    yesterday_date := DATEADD(day, -1, CURRENT_DATE());

    -- run validation and store it in a temp table
    WITH main_query AS (
        SELECT
            CHK.LOCATION_DIM_FK AS LOCATION_DIM_FK,
            CHK.FISCAL_DATE AS FISCAL_DATE,
            POS.ID AS cheque_id,
            TRY_PARSE_JSON(POS.BALANCE):tax::DECIMAL(10, 2) AS balance_tax,
            COALESCE(SUM(CASE 
                             WHEN ITM.value:status::STRING IN (''Added'', ''Sent'') 
                             THEN TAX.value:tax::DECIMAL(10, 2) 
                             ELSE 0 
                         END), 0) AS calculated_items_tax_total,
            abs(balance_tax - calculated_items_tax_total) AS delta
        FROM
            DATALANDING.POSAPI_PUBLIC_CHEQUE POS
            -- (select * FROM DATALANDING.POSAPI_PUBLIC_CHEQUE  WHERE ITEMS <> ''__value_not_modified__'') POS --to exclude non toast column issue
        INNER JOIN
            (
                SELECT CHEQUE_FACT_NK, MTLN_CDC_SEQUENCE_NUMBER, FISCAL_DATE, LOCATION_DIM_FK
                FROM DATAWAREHOUSE.CHEQUE_FACT
                WHERE DW_ISCURRENTROW
                AND FISCAL_DATE = :yesterday_date -- Parameterized date
                AND STATUS IN(''Closed'')
            ) CHK ON POS.ID = CHK.CHEQUE_FACT_NK AND POS.MTLN_CDC_SEQUENCE_NUMBER = CHK.MTLN_CDC_SEQUENCE_NUMBER
        , LATERAL FLATTEN(INPUT => TRY_PARSE_JSON(POS.ITEMS), OUTER => TRUE) ITM
        , LATERAL FLATTEN(INPUT => ITM.value:taxes, OUTER => TRUE) TAX
        GROUP BY 1,2,3,4
    )
    SELECT 
        LOCATION_DIM_FK,
        FISCAL_DATE,
        delta
    FROM main_query
    WHERE delta > 0;

    validation_query_id := last_query_id();

     CREATE OR REPLACE TEMP TABLE dq_tax_array_issue_results AS
     SELECT * FROM TABLE(RESULT_SCAN(:validation_query_id)); 

    SELECT COUNT(*) INTO :row_count FROM dq_tax_array_issue_results;

    IF (row_count > 0) THEN
        -- If there are deltas, construct the summary error message
        -- We first need to aggregate the deltas per location, and then list-aggregate the results.
        SELECT ''For '' || :yesterday_date || '' the following locations have deltas: '' ||
               LISTAGG(location_summary, '' ; '') WITHIN GROUP (ORDER BY LOCATION_DIM_FK)
        INTO :error_message
        FROM (
            SELECT 
                LOCATION_DIM_FK,
                LOCATION_DIM_FK || '': '' || SUM(delta) AS location_summary
            FROM dq_tax_array_issue_results
            GROUP BY LOCATION_DIM_FK
        );

        -- Log the single, summarized error message
        INSERT INTO DATAADMIN.error_logs (
            parent_query_id, task_run_group_id, attempt_number, session_id, task_name,
            failed_query_id, error_type_id, severity, sql_error_code, sql_error_message, sql_state, details
        )
        SELECT
            :parent_query_id, :task_run_group_id, :attempt_number, :session_id, :task_name,
            :validation_query_id, 3, ''WARNING'', NULL, :error_message, NULL,
            OBJECT_CONSTRUCT(''check_name'', ''sp_dq_tax_array_issue'', ''fiscal_date_checked'', :yesterday_date);

        RETURN ''Data quality check failed. Details logged: '' || :error_message;
    ELSE
        -- If there are no deltas, return a success message
        RETURN ''Data quality check passed for '' || :yesterday_date || ''. No tax calculation deltas found.'';
    END IF;

END;
';"
PROCEDURE,DATAADMIN,"SP_GETPERSPECTIVESCHEMA(VARCHAR, TIMESTAMP_TZ, TIMESTAMP_TZ)","CREATE OR REPLACE PROCEDURE ""SP_GETPERSPECTIVESCHEMA""(""SPROCNAME"" VARCHAR(500), ""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS '
--=================================================================================================================
--This sproc creates the schema for a Perspective Report from the Source Data Stored Proceedure
-- call SP_GetPerspectiveSchema;
--=================================================================================================================
DECLARE 
--sprocName VARCHAR(500):= ''DATAADMIN.SP_REPORT_PMIX'';
 -- startdate timestamp_tz :=      ''2000-11-20T14:48:37.661Z'';  
 -- enddate timestamp_tz :=        ''2023-11-20T14:48:37.661Z''; 
  locationid number :=            351;
  dataout resultset;  

BEGIN
  drop table if exists schema_data; 
  CALL DATAADMIN.SP_REPORT_PMIX(''2000-11-20T14:48:37.661Z'',''2023-11-20T14:48:37.661Z'',351) ;
 
  CREATE TABLE schema_data AS
    SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

  ALTER TABLE schema_data ADD COLUMN MAXROW NUMBER;

  dataout := (

  SELECT   ''""schema"": {\\n''
    || LISTAGG (''  '' || ''""'' 
     || COLUMN_NAME 
     || ''"" : '' 
     || CASE DATA_TYPE 
       WHEN ''TEXT'' THEN ''""str""'' 
       WHEN ''NUMBER'' THEN ''""float""''
       WHEN ''TIMESTAMP_TZ'' THEN ''""datetime""'' 
       WHEN ''BOOLEAN'' THEN ''""bool""''
      ELSE DATA_TYPE END 
      || '','' 
      || ''\\n''
      ) || ''}''
      AS DATA_TYPE 
    FROM information_schema.columns 
    WHERE table_name=''SCHEMA_DATA'' 
    ORDER BY ORDINAL_POSITION
    );
    

  return table(dataout);
END
';"
PROCEDURE,DATAADMIN,SP_REPORT_USE(),"CREATE OR REPLACE PROCEDURE ""SP_REPORT_USE""()
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS '
-- ====================================================================================================================
DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2000-11-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2023-11-20T14:48:37.661Z''; 
  -- locationid number      :=  351;
-- ====================================================================================================================
--NOTE:  Change retention of execution value????  Or make Warehouse factg?
--==========================================================================================
BEGIN

 reportSet   := (
SELECT
ARRAY_TO_STRING(ARRAY_SLICE(
 STRTOK_TO_ARRAY(ARRAY_TO_STRING( ARRAY_SLICE(
  STRTOK_TO_ARRAY(QRY.QUERY_TAG, ''&''), 3, 4)
   , ''&reportId=''),''.'' ),1,2),'' ''	)

                                                    as ""Report Name""
,TO_DATE(QRY.START_TIME)							as ""Start Date"" 
,QRY.START_TIME										as ""Start Time""
,QRY.END_TIME								        as ""End Time""
,QRY.QUERY_TAG										as ""Query Tag""
,QRY.BYTES_SCANNED									as ""Bytes Scanned""
,QRY.ROWS_PRODUCED									as ""Rows Produced""
,QRY.QUERY_TEXT										as ""Query Text""
,QRY.EXECUTION_STATUS								as ""Execution Status""
,COALESCE(QRY.ERROR_CODE,0.00,''99.9'')				as ""Error Code""
,COALESCE(QRY.ERROR_MESSAGE,''None'')					as ""Error Message""
,QRY.COMPILATION_TIME								as ""Compilation Time""
,QRY.EXECUTION_TIME									as ""Execution Time""
,QRY.TOTAL_ELAPSED_TIME								as ""Total Elapsed Time""
	FROM TABLE(INFORMATION_SCHEMA.QUERY_HISTORY_BY_USER(
		USER_NAME => ''APP_AIRBYTE_HOSPENG''
        --NOTE:  we have default time of 7 days to keep this history
        --,END_TIME_RANGE_START=>to_timestamp_ltz(''2022-02-23 12:00:00.000 -0000'')
        --,END_TIME_RANGE_END=>to_timestamp_ltz(''2023-12-12 12:00:00.000 -0000'')
    ))                                                             QRY
-- WHERE QRY.QUERY_TYPE = ''SELECT''
--   AND QRY.QUERY_TAG LIKE ''REPORT%''
ORDER BY QRY.START_TIME desc
--==========================================================================================
); 
 RETURN TABLE(reportSet); 
END;
';"
PROCEDURE,DATAADMIN,SP_STAGELOADCASHBANK_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADCASHBANK_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.CASHBANK_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.CASHBANK_DIM(   
          CASHBANK_DIM_NK, 
          CASHBANK, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          SHIFT_DIM_FK, 
          CREATED_AT, 
          UPDATED_AT, 
          STATUS, 
          EXPECTED_AMOUNT, 
          OPEN_AMOUNT, 
          CLOSE_AMOUNT 
) 
 SELECT   CASHBANK_DIM_NK  as   CASHBANK_DIM_NK,  
   CASHBANK  as   CASHBANK,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   SHIFT_DIM_FK  as   SHIFT_DIM_FK,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   STATUS  as   STATUS,  
   EXPECTED_AMOUNT  as   EXPECTED_AMOUNT,  
   OPEN_AMOUNT  as   OPEN_AMOUNT,  
   CLOSE_AMOUNT  as   CLOSE_AMOUNT 
  FROM DATAADMIN.CASHBANK_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''CASHBANK_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''CASHBANK_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,"GET_TOP_10_DUPLICATE_ROWS_NOEXIST(VARCHAR, VARCHAR, ARRAY, BOOLEAN)","CREATE OR REPLACE PROCEDURE ""GET_TOP_10_DUPLICATE_ROWS_NOEXIST""(""DB_NAME"" VARCHAR, ""SCHEMA_NAME"" VARCHAR, ""TARGET_TABLES"" ARRAY, ""EVALUATE_PK"" BOOLEAN)
RETURNS TABLE (""DATABASE_NAME"" VARCHAR, ""SCHEMA_NAME"" VARCHAR, ""TABLE_NAME"" VARCHAR, ""MTLN_CDC_LOAD_TIMESTAMP"" TIMESTAMP_LTZ(9), ""ROW_DATA"" VARIANT)
LANGUAGE SQL
EXECUTE AS OWNER
AS '
DECLARE
    object_list CURSOR FOR SELECT ""name"" FROM temp_object_list;
    table_name VARCHAR;
    column_list VARCHAR;
    dynamic_sql VARCHAR;
    info_schema_path VARCHAR;
    schema_identifier VARCHAR;
    evaluate_pk_effective BOOLEAN;
    final_results RESULTSET;
    missing_objects_list VARCHAR;
    --  Declare a custom exception for our error
    object_not_found_exception EXCEPTION (-20001, ''Object not found error.'');

BEGIN
    -- Create a temporary table to hold names of all existing tables and views
    CREATE OR REPLACE TEMPORARY TABLE temp_object_list (""name"" VARCHAR);
    
    CREATE OR REPLACE TEMPORARY TABLE temp_duplicate_results (
        DATABASE_NAME VARCHAR,
        SCHEMA_NAME VARCHAR,
        TABLE_NAME VARCHAR,
        MTLN_CDC_LOAD_TIMESTAMP TIMESTAMP_LTZ,
        ROW_DATA VARIANT
    );

    evaluate_pk_effective := COALESCE(:EVALUATE_PK, TRUE);
    schema_identifier := :DB_NAME || ''.'' || :SCHEMA_NAME;

    -- Get all tables and views and insert them into our temp list
    SHOW TABLES IN SCHEMA IDENTIFIER(:schema_identifier);
    INSERT INTO temp_object_list (""name"")
    SELECT ""name"" FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

    SHOW VIEWS IN SCHEMA IDENTIFIER(:schema_identifier);
    INSERT INTO temp_object_list (""name"")
    SELECT ""name"" FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

    -- Validate that all specified target tables/views exist
    IF (TARGET_TABLES IS NOT NULL AND ARRAY_SIZE(TARGET_TABLES) > 0) THEN
        -- Find any names from the input array that are NOT in our list of existing objects
        SELECT LISTAGG(f.value::string, '', '')
        INTO missing_objects_list
        FROM TABLE(FLATTEN(INPUT => :TARGET_TABLES)) f
        LEFT JOIN temp_object_list o ON UPPER(f.value::string) = UPPER(o.""name"")
        WHERE o.""name"" IS NULL;

        -- If any objects were missing, raise the custom exception
        IF (missing_objects_list IS NOT NULL) THEN
            RAISE object_not_found_exception;
        END IF;
    END IF;

    -- Loop through the combined list of objects to find duplicates
    FOR rec IN object_list DO
        table_name := rec.""name"";

        IF (TARGET_TABLES IS NULL OR ARRAY_SIZE(TARGET_TABLES) = 0 OR ARRAY_CONTAINS(:table_name::VARIANT, TARGET_TABLES)) THEN

            info_schema_path := :DB_NAME || ''.INFORMATION_SCHEMA.COLUMNS'';

            SELECT
                LISTAGG(IFF(REGEXP_LIKE(column_name, ''^[a-zA-Z0-9_]+$''), column_name, ''""'' || column_name || ''""''), '', '')
            INTO column_list
            FROM IDENTIFIER(:info_schema_path)
            WHERE
                table_schema = :SCHEMA_NAME
                AND table_name = :table_name
                AND (:evaluate_pk_effective = TRUE OR NOT ENDSWITH(UPPER(column_name), ''_PK''));

            IF (column_list IS NOT NULL AND column_list != '''') THEN
                dynamic_sql := ''
                    INSERT INTO temp_duplicate_results (DATABASE_NAME, SCHEMA_NAME, TABLE_NAME, MTLN_CDC_LOAD_TIMESTAMP, ROW_DATA)
                    SELECT
                        '''''' || DB_NAME || '''''',
                        '''''' || SCHEMA_NAME || '''''',
                        '''''' || table_name || '''''',
                        MTLN_CDC_LOAD_TIMESTAMP,
                        OBJECT_CONSTRUCT(*)
                    FROM (
                        SELECT *, COUNT(*) OVER (PARTITION BY '' || column_list || '') as dup_count
                        FROM '' || DB_NAME || ''.'' || SCHEMA_NAME || ''.""'' || table_name || ''""
                    )
                    WHERE dup_count > 1;
                '';

                EXECUTE IMMEDIATE dynamic_sql;
            END IF;
        END IF;
    END FOR;

    final_results := (
        SELECT DATABASE_NAME, SCHEMA_NAME, TABLE_NAME, MTLN_CDC_LOAD_TIMESTAMP, ROW_DATA
        FROM temp_duplicate_results
        ORDER BY MTLN_CDC_LOAD_TIMESTAMP DESC
        LIMIT 10
    );

    RETURN TABLE(final_results);

--  FIX: Add the dynamic information to the exception object itself
EXCEPTION
    WHEN object_not_found_exception THEN
        LET error_message VARCHAR := ''The following specified tables or views were not found in '' || :schema_identifier || '': '' || :missing_objects_list;
        LET sqlerrm_with_details VARCHAR := SQLERRM || '' - '' || error_message;
        RAISE; -- Re-raise the exception with the modified details
END;
';"
PROCEDURE,DATAADMIN,SP_CREATEDWTABLE_CREATEALL(),"CREATE OR REPLACE PROCEDURE ""SP_CREATEDWTABLE_CREATEALL""()
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
    SQLStmt resultset;
    ScriptIns varchar;
    SQLTextOut varchar;
    SQLIns varchar;
    SCRIPT resultset;
    BIGSCRIPTS resultset;

-----------------------------------------------------------------------------------------------------------
BEGIN
   --drop temp tables if they exist
   drop table if exists dwtable_lists; 
   drop table if exists dwtable_scripts;
   create table dwtable_scripts (
     name varchar (100) 
     ,scripttext varchar
  );

   --create a table containing rows with the call statements to create the load stored procedures
   SELECT 
     REPLACE(''CALL DATAADMIN.SP_CreateDWTable(\\''DEV_HOSPENG_REPORTING\\'',\\''DATASTAGE\\'',\\''<TABLENAME>\\'')''
       ,''<TABLENAME>'',TABLE_NAME) AS sqltext
     FROM information_schema.tables t
   WHERE TABLE_SCHEMA = ''DATAADMIN''
     AND TABLE_TYPE = ''VIEW''
     AND TABLE_NAME ILIKE ANY (''%_DIM'', ''%_FACT'',''%_XREF'')
     AND TABLE_NAME NOT ILIKE (''DW_%'')
     AND TABLE_NAME NOT ILIKE (''DW_%'')
     AND TABLE_NAME  ILIKE ANY (''%_FACT'',''%_DIM'',''%_XREF'',''%_SUMMARY'')
     AND TABLE_NAME NOT IN (''ORDER_SUMMARY'',''ERRORDWDATE_DIM'',''DATE_DIM'',''DATASHARETEST_DIM'',''ITEM_SALES'',''UPDATE_TABLE'',''DW_SQLPARAMETERS'');
   
   CREATE TABLE dwtable_lists AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

  SQLStmt := (select * from dwtable_lists);

  --loop through all rows that create the load stored proceedure 1 per table
      BEGIN
          FOR record IN SQLStmt DO
            SQLTextOut := record.sqltext;
            SCRIPT := (EXECUTE IMMEDIATE record.sqltext);           
            ScriptIns := (SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID())));
            INSERT INTO dwtable_scripts(scripttext)    
                VALUES(:ScriptIns);   --works       
          END FOR;
     END;

  BIGSCRIPTS := (SELECT listagg(scripttext) from dwtable_scripts);   
  RETURN TABLE(BIGSCRIPTS);
  
END';"
PROCEDURE,DATAADMIN,SP_GETPERSPECTIVESCHEMA(),"CREATE OR REPLACE PROCEDURE ""SP_GETPERSPECTIVESCHEMA""()
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS '
--=================================================================================================================
--This sproc creates the schema for a Perspective Report from the Source Data Stored Proceedure
-- call SP_GetPerspectiveSchema;
--=================================================================================================================
--DECLARE varchar(500) sprocname = ''CALL DATAADMIN.SP_REPORT_PMIX(''2000-11-20T14:48:37.661Z'',''2023-11-20T14:48:37.661Z'',351)''
DECLARE sprocName VARCHAR(500):= ''DATAADMIN.SP_REPORT_PMIX'';
  startdate timestamp_tz :=      ''2000-11-20T14:48:37.661Z'';  
  enddate timestamp_tz :=        ''2023-11-20T14:48:37.661Z''; 
  locationid number :=            351;
  dataout resultset;  

BEGIN
  drop table if exists schema_data; 
  CALL DATAADMIN.SP_REPORT_PMIX(''2000-11-20T14:48:37.661Z'',''2023-11-20T14:48:37.661Z'',351) ;
 
  CREATE TABLE schema_data AS
    SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

  ALTER TABLE schema_data ADD COLUMN MAXROW NUMBER;

  dataout := (

  SELECT   ''""schema"": {\\n''
    || LISTAGG (''  '' || ''""'' 
     || COLUMN_NAME 
     || ''"" : '' 
     || CASE DATA_TYPE 
       WHEN ''TEXT'' THEN ''""str""'' 
       WHEN ''NUMBER'' THEN ''""float""''
       WHEN ''TIMESTAMP_TZ'' THEN ''""datetime""'' 
       WHEN ''BOOLEAN'' THEN ''""bool""''
      ELSE DATA_TYPE END 
      || '','' 
      || ''\\n''
      ) || ''}''
      AS DATA_TYPE 
    FROM information_schema.columns 
    WHERE table_name=''SCHEMA_DATA'' 
    ORDER BY ORDINAL_POSITION
    );
    

  return table(dataout);
END
';"
PROCEDURE,DATAADMIN,SP_LISTSTRUCTURES(),"CREATE OR REPLACE PROCEDURE ""SP_LISTSTRUCTURES""()
RETURNS TABLE (""Table Name"" VARCHAR(16777216), ""Conforming View"" VARCHAR(16777216), ""Data Warehouse Table"" VARCHAR(16777216), ""Procedure"" VARCHAR(16777216))
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res_list resultset;

BEGIN
   --drop temp tables if they exist
   drop table if exists dataadmin_list ; 
   drop table if exists datawarehouse_list; 
   drop table if exists procedure_list;
   
--Get list of datawarehouse tables
SELECT  TABLE_NAME 
     FROM information_schema.tables t
   WHERE  TABLE_SCHEMA = ''DATAWAREHOUSE''
     AND TABLE_TYPE    = ''BASE TABLE''
     AND (TABLE_NAME ILIKE ''%_DIM''
       OR TABLE_NAME ILIKE ''%_FACT''
       OR TABLE_NAME ILIKE ''%_XREF'')
ORDER BY T.TABLE_NAME  
;

CREATE TABLE datawarehouse_list AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

--Get list of admin tables
SELECT  TABLE_NAME 
     FROM information_schema.tables t
   WHERE  TABLE_SCHEMA = ''DATAADMIN''
     AND TABLE_TYPE    = ''VIEW''
     AND (TABLE_NAME ILIKE ''%_DIM''
       OR TABLE_NAME ILIKE ''%_FACT''
       OR TABLE_NAME ILIKE ''%_XREF'')
ORDER BY T.TABLE_NAME  
;

CREATE TABLE dataadmin_list AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));  

     -- select * from dataadmin_list order by TABLE_NAME;  --47
     -- select * from datawarehouse_list order by TABLE_NAME;  --13

SHOW PROCEDURES LIKE ''SP_STAGELOAD%'' IN SCHEMA DATAADMIN;

CREATE TABLE procedure_list AS
     SELECT ""name"" as ""PROCEDURE"", REPLACE(""name"",''SP_STAGELOAD'','''') AS TABLE_NAME  FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));  

--Compare the objects in daaadmin vs datawarehouse
 
res_list  := (
  SELECT TABLE_NAME     AS ""Table Name""
    ,MAX(dataadmin)     AS ""Conforming View""
    ,MAX(datawarehouse) AS ""Data Warehouse Table""
    ,MAX(PROCEDURE)     AS ""Procedure""
  -- ,CASE WHEN datawarehouse is NULL THEN ''MISSING'' ELSE ''FOUND'' END AS STATUSMESSAGE
  FROM (
        SELECT dal.TABLE_NAME, dal.TABLE_NAME AS dataadmin, NULL as datawarehouse, NULL as PROCEDURE
          FROM dataadmin_list            dal
        UNION
        SELECT dwl.TABLE_NAME, NULL AS dataadmin, dwl.TABLE_NAME as datawarehouse, NULL as PROCEDURE
         FROM datawarehouse_list   dwl
        UNION
        SELECT prl.TABLE_NAME, NULL AS dataadmin, NULL as datawarehouse, prl.PROCEDURE as PROCEDURE
         FROM procedure_list   prl         
        ) GROUP BY TABLE_NAME
); 

RETURN TABLE(res_list);
--========================================================================================================================
END';"
PROCEDURE,DATAADMIN,SP_LOADALLDWTABLES(VARCHAR),"CREATE OR REPLACE PROCEDURE ""SP_LOADALLDWTABLES""(""VALIDATE_DATE"" VARCHAR(5))
RETURNS VARCHAR(16777216)
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE
----------------------------------------------------------------------------------------------------------------------
  IsTableName      boolean;
  res_list         resultset;
  -- validate_date    varchar  := ''TRUE'';
  SQLText VARCHAR(75)   := ''CALL DATAADMIN.<SPROCNAME>(<VALIDATE_DATE>);''; 
----------------------------------------------------------------------------------------------------------------------
BEGIN
----------------------------------------------------------------------------------------------------------------------
--put list of proceedures in a temp table
SHOW PROCEDURES 
  LIKE ''SP_STAGELOAD%''
    IN SCHEMA DATAADMIN; 

--read all of the load proceedures that eist into a result set
res_list := (SELECT REPLACE(REPLACE(:SQLText,''<SPROCNAME>'',""name""),''<VALIDATE_DATE>'',:validate_date) AS ExecStmt
FROM TABLE(RESULT_SCAN(LAST_QUERY_ID())));

DECLARE cur1 CURSOR FOR res_list;
  BEGIN
    FOR row_variable IN cur1 DO
      EXECUTE IMMEDIATE row_variable.ExecStmt;
    END FOR;
  END;

-- ---------------------------------------------------------------------------------------------------------------------- 
--RETURN condition message
RETURN (''INFORMATIONAL MESSAGE:  Load Complete'');

--========================================================================================================================
END';"
PROCEDURE,DATAADMIN,"SP_LOAD_365_SALESDETAIL(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_365_SALESDETAIL""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz   := ''2025-01-16'';
  -- enddate timestamp_tz     := ''2025-01-16'';
  -- locationid string        := ''[351]'';
  locationidS string          :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--=================================================================================================================================
BEGIN
  DROP TABLE IF EXISTS TEMP_salesdetail; 
  DROP TABLE IF EXISTS TEMP_header; 

----------------------------------------------------------------------------------------------------------------------------------
SELECT ''CheckNumber''
    ,''CloseTime'' 
    ,''ItemSale_TicketItemNumber'' 
    ,''ItemSale_ItemNumber'' 
    ,''ItemSale_GrossAmount''
    ,''ItemSale_Modifiers_ItemNumber'' 
    ,''ItemSale_Modifiers_Quantity''
    ,''ItemSale_Modfiers_GrossAmount''
    ,''ItemSale_Comp_CompName''
    ,''ItemSale_Comp_Amount''
    ,''ItemSale_Promo_PromoName''
    ,''ItemSale_Promo_Amount''
    ,''ItemSale_RevenueCenterName''
    ,''ItemSale_Quantity''
;

 CREATE TEMP TABLE TEMP_header AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));
  
----------------------------------------------------------------------------------------------------------------------------------
SELECT to_char(CHK.chequenumber) || ''.'' || to_char(CHK.cheque_fact_nk)               
                                                                   AS CheckNumber --* string
    ,TO_CHAR(TO_TIMESTAMP(CHK.CLOSED_AT),''MM/DD/YYYY HH24:MI:SS'')  AS CloseTime  --* DateTime(mm/dd/yyyy hh:mm:ss)
    ,TO_CHAR(row_number() OVER (PARTITION BY CHK.CHEQUE_FACT_NK ORDER BY itf.ITEM_FACT_NK)::NUMBER(18,0))                                             
                                                                   AS ItemSale_TicketItemNumber  --* integer  
    ,TO_CHAR(itf.MENUITEMNAME_DIM_FK)                              AS ItemSale_ItemNumber  --* string 
    ,TO_CHAR((itf.GROSS -  IFNULL(itf.INCLUSIVETAX,0)) ::DECIMAL(18,2))     
                                                                   AS ItemSale_GrossAmount --* decimal
    ,TO_CHAR(1)                                                    AS ItemSale_Modifiers_ItemNumber --**string this is an fk 
    ,TO_CHAR(0)                                                    AS ItemSale_Modifiers_Quantity --int
    ,TO_CHAR(0)                                                    AS ItemSale_Modfiers_GrossAmount --** int
    ,''None''                                                        AS ItemSale_Comp_CompName --* string name of discount  
    ,TO_CHAR(0.00)                                                 AS ItemSale_Comp_Amount  --*decimal amount subtracted from tota
    ,''None''                                                        AS ItemSale_Promo_PromoName --*string  promo name
    ,TO_CHAR(itf.DiscountItem::decimal(18,2))                      AS ItemSale_Promo_Amount --*amount subtracted from total 
    ,IFNULL(REPLACE(itf.REVENUECENTERNAME,'','',''''),''None'')          AS ItemSale_RevenueCenterName  --string
    ,TO_CHAR(IFNULL(itf.QUANTITY,0)::number(18,0))                 AS ItemSale_Quantity           --int

    FROM DATAWAREHOUSE.ITEM_FACT                                itf
     INNER JOIN DATAWAREHOUSE.MENUITEMNAME_DIM                  med
       ON med.MENUITEMNAME_DIM_NK = itf.MENUITEMNAME_DIM_FK
          AND itf.ITEMSTATUS IN (''Added'',''Sent'')
          AND itf.CHECKSTATUS IN (''Closed'')
          AND itf.DW_ISCURRENTROW  
          AND med.DW_ISCURRENTROW  
          AND NOT itf.DW_ISDELETED
          AND NOT itf.IS_TRAINING
          AND itf.LOCATION_DIM_FK IN (--351,352
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)
      INNER JOIN DATAWAREHOUSE.CHEQUE_FACT                          chk
        ON chk.CHEQUE_FACT_NK = itf.CHEQUE_FACT_FK
          AND chk.DW_ISCURRENTROW
          AND chk.STATUS in (''Closed'')
          AND itf.ITEMSTATUS IN (''Added'',''Sent'')
          AND chk.UNPAID = 0
          AND chk.CLOSED_AT is not null
          AND (chk.FISCAL_DATE::date >= :startdate::date 
                AND chk.FISCAL_DATE::date  <= :enddate::date)
      INNER JOIN DATAWAREHOUSE.REPORTCATEGORY_DIM                    meg
        ON med.REPORTCATEGORY_DIM_FK = meg.REPORTCATEGORY_DIM_NK
          AND meg.DW_ISCURRENTROW = TRUE
      INNER JOIN DATAWAREHOUSE.COGSCATEGORY_DIM                      ccd
        ON ccd.COGSCATEGORY_DIM_NK = meg.COGSCATEGORY_DIM_FK    
          AND ccd.DW_ISCURRENTROW         
     ORDER BY CHK.CLOSED_AT DESC;

   CREATE TEMP TABLE TEMP_salesdetail AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));  
--=================================================================================================================================
reportSet := (  
  select * from TEMP_header
    UNION ALL
  select * from TEMP_salesdetail
--=================================================================================================================================
);
RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,"SP_LOAD_DATASHARE_CRAFTABLE_ITEM(VARCHAR, VARCHAR, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_DATASHARE_CRAFTABLE_ITEM""(""START_DATE"" VARCHAR, ""END_DATE"" VARCHAR, ""LOCATION_IDS"" VARCHAR)
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS CALLER
AS 'BEGIN
    -- Execute the source procedure that returns the data
    CALL DATAADMIN.SP_DATASHARE_CRAFTABLE_ITEM(:START_DATE, :END_DATE, :LOCATION_IDS);

    -- Insert the results into the target table
    INSERT INTO DATASHARE_DEV.CRAFTABLE_ITEM (
        ""Organization Name"",
        ""Organization ID"",
        ""Location Name"",
        ""Location ID"",
        ""Business Day"",
        ""Check Number"",
        ""Check ID"",
        ""Item Name"",
        ""Item ID"",
        ""Item Category"",
        ""Item Price"",
        ""Item Quantity"",
        ""Item Tax"",
        ""Net Amount""
    )
    SELECT
        ""Organization Name"",
        ""Organization ID"",
        ""Location Name"",
        ""Location ID"",
        ""Business Day"",
        ""Check Number"",
        ""Check ID"",
        ""Item Name"",
        ""Item ID"",
        ""Item Category"",
        ""Item Price"",
        ""Item Quantity"",
        ""Item Tax"",
        ""Net Amount""
    FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

    RETURN ''Success: Data loaded into DATASHARE_DEV.CRAFTABLE_ITEM.'';
END';"
PROCEDURE,DATAADMIN,"SP_REPORT_ACCOUNTSUMMARY_PAYMENTS(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_ACCOUNTSUMMARY_PAYMENTS""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet           resultset;
  -- startdate string    := ''2020-07-10'';  
  -- enddate string      := ''2029-07-10''; 
  -- locationid string   := ''[351]'';
  locationidS string  :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--=========================================================================================
BEGIN
  DROP TABLE IF EXISTS TEMP_GCPURCHASE;
  DROP TABLE IF EXISTS TEMP_PMIX;
  DROP TABLE IF EXISTS TEMP_CHECK;
  DROP TABLE IF EXISTS TEMP_GIFTCARDS;  
  DROP TABLE IF EXISTS TEMP_TAXDETAILSFEE;
  DROP TABLE IF EXISTS TEMP_TAXDETAILSTENDER;
  DROP TABLE IF EXISTS TEMP_REFUNDS;  
  DROP TABLE IF EXISTS TEMP_FEES;
  DROP TABLE IF EXISTS TEMP_PAYINOUT;

  DROP TABLE IF EXISTS TEMP_TABLE_PAYMENTS_1AA; 
  DROP TABLE IF EXISTS TEMP_TABLE_PAYMENTS_1AB;
  DROP TABLE IF EXISTS TEMP_TABLE_PAYMENTS_1AC;
  DROP TABLE IF EXISTS TEMP_TABLE_PAYMENTS_1A;   
--=========================================================================================

CREATE TEMP TABLE TEMP_PAYINOUT  AS
 SELECT ''PayInOut''                                                            as ""Level""   
     ,SHD.FISCAL_DAY                                                          as ""Fiscal Date""
    ,CASE WHEN PAR.IS_PAY_IN THEN ''Pay In'' ELSE ''Pay Out''END                  as ""Type""  
    ,SHD.LOCATION_DIM_FK::decimal(36,0)                                       as ""Location ID""  
    ,CASE WHEN PMD.PAYMENTMETHODTYPE IN (''CC'',''EPX'') 
       THEN ''Credit Card'' ELSE PMD.PAYMENTMETHODTYPE  END                                                             
                                                                              as ""Group 1B""
    ,CASE WHEN PMD.PAYMENTMETHODTYPE IN (''CC'',''EPX'')  
             THEN CCT.CARD_TYPE
        ELSE ''None'' END                                                       as ""Group 2B""  
    ,1                                                                        as ""CountPIO""
    ,IFNULL(PMD.PAYMENTMETHODTYPE ,''None'')                                    as ""Payment Type""
    ,IFNULL(PMD.PAYMENTMETHODTYPE ,''None'')                                    as ""Payment Method""
    ,IFNULL(CCT.CARD_TYPE,''None'')                                             as ""Card Brand""   
    ,SUM(1::NUMBER(18,0))                                                     as ""Count""
    ,SUM(PIO.AMOUNT * CASE WHEN PAR.IS_PAY_IN THEN 1 ELSE -1 END
          ) ::DECIMAL(36,2)                                                   as ""Amount"" 
       FROM DATAWAREHOUSE.PAYINOUT_FACT                                       PIO  
            INNER JOIN DATAWAREHOUSE.SHIFT_DIM                                SHD
              ON PIO.SHIFT_DIM_FK = SHD.SHIFT_DIM_NK
                  AND SHD.DW_ISCURRENTROW
                  AND PIO.DW_ISCURRENTROW
                  AND NOT PIO.DW_ISDELETED
                  AND NOT PIO.IS_VOID
                  AND PIO.STATUS = ''Success''
                  AND SHD.FISCAL_DAY::date >= :startdate::date 
                  AND SHD.FISCAL_DAY::date <= :enddate::date  
                  AND SHD.LOCATION_DIM_FK in (
                    SELECT table1.value 
                      FROM table(split_to_table(:locationidS, '',''))  table1) 
            INNER JOIN DATAWAREHOUSE.PAYMENTMETHOD_DIM                         PMD
              ON PMD.PAYMENTMETHOD_DIM_NK = PIO.PAYMENTMETHOD_DIM_FK
                  AND PMD.DW_ISCURRENTROW
            INNER JOIN DATAWAREHOUSE.PAYINPAYOUTREASON_DIM                     PAR
              ON PAR.PAYINPAYOUTREASON_DIM_NK = PIO.PAYINPAYOUTREASON_DIM_FK
                  AND PAR.DW_ISCURRENTROW                
            LEFT JOIN DATAWAREHOUSE.CCTRANSACTION_FACT                         CCT
              ON CCT.CCTRANSACTION_FACT_NK = PIO.CCTRANSATION_FACT_FK
                  AND CCT.DW_ISCURRENTROW
            GROUP BY ""Level"" 
                ,""Type""
                ,""Group 1B""
                ,""Group 2B""
                ,""Fiscal Date""
                ,""Location ID""  
                ,""Payment Method""
                ,""Payment Type""
                ,""Card Brand""  ;

-------------------------------------------------------------------------------------------
 CREATE TEMP TABLE TEMP_REFUNDS
    AS
 SELECT ''Refunds''                                                       AS ""Level""
    ,''Refunds''                                                          AS ""Group 1C""
    ,''Refunds''                                                          AS ""Group 2C""    
    ,CHK.FISCAL_DATE                                                    AS ""Fiscal Date""
    ,IFNULL(PMD.PAYMENTMETHODTYPE ,''None'')                              AS ""Payment Type""
    ,IFNULL(PMD.PAYMENTMETHODTYPE ,''None'')                              AS ""Payment Method""
    ,ref.LOCATION_DIM_FK                                                AS ""Location ID""
    ,1                                                                  AS ""Count""
    ,ref.REFUND_AMOUNT::DECIMAL(18,2)                                   AS ""Refund Amount""  
        FROM DATAWAREHOUSE.REFUNDS_FACT                                 ref
          INNER JOIN DATAWAREHOUSE.CHEQUE_FACT                          chk
            ON chk.CHEQUE_FACT_NK = ref.CHEQUE_FACT_FK
              AND chk.DW_ISCURRENTROW
              AND NOT chk.dw_isdeleted
              AND chk.STATUS = ''Closed''
              AND ref.PAYMENTSTATUS = ''Success''
              AND (chk.FISCAL_DATE::date >= :startdate::date 
              AND chk.FISCAL_DATE::date  <= :enddate::date)
                              AND ref.opened_at::timestamp_ntz  >= :startdate::timestamp_ntz 
              AND ref.LOCATION_DIM_FK in (
                    SELECT table1.value 
                      FROM table(split_to_table(:locationidS, '',''))  table1)                               
              AND ref.DW_ISCURRENTROW
              AND NOT ref.IS_TRAINING
              AND NOT ref.dw_isdeleted
            INNER JOIN DATAWAREHOUSE.PAYMENTMETHOD_DIM                  pmd
              ON pmd.PAYMENTMETHOD_DIM_NK = ref.PAYMENTMETHOD_DIM_FK
                AND pmd.DW_ISCURRENTROW
;         

--===========================================================================================
CREATE TEMP TABLE TEMP_GCPURCHASE AS
  SELECT CHF.FISCAL_DATE   AS  FISCAL_DATE
      ,CHF.LOCATION_DIM_FK AS  LOCATION_DIM_FK
      ,GCF.CHEQUE_FACT_FK  AS  CHEQUE_FACT_FK
      ,SUM(GCF.AMOUNT)     AS ""Gift Card Purchase Amount""
     FROM DATAWAREHOUSE.GIFTCARDTRANSACTION_FACT                       GCF  
        INNER JOIN DATAWAREHOUSE.CHEQUE_FACT                           CHF
            ON CHF.CHEQUE_FACT_NK = GCF.CHEQUE_FACT_FK
                AND CHF.STATUS = ''Closed''
                AND GCF.COMMAND = ''Issue''
                AND CHF.DW_ISCURRENTROW
                AND GCF.DW_ISCURRENTROW
                AND NOT GCF.DW_ISDELETED
                AND CHF.FISCAL_DATE::date >= :startdate::date 
                AND CHF.FISCAL_DATE::date <= :enddate::date  
                AND CHF.LOCATION_DIM_FK in (
                  SELECT table1.value 
                     FROM table(split_to_table(:locationidS, '',''))  table1)                 
     GROUP BY CHF.FISCAL_DATE
       ,CHF.LOCATION_DIM_FK
       ,GCF.CHEQUE_FACT_FK;

-- -------------------------------------------------------------------------------------
CREATE TEMP TABLE TEMP_CHECK AS 
SELECT ''Cheque''                                                         as ""Level""   
    ,pay.fiscaldate                                                     as ""Fiscal Date""
    ,loc.location_dim_nk::decimal(36,0)                                 as ""Location ID""  
    ,CASE WHEN PAYMENTTYPE IN (''CC'',''EPX'') 
       THEN ''Credit Card'' ELSE PAYMENTTYPE  END                                                             
                                                                        as ""Group 1B""
    ,CASE WHEN PAYMENTTYPE IN (''CC'',''EPX'') 
             THEN pay.cardbrand
        ELSE  ptd.paymentmethodname END                                 as ""Group 2B""    
    ,PAYMENTTYPE                                                        as ""Payment Type""    
    ,IFNULL(ptd.paymentmethodname ,''None'')                              as ""Payment Method""

    ,IFNULL(case pay.cardbrand when '''' 
             THEN ''Not a Credit Card'' 
            else pay.cardbrand end,''None'')  
                                                                        as ""Card Brand"" 
-------------------------------------------------------------------------------------
    ,ROW_NUMBER() OVER (PARTITION BY CHF.CHEQUE_FACT_NK 
        ORDER BY PAY.PAYMENTS_FACT_NK)                                  as ""Check Count""
    ,CHF.CHEQUE_FACT_NK                                                 as CHEQUE_FACT_NK
    ,PAY.PAYMENTS_FACT_NK                                               as PAYMENTS_FACT_NK
    ,SUM(IFNULL(CHF.TAX       ,0.00))::DECIMAL(36,2)                    as ""Taxes""
    ,SUM(IFNULL(CHF.SURCHARGE ,0.00))::DECIMAL(36,2)                    as ""Surcharges""
    ,SUM(IFNULL(CHF.UNPAID    ,0.00))::DECIMAL(36,2)                    as ""Unpaid""
    ,SUM(IFNULL(CHF.GRATUITIES,0.00))::DECIMAL(36,2)                    as ""Gratuities""    
    ,SUM(IFNULL(CHF.FEES      ,0.00))::DECIMAL(36,2)                    as ""Fees""    
    ,SUM(CASE WHEN  ptd.paymentmethodname ILIKE ''%Event Deposit%''
      THEN CASE WHEN pay.PAYMENTTYPE = ''Cash'' THEN pay.AMOUNTAPPLIEDTOCHECK 
                  ELSE pay.TOTAL END ELSE 0 END        
        - IFNULL(pay.Tip,0))                       ::DECIMAL(36,2)      as ""Deposits""
    ,SUM(IFNULL(GCF.""Gift Card Purchase Amount"",0.00)) ::DECIMAL(36,2)  as ""Gift Card Sales""
    ,SUM(IFNULL(CHF.TIP       ,0.00))::DECIMAL(36,2)                    as ""Tips2""           
    ,SUM(0.00)::DECIMAL(36,2)                                           as ""Pay In/Out""
    ,SUM(0.00)::DECIMAL(36,2)                                           as ""Deposit Applied""
    ,SUM(IFNULL(CHF.net,0) - IFNULL(CHF.tax,0) - IFNULL(CHF.SURCHARGE,0) - IFNULL(GCF.""Gift Card Purchase Amount"",0)
    -- - CASE WHEN  ptd.paymentmethodname ILIKE ''%Event Deposit%''
    --   THEN CASE WHEN pay.PAYMENTTYPE = ''Cash'' THEN pay.AMOUNTAPPLIEDTOCHECK 
    --               ELSE pay.TOTAL END ELSE 0 END 
    
    )::DECIMAL(36,2) 
                                                                        as ""Net Sales"" 
    -- ,SUM(tpr.""Applied Amount"")::DECIMAL(36,2)                        as ""Net Sates from Item""
-------------------------------------------------------------------------------------
    ,SUM(1::NUMBER(36,0))                                               as ""Count""
    ,SUM(IFNULL(pay.Tip,0))::DECIMAL(36,2)                              as ""Tips"" 
    ,(SUM( CASE WHEN pay.PAYMENTTYPE = ''Cash'' THEN pay.AMOUNTAPPLIEDTOCHECK 
                  ELSE pay.TOTAL END   )    
        - SUM(IFNULL(pay.Tip,0))
        
        - SUM(IFNULL(CASE WHEN  ptd.paymentmethodname ILIKE ''%Event Deposit%''
      THEN CASE WHEN pay.PAYMENTTYPE = ''Cash'' THEN pay.AMOUNTAPPLIEDTOCHECK 
                  ELSE pay.TOTAL END ELSE 0 END,0)
        
        ))::DECIMAL(18,2)          
                                                                       as ""Sales""       
 
    ,SUM(CASE WHEN ptd.paymentmethodname ilike ''%Event Deposit%'' 
             THEN CASE WHEN pay.PAYMENTTYPE = ''Cash'' 
                THEN pay.AMOUNTAPPLIEDTOCHECK::DECIMAL(18,2) 
             ELSE pay.TOTAL END  
           ELSE 0 END) ::DECIMAL(36,2)                                  as ""Deposit""     
    ,SUM(CASE WHEN pay.PAYMENTTYPE = ''Cash'' 
          THEN pay.AMOUNTAPPLIEDTOCHECK 
                  ELSE pay.TOTAL END )::DECIMAL(36,2)                   as ""Total""            
        FROM DATAWAREHOUSE.CHEQUE_FACT                                  chf
          INNER JOIN DATAWAREHOUSE.PAYMENTS_FACT                        pay
            ON pay.CHEQUE_FACT_FK = chf.CHEQUE_FACT_NK
              AND chf.DW_ISCURRENTROW
              AND pay.DW_ISCURRENTROW
              AND chf.FISCAL_DATE::date >= :startdate::date 
              AND chf.FISCAL_DATE::date <= :enddate::date  
              AND chf.LOCATION_DIM_FK in (
                SELECT table1.value 
                   FROM table(split_to_table(:locationidS, '',''))  table1) 
               AND NOT chf.IS_TRAINING
               AND NOT chf.DW_ISDELETED
               AND pay.PAYMENTSTATUS = ''Success''
               AND chf.STATUS = ''Closed''
          INNER JOIN DATAWAREHOUSE.location_DIM                          loc
            ON pay.location_DIM_FK = loc.location_DIM_NK
              AND loc.DW_ISCURRENTROW
          INNER JOIN DATAWAREHOUSE.PaymentMethod_DIM                     ptd      
            ON pay.PaymentMethod_DIM_FK = ptd.PaymentMethod_DIM_NK
              AND ptd.DW_ISCURRENTROW
              AND NOT ptd.DW_ISDELETED  
          LEFT JOIN TEMP_GCPURCHASE                                      gcf
            ON chf.CHEQUE_FACT_NK = gcf.CHEQUE_FACT_FK
    GROUP BY ""Level""   
    ,""Location ID"" 
    ,loc.LOCATION_DIM_NK
    ,CHF.CHEQUE_FACT_NK
    ,PAY.PAYMENTS_FACT_NK
    ,""Group 1B""
    ,""Group 2B""
    ,""Payment Method""
    ,""Payment Type""
    ,""Card Brand"" 
    ,""Fiscal Date""

UNION
 
 SELECT pio.""Level""              as ""Level""   
    ,pio.""Fiscal Date""           as ""Fiscal Date""
    ,pio.""Location ID""           as ""Location ID""  
    ,pio.""Group 1B""              as ""Group 1B""
    ,pio.""Group 2B""              as ""Group 2B""    
    ,pio.""Payment Type""          as ""Payment Type""    
    ,pio.""Payment Method""        as ""Payment Method""
    ,pio.""Card Brand""            as ""Card Brand"" 
-------------------------------------------------------------------------------------
    ,0                           as ""Check Count""
    ,NULL                        as CHEQUE_FACT_NK
    ,NULL                        as PAYMENTS_FACT_NK
    ,0                           as ""Taxes""
    ,0                           as ""Surcharges""
    ,0                           as ""Unpaid""
    ,0                           as ""Gratuities""    
    ,0                           as ""Fees""    
    ,0                           as ""Deposits""
    ,0                           as ""Gift Card Sales""
    ,0                           as ""Tips2""           
    ,pio.""Amount""                as ""Pay In/Out""
    ,0                           as ""Deposit Applied""
    ,0                           as ""Net Sales"" 
-------------------------------------------------------------------------------------
    ,1                           as ""Count""
    ,0                           as ""Tips"" 
    ,0                           as ""Sales""       
    ,0                           as ""Deposit""     
    ,pio.""Amount""                as ""Total""      
FROM TEMP_PAYINOUT               pio
;    

-------------------------------------------------------------------------------------------
-- UNPIVOT CHECK BALANCES TO CREATE ROWS FOR THE ''Total Payments'' Row
-- DROP TABLE TEMP_TABLE_PAYMENTS_1AA
CREATE TEMP TABLE TEMP_TABLE_PAYMENTS_1AA AS
 SELECT ''Total Payments''  as ""Group 1A""
  ,""Level""                as ""Group 2A""
  ,""Fiscal Date""          as ""Fiscal Date""
  ,""Location ID""          as ""Location ID""
  ,SUM(""Amount"")          as ""Total1"" 
    FROM TEMP_PAYINOUT
    GROUP BY ""Group 1A"",""Group 2A"",""Fiscal Date"",""Location ID""  
    ;
    
CREATE TEMP TABLE TEMP_TABLE_PAYMENTS_1AC AS
 SELECT ''Total Payments''  as ""Group 1A""
  ,''Refunds''              as ""Group 2A""
  ,""Fiscal Date""          as ""Fiscal Date""
  ,""Location ID""          as ""Location ID""
  ,SUM(""Count"")           as ""Count""
  ,SUM(""Refund Amount"")   as ""Total1"" 
    FROM TEMP_REFUNDS
    GROUP BY ""Group 1A"",""Group 2A"",""Fiscal Date"",""Location ID""      
;

CREATE TEMP TABLE TEMP_TABLE_PAYMENTS_1AB AS
SELECT ''Total Payments'' as ""Group 1A""
  ,""Group 2""            as ""Group 2A""
  ,""Fiscal Date""        as ""Fiscal Date""
  ,""Location ID""        as ""Location ID""
  ,SUM(""Total1"")        as ""Total1""
  FROM TEMP_CHECK
    UNPIVOT (""Total1"" FOR ""Group 2"" IN (""Taxes"",""Surcharges"",""Fees"",""Deposit Applied"",""Gift Card Sales"",""Tips2"",""Pay In/Out"",""Net Sales""/*,""Net Sates from Item""*/,""Gratuities""))
    WHERE ""Check Count"" = 1 --get only one row per check for check level details
  GROUP BY ""Group 1A"",""Group 2A"",""Fiscal Date"",""Location ID""   
  ;

-- select * from TEMP_TABLE_PAYMENTS_1A  whERE ""Group 1"" = ''Refunds'';
-- select ""Group 1"",""Group 2"" from TEMP_TABLE_PAYMENTS_1A group by ""Group 1"", ""Group 2"" order by ""Group 1"", ""Group 2""
--===========================================================================================
CREATE TEMP TABLE TEMP_TABLE_PAYMENTS_1A AS --don''t change to join since not all groups of brand and type will exist as pio and checks
SELECT ''Payments 1''                                                                             AS ""Display Table ID""
      ,INLT1.""Fiscal Date""                                                                      AS ""Fiscal Date""
      ,INLT1.""Group 1""                                                                          AS ""Group 1""                                                                                    
      ,INLT1.""Group 2""                                                                          AS ""Group 2"" 
      ,INLT1.""Location ID""                                                                      AS ""Location ID""
      ,IFNULL(SUM(INLT1.""Count"")     ,0)                                                        AS ""Count""
      ,IFNULL(SUM(INLT1.""Tips"")      ,0)                                                        AS ""Tips""  
      ,IFNULL(SUM(INLT1.""Sales"")     ,0)                                                        AS ""Sales""
      ,IFNULL(SUM(INLT1.""Pay In"")    ,0)                                                        AS ""Pay In""
      ,IFNULL(SUM(INLT1.""Deposit"")   ,0)                                                        AS ""Deposit""
      
      ,SUM(CASE WHEN INLT1.""Level"" = ''Summary''
        THEN INLT1.""Total1""
        ELSE
        IFNULL(INLT1.""Tips""         ,0)
        + IFNULL(INLT1.""Sales""      ,0) 
        + IFNULL(INLT1.""Pay In""     ,0) 
        + IFNULL(INLT1.""Deposit""    ,0)  
        END )
                                                                                                AS ""Total"" 
  FROM (
          SELECT CHK.""Level""       AS ""Level""
              ,CHK.""Group 1B""      AS ""Group 1""
              ,CHK.""Group 2B""      AS ""Group 2""  
              ,CHK.""Fiscal Date""   AS ""Fiscal Date"" 
              ,CHK.""Location ID""   AS ""Location ID""
              ,CHK.""Payment Type""  AS ""Payment Type""
              ,CHK.""Payment Method""AS ""Payment Method""
              ,CHK.""Card Brand""    AS ""Card Brand""
              ,CHK.""Count""         AS ""Count""
              ,CHK.""Tips""          AS ""Tips""  
              ,CHK.""Sales""         AS ""Sales""
              ,0                   AS ""Pay In""
              ,CHK.""Deposit""       AS ""Deposit""
              ,0                    AS ""Total1""
            FROM TEMP_CHECK        CHK
          UNION ALL
           SELECT PIO.""Level""       AS ""Level""
              ,""Group 1B""           AS ""Group 1""
              ,""Group 2B""           AS ""Group 2""  
              ,PIO.""Fiscal Date""    AS ""Fiscal Date"" 
              ,PIO.""Location ID""    AS ""Location ID""
              ,PIO.""Payment Type""   AS ""Payment Type""
              ,PIO.""Payment Method"" AS ""Payment Method""
              ,PIO.""Card Brand""     AS ""Card Brand""
              ,0                    AS ""Count"" 
              ,0                    AS ""Tips"" 
              ,0                    AS ""Sales""
              ,PIO.""Amount""         AS ""Pay In""
              ,0                    AS ""Deposit""
              ,0                    AS ""Total1""
            FROM TEMP_PAYINOUT      PIO
           UNION ALL
            SELECT REF.""Level""      AS ""Level""
              ,REF.""Group 1C""       AS ""Group 1""
              ,REF.""Group 2C""       AS ""Group 2""              
              ,REF.""Fiscal Date""    AS ""Fiscal Date"" 
              ,REF.""Location ID""    AS ""Location ID""
              ,REF.""Payment Type""   AS ""Payment Type""
              ,REF.""Payment Method"" AS ""Payment Method""
              ,NULL                 AS ""Card Brand""
              ,REF.""Count""          AS ""Count"" 
              ,0                    AS ""Tips"" 
              ,REF.""Refund Amount""  AS ""Sales""
              ,0                    AS ""Pay In""
              ,0                    AS ""Deposit""
              ,0                    AS ""Total1""
           FROM TEMP_REFUNDS       REF    
               UNION ALL
           SELECT ''Summary''         AS ""Level""
              ,SPY.""Group 1A""       AS ""Group 1""
              ,SPY.""Group 2A""       AS ""Group 2""
              ,SPY.""Fiscal Date""    AS ""Fiscal Date"" 
              ,SPY.""Location ID""    AS ""Location ID""
              ,NULL                 AS ""Payment Type""
              ,NULL                 AS ""Payment Method""
              ,NULL                 AS ""Card Brand""
              ,0                    AS ""Count"" 
              ,0                    AS ""Tips"" 
              ,0                    AS ""Sales""
              ,0                    AS ""Pay In""
              ,0                    AS ""Deposit""
              ,SPY.""Total1""         AS ""Total1""
            FROM TEMP_TABLE_PAYMENTS_1AA     SPY   
               UNION ALL   
           SELECT ''Summary''         AS ""Level""
              ,SPI.""Group 1A""       AS ""Group 1""
              ,SPI.""Group 2A""       AS ""Group 2""
              ,SPI.""Fiscal Date""    AS ""Fiscal Date"" 
              ,SPI.""Location ID""    AS ""Location ID""
              ,NULL                 AS ""Payment Type""
              ,NULL                 AS ""Payment Method""
              ,NULL                 AS ""Card Brand""
              ,0                    AS ""Count"" 
              ,0                    AS ""Tips"" 
              ,0                    AS ""Sales""
              ,0                    AS ""Pay In""
              ,0                    AS ""Deposit""
              ,SPI.""Total1""         AS ""Total1""
            FROM TEMP_TABLE_PAYMENTS_1AB    SPI  
               UNION ALL   
           SELECT ''Summary''         AS ""Level""
              ,SPR.""Group 1A""       AS ""Group 1""
              ,SPR.""Group 2A""       AS ""Group 2""
              ,SPR.""Fiscal Date""    AS ""Fiscal Date"" 
              ,SPR.""Location ID""    AS ""Location ID""
              ,NULL                 AS ""Payment Type""
              ,NULL                 AS ""Payment Method""
              ,NULL                 AS ""Card Brand""
              ,0                    AS ""Count"" 
              ,0                    AS ""Tips"" 
              ,0                    AS ""Sales""
              ,0                    AS ""Pay In""
              ,0                    AS ""Deposit""
              ,SPR.""Total1""         AS ""Total1""
            FROM TEMP_TABLE_PAYMENTS_1AC    SPR              
            
         ) INLT1
  GROUP BY INLT1.""Location ID""   
     ,""Fiscal Date""
      ,""Level""     
      ,""Group 1""
      ,""Group 2""
  ;
-- SELECT * FROM TEMP_TABLE_PAYMENTS_1AA WHERE ""Group 2A"" = ''PayInOut'';
--SELECT * FROM TEMP_TABLE_PAYMENTS_1A WHERE ""Group 2"" = ''PayInOut'';
--=========================================================================================== 
 reportSet:= (
 -- SELECT ''SS''  AS TESTCIK
 -- SELECT * FROM TEMP_CHECK
 -- SELECT * FROM TEMP_GIFTCARDS
 -- SELECT * FROM  TEMP_PAYINOUTS
 -- SELECT * FROM TEMP_TAXDETAILSFEE
 -- SELECT * FROM TEMP_TAXDETAILSTENDER
 -- SELECT * FROM TEMP_REFUNDS  
 -- SELECT * FROM TEMP_FEES    
 -- SELECT * FROM TEMP_TABLE_PAYMENTS_1A
 SELECT ROW_NUMBER() OVER (ORDER BY ""Location ID"")            AS  ""Support ID"" 
   ,* from TEMP_TABLE_PAYMENTS_1A
);

--===========================================================================================
RETURN TABLE(reportSet); 

END';"
PROCEDURE,DATAADMIN,"SP_REPORT_CLOSE(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_CLOSE""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2024-08-01T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2024-08-05T14:48:37.661Z''; 
  -- locationid string      := ''[3,351]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
BEGIN
 reportSet   := (
SELECT  COS.CLOSEOUTSUMMARY_FACT_NK                                            as ""Support ID"" 
    , ''cos-'' ||row_number() over (order by cos.CLOSEOUTSUMMARY_FACT_NK) 
                                                                               as ""Detail ID""   
  --Status, categories and levels-------------------------------------------
  --Geography---------------------------------------------------------------
  ,IFNULL(loc.locationname,''None'')                                             as ""Location""
  ,cos.location_dim_fk::decimal(38,0)                                          as ""Location ID""
 --Payment Method----------------------------------------------------------- 
 --Dates---------------------------------------------------------------------
    ,LOC.TZ_NAME                                                               as ""Time Zone""
    ,to_char(LEFT(COS.FISCAL_DATE,4))                                          as ""Year""
    ,to_char(YEAR(COS.FISCAL_DATE)) || ''|'' || TO_CHAR(RIGHT(''0'' || MONTH(COS.FISCAL_DATE),2))
                                                                               as ""Year and Month""                                                                             
    ,to_char(COS.FISCAL_DATE)                                                  as ""Fiscal Day""
    ,IFNULL(DAYNAME(COS.FISCAL_DATE),''None'')                                   as ""Day of Week""
    ,CASE WHEN DAYNAME(COS.FISCAL_DATE) IN (''Sat'',''Sun'')  
    THEN TRUE ELSE FALSE END                                                   as ""Is Weekend""
    ,CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,COS.CREATED_AT::timestamp_ntz )::timestamp                                             
                                                                               as ""Created At""
  -- --Flags----------------------------------------------------
  -- --People---------------------------------------------------
  -- --Report Specific Dimensions--------------------------------
  -- --Facts-----------------------------------------------------
    ,1::NUMBER(10,0)                                      as ""Count""
    ,COS.TAX::NUMBER(18,2)                                as ""Tax"" 
    ,COS.TIPS::NUMBER(18,2)                               as ""Tips"" 
    ,COS.VOIDS::NUMBER(18,2)                              as ""Voids"" 
    ,COS.DISCOUNTS::NUMBER(18,2)                          as ""Discounts"" 
    ,COS.FEES::NUMBER(18,2)                               as ""Fees"" 
    ,COS.GRATUITIES::NUMBER(18,2)                         as ""Gratuities""     
    ,COS.GROSS_RECEIPTS::NUMBER(18,2)                     as ""Gross Receipts"" 
    ,COS.GROSS_SALES::NUMBER(18,2)                        as ""Gross""     
    
 ------------------------------------------------------------  
FROM datawarehouse.CLOSEOUTSUMMARY_FACT                       COS
      INNER JOIN datawarehouse.LOCATION_DIM                   LOC
        ON cos.LOCATION_DIM_FK = loc.LOCATION_DIM_NK
          AND loc.DW_ISCURRENTROW
          AND cos.DW_ISCURRENTROW  
          AND COS.FISCAL_DATE::date
              >= :startdate::date 
          AND COS.FISCAL_DATE::date  
              <= :enddate::date 
          AND cos.LOCATION_DIM_FK IN ( 
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1) 
ORDER BY COS.FISCAL_DATE                 

--==========================================================================================
);
RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,"SP_REPORT_PMIX_0001(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_PMIX_0001""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS '
-- -- =====================================================================================
--Example Call Statement
--CALL DATAADMIN.SP_REPORT_PMIX_0001(''2000-11-20T14:48:37.661Z'',''2023-11-20T14:48:37.661Z'',''[351,352]'');
-- =======================================================================================
-- --NOTE:  Convert to local timezone.
-- --NOTE:  Split checks - report quantity - what about an item that was split, but one split check was -- --=========================================================================================
DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2000-11-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2023-11-20T14:48:37.661Z''; 
  -- locationid string      := ''[351,352]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--=========================================================================================
BEGIN
 reportSet:= (
SELECT itf.ITEM_FACT_NK                                   as ""Support ID"" 
    , ''PMIX-'' ||row_number() over (order by itf.ITEM_FACT_NK) 
                                                          as ""Detail ID""
--status, category, level-------------------------------------------------------------------
    ,IFNULL(itf.CHECKSTATUS,''None'')                       as ""Check Status""
    ,IFNULL(itf.ITEMSTATUS,''None'')                        as ""Item Status""
    ,IFNULL(itf.STATUSREASON,''None'')                      as ""Status Reason""
    ,IFNULL(meg.REPORTCATEGORY,''None'')                    as ""Category""
-- --geography--------------------------------------------------------------------------------
    ,IFNULL(loc.LOCATIONNAME,''None'')                      as ""Location""
    ,IFNULL(itf.REVENUECENTERNAME,''None'')                 as ""Revenue Center""
-- --dates-------------------------------------------------------------------------------------
    ,LOC.TZ_NAME                                          as ""Time Zone""
    ,to_char(LEFT(
    CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,itf.OPENED_AT::timestamp_ntz )
    ,4))                                                  as ""Year""
    ,to_char(LEFT(
    CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,itf.OPENED_AT::timestamp_ntz )
    ,7))                                                  as ""Year and Month""
    ,IFNULL(dad.DAYPART,''None'')                           as ""Daypart""
    ,CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,itf.OPENED_AT::timestamp_ntz )                                        as ""Opened At""
    ,IFNULL(DAYNAME(
    CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,itf.OPENED_AT::timestamp_ntz )
    ),'' None'') 
                                                          as ""Day of Week""
    ,CASE WHEN DAYNAME(
    CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,itf.OPENED_AT::timestamp_ntz )
    ) IN (''Sat'',''Sun'')  
    THEN TRUE ELSE FALSE END                              as ""Is Weekend""
-- --flags--------------------------------------------------------------------------------------
    ,IFNULL(itf.HASMODIFIERS,FALSE)                       as ""Has Modifiers""
-- --people-------------------------------------------------------------------------------------
    ,IFNULL(emd.EMPLOYEE_NAME,''None'')                     as ""Employee""
-- --Descriptors-------------------------------------------------------------------------------- 
    ,IFNULL(itf.chequenumber ,''None'')                     as ""Check""
    ,IFNULL(med.MENUITEMNAME,'' None'')                     as ""Menu Item""
    ,IFNULL(itf.NOTE,''None'')                              as ""Note""
    ,IFNULL(itf.DESCRIPTION,''None'')                       as ""Description""
    ,IFNULL(vad.VARIANT,''None'')                           as ""Variant""     
    ,itf.SPLITBY                                          as ""Split By""
-- --Facts-----------------------------------------------------------------------------------------
    ,1::NUMBER(18,0)                                      as ""Count""
    ,itf.REPORTQUANTITY::NUMBER(18,2)                     as ""Report Quantity""                   
    ,itf.BASEPRICE::NUMBER(18,2)                          as ""Base Price""
    ,itf.INCLUSIVETAX::NUMBER(18,2)                       as ""Inclusive Tax""
    ,itf.PRICE::NUMBER(18,2)                              as ""Price""
    ,itf.GROSS::NUMBER(18,2)                              as ""Gross""  
    ,itf.NET::NUMBER(18,2)                                as ""Net""  
    ,itf.TAX::NUMBER(18,2)                                as ""Tax""
    ,itf.TOTAL::NUMBER(18,2)                              as ""Total"" 
--------------------------------------------------------------------------------------------   
FROM DATAADMIN.ITEM_FACT                                  itf
     INNER JOIN DATAADMIN.MENUITEMNAME_DIM                med
       ON med.MENUITEMNAME_DIM_NK = itf.MENUITEMNAME_DIM_FK
          AND itf.ITEMSTATUS IN (''Added'',''Sent'')
          AND NOT itf.CHECKSTATUS = ''Voided''
        AND itf.OPENED_AT is not null
          AND itf.DW_ISCURRENTROW  
          AND med.DW_ISCURRENTROW  
          AND NOT itf.DW_ISDELETED
          AND NOT itf.IS_TRAINING
          AND itf.LOCATION_DIM_FK IN (--351,352
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)
      INNER JOIN DATAADMIN.LOCATION_DIM                     loc
        ON itf.LOCATION_DIM_FK = loc.LOCATION_DIM_NK
          AND loc.DW_ISCURRENTROW
          AND CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,OPENED_AT::timestamp_ntz ) > CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,:startdate::timestamp_ntz )
          AND CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,OPENED_AT::timestamp_ntz ) < CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,:enddate::timestamp_ntz )
      INNER JOIN DATAADMIN.EMPLOYEE_DIM                     emd
        ON itf.employee_dim_fk = emd.employee_dim_pk
          AND emd.DW_ISCURRENTROW 
      INNER JOIN DATAADMIN.DAYPART_DIM                      dad
        ON itf.daypart_dim_fk = dad.daypart_dim_pk
          AND dad.DW_ISCURRENTROW = TRUE         
      INNER JOIN DATAADMIN.REPORTCATEGORY_DIM               meg
        ON med.REPORTCATEGORY_DIM_FK = meg.REPORTCATEGORY_DIM_NK
          AND med.DW_ISCURRENTROW = TRUE
      INNER JOIN DATAADMIN.VARIANT_DIM                      vad
        ON itf.VARIANT_DIM_FK = vad.variant_dim_nk
          AND vad.dw_iscurrentrow
      ORDER BY itf.OPENED_AT
--==========================================================================================
);
RETURN TABLE(reportSet); 
END;
-- ';"
PROCEDURE,DATAADMIN,"SP_REPORT_TAX_DEBUG(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_TAX_DEBUG""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS '
DECLARE
  reportSet resultset;
  -- startdate timestamp_tz := ''2024-07-01T14:48:37.661Z'';
  -- enddate timestamp_tz   := ''2029-07-31T14:48:37.661Z'';
  -- locationid string      := ''[351,352,353,361,379,382,385,387,388,389,390,399,408,421,433,480,574,680]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--========================================================================================================
BEGIN
  DROP TABLE IF EXISTS temp_itemtax;
  DROP TABLE IF EXISTS temp_feetax;

  CREATE TEMP TABLE temp_itemtax AS
  SELECT
      tax.TAX_FACT_NK                                       as ""Support ID""
      ,tax.MTLN_CDC_SEQUENCE_NUMBER                         as ""MTLN_CDC_SEQUENCE_NUMBER""
      , ''TAX-'' ||row_number() over (order by tax.TAX_FACT_NK)
                                                            as ""Detail ID""
      ,tax.CHEQUE_FACT_FK                                   as ""CHEQUE_FACT_FK""
      ,tax.ITEM_FACT_FK                                     as ""ITEM_FACT_FK""
  --Status, category, level------------------------------------------------------------------------------------
      ,IFNULL(tax.CHECKSTATUS,''None'')                      as ""Check Status""
      ,IFNULL(tax.ITEMSTATUS,''None'')                       as ""Item Status""
      ,IFNULL(ccd.COGSCATEGORY,''None'')                     as ""Category""
  --Geography----------------------------------------------------------------------------------------------
      ,IFNULL(org.ORGANIZATION,''None'')                     as ""Organization""
      ,IFNULL(loc.LOCATIONNAME,''None'')                     as ""Location""
      ,loc.LOCATION_DIM_NK                                  as ""Location ID""
      ,IFNULL(tax.REVENUECENTERNAME,''None'')                as ""Revenue Center""
  --Dates---------------------------------------------------------------------------------------------------
     ,LOC.TZ_NAME                                           as ""Time Zone""
      ,to_char(LEFT(tax.FISCAL_DATE,4))                      as ""Year""
      ,to_char(YEAR(tax.FISCAL_DATE)) || ''|''
          || TO_CHAR(RIGHT(''0'' || MONTH(tax.FISCAL_DATE),2))
                                                            as ""Year and Month""
      ,IFNULL(dad.DAYPART,''None'')                          as ""Daypart""
      ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,
         tax.CLOSED_AT::timestamp_ntz )::timestamp)
                                                            as ""Closed At""
      ,to_char(tax.FISCAL_DATE)                             as ""Fiscal Date""
      ,IFNULL(DAYNAME(tax.FISCAL_DATE),''None'')             as ""Day of Week""
      ,CASE WHEN DAYNAME(tax.FISCAL_DATE) IN (''Sat'',''Sun'')
         THEN TRUE ELSE FALSE END                           as ""Is Weekend""
  --Flags---------------------------------------------------------------------------------------------------
      ,tax.IS_TAX_INCLUDED::BOOLEAN                         as ""Is Tax Included""
  --Descriptors----------------------------------------------------------------------------------------------
      ,IFNULL(tax.CHEQUENUMBER ,''None'')                    as ""Check""
      ,IFNULL(med.MENUITEMNAME,'' None'')                    as ""Menu Item""
      ,IFNULL(ord.ORDER_TYPE,'' None'')                      as ""Order Type""
      ,IFNULL(tax.TAXRATENAME,'' None'')                     as ""Rate Name""
  --Facts-----------------------------------------------------------------------------------------------------
      ,1::NUMBER(18,0)                                      as ""Count""
      ,CASE WHEN split_part(tax.tax_fact_nk, ''.'',  3)  = 0
        THEN itf.GROSS::NUMBER(18,2)
        ELSE NULL::NUMBER(18,2)
        END
                                                            as ""Gross""
      ,CASE WHEN split_part(tax.tax_fact_nk, ''.'',  3)  = 0
        THEN itf.APPLIEDAMOUNT::NUMBER(18,2)
        ELSE NULL::NUMBER(18,2)
        END
                                                            as ""Applied Amount""
      ,(CASE WHEN ABS(tax.AMOUNT - (itf.GROSS * (tax.PERCENT/100))) < 0.009
        THEN itf.GROSS
        ELSE itf.APPLIEDAMOUNT END) ::NUMBER(18,2)          as ""Tax Basis Amount""
      ,tax.AMOUNT::NUMBER(18,2)                             as ""Tax Amount""
      ,tax.AMOUNT::NUMBER(18,2)                             as ""Tax Total""
      ,tax.PERCENT::NUMBER(18,2)                            as ""Tax Percent""
  ----------------------------------------------------------------------------------------------------------------
  FROM DATAWAREHOUSE.TAX_FACT                               tax
       INNER JOIN DATAWAREHOUSE.ITEM_FACT                   itf
          ON itf.ITEM_FACT_NK = tax.ITEM_FACT_FK
            AND itf.DW_ISCURRENTROW
            AND tax.ITEMSTATUS IN (''Added'',''Sent'')
            AND tax.CHECKSTATUS = ''Closed''
            AND tax.OPENED_AT is not null
            AND tax.DW_ISCURRENTROW
            AND NOT tax.DW_ISDELETED
            AND NOT tax.IS_TRAINING
            AND tax.FISCAL_DATE::date
                >= :startdate::date
            AND tax.FISCAL_DATE::date
                <= :enddate::date
            AND tax.LOCATION_DIM_FK IN (
               SELECT table1.value
                    FROM table(split_to_table(:locationidS, '',''))  table1)
        INNER JOIN DATAWAREHOUSE.LOCATION_DIM                 loc
          ON tax.LOCATION_DIM_FK = loc.LOCATION_DIM_NK
            AND loc.DW_ISCURRENTROW
        INNER JOIN DATAWAREHOUSE.MENUITEMNAME_DIM             med
         ON med.MENUITEMNAME_DIM_NK = tax.MENUITEMNAME_DIM_FK
           AND med.DW_ISCURRENTROW
        INNER JOIN DATAWAREHOUSE.ORDERTYPE_DIM                ord
          ON ord.ORDERTYPE_DIM_NK = tax.ORDERTYPE_DIM_FK
            AND ord.DW_ISCURRENTROW
        INNER JOIN DATAWAREHOUSE.ORGANIZATION_DIM             org
          ON org.ORGANIZATION_DIM_NK = loc.ORGANIZATION_DIM_FK
            AND org.DW_ISCURRENTROW
        INNER JOIN DATAWAREHOUSE.DAYPART_DIM                  dad
          ON tax.DAYPART_DIM_FK = dad.DAYPART_DIM_NK
            AND dad.DW_ISCURRENTROW
        INNER JOIN DATAWAREHOUSE.REPORTCATEGORY_DIM           meg
          ON med.REPORTCATEGORY_DIM_FK = meg.REPORTCATEGORY_DIM_NK
            AND meg.DW_ISCURRENTROW
      INNER JOIN DATAWAREHOUSE.COGSCATEGORY_DIM               ccd
          ON ccd.COGSCATEGORY_DIM_NK = meg.COGSCATEGORY_DIM_FK
            AND ccd.DW_ISCURRENTROW
  -- This QUALIFY clause removes duplicates by keeping only the latest record for each tax entry
  QUALIFY ROW_NUMBER() OVER(PARTITION BY tax.CHEQUE_FACT_FK,tax.ITEM_FACT_FK ORDER BY tax.MTLN_CDC_SEQUENCE_NUMBER DESC) = 1;

-------------------------------------------------------------------------------------------------------------
SELECT
     FEETAX_FACT_NK                                          as ""Support ID""
     ,tax.MTLN_CDC_SEQUENCE_NUMBER                           as ""MTLN_CDC_SEQUENCE_NUMBER""
     , ''FEE-'' ||row_number() over (order by FEETAX_FACT_NK)
                                                             as ""Detail ID""
    ,tax.CHEQUE_FACT_FK AS ""CHEQUE_FACT_FK""
    ,null                                 as ""ITEM_FACT_FK""
--Status, category, level------------------------------------------------------------------------------------
    ,IFNULL(chk.STATUS,''None'')                               as ""Check Status""
    ,''None''                                                  as ""Item Status""
    ,''None''                                                  as ""Category""
--Geography----------------------------------------------------------------------------------------------
    ,IFNULL(org.ORGANIZATION,''None'')                         as ""Organization""
    ,IFNULL(loc.LOCATIONNAME,''None'')                         as ""Location""
    ,loc.LOCATION_DIM_NK                                     as ""Location ID""
    ,IFNULL(chk.REVENUECENTERNAME,''None'')                    as ""Revenue Center""
--Dates---------------------------------------------------------------------------------------------------
   ,LOC.TZ_NAME                                              as ""Time Zone""
    ,to_char(LEFT(tax.FISCAL_DATE,4))                        as ""Year""
    ,to_char(YEAR(tax.FISCAL_DATE)) || ''|''
        || TO_CHAR(RIGHT(''0'' || MONTH(tax.FISCAL_DATE),2))
                                                             as ""Year and Month""
    ,IFNULL(dad.DAYPART,''None'')                              as ""Daypart""
    ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,
       chk.CLOSED_AT::timestamp_ntz )::timestamp)
                                                             as ""Closed At""
    ,to_char(chk.FISCAL_DATE)                                as ""Fiscal Date""
    ,IFNULL(DAYNAME(chk.FISCAL_DATE),''None'')                 as ""Day of Week""
    ,CASE WHEN DAYNAME(chk.FISCAL_DATE) IN (''Sat'',''Sun'')
       THEN TRUE ELSE FALSE END                              as ""Is Weekend""
--Flags---------------------------------------------------------------------------------------------------
    ,tax.IS_TAXINCLUDED::BOOLEAN                             as ""Is Tax Included""
--Descriptors----------------------------------------------------------------------------------------------
    ,IFNULL(tax.CHEQUENUMBER ,''None'')                        as ""Check""
    ,''None''                                                  as ""Menu Item""
    ,IFNULL(ord.ORDER_TYPE,'' None'')                          as ""Order Type""
    ,IFNULL(tax.TAXRATENAME,'' None'')                         as ""Rate Name""
--Facts-----------------------------------------------------------------------------------------------------
    ,1::NUMBER(18,0)                                         as ""Count""
    ,0::NUMBER(18,0)                                         as ""Gross""
    ,tax.APPLIEDAMOUNT::NUMBER(18,2)                         as ""Applied Amount""
    ,tax.TAXBASIS ::NUMBER(18,2)                             as ""Tax Basis Amount""
    ,tax.TAX::NUMBER(18,2)                                   as ""Tax Amount""
    ,tax.TAX::NUMBER(18,2)                                   as ""Tax Total""
    ,tax.PERCENT::NUMBER(18,2)                               as ""Tax Percent""
----------------------------------------------------------------------------------------------------------------
FROM DATAWAREHOUSE.FEETAX_FACT                               tax
     INNER JOIN DATAWAREHOUSE.CHEQUE_FACT                    chk
        ON chk.CHEQUE_FACT_NK = tax.CHEQUE_FACT_FK
          AND chk.TAX > 0.000
          AND chk.STATUS = ''Closed''
          AND chk.OPENED_AT is not null
          AND chk.DW_ISCURRENTROW
          AND tax.DW_ISCURRENTROW
          AND NOT tax.DW_ISDELETED
          AND NOT tax.IS_TRAINING
          AND tax.FISCAL_DATE::date
              >= :startdate::date
          AND tax.FISCAL_DATE::date
              <= :enddate::date
          AND tax.LOCATION_DIM_FK IN (
             SELECT table1.value
                  FROM table(split_to_table(:locationidS, '',''))  table1)
      INNER JOIN DATAWAREHOUSE.LOCATION_DIM                 loc
        ON tax.LOCATION_DIM_FK = loc.LOCATION_DIM_NK
          AND loc.DW_ISCURRENTROW
      INNER JOIN DATAWAREHOUSE.ORDERTYPE_DIM                ord
        ON ord.ORDERTYPE_DIM_NK = chk.ORDERTYPE_DIM_FK
          AND ord.DW_ISCURRENTROW
      INNER JOIN DATAWAREHOUSE.ORGANIZATION_DIM             org
        ON org.ORGANIZATION_DIM_NK = loc.ORGANIZATION_DIM_FK
          AND org.DW_ISCURRENTROW
      INNER JOIN DATAWAREHOUSE.DAYPART_DIM                  dad
        ON tax.DAYPART_DIM_FK = dad.DAYPART_DIM_NK
          AND dad.DW_ISCURRENTROW         
    ;

    CREATE TEMP TABLE temp_feetax AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));
-------------------------------------------------------------------------------------------------------------
 reportSet:= (
select * from temp_itemtax
  union
select * from temp_feetax
--==============================================================================================================
);
RETURN TABLE(reportSet);
END;
';"
PROCEDURE,DATAADMIN,SP_STAGELOADLOCATIONGROUP_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADLOCATIONGROUP_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.LOCATIONGROUP_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.LOCATIONGROUP_DIM(   
          LOCATIONGROUP_DIM_NK, 
          LOCATIONGROUP, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          ORGANIZATION_DIM_FK, 
          IS_DEFAULT, 
          CREATED_AT, 
          UPDATED_AT, 
          TYPE 
) 
 SELECT   LOCATIONGROUP_DIM_NK  as   LOCATIONGROUP_DIM_NK,  
   LOCATIONGROUP  as   LOCATIONGROUP,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   ORGANIZATION_DIM_FK  as   ORGANIZATION_DIM_FK,  
   IS_DEFAULT  as   IS_DEFAULT,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   TYPE  as   TYPE 
  FROM DATAADMIN.LOCATIONGROUP_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''LOCATIONGROUP_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''LOCATIONGROUP_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADMERCHANT_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADMERCHANT_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.MERCHANT_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.MERCHANT_DIM(   
          MERCHANT_DIM_NK, 
          MERCHANT, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          IS_GIFTCARDDISABED, 
          CREATED_AT, 
          UPDATED_AT, 
          GIFTCARD_CREDIT_CEILING, 
          GIFTCARD_DEBIT_CEILING, 
          GIFTCARD_CREDIT_FLOOR 
) 
 SELECT   MERCHANT_DIM_NK  as   MERCHANT_DIM_NK,  
   MERCHANT  as   MERCHANT,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   IS_GIFTCARDDISABED  as   IS_GIFTCARDDISABED,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   GIFTCARD_CREDIT_CEILING  as   GIFTCARD_CREDIT_CEILING,  
   GIFTCARD_DEBIT_CEILING  as   GIFTCARD_DEBIT_CEILING,  
   GIFTCARD_CREDIT_FLOOR  as   GIFTCARD_CREDIT_FLOOR 
  FROM DATAADMIN.MERCHANT_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''MERCHANT_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''MERCHANT_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADPAYINOUT_FACT(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADPAYINOUT_FACT""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.PAYINOUT_FACT),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.PAYINOUT_FACT(   
          PAYINOUT_FACT_NK, 
          PAYID, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          CCTRANSATION_FACT_FK, 
          PAYMENTMETHOD_DIM_FK, 
          PAYINPAYOUTREASON_DIM_FK, 
          SHIFT_DIM_FK, 
          IS_VOID, 
          VOIDED_AT, 
          CREATED_AT, 
          UPDATED_AT, 
          STATUS, 
          VOIDED_BY, 
          NOTES, 
          CC_TRANSACTION_ID, 
          PAY_IN_OUT_REASON_ID, 
          SHIFT_ID, 
          AMOUNT 
) 
 SELECT   PAYINOUT_FACT_NK  as   PAYINOUT_FACT_NK,  
   PAYID  as   PAYID,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   CCTRANSATION_FACT_FK  as   CCTRANSATION_FACT_FK,  
   PAYMENTMETHOD_DIM_FK  as   PAYMENTMETHOD_DIM_FK,  
   PAYINPAYOUTREASON_DIM_FK  as   PAYINPAYOUTREASON_DIM_FK,  
   SHIFT_DIM_FK  as   SHIFT_DIM_FK,  
   IS_VOID  as   IS_VOID,  
   VOIDED_AT  as   VOIDED_AT,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   STATUS  as   STATUS,  
   VOIDED_BY  as   VOIDED_BY,  
   NOTES  as   NOTES,  
   CC_TRANSACTION_ID  as   CC_TRANSACTION_ID,  
   PAY_IN_OUT_REASON_ID  as   PAY_IN_OUT_REASON_ID,  
   SHIFT_ID  as   SHIFT_ID,  
   AMOUNT  as   AMOUNT 
  FROM DATAADMIN.PAYINOUT_FACT
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''PAYINOUT_FACT'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''PAYINOUT_FACT'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,"SP_DATASHARE_CRAFTABLE_GRATUITIES(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_DATASHARE_CRAFTABLE_GRATUITIES""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE
  reportSet resultset;
--   startdate timestamp_tz      := ''2020-08-20T14:48:37.661Z'';
--   enddate timestamp_tz        := ''2029-08-20T14:48:37.661Z'';
--   locationid string           := ''[37,7,1,35,9,38,32,27,13,4,41,29,43,11,21,25,3,6,39]'';
  locationidS string          :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
  today char(11)              := CURRENT_DATE()::date::VARCHAR(10);
-----------------------------------------------------------------------------------------------------------------------
BEGIN
-----------------------------------------------------------------------------------------------------------------------
     reportSet := (
         SELECT 
            ORG.ORGANIZATION                             AS ""Organization Name""
            ,ORG.ORGANIZATION_DIM_NK                     AS ""Organization ID""
            ,LOC.LOCATIONNAME                            AS ""Location Name""
            ,SF.LOCATION_DIM_FK                          AS ""Location ID""
            ,CHK.FISCAL_DATE::DATE                       AS ""Business Day""
            ,CHK.CHEQUENUMBER                             as ""Check Number""
            ,SF.CHEQUE_FACT_FK                           as ""Check ID""
            ,SF.IS_GRATUITY                              as ""Is Gratuity Flag""
            ,SD.SURCHARGE                                as ""Gratuity Name""
            ,SF.SURCHARGE_FACT_NK                        as ""Gratuity ID""
            ,IFNULL(SF.APPLIEDAMOUNT,0)                  as ""Gratuity Amount""
            ,IFNULL(emd.EMPLOYEE_NAME,''None'')            as ""Employee for Gratuity""
            --for debugging:
            -- ,SF.MTLN_CDC_SEQUENCE_NUMBER                  as ""MTLN_CDC_SEQUENCE_NUMBER""
            -- ,SUM(IFNULL(SF.APPLIEDAMOUNT,0)) OVER()      as ""Total Applied Amount""
            -- ,SUM(IFNULL(SF.AMOUNT,0)) OVER()             as ""Total Amount""
            -- ,COUNT(SF.SURCHARGE_FACT_NK) OVER()          as ""Count Surcharge NKs""
            -- ,COUNT(DISTINCT SF.SURCHARGE_FACT_NK) OVER() as ""Count DISTINCT Surcharge NKs""
         ---------------------------------------------------------------------------------------------------------------
         FROM DATAWAREHOUSE.SURCHARGE_FACT SF
         INNER JOIN DATAWAREHOUSE.CHEQUE_FACT CHK
            ON SF.CHEQUE_FACT_FK = CHK.CHEQUE_FACT_NK
            AND SF.MTLN_CDC_SEQUENCE_NUMBER = CHK.MTLN_CDC_SEQUENCE_NUMBER
            -- AND SF.DW_ISCURRENTROW --instead of filtering on current row. we join con sequence number
            AND SF.IS_GRATUITY
            AND NOT SF.DW_ISDELETED 
            AND NOT SF.IS_TRAINING
            AND SF.STATUS in (''Enabled'')
            AND CHK.DW_ISCURRENTROW
            AND NOT CHK.IS_TRAINING
            AND NOT CHK.IS_VOID
            AND NOT CHK.DW_ISDELETED
            AND CHK.STATUS IN (''Closed'')
            AND SF.LOCATION_DIM_FK IN (--351,352
                SELECT table1.value 
                      FROM table(split_to_table(:locationidS, '',''))  table1)
            AND (chk.FISCAL_DATE::date >= :startdate::date 
                  AND chk.FISCAL_DATE::date  <= :enddate::date)
         INNER JOIN DATAWAREHOUSE.SURCHARGE_DIM SD
            ON SF.SURCHARGE_DIM_NK = SD.SURCHARGE_DIM_NK
            AND SD.DW_ISCURRENTROW
         INNER JOIN DATAWAREHOUSE.EMPLOYEE_DIM                     emd
            ON SF.EMPLOYEE_DIM_FK = emd.employee_dim_Nk
            AND emd.DW_ISCURRENTROW 
        INNER JOIN DATAWAREHOUSE.LOCATION_DIM LOC
            ON SF.LOCATION_DIM_FK = LOC.LOCATION_DIM_NK
            AND LOC.DW_ISCURRENTROW
        INNER JOIN DATAWAREHOUSE.ORGANIZATION_DIM ORG
            ON LOC.ORGANIZATION_DIM_FK = ORG.ORGANIZATION_DIM_NK
            AND ORG.DW_ISCURRENTROW
         
         WHERE 1=1 
            AND SF.IS_GRATUITY
            -- AND SF.CHEQUE_FACT_FK = 166174
     );
--=====================================================================================================================
RETURN TABLE(reportSet);
END';"
PROCEDURE,DATAADMIN,SP_LOADDIMENSIONNONEROW_ALL(),"CREATE OR REPLACE PROCEDURE ""SP_LOADDIMENSIONNONEROW_ALL""()
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
    SQLStmt resultset;
    ScriptIns varchar;
    SQLTextOut varchar;
    SQLIns varchar;
    SCRIPT resultset;
    BIGSCRIPTS resultset;

-----------------------------------------------------------------------------------------------------------
BEGIN
   --drop temp tables if they exist
   drop table if exists dwtable_lists; 
   drop table if exists dwtable_scripts; 

   create temp table dwtable_scripts (
     name varchar (100) 
     ,scripttext varchar
  );

   --create a table containing rows with the call statements to create the load stored procedures
   SELECT 
     REPLACE(''CALL DATAADMIN.SP_LOADDIMENSIONNONEROW(\\''<TABLENAME>\\'')''
       ,''<TABLENAME>'',TABLE_NAME) AS sqltext
     FROM information_schema.tables t
   WHERE TABLE_SCHEMA = ''DATAWAREHOUSE''
     AND TABLE_TYPE = ''BASE TABLE''
     --AND TABLE_NAME IN (''EMPLOYEE_DIM'',''ACTIVITY_FACT'')--WORKS ERROR MESSAGES ONLY
     --AND TABLE_NAME IN (''LOCATION_DIM'',''SHIFT_DIM'')  --WORKS LOAD STMTS ONLY
     --AND TABLE_NAME IN (''EMPLOYEE_DIM'',''LOCATION_DIM'')
     AND TABLE_NAME ILIKE ''%_DIM''
     AND TABLE_NAME NOT IN  (''DATASHARETEST_DIM'',''DATE_DIM'',''ORDER_SUMMARY'',''ERRORDWDATE_DIM'')
 ;
   
   CREATE temp TABLE dwtable_lists AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

  SQLStmt := (select * from dwtable_lists);
--CALL DATAADMIN.SP_LOADDIMENSIONNONEROW(''EMPLOYEE_DIM'')
  --loop through all rows that create the load stored proceedure 1 per table
      BEGIN
          FOR record IN SQLStmt DO
            SQLTextOut := record.sqltext;
            SCRIPT := (EXECUTE IMMEDIATE record.sqltext);           
            ScriptIns := (SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID())));
            INSERT INTO dwtable_scripts(scripttext)    
                VALUES(:ScriptIns);   --works       
          END FOR;
     END;

  BIGSCRIPTS := (SELECT listagg(scripttext) from dwtable_scripts);   
  RETURN TABLE(BIGSCRIPTS);
  
END';"
PROCEDURE,DATAADMIN,"SP_LOAD_365_TILL(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_365_TILL""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2020-08-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2029-08-20T14:48:37.661Z''; 
  -- locationid string      := ''[2,3,4,351,352]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--==================================================================================================================================
BEGIN
--==================================================================================================================================
--ISSUE
-- business day is supposed to be fiscal day, but is formatted with hours, minutes, and seconds
-- we used to send open amount, but there is no field for that column
--==================================================================================================================================
reportSet := (  
------------------------------------------------------------------------------------------------------------------------------------
SELECT TO_CHAR(TO_TIMESTAMP(SHD.FISCAL_DAY),''MM/DD/YYYY HH24:MI:SS'') AS BusinessDate  --* DateTime(mm/dd/yyyy hh:mm:ss)
    ,CBD.CASHBANK_DIM_NK                                             AS DrawerNumber  --* string
    ,CBD.OPEN_AMOUNT::DECIMAL(20,2)                                 AS ExpectedAmount  --*decimal
    FROM DATAWAREHOUSE.CASHBANK_DIM            CBD
      INNER JOIN DATAWAREHOUSE.SHIFT_DIM       SHD
        ON CBD.SHIFT_DIM_FK = SHD.SHIFT_DIM_NK
          AND SHD.DW_ISCURRENTROW
          AND CBD.DW_ISCURRENTROW
          AND SHD.fiscal_day::date
            >= :startdate::date  
          AND  SHD.fiscal_day::date  
            <= :enddate::date    
          AND SHD.LOCATION_DIM_FK IN ( SELECT table1.value 
            FROM table(split_to_table(:locationidS, '',''))  table1)    
--==================================================================================================================================
);
RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,"SP_LOAD_DATASHARE_CRAFTABLE_PAYMENT(VARCHAR, VARCHAR, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_DATASHARE_CRAFTABLE_PAYMENT""(""START_DATE"" VARCHAR, ""END_DATE"" VARCHAR, ""LOCATION_IDS"" VARCHAR)
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS CALLER
AS 'BEGIN
    -- Execute the source procedure that returns the data
    CALL DATAADMIN.SP_DATASHARE_CRAFTABLE_PAYMENTS(:START_DATE, :END_DATE, :LOCATION_IDS);

    -- Insert the results into the target table
    INSERT INTO DATASHARE_DEV.CRAFTABLE_PAYMENT (
        ""Organization Name"",
        ""Organization ID"",
        ""Location Name"",
        ""Location ID"",
        ""Business Day"",
        ""Check ID"",
        ""Tender Type"",
        ""Tender Name"",
        ""Tender Amount"",
        ""Cardholder Name"",
        ""Cender Number (last 4)""
    )
    SELECT
        ""Organization Name"",
        ""Organization ID"",
        ""Location Name"",
        ""Location ID"",
        ""Business Day"",
        ""Check ID"",
        ""Tender Type"",
        ""Tender Name"",
        ""Tender Amount"",
        ""Cardholder Name"",
        ""Cender Number (last 4)""
    FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

    RETURN ''Success: Data loaded into DATASHARE_DEV.CRAFTABLE_PAYMENT.'';
END';"
PROCEDURE,DATAADMIN,SP_STAGELOADEMPLOYEE_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADEMPLOYEE_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.EMPLOYEE_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.EMPLOYEE_DIM(   
          EMPLOYEE_DIM_NK, 
          EMPLOYEE_NAME, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          ORGANIZATION_DIM_FK, 
          IS_DISABLED, 
          IS_TRAINING, 
          TERMINATE_DATE, 
          BIRTH_DATE, 
          CREATED_AT, 
          UPDATED_AT, 
          FIRST_NAME, 
          LAST_NAME, 
          IMPORT_GUID, 
          SYSTEM_ID, 
          PAYROLL_ID, 
          PIN, 
          EMAIL, 
          INITIALS, 
          NICKNAME, 
          UI_COLOR, 
          CARD_CODE, 
          AVATAR, 
          GENDER, 
          FLSA_STATUS 
) 
 SELECT   EMPLOYEE_DIM_NK  as   EMPLOYEE_DIM_NK,  
   EMPLOYEE_NAME  as   EMPLOYEE_NAME,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   ORGANIZATION_DIM_FK  as   ORGANIZATION_DIM_FK,  
   IS_DISABLED  as   IS_DISABLED,  
   IS_TRAINING  as   IS_TRAINING,  
   TERMINATE_DATE  as   TERMINATE_DATE,  
   BIRTH_DATE  as   BIRTH_DATE,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   FIRST_NAME  as   FIRST_NAME,  
   LAST_NAME  as   LAST_NAME,  
   IMPORT_GUID  as   IMPORT_GUID,  
   SYSTEM_ID  as   SYSTEM_ID,  
   PAYROLL_ID  as   PAYROLL_ID,  
   PIN  as   PIN,  
   EMAIL  as   EMAIL,  
   INITIALS  as   INITIALS,  
   NICKNAME  as   NICKNAME,  
   UI_COLOR  as   UI_COLOR,  
   CARD_CODE  as   CARD_CODE,  
   AVATAR  as   AVATAR,  
   GENDER  as   GENDER,  
   FLSA_STATUS  as   FLSA_STATUS 
  FROM DATAADMIN.EMPLOYEE_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''EMPLOYEE_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''EMPLOYEE_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADINTEGRATION_FACT(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADINTEGRATION_FACT""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.INTEGRATION_FACT),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.INTEGRATION_FACT(   
          INTEGRATION_FACT_NK, 
          INTEGRATION_ID, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          INTEGRATIONTYPE_DIM_FK, 
          LOCATION_DIM_FK, 
          LOCATIONGGROUP_DIM_FK, 
          CREATED_AT, 
          UPDATED_AT 
) 
 SELECT   INTEGRATION_FACT_NK  as   INTEGRATION_FACT_NK,  
   INTEGRATION_ID  as   INTEGRATION_ID,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   INTEGRATIONTYPE_DIM_FK  as   INTEGRATIONTYPE_DIM_FK,  
   LOCATION_DIM_FK  as   LOCATION_DIM_FK,  
   LOCATIONGGROUP_DIM_FK  as   LOCATIONGGROUP_DIM_FK,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT 
  FROM DATAADMIN.INTEGRATION_FACT
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''INTEGRATION_FACT'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''INTEGRATION_FACT'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADITEMMODIFIER_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADITEMMODIFIER_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.ITEMMODIFIER_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.ITEMMODIFIER_DIM(   
          ITEMMODIFIER_DIM_NK, 
          MODIFICATION_ID, 
          DW_STARTDATE, 
          FISCALDATE, 
          DW_ENDDATE, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISDELETED, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          CHEQUE_FACT_FK, 
          DAYPART_DIM_FK, 
          EMPLOYEE_DIM_FK, 
          ITEM_FACT_FK, 
          LOCATION_DIM_FK, 
          MODIFIERGROUP_DIM_FK, 
          MODIFIER_DIM_FK, 
          IS_TRAINING, 
          CREATED_AT, 
          FISCAL_DATE, 
          OPENED_AT, 
          UPDATED_AT, 
          CHEQUESTATUS, 
          MODIFIER_GROUP, 
          MODIFIER, 
          MODIFIER_TYPE, 
          REVENUECENTERNAME, 
          ROUNDINGMETHOD, 
          CHEQUENUMBER, 
          PRICE 
) 
 SELECT   ITEMMODIFIER_DIM_NK  as   ITEMMODIFIER_DIM_NK,  
   MODIFICATION_ID  as   MODIFICATION_ID,  
   DW_STARTDATE  as   DW_STARTDATE,  
   FISCALDATE  as   FISCALDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISDELETED  as   DW_ISDELETED,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   CHEQUE_FACT_FK  as   CHEQUE_FACT_FK,  
   DAYPART_DIM_FK  as   DAYPART_DIM_FK,  
   EMPLOYEE_DIM_FK  as   EMPLOYEE_DIM_FK,  
   ITEM_FACT_FK  as   ITEM_FACT_FK,  
   LOCATION_DIM_FK  as   LOCATION_DIM_FK,  
   MODIFIERGROUP_DIM_FK  as   MODIFIERGROUP_DIM_FK,  
   MODIFIER_DIM_FK  as   MODIFIER_DIM_FK,  
   IS_TRAINING  as   IS_TRAINING,  
   CREATED_AT  as   CREATED_AT,  
   FISCAL_DATE  as   FISCAL_DATE,  
   OPENED_AT  as   OPENED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   CHEQUESTATUS  as   CHEQUESTATUS,  
   MODIFIER_GROUP  as   MODIFIER_GROUP,  
   MODIFIER  as   MODIFIER,  
   MODIFIER_TYPE  as   MODIFIER_TYPE,  
   REVENUECENTERNAME  as   REVENUECENTERNAME,  
   ROUNDINGMETHOD  as   ROUNDINGMETHOD,  
   CHEQUENUMBER  as   CHEQUENUMBER,  
   PRICE  as   PRICE 
  FROM DATAADMIN.ITEMMODIFIER_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''ITEMMODIFIER_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''ITEMMODIFIER_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADMENUITEM_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADMENUITEM_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.MENUITEM_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.MENUITEM_DIM(   
          MENUITEM_DIM_NK, 
          SKU, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          ORGANIZATION_DIM_FK, 
          MENUITEMNAME_DIM_FK, 
          VARIANT_DIM_FK, 
          CREATED_AT, 
          UPDATED_AT, 
          UPC, 
          VARIANT_OPTION_ID, 
          CALORIES, 
          COST, 
          PRICE 
) 
 SELECT   MENUITEM_DIM_NK  as   MENUITEM_DIM_NK,  
   SKU  as   SKU,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   ORGANIZATION_DIM_FK  as   ORGANIZATION_DIM_FK,  
   MENUITEMNAME_DIM_FK  as   MENUITEMNAME_DIM_FK,  
   VARIANT_DIM_FK  as   VARIANT_DIM_FK,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   UPC  as   UPC,  
   VARIANT_OPTION_ID  as   VARIANT_OPTION_ID,  
   CALORIES  as   CALORIES,  
   COST  as   COST,  
   PRICE  as   PRICE 
  FROM DATAADMIN.MENUITEM_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''MENUITEM_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''MENUITEM_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADREPORTCATEGORY_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADREPORTCATEGORY_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.REPORTCATEGORY_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.REPORTCATEGORY_DIM(   
          REPORTCATEGORY_DIM_NK, 
          REPORTCATEGORY, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          COGSCATEGORY_DIM_FK, 
          ORGANIZATION_DIM_FK, 
          CREATED_AT, 
          UPDATED_AT 
) 
 SELECT   REPORTCATEGORY_DIM_NK  as   REPORTCATEGORY_DIM_NK,  
   REPORTCATEGORY  as   REPORTCATEGORY,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   COGSCATEGORY_DIM_FK  as   COGSCATEGORY_DIM_FK,  
   ORGANIZATION_DIM_FK  as   ORGANIZATION_DIM_FK,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT 
  FROM DATAADMIN.REPORTCATEGORY_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''REPORTCATEGORY_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''REPORTCATEGORY_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,"FILTERBYROLE(VARCHAR, VARCHAR)","CREATE OR REPLACE PROCEDURE ""FILTERBYROLE""(""TABLENAME"" VARCHAR(16777216), ""ROLE"" VARCHAR(16777216))
RETURNS TABLE (""TESTTEXT"" VARCHAR(16777216))
LANGUAGE PYTHON
RUNTIME_VERSION = '3.8'
PACKAGES = ('snowflake-snowpark-python')
HANDLER = 'filter_by_role'
EXECUTE AS OWNER
AS '
from snowflake.snowpark.functions import col

def filter_by_role(session, table_name, role):
   df = session.table(table_name)
   #return df.filter(col(""role"") == role)
   return df
';"
PROCEDURE,DATAADMIN,"GET_TOP_10_DUPLICATE_ROWS_2(VARCHAR, VARCHAR, ARRAY, BOOLEAN)","CREATE OR REPLACE PROCEDURE ""GET_TOP_10_DUPLICATE_ROWS_2""(""DB_NAME"" VARCHAR, ""SCHEMA_NAME"" VARCHAR, ""TARGET_TABLES"" ARRAY, ""EVALUATE_PK"" BOOLEAN)
RETURNS TABLE (""DATABASE_NAME"" VARCHAR, ""SCHEMA_NAME"" VARCHAR, ""TABLE_NAME"" VARCHAR, ""MTLN_CDC_LOAD_TIMESTAMP"" TIMESTAMP_LTZ(9), ""ROW_DATA"" VARIANT)
LANGUAGE SQL
EXECUTE AS OWNER
AS '
DECLARE
    --  Changed to a temporary table to hold both tables and views
    object_list CURSOR FOR SELECT ""name"" FROM temp_object_list;
    table_name VARCHAR;
    column_list VARCHAR;
    dynamic_sql VARCHAR;
    info_schema_path VARCHAR;
    schema_identifier VARCHAR;
    evaluate_pk_effective BOOLEAN;
    final_results RESULTSET;

BEGIN
    -- Create a temporary table to hold results from SHOW commands
    CREATE OR REPLACE TEMPORARY TABLE temp_object_list (""name"" VARCHAR);
    
    CREATE OR REPLACE TEMPORARY TABLE temp_duplicate_results (
        DATABASE_NAME VARCHAR,
        SCHEMA_NAME VARCHAR,
        TABLE_NAME VARCHAR,
        MTLN_CDC_LOAD_TIMESTAMP TIMESTAMP_LTZ,
        ROW_DATA VARIANT
    );

    evaluate_pk_effective := COALESCE(:EVALUATE_PK, TRUE);
    schema_identifier := :DB_NAME || ''.'' || :SCHEMA_NAME;

    --  Step 1: Get all tables and insert into the temp list
    SHOW TABLES IN SCHEMA IDENTIFIER(:schema_identifier);
    INSERT INTO temp_object_list (""name"")
    SELECT ""name"" FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

    --  Step 2: Get all views and insert into the temp list
    SHOW VIEWS IN SCHEMA IDENTIFIER(:schema_identifier);
    INSERT INTO temp_object_list (""name"")
    SELECT ""name"" FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));


    --  Step 3: Loop through the combined list of objects
    FOR rec IN object_list DO
        table_name := rec.""name"";

        IF (TARGET_TABLES IS NULL OR ARRAY_SIZE(TARGET_TABLES) = 0 OR ARRAY_CONTAINS(:table_name::VARIANT, TARGET_TABLES)) THEN

            info_schema_path := :DB_NAME || ''.INFORMATION_SCHEMA.COLUMNS'';

            SELECT
                LISTAGG(IFF(REGEXP_LIKE(column_name, ''^[a-zA-Z0-9_]+$''), column_name, ''""'' || column_name || ''""''), '', '')
            INTO column_list
            FROM IDENTIFIER(:info_schema_path)
            WHERE
                table_schema = :SCHEMA_NAME
                AND table_name = :table_name
                AND (:evaluate_pk_effective = TRUE OR NOT ENDSWITH(UPPER(column_name), ''_PK''));

            IF (column_list IS NOT NULL AND column_list != '''') THEN
                dynamic_sql := ''
                    INSERT INTO temp_duplicate_results (DATABASE_NAME, SCHEMA_NAME, TABLE_NAME, MTLN_CDC_LOAD_TIMESTAMP, ROW_DATA)
                    SELECT
                        '''''' || DB_NAME || '''''',
                        '''''' || SCHEMA_NAME || '''''',
                        '''''' || table_name || '''''',
                        MTLN_CDC_LOAD_TIMESTAMP,
                        OBJECT_CONSTRUCT(*)
                    FROM (
                        SELECT *, COUNT(*) OVER (PARTITION BY '' || column_list || '') as dup_count
                        FROM '' || DB_NAME || ''.'' || SCHEMA_NAME || ''.""'' || table_name || ''""
                    )
                    WHERE dup_count > 1;
                '';

                EXECUTE IMMEDIATE dynamic_sql;
            END IF;
        END IF;
    END FOR;

    final_results := (
        SELECT DATABASE_NAME, SCHEMA_NAME, TABLE_NAME, MTLN_CDC_LOAD_TIMESTAMP, ROW_DATA
        FROM temp_duplicate_results
        ORDER BY MTLN_CDC_LOAD_TIMESTAMP DESC
        LIMIT 10
    );

    RETURN TABLE(final_results);

END;
';"
PROCEDURE,DATAADMIN,"SP_ACCOUNTINGSUMMARY_PAYMENTS_TOP(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_ACCOUNTINGSUMMARY_PAYMENTS_TOP""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet           resultset;
  -- startdate string    := ''2025-06-11'';  
  -- enddate string      := ''2025-06-11''; 
  -- locationid string   := ''[351]'';
  locationidS string  :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--=========================================================================================
BEGIN
  DROP TABLE IF EXISTS TEMP_TABLE1;

------------------------------------------------------------------------------------------------  
CALL DATAADMIN.SP_REPORT_ACCOUNTSUMMARY_PAYMENTS(:startdate,:enddate,:locationid);
CREATE TEMP TABLE TEMP_TABLE1 AS SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

SELECT  ROW_NUMBER() OVER (ORDER BY ""Location ID"") AS ""Support ID""     
        ,""Location ID""                             AS ""Location ID""
       ,""Group 1""                                  AS ""Group 1""
       ,""Group 2""                                  AS ""Group 2""
       ,SUM(""Count"")                               AS ""Count""
       ,SUM(""Tips"")                                AS ""Tips""
       ,SUM(""Sales"")                               AS ""Sales""
       ,SUM(""Pay In"")                              AS ""Pay In""
       ,SUM(""Deposit"")                             AS ""Deposit""
       ,SUM(""Total"")                               AS ""Total"" 
    FROM TEMP_TABLE1
      WHERE ""Group 1"" <> ''Total Payments''
    GROUP BY ""Group 1"",""Group 2"",""Location ID""
    ORDER BY ""Location ID"",""Group 1"",""Group 2""
;    

--=========================================================================================
 reportSet:= (
   SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))
);

--===========================================================================================
RETURN TABLE(reportSet); 

END';"
PROCEDURE,DATAADMIN,SP_DAG_DATASHARE_CRAFTABLE_LOAD_TABLES(),"CREATE OR REPLACE PROCEDURE ""SP_DAG_DATASHARE_CRAFTABLE_LOAD_TABLES""()
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS OWNER
AS '
DECLARE
    -- Runtime metadata
    run_metadata VARIANT;
    parent_query_id VARCHAR;
    task_run_group_id VARCHAR;
    attempt_number NUMBER;
    session_id VARCHAR;
    task_name VARCHAR;

    -- Log variable
    LOGS VARCHAR DEFAULT ''Execution Log:\\n''; --to debug, you can add variables to the log and then return it. for example: LOGS := LOGS || ''target_table_name: '' || COALESCE(:target_table_name, ''NULL'') || ''\\n'';

    -- Constants (Screaming Snake Case)
    LOOKBACK_DAYS INT DEFAULT 30;
    DATE_FORMAT VARCHAR DEFAULT ''YYYY-MM-DD'';
    CRAFTABLE_TABLES_TARGET_SCHEMA VARCHAR DEFAULT ''DATASHARE_DEV'';
    
    -- List of EXISTING Stored Procedures to call
    TARGET_SPROC_LIST ARRAY DEFAULT ARRAY_CONSTRUCT (
        ''DATAADMIN.SP_LOAD_DATASHARE_CRAFTABLE_CHECK''
        ,''DATAADMIN.SP_LOAD_DATASHARE_CRAFTABLE_GRATUITY''
        ,''DATAADMIN.SP_LOAD_DATASHARE_CRAFTABLE_DISCOUNT''
        ,''DATAADMIN.SP_LOAD_DATASHARE_CRAFTABLE_FEE'',
        ''DATAADMIN.SP_LOAD_DATASHARE_CRAFTABLE_ITEM'',
        ''DATAADMIN.SP_LOAD_DATASHARE_CRAFTABLE_LABOR'',
        ''DATAADMIN.SP_LOAD_DATASHARE_CRAFTABLE_MODIFIER'',
        ''DATAADMIN.SP_LOAD_DATASHARE_CRAFTABLE_PAYMENT'',
        ''DATAADMIN.SP_LOAD_DATASHARE_CRAFTABLE_VOID''
    );
    
    -- Variables needed for the SP call arguments
    -- SIGNED_UP_LOCATIONS VARCHAR DEFAULT ''4,25,26,27,28,32'';
    SIGNED_UP_LOCATIONS VARCHAR DEFAULT ''4,32'';
    
    -- Date Variables (DATE type)
    yesterday_date DATE;             -- The end date for the load (DATE type).
    retention_boundary_date DATE;    -- The date 30 days before yesterday (DATE type).

    -- String Variables (VARCHAR type - for passing to the SPROCs)
    start_date_str VARCHAR;          -- The start date parameter as a string.
    end_date_str VARCHAR;            -- The end date parameter as a string.

    -- Variables for the loop and dynamic execution
    sproc_name VARCHAR;
    sql_command VARCHAR;
    target_table_name VARCHAR;

    -- Variables for Watermark Logic
    target_table_max_date DATE;
    calculated_start_date DATE;
    res RESULTSET;
    c1 CURSOR FOR SELECT NULL; -- Initialized with a dummy query
    

BEGIN
    CALL dataadmin.sp_get_dag_run_metadata(COALESCE(last_query_id(), ''NOT_FOUND'')) INTO :run_metadata;
    parent_query_id := :run_metadata:parent_query_id::VARCHAR;
    task_run_group_id := :run_metadata:graph_run_group_id::VARCHAR;
    attempt_number := :run_metadata:run_attempt_number::NUMBER;
    session_id := :run_metadata:session_id::VARCHAR;
    task_name := :run_metadata:task_name::VARCHAR;
    
    ----------------------------------------------------------
    -- todo: get signed up locations. for the moment we are using `SIGNED_UP_LOCATIONS` and writting to a dev schema
    ----------------------------------------------------------

    -- Calculate Date Values (DATE Type)
    yesterday_date := DATEADD(day, -1, CURRENT_DATE());
    retention_boundary_date := DATEADD(day, -:LOOKBACK_DAYS, :yesterday_date);
    -- Convert Dates to String Format (VARCHAR Type)
    end_date_str := TO_VARCHAR(:yesterday_date, :DATE_FORMAT);
    
    -- Loop through each target stored procedure
    FOR i IN 0 TO ARRAY_SIZE(TARGET_SPROC_LIST) - 1 DO
        sproc_name := TARGET_SPROC_LIST[i];

        BEGIN
            -- Determine target table name from sproc name.
            target_table_name := ''CRAFTABLE_'' || SPLIT_PART(:sproc_name, ''_'', -1);

            -- =======================================================
            -- START: WATERMARK CALCULATION LOGIC
            -- =======================================================
            
            -- Step A: Run the Dynamic SQL and fetch the result into a variable
            sql_command := ''SELECT MAX(""Business Day"") FROM '' || CRAFTABLE_TABLES_TARGET_SCHEMA || ''.'' || target_table_name;
            LOGS := LOGS || ''Executing: '' || :sql_command || ''\\n'';
            res := (EXECUTE IMMEDIATE :sql_command);
            OPEN c1 FOR res;
            FETCH c1 INTO target_table_max_date;
            CLOSE c1;

            -- Step B: Handle NULL (First Load)
            IF (target_table_max_date IS NULL) THEN
                target_table_max_date := ''1900-01-01''::DATE;
            END IF;

            -- Step C: Compare Max Date vs Retention Boundary
            IF (target_table_max_date > retention_boundary_date) THEN
                calculated_start_date := DATEADD(day, 1, target_table_max_date);
            ELSE
                calculated_start_date := retention_boundary_date;
            END IF;

            -- Step D: Convert to String for SPROC call
            start_date_str := TO_VARCHAR(calculated_start_date, DATE_FORMAT);

            -- =======================================================
            -- END: WATERMARK CALCULATION LOGIC
            -- =======================================================

            -- Step 3: Call Load Procedure
            -- We pass the string variables (start_date_str, end_date_str) to the SPROC.
            sql_command := ''CALL '' || sproc_name || 
                         ''(?, ?, ?)'';
            LOGS := LOGS || ''Executing: '' || :sql_command || '' with ('' || :start_date_str || '', '' || :end_date_str || '', '' || :SIGNED_UP_LOCATIONS || '')\\n'';
                        
            EXECUTE IMMEDIATE :sql_command USING (start_date_str, end_date_str, SIGNED_UP_LOCATIONS);


            -- Step 4: Data Retention Policy (DELETE)
            -- Uses the dynamically extracted target_table_name.
            sql_command := ''DELETE FROM '' || CRAFTABLE_TABLES_TARGET_SCHEMA || ''.'' || target_table_name || 
                        '' WHERE ""Business Day"" <= ?'';
            LOGS := LOGS || ''Executing: '' || :sql_command || '' with ('' || :retention_boundary_date || '')\\n'';
                        
            EXECUTE IMMEDIATE :sql_command USING (retention_boundary_date);
            
        EXCEPTION
            WHEN OTHER THEN
                INSERT INTO dataadmin.error_logs (
                    parent_query_id,
                    task_run_group_id,
                    attempt_number,
                    session_id,
                    task_name,
                    failed_query_id,
                    error_type_id,
                    severity,
                    sql_error_code,
                    sql_error_message,
                    sql_state,
                    details
                )
                SELECT
                    :parent_query_id,
                    :task_run_group_id,
                    :attempt_number,
                    :session_id,
                    :task_name,
                    COALESCE(last_query_id(), ''NOT_FOUND''), --it should return the query_id of the failed command in the BEGIN block.
                    2, --1 are hard fails and 2 soft fails
                    ''ERROR'',
                    :SQLCODE,
                    :SQLERRM,
                    :SQLSTATE,
                    OBJECT_CONSTRUCT(''LOGS'', :LOGS);
        END;

    END FOR;
    
    RETURN ''Graph Run Group ID: ''||:run_metadata:graph_run_group_id || '', Attempt: ''||:run_metadata:run_attempt_number ||    ''--- LOGS:'' || COALESCE(:LOGS, ''LOGS variable is NULL'');
END;
';"
PROCEDURE,DATAADMIN,"SP_DATASHARE_CRAFTABLE_ITEM(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_DATASHARE_CRAFTABLE_ITEM""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE
  reportSet resultset;
  -- startdate timestamp_tz      := ''2020-08-20T14:48:37.661Z'';
  -- enddate timestamp_tz        := ''2029-08-20T14:48:37.661Z'';
  -- locationid string           := ''[35]'';
  locationidS string          :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
  today char(11)              := CURRENT_DATE()::date::VARCHAR(10);
-----------------------------------------------------------------------------------------------------------------------
BEGIN
DROP TABLE if exists ITEM_DATA_TEMP;

CALL DATAADMIN.SP_REPORT_PMIX(:startdate,:enddate,:locationidS);
CREATE OR REPLACE TEMP TABLE ITM_DATA_TEMP AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));
;
-----------------------------------------------------------------------------------------------------------------------
     reportSet := (
         SELECT 
         ORG.ORGANIZATION             AS ""Organization Name""
         ,ORG.ORGANIZATION_DIM_NK     AS ""Organization ID""
         ,IDT.""Location""              AS ""Location Name""
         ,IDT.""Location ID""           AS ""Location ID""
         ,IDT.""Fiscal Date""           AS ""Business Day""
         ,IDT.""Check ID""              AS ""Check Number""
         ,IDT.""Check""                 AS ""Check ID""
         ,IDT.""Menu Item""             AS ""Item Name""
         ,IDT.""Support ID""            AS ""Item ID""
         ,IDT.""Category""              AS ""Item Category""
         ,IDT.""Price""                 AS ""Item Price""
         ,IDT.""Count""                 AS ""Item Quantity""
         ,IDT.""Tax""                   AS ""Item Tax""
         ,IDT.""Net""                   AS ""Net Amount""
         FROM 
         ITM_DATA_TEMP                                      IDT
         LEFT JOIN DATAWAREHOUSE.ORGANIZATION_DIM           ORG
            ON IDT.""Location ID""  = ORG.ORGANIZATION_DIM_NK
            AND ORG.DW_ISCURRENTROW
     );
--=====================================================================================================================
RETURN TABLE(reportSet);
END';"
PROCEDURE,DATAADMIN,SP_DQ_ACCELERATION_ELEGIBLE(),"CREATE OR REPLACE PROCEDURE ""SP_DQ_ACCELERATION_ELEGIBLE""()
RETURNS VARIANT
LANGUAGE SQL
EXECUTE AS OWNER
AS '
DECLARE
    -- Runtime metadata
    run_metadata VARIANT;
    parent_query_id VARCHAR;
    task_run_group_id VARCHAR;
    attempt_number NUMBER;
    session_id VARCHAR;
    task_name VARCHAR;

    -- Procedure specific variables
    select_query_id VARCHAR;
    opportunities_result VARIANT;
    row_count NUMBER;
BEGIN
    -- Get runtime metadata for logging and traceability
    CALL dataadmin.sp_get_dag_run_metadata(COALESCE(last_query_id(), ''NOT_FOUND'')) INTO :run_metadata;
    parent_query_id := :run_metadata:parent_query_id::VARCHAR;
    task_run_group_id := :run_metadata:graph_run_group_id::VARCHAR;
    attempt_number := :run_metadata:run_attempt_number::NUMBER;
    session_id := :run_metadata:session_id::VARCHAR;
    task_name := COALESCE(:run_metadata:task_name::VARCHAR, ''sp_dq_acceleration_elegible'');

    -- The actual data quality check logic
    -- Aggregate potential opportunities into a JSON array, preserving the order of importance.
    SELECT ARRAY_AGG(OBJECT_CONSTRUCT(
        ''query_id'', q.query_id,
        ''eligible_query_acceleration_time'', q.eligible_query_acceleration_time,
        ''query_text'', q.query_text,
        ''query_type'', q.query_type,
        ''user_name'', q.user_name,
        ''role_name'', q.role_name,
        ''query_tag'', q.query_tag,
        ''start_time'', q.start_time,
        ''end_time'', q.end_time,
        ''user_type'', q.user_type
    )) WITHIN GROUP (ORDER BY q.eligible_query_acceleration_time DESC)
    INTO :opportunities_result
    FROM (
        SELECT
            qae.query_id,
            qae.eligible_query_acceleration_time,
            qh.query_text,
            qh.query_type,
            qh.user_name,
            qh.role_name,
            qh.query_tag,
            qh.start_time,
            qh.end_time,
            qh.user_type
        FROM (
            select query_id,eligible_query_acceleration_time  from SNOWFLAKE.ACCOUNT_USAGE.QUERY_ACCELERATION_ELIGIBLE WHERE
            start_time > DATEADD(''day'', -7, CURRENT_TIMESTAMP())
            ) qae
        LEFT JOIN
            (select * from SNOWFLAKE.ACCOUNT_USAGE.QUERY_HISTORY where start_time > DATEADD(''day'', -7, CURRENT_TIMESTAMP()) ) qh
             ON qae.query_id = qh.query_id
    ) q;

    select_query_id := last_query_id();
    row_count := ARRAY_SIZE(COALESCE(:opportunities_result, ARRAY_CONSTRUCT()));

    IF (row_count > 0) THEN
        -- If there are opportunities, log a single data quality issue.
        INSERT INTO DATAADMIN.error_logs (
            parent_query_id,
            task_run_group_id,
            attempt_number,
            session_id,
            task_name,
            failed_query_id,
            error_type_id,
            severity,
            sql_error_code,
            sql_error_message,
            sql_state,
            details
        )
        SELECT
            :parent_query_id,
            :task_run_group_id,
            :attempt_number,
            :session_id,
            :task_name,
            :select_query_id,
            3, -- 1=Hard Fail, 2=Soft Fail, 3=Data Quality
            ''WARNING'',
            NULL,
            ''Data quality check failed: Query acceleration opportunities detected.'',
            NULL,
            OBJECT_CONSTRUCT(
                ''check_name'', ''sp_dq_acceleration_elegible'',
                ''eligible_query_count'', :row_count,
                ''message'', ''Queries eligible for acceleration were found. See return value for details.''
            );
        RETURN :opportunities_result;
    ELSE
        RETURN OBJECT_CONSTRUCT(''status'', ''Data quality check passed. No acceleration opportunities found.'');
    END IF;

END;
';"
PROCEDURE,DATAADMIN,"SP_GETPERSPECTIVESCHEMA(VARCHAR, TIMESTAMP_TZ, TIMESTAMP_TZ, NUMBER)","CREATE OR REPLACE PROCEDURE ""SP_GETPERSPECTIVESCHEMA""(""SPROCNAME"" VARCHAR(500), ""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" NUMBER(38,0))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS '
--=================================================================================================================
--This sproc creates the schema for a Perspective Report from the Source Data Stored Proceedure
-- call SP_GetPerspectiveSchema;
--=================================================================================================================
DECLARE 
--sprocName VARCHAR(500):= ''DATAADMIN.SP_REPORT_PMIX'';
 -- startdate timestamp_tz :=      ''2000-11-20T14:48:37.661Z'';  
 -- enddate timestamp_tz :=        ''2023-11-20T14:48:37.661Z''; 
--  locationid number :=            351;
  dataout resultset;  

BEGIN
  drop table if exists schema_data; 
  CALL DATAADMIN.SP_REPORT_PMIX(''2000-11-20T14:48:37.661Z'',''2023-11-20T14:48:37.661Z'',351) ;
 
  CREATE TABLE schema_data AS
    SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

  ALTER TABLE schema_data ADD COLUMN MAXROW NUMBER;

  dataout := (

  SELECT   ''""schema"": {\\n''
    || LISTAGG (''  '' || ''""'' 
     || COLUMN_NAME 
     || ''"" : '' 
     || CASE DATA_TYPE 
       WHEN ''TEXT'' THEN ''""str""'' 
       WHEN ''NUMBER'' THEN ''""float""''
       WHEN ''TIMESTAMP_TZ'' THEN ''""datetime""'' 
       WHEN ''BOOLEAN'' THEN ''""bool""''
      ELSE DATA_TYPE END 
      || '','' 
      || ''\\n''
      ) || ''}''
      AS DATA_TYPE 
    FROM information_schema.columns 
    WHERE table_name=''SCHEMA_DATA'' 
    ORDER BY ORDINAL_POSITION
    );
    

  return table(dataout);
END
';"
PROCEDURE,DATAADMIN,"SP_LOAD_AVERO_CHECKDETAIL(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_AVERO_CHECKDETAIL""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2020-08-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2029-08-20T14:48:37.661Z''; 
  -- locationid string      := ''[2,3,4,351,352]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--=================================================================================================================================
BEGIN

--=================================================================================================================================
reportSet := (  
----------------------------------------------------------------------------------------------------------------------------------
SELECT ITF.ITEM_FACT_PK   AS CHROWNUM     --Row number   
,TO_CHAR(CHF.FISCAL_DATE,''YYYYMMDD'') 
                          AS BUSDATE      --Business Day Date as YYYYMMDD 8 digits(99991231)fiscal day of check20
,CHF.REVENUECENTER_DIM_FK AS RVCNUM       --Revenue center number
,CHF.REVENUECENTERNAME AS RVCDESC         --Revenue center desription
,CHF.CHEQUE_FACT_NK       AS CHKSEQ       --Unique check sequence identifier String
,CHF.CHEQUENUMBER         AS CHKNUM       --CHEQUE NUMBER
,CHF.EMPLOYEE_DIM_FK      AS EMPNUM       --Employee Number Number 12 digit(999999999999)Unique identifier for check owner
,EMD.EMPLOYEE_NAME        AS EMPDESC      --Employee Description String 40 characters First and Last Name of check owning employee
,SHD.JOBPOSITION_DIM_FK   AS EMPCLASS     --NUM Employee Class Number Number 12 digit (999999999999)Employee class number
,JPD.JOB_POSITION         AS EMPCLASSDESC --Employee ClassDescription string 40 characters Class Description of employ
,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHF.OPENED_AT::timestamp_ntz ),''YYYYMMDD'' )     
                          AS TRANSDATE    --Transaction day
,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHF.OPENED_AT::timestamp_ntz ),''HH:MM'' )     
                          AS TRANSTIME    --Transaction TIME                                                         
-- --???????????????????????????????????????????????
,NULL AS RECTYPE --Record type
,NULL AS NUM     --RECTYPE Number-
,NULL AS ""DESC""  --RECTYPE Description
-- --???????????????????????????????????????????????
,ITF.QUANTITY             AS QTY--Quantity
,ITF.APPLIEDAMOUNT        AS AMT--RECtYPE amt
FROM DATAWAREHOUSE.CHEQUE_FACT                           CHF
  INNER JOIN DATAWAREHOUSE.EMPLOYEE_DIM EMD
    ON EMD.EMPLOYEE_DIM_NK = CHF.EMPLOYEE_DIM_FK
      AND CHF.DW_ISCURRENTROW
      AND EMD.DW_ISCURRENTROW
      AND CHF.LOCATION_DIM_FK IN (--351,352
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)
      AND NOT CHF.IS_TRAINING
      AND CHF.DW_ISCURRENTROW
      AND CHF.STATUS in (''Closed'')
          AND (CHF.FISCAL_DATE::date >= :startdate::date 
                AND CHF.FISCAL_DATE::date  <= :enddate::date)
  INNER JOIN DATAWAREHOUSE.ITEM_FACT                     ITF
    ON ITF.CHEQUE_FACT_FK = CHF.CHEQUE_FACT_NK
      AND ITF.DW_ISCURRENTROW
  INNER JOIN DATAWAREHOUSE.LOCATION_DIM                 LOC
    ON LOC.LOCATION_DIM_NK = CHF.LOCATION_DIM_fK
      AND CHF.DW_ISCURRENTROW
      AND LOC.DW_ISCURRENTROW
  INNER JOIN DATAWAREHOUSE.SHIFT_DIM                    SHD
    ON SHD.SHIFT_DIM_NK = CHF.SHIFT_DIM_FK
      AND SHD.DW_ISCURRENTROW
  INNER JOIN DATAWAREHOUSE.JOBPOSITION_DIM              JPD
    ON JPD.JOBPOSITION_DIM_NK = SHD.JOBPOSITION_DIM_FK
      AND JPD.DW_ISCURRENTROW
--=================================================================================================================================
);
RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,"SP_REPORT_ACCOUNTSUMMARY_PAYMENTS_FEETAX(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_ACCOUNTSUMMARY_PAYMENTS_FEETAX""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet           resultset;
  -- startdate string    := ''2020-07-10'';  
  -- enddate string      := ''2029-07-10''; 
  -- locationid string   := ''[351]'';
  locationidS string  :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--=========================================================================================
BEGIN
  DROP TABLE IF EXISTS TEMP_TABLE1;

 CREATE TEMP TABLE  TEMP_TABLE1 AS
 SELECT ''Tax Detail Fee''                                     as ""Level""
    ,tax.FISCAL_DATE::date                                   as ""Fiscal Day""
    ,tax.LOCATION_DIM_FK                                     as ""Location ID""
    ,IFNULL(tax.TAXRATENAME,'' None'')                         as ""Rate Name""
    ,tax.TAX::NUMBER(18,2)                                   as ""Fee Tax Amount""
    ,tax.PERCENT::NUMBER(18,2)                               as ""Tax Percent""
 FROM DATAWAREHOUSE.FEETAX_FACT                              tax
     INNER JOIN DATAWAREHOUSE.CHEQUE_FACT                    chk
        ON chk.CHEQUE_FACT_NK = tax.CHEQUE_FACT_FK
          AND chk.TAX > 0.000
          AND chk.STATUS = ''Closed''
          AND chk.OPENED_AT is not null
          AND chk.DW_ISCURRENTROW          
          AND tax.DW_ISCURRENTROW  
          AND NOT tax.DW_ISDELETED
          AND NOT tax.IS_TRAINING
          AND tax.FISCAL_DATE::date
              >= :startdate::date 
          AND tax.FISCAL_DATE::date  
              <= :enddate::date 
          AND tax.LOCATION_DIM_FK IN ( 
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)
;                  
       
--=========================================================================================
 reportSet:= (
 SELECT * from TEMP_TABLE1
);

--===========================================================================================
RETURN TABLE(reportSet); 

END';"
PROCEDURE,DATAADMIN,"SP_REPORT_ACCOUNTSUMMARY_PAYMENTS_REFUNDS(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_ACCOUNTSUMMARY_PAYMENTS_REFUNDS""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz      := ''2020-08-20T14:48:37.661Z'';  
  -- enddate timestamp_tz        := ''2029-08-20T14:48:37.661Z''; 
  -- locationid string           := ''[351,352,400,403,352,501,357]'';
  locationidS string          :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
  
-----------------------------------------------------------------------------------------------------------------------
  BEGIN
    --drop temp tables
    DROP TABLE IF EXISTS REPORT_DATA;

-----------------------------------------------------------------------------------------------------------------------
    CALL DATAADMIN.SP_REPORT_REFUNDS(:startdate,:enddate,:locationid);
    
    CREATE TEMP TABLE REPORT_DATA AS
       SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))
    ;

-----------------------------------------------------------------------------------------------------------------------    
    --return values from the sproc with validated columns only  
     reportSet := (
       SELECT TO_CHAR(ROW_NUMBER() OVER (ORDER BY ""Location ID""))  AS  ""Support ID"" 
          ,""Location ID""   AS ""Location ID""
          ,""Location""      AS ""Location""
          ,""Check""         AS ""Check""
          ,""Tip Amount""    AS ""Tip Amount""
          ,""Check Amount""  AS ""Check Amount""
          ,""Refund Amount"" AS ""Refund Amount""
        FROM REPORT_DATA   REPD

     );

--=====================================================================================================================
RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,SP_STAGELOADACTIVITY_FACT(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADACTIVITY_FACT""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.ACTIVITY_FACT),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.ACTIVITY_FACT(   
          ACTIVITY_FACT_NK, 
          ACTIVITY, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          VOIDSUMMARY_FACT_FK, 
          CHEQUE_FACT_FK, 
          DISCOUNT_FACT_FK, 
          EMPLOYEE_DIM_FK, 
          EMPLOYEE_DIM_FK_AS_PERFORMING_EMPLOYEE, 
          EMPLOYEE_DIM_FK_AS_APPROVING_EMPLOYEE, 
          ITEM_FACT_FK, 
          LOCATION_DIM_FK, 
          MENUITEM_DIM_FK, 
          IS_DISCOUNT, 
          IS_TRAINING, 
          IS_VOID, 
          IS_VOID_ITEM, 
          CREATED_AT, 
          UPDATED_AT, 
          PERFORMED_AT, 
          TABLENAME, 
          PERFORMEDBYUSERUUID, 
          MENUITEMNAME, 
          MENUITEMID, 
          TYPE, 
          ITEM_ID, 
          OVERRIDE, 
          LEVEL, 
          REASON, 
          PRICE 
) 
 SELECT   ACTIVITY_FACT_NK  as   ACTIVITY_FACT_NK,  
   ACTIVITY  as   ACTIVITY,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   VOIDSUMMARY_FACT_FK  as   VOIDSUMMARY_FACT_FK,  
   CHEQUE_FACT_FK  as   CHEQUE_FACT_FK,  
   DISCOUNT_FACT_FK  as   DISCOUNT_FACT_FK,  
   EMPLOYEE_DIM_FK  as   EMPLOYEE_DIM_FK,  
   EMPLOYEE_DIM_FK_AS_PERFORMING_EMPLOYEE  as   EMPLOYEE_DIM_FK_AS_PERFORMING_EMPLOYEE,  
   EMPLOYEE_DIM_FK_AS_APPROVING_EMPLOYEE  as   EMPLOYEE_DIM_FK_AS_APPROVING_EMPLOYEE,  
   ITEM_FACT_FK  as   ITEM_FACT_FK,  
   LOCATION_DIM_FK  as   LOCATION_DIM_FK,  
   MENUITEM_DIM_FK  as   MENUITEM_DIM_FK,  
   IS_DISCOUNT  as   IS_DISCOUNT,  
   IS_TRAINING  as   IS_TRAINING,  
   IS_VOID  as   IS_VOID,  
   IS_VOID_ITEM  as   IS_VOID_ITEM,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   PERFORMED_AT  as   PERFORMED_AT,  
   TABLENAME  as   TABLENAME,  
   PERFORMEDBYUSERUUID  as   PERFORMEDBYUSERUUID,  
   MENUITEMNAME  as   MENUITEMNAME,  
   MENUITEMID  as   MENUITEMID,  
   TYPE  as   TYPE,  
   ITEM_ID  as   ITEM_ID,  
   OVERRIDE  as   OVERRIDE,  
   LEVEL  as   LEVEL,  
   REASON  as   REASON,  
   PRICE  as   PRICE 
  FROM DATAADMIN.ACTIVITY_FACT
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''ACTIVITY_FACT'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''ACTIVITY_FACT'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADJOBPOSITION_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADJOBPOSITION_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.JOBPOSITION_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.JOBPOSITION_DIM(   
          JOBPOSITION_DIM_NK, 
          JOB_POSITION, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          JOBCATEGORY_DIM_FK, 
          ORGANIZATION_DIM_FK, 
          IS_ARCHIVED, 
          IS_CASH_DRAWER_ASSIGNMENT_REQUIRED, 
          IS_TRAINING, 
          HAS_SKIP_AUTO_CLOCKOUT, 
          CREATED_AT, 
          UPDATED_AT, 
          ARCHIVED_AT, 
          DEFAULT_PAY_RATE 
) 
 SELECT   JOBPOSITION_DIM_NK  as   JOBPOSITION_DIM_NK,  
   JOB_POSITION  as   JOB_POSITION,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   JOBCATEGORY_DIM_FK  as   JOBCATEGORY_DIM_FK,  
   ORGANIZATION_DIM_FK  as   ORGANIZATION_DIM_FK,  
   IS_ARCHIVED  as   IS_ARCHIVED,  
   IS_CASH_DRAWER_ASSIGNMENT_REQUIRED  as   IS_CASH_DRAWER_ASSIGNMENT_REQUIRED,  
   IS_TRAINING  as   IS_TRAINING,  
   HAS_SKIP_AUTO_CLOCKOUT  as   HAS_SKIP_AUTO_CLOCKOUT,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   ARCHIVED_AT  as   ARCHIVED_AT,  
   DEFAULT_PAY_RATE  as   DEFAULT_PAY_RATE 
  FROM DATAADMIN.JOBPOSITION_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''JOBPOSITION_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''JOBPOSITION_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,"SP_LOAD_365_TENDERS(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_365_TENDERS""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2020-08-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2029-08-20T14:48:37.661Z''; 
  -- locationid string      := ''[2,3,4,351,352]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
  -- GRANT usage ON procedure dataadmin.SP_LOAD_365_TENDERS(timestamp_tz,timestamp_tz,string) TO ROLE matillion;
--=================================================================================================================================
BEGIN
--=================================================================================================================================
reportSet := (  
-----------------------------------------------------------------------------------------------------------------------------------
SELECT PAY.PAYMENTMETHOD_DIM_NK                         AS  Number  --*sTRING 
  ,IFNULL(REPLACE(PAY.PAYMENTMETHODNAME,'','',''''),''None'') AS  Name    --*sTRING 
  ,IFNULL(REPLACE(PAY.PAYMENTMETHODTYPE,'','',''''),''None'') AS  Type    -- string
FROM DATAWAREHOUSE.PAYMENTMETHOD_DIM                        PAY
  INNER JOIN DATAWAREHOUSE.ORGANIZATION_DIM                 ORG
    ON PAY.ORGANIZATION_DIM_FK = ORG.ORGANIZATION_DIM_NK
      AND PAY.DW_ISCURRENTROW
      AND ORG.DW_ISCURRENTROW
  INNER JOIN DATAWAREHOUSE.LOCATION_DIM                      LOC
    ON LOC.ORGANIZATION_DIM_FK = ORG.ORGANIZATION_DIM_NK
      AND LOC.DW_ISCURRENTROW
      AND (LOC.LOCATION_DIM_NK in (SELECT table1.value 
        FROM table(split_to_table(:locationidS, '',''))  table1)    
          OR PAY.PAYMENTMETHOD_DIM_NK = -1
        )
GROUP BY PAY.PAYMENTMETHOD_DIM_NK
  ,Name
  ,Type

--=================================================================================================================================
);
RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,"SP_LOAD_DATASHARE_CRAFTABLE_GRATUITY(VARCHAR, VARCHAR, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_DATASHARE_CRAFTABLE_GRATUITY""(""START_DATE"" VARCHAR, ""END_DATE"" VARCHAR, ""LOCATION_IDS"" VARCHAR)
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS CALLER
AS 'BEGIN
    -- Execute the source procedure that returns the data
    CALL DATAADMIN.SP_DATASHARE_CRAFTABLE_GRATUITIES(:START_DATE, :END_DATE, :LOCATION_IDS);

    -- Insert the results into the target table
    INSERT INTO DATASHARE_DEV.CRAFTABLE_GRATUITY (
        ""Organization Name"",
        ""Organization ID"",
        ""Location Name"",
        ""Location ID"",
        ""Business Day"",
        ""Check Number"",
        ""Check ID"",
        ""Is Gratuity Flag"",
        ""Gratuity Name"",
        ""Gratuity ID"",
        ""Gratuity Amount"",
        ""Employee for Gratuity""
    )
    SELECT
        ""Organization Name"",
        ""Organization ID"",
        ""Location Name"",
        ""Location ID"",
        ""Business Day"",
        ""Check Number"",
        ""Check ID"",
        ""Is Gratuity Flag"",
        ""Gratuity Name"",
        ""Gratuity ID"",
        ""Gratuity Amount"",
        ""Employee for Gratuity""
    FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

    RETURN ''Success: Data loaded into DATASHARE_DEV.CRAFTABLE_GRATUITY.'';
END';"
PROCEDURE,DATAADMIN,"SP_LOAD_DATASHARE_CRAFTABLE_VOID(VARCHAR, VARCHAR, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_DATASHARE_CRAFTABLE_VOID""(""START_DATE"" VARCHAR, ""END_DATE"" VARCHAR, ""LOCATION_IDS"" VARCHAR)
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS CALLER
AS 'BEGIN
    -- Execute the source procedure that returns the data
    CALL DATAADMIN.SP_DATASHARE_CRAFTABLE_VOID(:START_DATE, :END_DATE, :LOCATION_IDS);

    -- Insert the results into the target table
    INSERT INTO DATASHARE_DEV.CRAFTABLE_VOID (
        ""Organization Name"",
        ""Organization ID"",
        ""Location Name"",
        ""Location ID"",
        ""Business Day"",
        ""Void ID"",
        ""Void Level"",
        ""Void Reason"",
        ""Check Number"",
        ""Check ID"",
        ""Item Name"",
        ""Item ID"",
        ""Item Amount"",
        ""Employee for Void (approver)"",
        ""Void Amount""
    )
    SELECT
        ""Organization Name"",
        ""Organization ID"",
        ""Location Name"",
        ""Location ID"",
        ""Business Day"",
        ""Void ID"",
        ""Void Level"",
        ""Void Reason"",
        ""Check Number"",
        ""Check ID"",
        ""Item Name"",
        ""Item ID"",
        ""Item Amount"",
        ""Employee for Void (approver)"",
        ""Void Amount""
    FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

    RETURN ''Success: Data loaded into DATASHARE_DEV.CRAFTABLE_VOID.'';
END';"
PROCEDURE,DATAADMIN,"SP_REPORT_ACCOUNTSUMMARY_PAYMENTS_LABOR(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_ACCOUNTSUMMARY_PAYMENTS_LABOR""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet           resultset;
  -- startdate string    := ''2025-11-10'';  
  -- enddate string      := ''2025-11-10''; 
  -- locationid string   := ''[1]'';
  locationidS string  :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--=========================================================================================
BEGIN
  DROP TABLE IF EXISTS TEMP_TABLE1;

------------------------------------------------------------------------------------------------  
CALL DATAADMIN.SP_REPORT_LABOR(:startdate,:enddate,:locationid);

SELECT 
  ""Location ID""                                                        AS ""Location ID""
  ,""Job Position""                                                      AS ""Job Position""
  ,""Job Category""                                                      AS ""Job Category""
  ,(""Regular Seconds"")::DECIMAL(18,2)                                  AS ""Regular Seconds""
  ,(""Overtime Seconds"")::DECIMAL(18,2)                                 AS ""Overtime Seconds""
  ,(((""Regular Seconds""/3600)  * ""Regular Rate"") 
      + ((""Overtime Seconds""/3600) * ""Overtime Rate""))::DECIMAL(18,2)  AS ""Labor Cost""
  ,IFNULL(""Net Sales"",0)                                               AS ""Net Sales""
FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))
;
    
--=========================================================================================
 reportSet:= (
 SELECT ROW_NUMBER() OVER (ORDER BY ""Location ID"")      AS  ""Support ID"" 
  , ""Location ID""                                       AS ""Location ID""
  , ""Job Position""                                      AS ""Job Position""
  , ""Job Category""                                      AS ""Job Category"" 
  , SUM(""Regular Seconds"")                              AS ""Regular Seconds""
  , SUM(""Overtime Seconds"")                             AS ""Overtime Seconds""
  , SUM(""Labor Cost"")                                   AS ""Labor Cost""
  , SUM(""Net Sales"")                                    AS ""Net Sales""
 FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))
 GROUP BY ""Location ID""  
   ,""Job Position""
   ,""Job Category"" 
);

--===========================================================================================
RETURN TABLE(reportSet); 

END';"
PROCEDURE,DATAADMIN,"SP_REPORT_DISCOUNT_0001(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_DISCOUNT_0001""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS '
--==========================================================================================
--Example Call Statement
--CALL DATAADMIN.SP_REPORT_DISCOUNT(''2000-11-20T14:48:37.661Z'',''2024-11-20T14:48:37.661Z'',''[351,352]'');
-- ==============================================================================================
DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2000-11-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2029-11-20T14:48:37.661Z''; 
  -- locationid string      := ''[351,352]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--======================================================================================================
--TO DO
--ITEM 1:  Discounts are not broken out a the each discount level.  Ie there is a discount total at check level, and many discounts in the discount array in the discount column in the check table.
--ITEM 2:  Need to convert performed at tine to local pos time
--ITEM 3:  Need to calculate percentages wihin Perspective because of filetering
--ITEM 4:  Need to get the employee from activities
--ITEM 5:  IS DEV_HOSPENG_REPORTING.DATALANDING.POSAPI_PUBLIC_CASH_DISCOUNT A TABLE THAT WE NEED?
--ITEM 6:  Need to add discountitem_fact to this report as union
--ITEM 7:  Need to rule out training from discountitem_fact
--ITEM 8:  Need performed at for dates in activity
--NEED TO KNOW IF WE CALCULATE PERCENTAGES FROM THE VALUE FIELD -- issues with rouning?  calc rules outside database????
--======================================================================================================
BEGIN
 reportSet   := (
        SELECT CHF.DISCOUNTitem_FACT_NK             AS ""Support ID"" 
           , ''DISI-'' ||row_number() over (order by  CHF.DISCOUNTitem_FACT_NK ) 
                                                    AS ""Detail ID""
         --Status, categories and levels----------------------------------------------------------
            ,CHF.STATUS                             AS ""Status""
            ,CHF.DISCOUNTLEVEL                      AS ""Discount Level""
        --geography--------------------------------------------------------------------------------
            ,IFNULL(LOC.LOCATIONNAME ,''None'')       AS ""Location""
            ,IFNULL(CHF.revenueCenterName ,''None'')  AS ""Revenue Center""
        --dates-------------------------------------------------------------------------------------   
            ,LOC.TZ_NAME                            AS ""Time Zone""
            ,to_char(LEFT(
            CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHF.ADDED_AT::timestamp_ntz )
            ,4))                                    AS ""Year""
            ,to_char(LEFT(
            CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHF.ADDED_AT::timestamp_ntz )
            ,7))                                    AS ""Year and Month""
            ,IFNULL(dad.DAYPART,''None'')             AS ""Daypart""
            ,CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHF.FISCAL_DATE::timestamp_ntz )        
                                                    AS ""Fiscal Date""
            ,CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHF.ADDED_AT::timestamp_ntz )                           
                                                    AS ""Added At""
            ,CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHF.CREATED_AT::timestamp_ntz)                        
                                                    AS ""Created At""
            ,IFNULL(DAYNAME(
            CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHF.ADDED_AT::timestamp_ntz ) 
            ),''None'')                              AS ""Day of Week""
            ,CASE WHEN DAYNAME(
            CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHF.ADDED_AT::timestamp_ntz ) 
            ) IN (''Sat'',''Sun'')  
                THEN TRUE ELSE FALSE END            AS""Is Weekend""
    
        --flags-------------------------------------------------------------------------------------
        --people------------------------------------------------------------------------------------
            ,COALESCE(EMD_ADD.EMPLOYEE_NAME,''None'') AS ""Added By""
            ,COALESCE(EMD_APP.EMPLOYEE_NAME,''None'') AS ""Approved By""
        --Descriptors------------------------------------------------------------------------------
            ,STD.STANDARDDISCOUNTNAME               AS ""Discount Name""
            ,CHF.DISCOUNTREASON                     AS ""Discount Reason""
            ,CHF.PROMOCODE                          AS ""Promo Code"" 
            ,CHF.CHEQUENUMBER                       AS ""Check""  --davis would like hyperlink to checkdetail view in bridge
            ,STD.DISCOUNTTYPE                       AS ""Discount Type""
            ,CHF.DISCOUNT_TYPE                      AS ""Application""  
        --Facts-----------------------------------------------------------------------------------------
            ,1::NUMBER(10,0)                        AS ""Count""   
            ,CHF.DISCOUNT_PERCENT::NUMBER(18,2)     AS ""Discount Percent""   
            ,CHF.NET             ::NUMBER(18,2)     AS ""Check Net Amount"" 
            ,CHF.GROSS           ::NUMBER(18,2)     AS ""Check Gross Amount""
            ,CHF.DISCOUNT_AMOUNT ::NUMBER(18,2)     AS ""Discount Amount"" 
         
                                                    --Percentages must be calculated within pyarrow cube as numerator and denominator can be filtred dynamically
            -- ,NULL                                AS ""% of Total Discounts"" --ex: per discount id: total count / all discount count    
            -- ,NULL                                AS ""Discount % of Net Sales""  --example (total discount amount / net sales + total discount amount) * 100 
                                                    --This represents the presumed % of lost revenue
        --------------------------------------------------------------------------------------------------------
        FROM DATAADMIN.DISCOUNTITEM_FACT                      CHF
            INNER JOIN DATAADMIN.LOCATION_DIM                 LOC
              ON CHF.LOCATION_DIM_FK = LOC.LOCATION_DIM_NK
                  AND CHF.STATUS NOT IN (''Voided'',''Removed'')
                  AND CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHF.CREATED_AT::timestamp_ntz ) 
                      > CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,:startdate::timestamp_ntz ) 
                  AND CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHF.CREATED_AT::timestamp_ntz ) 
                      < CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,:enddate ::timestamp_ntz )
                  AND CHF.LOCATION_DIM_FK IN (
                     SELECT table1.value 
                       FROM table(split_to_table(:locationidS, '',''))  table1)
                  AND CHF.CHEQUESTATUS NOT IN (''Voided'')
                  AND CHF.DISCOUNT_AMOUNT > 0  --This will eliminate discounts that have been removed
                  AND CHF.DW_ISCURRENTROW
                  AND NOT CHF.DW_ISDELETED
                  AND LOC.DW_ISCURRENTROW          
                  AND NOT CHF.IS_TRAINING
            INNER JOIN DATAADMIN.STANDARDDISCOUNT_DIM         STD
               ON STD.STANDARDDISCOUNT_DIM_NK = CHF.STANDARDDISCOUNT_DIM_FK
                 AND CHF.DW_ISCURRENTROW
            INNER JOIN DATAADMIN.DAYPART_DIM                  DAD
              ON CHF.DAYPART_DIM_FK = DAD.DAYPART_DIM_NK
                  AND CHF.DW_ISCURRENTROW
            INNER JOIN DATAADMIN.EMPLOYEE_DIM                 EMD_ADD
              ON EMPLOYEE_DIM_FK_AS_ADDED_BY = EMD_ADD.EMPLOYEE_DIM_NK
                AND EMD_ADD.DW_ISCURRENTROW
            LEFT JOIN DATAADMIN.EMPLOYEE_DIM                 EMD_APP
              ON EMPLOYEE_DIM_FK_AS_APPROVED_BY = EMD_APP.EMPLOYEE_DIM_NK
                AND EMD_APP.DW_ISCURRENTROW
UNION ALL

        SELECT CHF.DISCOUNTCHECK_FACT_NK            AS ""Support ID"" 
                   ,''DISC-'' || row_number() over (order by  CHF.DISCOUNTCHECK_FACT_NK ) 
                                                    AS ""Detail ID""
         --Status, categories and levels----------------------------------------------------------
            ,CHF.STATUS                             AS ""Status""
            ,CHF.DISCOUNTLEVEL                      AS ""Discount Level""
        --geography--------------------------------------------------------------------------------
            ,IFNULL(LOC.LOCATIONNAME ,''None'')       AS ""Location""
            ,IFNULL(CHF.revenueCenterName ,''None'')  AS ""Revenue Center""
        --dates-------------------------------------------------------------------------------------  
            ,LOC.TZ_NAME                            AS ""Time Zone""        
            ,to_char(LEFT(
            CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHF.ADDED_AT::timestamp_ntz ) 
            ,4))                                    AS ""Year""
            ,to_char(LEFT(
            CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHF.ADDED_AT::timestamp_ntz ) 
            ,7))                                    AS ""Year and Month""
            ,IFNULL(dad.DAYPART,''None'')             AS ""Daypart""
            ,CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHF.FISCAL_DATE::timestamp_ntz )                         
                                                    AS ""Fiscal Date""
            ,CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHF.ADDED_AT::timestamp_ntz )                            
                                                    AS ""Added At""
            ,CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHF.CREATED_AT::timestamp_ntz )                          
                                                    AS ""Created At""
            ,IFNULL(DAYNAME(
            CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHF.ADDED_AT::timestamp_ntz ) 
            )
            ,''None'')AS""Day of Week""
            ,CASE WHEN DAYNAME(
            CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHF.ADDED_AT::timestamp_ntz ) 
            ) IN (''Sat'',''Sun'')  
            THEN TRUE ELSE FALSE END                AS""Is Weekend""
        --flags-------------------------------------------------------------------------------------
        --people------------------------------------------------------------------------------------
            ,COALESCE(EMD_ADD.EMPLOYEE_NAME,''None'') AS ""Added By""
            ,COALESCE(EMD_APP.EMPLOYEE_NAME,''None'') AS ""proved By"" 
        --Descriptors------------------------------------------------------------------------------
            ,STD.STANDARDDISCOUNTNAME               AS ""Discount Name""
            ,CHF.DISCOUNTREASON                     AS ""Discount Reason""
            ,CHF.PROMOCODE                          AS ""Promo Code"" 
            ,CHF.CHEQUENUMBER                       AS ""Check""  --davis would like hyperlink to checkdetail view in bridge
            ,STD.DISCOUNTTYPE                       AS ""Discount Type""
            ,CHF.DISCOUNT_TYPE                      AS ""Application""  
        --Facts-----------------------------------------------------------------------------------------
            ,1                   ::NUMBER(10,0)     AS ""Count""          
            ,CHF.DISCOUNT_PERCENT::NUMBER(18,2)     AS ""Discount Percent""   
            ,CHF.NET             ::NUMBER(18,2)     AS ""Check Net Amount"" 
            ,CHF.GROSS           ::NUMBER(18,2)     AS ""Check Gross Amount""
            ,CHF.DISCOUNT_AMOUNT ::NUMBER(18,2)     AS ""Discount Amount"" 
         
                                                    --Percentages must be calculated within pyarrow cube as numerator and denominator can be filtred dynamically
            -- ,NULL                                AS ""% of Total Discounts"" --ex: per discount id: total count / all discount count    
            -- ,NULL                                AS ""Discount % of Net Sales""  --example (total discount amount / net sales + total discount amount) * 100 
                                                    --This represents the presumed % of lost revenue
        --------------------------------------------------------------------------------------------------------
        FROM DATAADMIN.DISCOUNTCHECK_FACT                     CHF
            INNER JOIN DATAADMIN.LOCATION_DIM                 LOC
              ON CHF.LOCATION_DIM_FK = LOC.LOCATION_DIM_NK
                  AND CHF.STATUS NOT IN (''Voided'',''Removed'')
                  AND CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHF.CREATED_AT::timestamp_ntz ) 
                      > CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,:startdate ::timestamp_ntz )
                  AND CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHF.CREATED_AT::timestamp_ntz ) 
                      < CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,:enddate ::timestamp_ntz )
                  AND CHF.LOCATION_DIM_FK IN (
                     SELECT table1.value 
                       FROM table(split_to_table(:locationidS, '',''))  table1)
                  AND CHF.CHEQUESTATUS NOT IN (''Voided'')
                  AND CHF.DISCOUNT_AMOUNT > 0  --This will eliminate discounts that have been removed
                  AND CHF.DW_ISCURRENTROW
                  AND NOT CHF.DW_ISDELETED
                  AND LOC.DW_ISCURRENTROW          
                  AND NOT CHF.IS_TRAINING
            INNER JOIN DATAADMIN.STANDARDDISCOUNT_DIM         STD
               ON STD.STANDARDDISCOUNT_DIM_NK = CHF.STANDARDDISCOUNT_DIM_FK
                 AND CHF.DW_ISCURRENTROW
            INNER JOIN DATAADMIN.DAYPART_DIM                  DAD
              ON CHF.DAYPART_DIM_FK = DAD.DAYPART_DIM_NK
                  AND CHF.DW_ISCURRENTROW
            INNER JOIN DATAADMIN.EMPLOYEE_DIM                 EMD_ADD
              ON EMPLOYEE_DIM_FK_AS_ADDED_BY = EMD_ADD.EMPLOYEE_DIM_NK
                AND EMD_ADD.DW_ISCURRENTROW
            LEFT JOIN DATAADMIN.EMPLOYEE_DIM                 EMD_APP
              ON EMPLOYEE_DIM_FK_AS_APPROVED_BY = EMD_APP.EMPLOYEE_DIM_NK
                AND EMD_APP.DW_ISCURRENTROW
                
--==========================================================================================
); 
 RETURN TABLE(reportSet); 
END;
';"
PROCEDURE,DATAADMIN,"SP_REPORT_VOID_0001(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_VOID_0001""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2025-05-23'';  
  -- enddate timestamp_tz   := ''2025-05-23''; 
  -- locationid string      := ''[26]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
-- --===================================================================================================================
BEGIN

-------------------------------------------------------------------------------------------------------------------------
DROP TABLE IF EXISTS TEMP_ITEM;

-------------------------------------------------------------------------------------------------------------------------
SELECT iaf.ITEM_FACT_NK                                             AS ITEM_FACT_NK
   ,iaf.CHEQUE_FACT_FK                                              AS CHEQUE_FACT_FK
   ,max(vdr_item.VOIDREASON)                                        AS VOIDREASON
   ,max(iaf.PRICE)                                                  AS ITEMPRICE
   ,sum(imf.PRICE)                                                  AS MODIFIERPRICE
   ,(max(case when iaf.PRICE > 0.0000 THEN iaf.PRICE ELSE iaf.baseprice END)
     + sum(ifnull(imf.PRICE,0))) * max(iaf.QUANTITY)                AS PRICE
        FROM DATAWAREHOUSE.ITEM_FACT                                iaf
           LEFT JOIN  DATAWAREHOUSE.ITEMMODIFIER_DIM                imf
              ON iaf.ITEM_FACT_NK = imf.ITEM_FACT_FK
                  -- AND iaf.LOCATION_DIM_fK = 2
                AND iaf.LOCATION_DIM_fK IN (
                    SELECT table1.value 
                      FROM table(split_to_table(:locationidS, '',''))  table1)
                -- AND iaf.FISCAL_DATE = ''2024-09-29''
                AND iaf.FISCAL_DATE::date
                    >= :startdate::date 
                AND iaf.FISCAL_DATE::date  
                   <= :enddate::date 
                AND iaf.IS_VOID
                AND iaf.CHECKSTATUS <> ''MergeVoided''
                AND iaf.DW_ISCURRENTROW 
                AND imf.DW_ISCURRENTROW 
                AND NOT iaf.DW_ISDELETED
                AND NOT iaf.IS_TRAINING
        LEFT JOIN DATAWAREHOUSE.VoidReason_DIM                        vdr_item
             ON vdr_item.VOIDREASON_DIM_NK = iaf.VoidReason_DIM_FK
               AND vdr_item.DW_ISCURRENTROW       
WHERE iaf.IS_VOID
                AND iaf.CHECKSTATUS <> ''MergeVoided''
                AND iaf.DW_ISCURRENTROW 
                AND NOT iaf.DW_ISDELETED
                AND NOT iaf.IS_TRAINING 
                AND (imf.DW_ISCURRENTROW  OR imf.DW_ISCURRENTROW IS NULL)
                AND (vdr_item.DW_ISCURRENTROW OR vdr_item.DW_ISCURRENTROW IS NULL             )
GROUP BY iaf.item_fact_nk,iaf.cheque_fact_fk 
;
-- select * from TEMP_ITEM where CHEQUE_FACT_FK =243922 ;
-------------------------------------------------------------------------------------------------------------------------
 CREATE TEMP TABLE TEMP_ITEM AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));
  
-------------------------------------------------------------------------------------------------------------------------
 reportSet   := (
        SELECT to_char(act.activity_fact_nk)        AS ""Support ID"" 
          ,''VOID-'' ||row_number() over (order by act.activity_fact_nk) 
                                                    AS ""Detail ID""        
        --status, category, level-----------------------------------------------------------------------------------------
        ,CASE act.TYPE 
          WHEN ''ItemVoided'' 
            THEN ''Item'' 
          WHEN ''Voided'' 
            THEN ''Check''
            ELSE ''None'' 
          END 
                                                 AS ""Level""          --Values of Check or Item.
        --geography--------------------------------------------------------------------------------------------------------
        ,IFNULL(LOC.LOCATIONNAME ,''None'')        AS ""Location""
        ,LOC.LOCATION_DIM_NK                     AS ""Location ID""        
        ,IFNULL(CHK.revenueCenterName ,''None'')   AS ""Revenue Center""
        --dates------------------------------------------------------------------------------------------------------------- 
        ,LOC.TZ_NAME                                                               AS ""Time Zone""
        ,to_char(LEFT(chk.FISCAL_DATE,4))                                          AS ""Year""
        ,to_char(YEAR(chk.FISCAL_DATE)) || ''|'' || TO_CHAR(RIGHT(''0'' || MONTH(chk.FISCAL_DATE),2))                                       
                                                                                   AS ""Year and Month""
        ,IFNULL(dad.DAYPART,''None'')                                                AS ""Daypart""
        ,to_char(chk.FISCAL_DATE)                                                  AS ""Fiscal Date""
        
        --,chk.OPENED_AT::timestamp_ntz 
         ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHK.OPENED_AT::timestamp_ntz )::timestamp )
                                                                                   AS ""Check Opened At""     
        --,chk.CREATED_AT::timestamp_ntz 
        ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHK.CREATED_AT::timestamp_ntz )::timestamp) 
                                                                                   AS ""Item Ordered At""    
        -- ,act.PERFORMED_AT::timestamp_ntz 
        ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,act.PERFORMED_AT::timestamp_ntz )::timestamp) 
                                                                                   AS ""Voided At""
        
        ,dad.DAYPART                                                               AS ""Day Part""              
        ,IFNULL(DAYNAME(chk.FISCAL_DATE),''None'')                                   AS ""Day of Week""
        ,CASE WHEN DAYNAME(chk.FISCAL_DATE) IN (''Sat'',''Sun'')  
           THEN TRUE ELSE FALSE END                                                AS ""Is Weekend""
        
        ,TIMESTAMPDIFF(second ,chk.OPENED_AT,act.PERFORMED_AT)::NUMBER(18,0) 
                                                                                   AS ""Seconds to Void""
        ,TIMESTAMPDIFF(minute ,chk.OPENED_AT,act.PERFORMED_AT) ::NUMBER(18,0)
                                                                                   AS ""Minutes to Void""                                                 
        --Flags---------------------------------------------------------------------------------------------------------
        --People--------------------------------------------------------------------------------------------------------
        ,IFNULL(amd_asperf.EMPLOYEE_NAME,''None'') AS ""Voider""
        ,IFNULL(amd_asapp.EMPLOYEE_NAME,''None'')  AS ""Approver""   
        --Descriptors----------------------------------------------------------------------------------------------------
        ,chk.CHEQUENUMBER                        AS ""Check""
        ,chk.CHEQUE_FACT_NK                      AS ""Check ID""
        ,IFNULL(COALESCE(itf.VOIDREASON,
         vdr_check.VOIDREASON),''None'')           AS ""Reason""
        
          
        ,IFNULL(act.MENUITEMNAME,''None'')         AS ""Item""
        ,itf.ITEM_FACT_NK                        AS ""Item ID""    

        --Facts-----------------------------------------------------------------------------------------------------------
        ,1::NUMBER(18,0)                         AS ""Count""  
        ,CASE WHEN act.TYPE = ''ItemVoided'' 
            THEN itf.PRICE 
         -- ELSE chk.NET END::NUMBER(18,2)
          ELSE chk.GROSS END::NUMBER(18,2)
                                                 AS ""Amount""                   
        FROM DATAWAREHOUSE.ACTIVITY_FACT                                  act
           INNER JOIN  DATAWAREHOUSE.LOCATION_DIM                         loc
              ON act.LOCATION_DIM_FK = loc.LOCATION_DIM_NK
                AND act.LOCATION_DIM_fK IN (
                    SELECT table1.value 
                      FROM table(split_to_table(:locationidS, '',''))  table1)
                AND loc.DW_ISCURRENTROW 
                AND NOT loc.DW_ISDELETED
            INNER JOIN DATAWAREHOUSE.CHEQUE_FACT                          chk
              ON act.CHEQUE_FACT_FK = chk.CHEQUE_FACT_NK
                AND act.IS_VOID
                AND act.DW_ISCURRENTROW 
                AND chk.FISCAL_DATE::date >= :startdate::date 
                AND chk.FISCAL_DATE::date <= :enddate::date  
                AND NOT act.DW_ISDELETED
                AND chK.DW_ISCURRENTROW 
                AND NOT chk.DW_ISDELETED
                AND NOT chk.IS_TRAINING
            INNER JOIN DATAWAREHOUSE.DAYPART_DIM                          dad
              ON chk.DAYPART_DIM_FK = dad.daypart_dim_Nk
                AND dad.DW_ISCURRENTROW 
                AND NOT dad.DW_ISDELETED
           
            LEFT JOIN DATAWAREHOUSE.EMPLOYEE_DIM                          amd_asperf
              ON act.EMPLOYEE_DIM_FK_AS_PERFORMING_EMPLOYEE 
                  = amd_asperf.EMPLOYEE_DIM_NK
                AND amd_asperf.DW_ISCURRENTROW 
                AND NOT amd_asperf.DW_ISDELETED 
            LEFT JOIN DATAWAREHOUSE.EMPLOYEE_DIM                          amd_asapp
              ON act.EMPLOYEE_DIM_FK_AS_APPROVING_EMPLOYEE 
                  = amd_asapp.EMPLOYEE_DIM_NK
                AND amd_asapp.DW_ISCURRENTROW 
                AND NOT amd_asapp.DW_ISDELETED   
            LEFT JOIN DATAWAREHOUSE.VoidReason_DIM                        vdr_check
             ON vdr_check.VOIDREASON_DIM_NK = CHK.VoidReason_DIM_FK
               AND vdr_check.DW_ISCURRENTROW 
               AND NOT vdr_check.DW_ISDELETED
            LEFT JOIN TEMP_ITEM                                              itf
              ON itf.Item_fact_NK = act.Item_fact_fk    
              
--=================================================================================================================
); 
 RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,SP_STAGELOADCASHBANKEVENT_FACT(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADCASHBANKEVENT_FACT""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.CASHBANKEVENT_FACT),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.CASHBANKEVENT_FACT(   
          CASHBANKEVENT_FACT_NK, 
          EVENT_TYPE, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          EMPLOYEE_DIM_FK, 
          CASHBANK_DIM_FK, 
          CREATED_AT, 
          NOTES, 
          AMOUNT 
) 
 SELECT   CASHBANKEVENT_FACT_NK  as   CASHBANKEVENT_FACT_NK,  
   EVENT_TYPE  as   EVENT_TYPE,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   EMPLOYEE_DIM_FK  as   EMPLOYEE_DIM_FK,  
   CASHBANK_DIM_FK  as   CASHBANK_DIM_FK,  
   CREATED_AT  as   CREATED_AT,  
   NOTES  as   NOTES,  
   AMOUNT  as   AMOUNT 
  FROM DATAADMIN.CASHBANKEVENT_FACT
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''CASHBANKEVENT_FACT'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''CASHBANKEVENT_FACT'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADGIFTCARD_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADGIFTCARD_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.GIFTCARD_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.GIFTCARD_DIM(   
          GIFTCARD_DIM_NK, 
          GIFTCARD, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          MERCHANT_DIM_FK, 
          IS_LEGACY, 
          IS_ISSUED, 
          CREATED_AT, 
          EXPIRES_AT, 
          UPDATED_AT, 
          ISSUED_AT, 
          BALANCE_REQUESTED_AT, 
          BATCH_ID, 
          BALANCE_REQUEST_COUNT, 
          BALANCE, 
          START_BALANCE 
) 
 SELECT   GIFTCARD_DIM_NK  as   GIFTCARD_DIM_NK,  
   GIFTCARD  as   GIFTCARD,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   MERCHANT_DIM_FK  as   MERCHANT_DIM_FK,  
   IS_LEGACY  as   IS_LEGACY,  
   IS_ISSUED  as   IS_ISSUED,  
   CREATED_AT  as   CREATED_AT,  
   EXPIRES_AT  as   EXPIRES_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   ISSUED_AT  as   ISSUED_AT,  
   BALANCE_REQUESTED_AT  as   BALANCE_REQUESTED_AT,  
   BATCH_ID  as   BATCH_ID,  
   BALANCE_REQUEST_COUNT  as   BALANCE_REQUEST_COUNT,  
   BALANCE  as   BALANCE,  
   START_BALANCE  as   START_BALANCE 
  FROM DATAADMIN.GIFTCARD_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''GIFTCARD_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''GIFTCARD_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADLOCATION_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADLOCATION_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.LOCATION_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.LOCATION_DIM(   
          LOCATION_DIM_NK, 
          LOCATIONNAME, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          ADDRESS_DIM_FK, 
          ORGANIZATION_DIM_FK, 
          CREATED_AT, 
          UPDATED_AT, 
          FISCAL_DAY_START, 
          TZ_NAME 
) 
 SELECT   LOCATION_DIM_NK  as   LOCATION_DIM_NK,  
   LOCATIONNAME  as   LOCATIONNAME,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   ADDRESS_DIM_FK  as   ADDRESS_DIM_FK,  
   ORGANIZATION_DIM_FK  as   ORGANIZATION_DIM_FK,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   FISCAL_DAY_START  as   FISCAL_DAY_START,  
   TZ_NAME  as   TZ_NAME 
  FROM DATAADMIN.LOCATION_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''LOCATION_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''LOCATION_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADORGANIZATION_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADORGANIZATION_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.ORGANIZATION_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.ORGANIZATION_DIM(   
          ORGANIZATION_DIM_NK, 
          ORGANIZATION, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          DO_AUTO_END_SHIFTS, 
          FISCAL_DAY_START, 
          START_OF_PAYROLL_WEEK_INT, 
          START_OF_BIZ_WEEK_INT, 
          CREATED_AT, 
          UPDATED_AT, 
          STATUS, 
          VERSION, 
          SERVICE_LEVEL, 
          DEFAULT_CURRENCY, 
          SUPPORTED_CURRENCIES 
) 
 SELECT   ORGANIZATION_DIM_NK  as   ORGANIZATION_DIM_NK,  
   ORGANIZATION  as   ORGANIZATION,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   DO_AUTO_END_SHIFTS  as   DO_AUTO_END_SHIFTS,  
   FISCAL_DAY_START  as   FISCAL_DAY_START,  
   START_OF_PAYROLL_WEEK_INT  as   START_OF_PAYROLL_WEEK_INT,  
   START_OF_BIZ_WEEK_INT  as   START_OF_BIZ_WEEK_INT,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   STATUS  as   STATUS,  
   VERSION  as   VERSION,  
   SERVICE_LEVEL  as   SERVICE_LEVEL,  
   DEFAULT_CURRENCY  as   DEFAULT_CURRENCY,  
   SUPPORTED_CURRENCIES  as   SUPPORTED_CURRENCIES 
  FROM DATAADMIN.ORGANIZATION_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''ORGANIZATION_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''ORGANIZATION_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,"SP_GETPERSPECTIVESCHEMA(VARCHAR, TIMESTAMP_TZ)","CREATE OR REPLACE PROCEDURE ""SP_GETPERSPECTIVESCHEMA""(""SPROCNAME"" VARCHAR(500), ""STARTDATE"" TIMESTAMP_TZ(9))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS '
--=================================================================================================================
--This sproc creates the schema for a Perspective Report from the Source Data Stored Proceedure
-- call SP_GetPerspectiveSchema;
--=================================================================================================================
DECLARE 
--sprocName VARCHAR(500):= ''DATAADMIN.SP_REPORT_PMIX'';
 -- startdate timestamp_tz :=      ''2000-11-20T14:48:37.661Z'';  
  enddate timestamp_tz :=        ''2023-11-20T14:48:37.661Z''; 
  locationid number :=            351;
  dataout resultset;  

BEGIN
  drop table if exists schema_data; 
  CALL DATAADMIN.SP_REPORT_PMIX(''2000-11-20T14:48:37.661Z'',''2023-11-20T14:48:37.661Z'',351) ;
 
  CREATE TABLE schema_data AS
    SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

  ALTER TABLE schema_data ADD COLUMN MAXROW NUMBER;

  dataout := (

  SELECT   ''""schema"": {\\n''
    || LISTAGG (''  '' || ''""'' 
     || COLUMN_NAME 
     || ''"" : '' 
     || CASE DATA_TYPE 
       WHEN ''TEXT'' THEN ''""str""'' 
       WHEN ''NUMBER'' THEN ''""float""''
       WHEN ''TIMESTAMP_TZ'' THEN ''""datetime""'' 
       WHEN ''BOOLEAN'' THEN ''""bool""''
      ELSE DATA_TYPE END 
      || '','' 
      || ''\\n''
      ) || ''}''
      AS DATA_TYPE 
    FROM information_schema.columns 
    WHERE table_name=''SCHEMA_DATA'' 
    ORDER BY ORDINAL_POSITION
    );
    

  return table(dataout);
END
';"
PROCEDURE,DATAADMIN,"SP_REPORT_DISCOUNT_SUMMARY(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_DISCOUNT_SUMMARY""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2020-09-18T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2024-09-18T14:48:37.661Z''; 
  -- locationid string      := ''[351,352]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--======================================================================================================
BEGIN
 reportSet   := (
        SELECT CHF.DISCOUNTitem_FACT_NK                      AS ""Support ID"" 
           , ''DISI-'' ||row_number() over (order by  CHF.DISCOUNTitem_FACT_NK ) 
                                                             AS ""Detail ID""
         --Status, categories and levels----------------------------------------------------------
            ,CHF.STATUS                                      AS ""Status"" 
            ,CHF.DISCOUNTLEVEL                               AS ""Discount Level""
        --geography--------------------------------------------------------------------------------
            ,IFNULL(LOC.LOCATIONNAME ,''None'')                AS ""Location""
            ,CHF.LOCATION_DIM_FK::DECIMAL(36,0)              AS ""Location ID""
            ,IFNULL(CHF.revenueCenterName ,''None'')           AS ""Revenue Center""
        --dates-------------------------------------------------------------------------------------  
        
            ,LOC.TZ_NAME                                     AS ""Time Zone""
            ,to_char(LEFT(CHF.FISCAL_DATE,4))                AS ""Year""
            ,to_char(YEAR(CHF.FISCAL_DATE)) || ''|'' || TO_CHAR(RIGHT(''0'' || MONTH(CHF.FISCAL_DATE),2))
                                                             AS ""Year and Month""
            ,IFNULL(dad.DAYPART,''None'')                      AS ""Daypart""
            ,to_char(CHF.FISCAL_DATE)                        AS ""Fiscal Date""
            ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHF.ADDED_AT::timestamp_ntz ))                           
                                                             AS ""Added At""

            ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHF.CREATED_AT::timestamp_ntz ))                                             
  
                                                             AS ""Created At""
            ,IFNULL(DAYNAME(CHF.FISCAL_DATE),''None'') 
                                                             AS ""Day of Week""
            ,CASE WHEN DAYNAME(CHF.FISCAL_DATE) IN (''Sat'',''Sun'')  
                THEN TRUE ELSE FALSE END                     AS ""Is Weekend""
    
        --flags-------------------------------------------------------------------------------------
        --people------------------------------------------------------------------------------------
            ,COALESCE(EMD_ADD.EMPLOYEE_NAME,''None'')          AS ""Added By""
            ,COALESCE(EMD_APP.EMPLOYEE_NAME,''None'')          AS ""Approved By""
        --Descriptors------------------------------------------------------------------------------
            ,STD.STANDARDDISCOUNTNAME                        AS ""Discount Name""
            ,CHF.DISCOUNTREASON                              AS ""Discount Reason""
            ,CHF.PROMOCODE                                   AS ""Promo Code"" 
            ,CHF.CHEQUENUMBER                                AS ""Check""  
            ,CHF.CHEQUE_FACT_FK                              AS ""Check ID""
            ,STD.DISCOUNTTYPE                                AS ""Discount Type""
            ,CHF.DISCOUNT_TYPE                               AS ""Application""  
        --Facts-----------------------------------------------------------------------------------------
            ,1::NUMBER(10,0)                                 AS ""Count""   
            ,CHF.DISCOUNT_PERCENT::NUMBER(18,2)              AS ""Discount Percent""   
            ,CHF.NET             ::NUMBER(18,2)              AS ""Check Net Amount"" 
            ,CHF.GROSS           ::NUMBER(18,2)              AS ""Check Gross Amount""
            ,itf.APPLIEDAMOUNT   ::NUMBER(18,2)              AS ""Discount Net Sales""
            ,CHF.APPLIED_AMOUNT  ::NUMBER(18,2)              AS ""Discount Amount"" 
         
                                                    --Percentages must be calculated within pyarrow cube as numerator and denominator can be filtred dynamically
            -- ,NULL                                AS ""% of Total Discounts"" --ex: per discount id: total count / all discount count    
            -- ,NULL                                AS ""Discount % of Net Sales""  --example (total discount amount / net sales + total discount amount) * 100 
                                                    --This represents the presumed % of lost revenue
        --------------------------------------------------------------------------------------------------------
        FROM DATAWAREHOUSE.DISCOUNTITEM_FACT                  CHF
            INNER JOIN DATAWAREHOUSE.ITEM_FACT                ITF
              ON CHF.ITEM_FACT_FK = ITF.ITEM_FACT_NK
                  AND ITF.ITEMSTATUS IN (''Added'',''Sent'')
                  AND NOT CHF.STATUS  = ''Disabled''
                  AND CHF.CHEQUESTATUS  IN (''Closed'')
                  AND IFNULL(CHF.APPLIED_AMOUNT,0.00) > 0.00
                  -- AND CHF.DISCOUNTREASON <> ''CASHDISCOUNT''
                  AND CHF.FISCAL_DATE::date
                      >= :startdate::date
                  AND CHF.FISCAL_DATE::date   
                      <= :enddate ::date 
                  AND CHF.LOCATION_DIM_FK IN (
                     SELECT table1.value 
                       FROM table(split_to_table(:locationidS, '',''))  table1)
                  AND CHF.DW_ISCURRENTROW
                  AND ITF.DW_ISCURRENTROW
                  AND NOT CHF.DW_ISDELETED                
                  AND NOT CHF.IS_TRAINING
            INNER JOIN DATAWAREHOUSE.LOCATION_DIM            LOC  
              ON CHF.LOCATION_DIM_FK = LOC.LOCATION_DIM_NK
                 AND LOC.DW_ISCURRENTROW  
            INNER JOIN DATAWAREHOUSE.STANDARDDISCOUNT_DIM    STD
               ON STD.STANDARDDISCOUNT_DIM_NK = CHF.STANDARDDISCOUNT_DIM_FK
                 AND STD.DW_ISCURRENTROW
            INNER JOIN DATAWAREHOUSE.DAYPART_DIM             DAD
              ON CHF.DAYPART_DIM_FK = DAD.DAYPART_DIM_NK
                  AND DAD.DW_ISCURRENTROW
            LEFT JOIN DATAWAREHOUSE.EMPLOYEE_DIM             EMD_ADD
              ON EMPLOYEE_DIM_FK_AS_ADDED_BY = EMD_ADD.EMPLOYEE_DIM_NK
                AND EMD_ADD.DW_ISCURRENTROW
            LEFT JOIN DATAWAREHOUSE.EMPLOYEE_DIM            EMD_APP
              ON EMPLOYEE_DIM_FK_AS_APPROVED_BY = EMD_APP.EMPLOYEE_DIM_NK
                AND EMD_APP.DW_ISCURRENTROW
UNION ALL

        SELECT CHF.DISCOUNTCHECK_FACT_NK                    AS ""Support ID"" 
                   ,''DISC-'' || row_number() over (order by  CHF.DISCOUNTCHECK_FACT_NK ) 
                                                            AS ""Detail ID""
         --Status, categories and levels----------------------------------------------------------
            ,CHF.STATUS                                     AS ""Status""
            ,CHF.DISCOUNTLEVEL                              AS ""Discount Level""
        --geography--------------------------------------------------------------------------------
            ,IFNULL(LOC.LOCATIONNAME ,''None'')               AS ""Location""
            ,CHF.LOCATION_DIM_FK::DECIMAL(36,0)             AS ""Location ID""
            ,IFNULL(CHF.revenueCenterName ,''None'')          AS ""Revenue Center""
        --dates-------------------------------------------------------------------------------------  
            ,LOC.TZ_NAME                                    AS ""Time Zone""        
            ,to_char(LEFT( CHF.FISCAL_DATE,4))              AS ""Year""
            ,to_char(YEAR(CHF.FISCAL_DATE)) || ''|'' || TO_CHAR(RIGHT(''0'' || MONTH(CHF.FISCAL_DATE),2))
                                                            AS ""Year and Month""
            ,IFNULL(dad.DAYPART,''None'')                     AS ""Daypart""
            ,to_char(CHF.FISCAL_DATE)                      
                                                            AS ""Fiscal Date""
            ,to_char(CHF.ADDED_AT::timestamp_ntz)                            
                                                            AS ""Added At""
            ,to_char(CHF.CREATED_AT::timestamp_ntz)                          
                                                            AS ""Created At""
            ,IFNULL(DAYNAME(
            CHF.FISCAL_DATE 
            )
            ,''None'')                                        AS ""Day of Week""
            ,CASE WHEN DAYNAME(
            CHF.FISCAL_DATE 
            ) IN (''Sat'',''Sun'')  
            THEN TRUE ELSE FALSE END                        AS ""Is Weekend""
        --flags-------------------------------------------------------------------------------------
        --people------------------------------------------------------------------------------------
            ,COALESCE(EMD_ADD.EMPLOYEE_NAME,''None'')         AS ""Added By""
            ,COALESCE(EMD_APP.EMPLOYEE_NAME,''None'')         AS ""Approved By"" 
        --Descriptors------------------------------------------------------------------------------
            ,STD.STANDARDDISCOUNTNAME                       AS ""Discount Name""
            ,CHF.DISCOUNTREASON                             AS ""Discount Reason""
            ,CHF.PROMOCODE                                  AS ""Promo Code"" 
            ,CHF.CHEQUENUMBER                               AS ""Check"" 
            ,CHF.CHEQUE_FACT_FK                             AS ""Check ID""
            ,STD.DISCOUNTTYPE                               AS ""Discount Type""
            ,CHF.DISCOUNT_TYPE                              AS ""Application""  
        --Facts-----------------------------------------------------------------------------------------
            ,1                           ::NUMBER(10,0)     AS ""Count""          
            ,CHF.DISCOUNT_PERCENT        ::NUMBER(18,2)     AS ""Discount Percent""   
            ,CHF.NET                     ::NUMBER(18,2)     AS ""Check Net Amount"" 
            ,CHF.GROSS                   ::NUMBER(18,2)     AS ""Check Gross Amount""
            ,(CHF.GROSS - CHF.DISCOUNT)  ::NUMBER(18,2)     AS ""Discount Net Sales""
            ,CHF.APPLIED_AMOUNT          ::NUMBER(18,2)     AS ""Discount Amount"" 
         
                                                    --Percentages must be calculated within pyarrow cube as numerator and denominator can be filtred dynamically
            -- ,NULL                                AS ""% of Total Discounts"" --ex: per discount id: total count / all discount count    
            -- ,NULL                                AS ""Discount % of Net Sales""  --example (total discount amount / net sales + total discount amount) * 100 
                                                    --This represents the presumed % of lost revenue
        --------------------------------------------------------------------------------------------------------
        FROM DATAWAREHOUSE.DISCOUNTCHECK_FACT                CHF
            INNER JOIN DATAWAREHOUSE.LOCATION_DIM            LOC
              ON CHF.LOCATION_DIM_FK = LOC.LOCATION_DIM_NK
                AND IFNULL(CHF.APPLIED_AMOUNT,0.00) > 0.00
                  AND CHF.FISCAL_DATE::date
                      >= :startdate::date
                  AND CHF.FISCAL_DATE::date   
                      <= :enddate ::date 
                  AND CHF.LOCATION_DIM_FK IN (
                     SELECT table1.value 
                       FROM table(split_to_table(:locationidS, '',''))  table1)
                  AND CHF.CHEQUESTATUS IN (''Closed'')
                  AND NOT CHF.STATUS = ''Disabled''
                  -- AND CHF.DISCOUNTREASON <> ''CASHDISCOUNT''
                  AND CHF.DW_ISCURRENTROW
                  AND NOT CHF.DW_ISDELETED
                  AND LOC.DW_ISCURRENTROW          
                  AND NOT CHF.IS_TRAINING
            INNER JOIN DATAWAREHOUSE.DAYPART_DIM                 DAD
              ON CHF.DAYPART_DIM_FK = DAD.DAYPART_DIM_NK
                  AND DAD.DW_ISCURRENTROW                  
            LEFT JOIN DATAWAREHOUSE.STANDARDDISCOUNT_DIM         STD
               ON STD.STANDARDDISCOUNT_DIM_NK = CHF.STANDARDDISCOUNT_DIM_FK
                 AND STD.DW_ISCURRENTROW
            LEFT JOIN DATAWAREHOUSE.EMPLOYEE_DIM                 EMD_ADD
              ON EMPLOYEE_DIM_FK_AS_ADDED_BY = EMD_ADD.EMPLOYEE_DIM_NK
                AND EMD_ADD.DW_ISCURRENTROW
            LEFT JOIN DATAWAREHOUSE.EMPLOYEE_DIM                 EMD_APP
              ON EMPLOYEE_DIM_FK_AS_APPROVED_BY = EMD_APP.EMPLOYEE_DIM_NK
                AND EMD_APP.DW_ISCURRENTROW        
--==========================================================================================
); 
 RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,"SP_REPORT_TEST(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_TEST""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS '
-- -- =====================================================================================
--Example Call Statement
--CALL DATAADMIN.SP_REPORT_PMIX(''2000-11-20T14:48:37.661Z'',''2023-11-20T14:48:37.661Z'',''[351,352]'');
-- =======================================================================================
-- --NOTE:  Convert to local timezone.
-- --NOTE:  Split checks - report quantity - what about an item that was split, but one split check was -- --=========================================================================================
DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2000-11-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2023-11-20T14:48:37.661Z''; 
  -- locationid string      := ''[351,352]'';
  locationidS string        :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--=========================================================================================
BEGIN
 reportSet:= (
SELECT ITEM_FACT_NK                                       as ""Support ID"" 
--status, category, level-------------------------------------------------------------------
    ,IFNULL(itf.CHECKSTATUS,''None'')                       as ""Check Status""
    ,IFNULL(itf.ITEMSTATUS,''None'')                        as ""Item Status""
    ,IFNULL(itf.STATUSREASON,''None'')                      as ""Status Reason""
    ,IFNULL(meg.REPORTCATEGORY,''None'')                    as ""Category""
-- --geography--------------------------------------------------------------------------------
    ,IFNULL(loc.LOCATIONNAME,''None'')                      as ""Location""
    ,IFNULL(itf.REVENUECENTERNAME,''None'')                 as ""Revenue Center""
-- --dates-------------------------------------------------------------------------------------
    ,to_char(LEFT(itf.OPENED_AT,4))                       as ""Year""
    ,to_char(LEFT(itf.OPENED_AT,7))                       as ""Year and Month""
    ,IFNULL(dad.DAYPART,''None'')                           as ""Daypart""
    ,itf.OPENED_AT                                        as ""Opened At""
    ,IFNULL(DAYNAME(itf.OPENED_AT),'' None'') 
                                                          as ""Day of Week""
    ,CASE WHEN DAYNAME(itf.OPENED_AT) IN (''Sat'',''Sun'')  
    THEN TRUE ELSE FALSE END                              as ""Is Weekend""
-- --flags--------------------------------------------------------------------------------------
    ,IFNULL(itf.HASMODIFIERS,FALSE)                       as ""Has Modifiers""
-- --people-------------------------------------------------------------------------------------
    ,IFNULL(emd.EMPLOYEE_NAME,''None'')                     as ""Employee""
-- --Descriptors-------------------------------------------------------------------------------- 
    ,IFNULL(itf.chequenumber ,''None'')                     as ""Check""
    ,IFNULL(mid.MENUITEMNAME,'' None'')                     as ""Menu Item""
    ,IFNULL(itf.NOTE,''None'')                              as ""Note""
    ,IFNULL(itf.DESCRIPTION,''None'')                       as ""Description""
    ,IFNULL(vad.VARIANT,''None'')                           as ""Variant""     
    ,itf.SPLITBY                                          as ""Split By""
-- --Facts-----------------------------------------------------------------------------------------
    ,1::NUMBER(18,0)                                      as ""Count""
    ,itf.REPORTQUANTITY::NUMBER(18,2)                     as ""Report Quantity""                   
    -- ,itf.BASEPRICE::NUMBER(18,2)                          as ""Base Price""
    -- ,itf.INCLUSIVETAX::NUMBER(18,2)                       as ""Inclusive Tax""
    -- ,itf.PRICE::NUMBER(18,2)                              as ""Price""
    -- ,itf.GROSS::NUMBER(18,2)                              as ""Gross""  
    -- ,itf.NET::NUMBER(18,2)                                as ""Net""  
    -- ,itf.TAX::NUMBER(18,2)                                as ""Tax""
    -- ,itf.TOTAL::NUMBER(18,2)                              as ""Total"" 
--------------------------------------------------------------------------------------------   
FROM DATAADMIN.ITEM_FACT                                  itf
     INNER JOIN DATAADMIN.MENUITEM_DIM                    med
       ON med.menuitem_dim_pk = itf.menuitem_dim_fk
          AND itf.ITEMSTATUS IN (''Added'',''Sent'')
          AND NOT itf.CHECKSTATUS = ''Voided''
          AND OPENED_AT > :startdate
          and OPENED_AT < :enddate
          AND itf.LOCATION_DIM_FK IN (--351,352
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)
          AND itf.OPENED_AT is not null
          AND itf.DW_ISCURRENTROW  
          AND med.DW_ISCURRENTROW  
          AND NOT itf.DW_ISDELETED
          AND NOT med.DW_ISDELETED
          AND NOT itf.IS_TRAINING
      INNER JOIN DATAADMIN.EMPLOYEE_DIM                     emd
        ON itf.employee_dim_fk = emd.employee_dim_pk
          AND emd.DW_ISCURRENTROW 
      INNER JOIN DATAADMIN.DAYPART_DIM                      dad
        ON itf.daypart_dim_fk = dad.daypart_dim_pk
          AND dad.DW_ISCURRENTROW = TRUE         
      INNER JOIN DATAADMIN.LOCATION_DIM                     loc
        ON itf.LOCATION_DIM_FK = loc.LOCATION_DIM_NK
          AND loc.DW_ISCURRENTROW
      INNER JOIN DATAADMIN.REPORTCATEGORY_DIM               meg
        ON med.REPORTCATEGORY_DIM_FK = meg.REPORTCATEGORY_DIM_NK
          AND med.DW_ISCURRENTROW = TRUE
      INNER JOIN DATAADMIN.MENUITEMNAME_DIM                 mid
        ON mid.menuitemname_dim_nk = med.menuitemname_dim_fk
          AND mid.DW_ISCURRENTROW 
      INNER JOIN DATAADMIN.VARIANT_DIM                      vad
        ON med.variant_dim_fk = vad.variant_dim_nk
          AND vad.dw_iscurrentrow
      ORDER BY itf.OPENED_AT
--==========================================================================================
);
RETURN TABLE(reportSet); 
END;
-- ';"
PROCEDURE,DATAADMIN,SP_REPORT_TESTQ(),"CREATE OR REPLACE PROCEDURE ""SP_REPORT_TESTQ""()
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS '
-- -- ====================================================================================================================
--Example Call Statement
--CALL DATAADMIN.SP_REPORT_PMIX(''2000-11-20T14:48:37.661Z'',''2023-11-20T14:48:37.661Z'',''[351,352]'');
-- ====================================================================================================================
DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2000-11-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2023-11-20T14:48:37.661Z''; 
  -- locationid string      := ''[351,352]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
-- -- ====================================================================================================================
-- --NOTE:  Convert to local timezone.
-- --NOTE:  Split checks - report quantity - what about an item that was split, but one split check was 
-- --       removed?  In that case, we would have 3/4 of an item see sql.
-- --==========================================================================================
BEGIN

reportSet := (
 SELECT 1 as count
    
--------------------------------------------------------------------------------------------   
FROM DATAADMIN.ITEM_FACT                                    itf
     
--==========================================================================================
);
RETURN TABLE(reportSet); 
END;
';"
PROCEDURE,DATAADMIN,SP_STAGELOADCHECKCASHPAYMENTLEDGER_FACT(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADCHECKCASHPAYMENTLEDGER_FACT""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.CHECKCASHPAYMENTLEDGER_FACT),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.CHECKCASHPAYMENTLEDGER_FACT(   
          CHECKCASHPAYMENTLEDGER_FACT_NK, 
          PAYMENT, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          CHEQUE_FACT_FK, 
          SHIFT_DIM_FK, 
          PAYMENTMETHOD_DIM_FK, 
          PAYMENTS_FACT_FK, 
          IS_VOID, 
          CREATED_AT, 
          UPDATED_AT, 
          AMOUNT_TENDERED, 
          AMOUNT_CHANGED 
) 
 SELECT   CHECKCASHPAYMENTLEDGER_FACT_NK  as   CHECKCASHPAYMENTLEDGER_FACT_NK,  
   PAYMENT  as   PAYMENT,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   CHEQUE_FACT_FK  as   CHEQUE_FACT_FK,  
   SHIFT_DIM_FK  as   SHIFT_DIM_FK,  
   PAYMENTMETHOD_DIM_FK  as   PAYMENTMETHOD_DIM_FK,  
   PAYMENTS_FACT_FK  as   PAYMENTS_FACT_FK,  
   IS_VOID  as   IS_VOID,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   AMOUNT_TENDERED  as   AMOUNT_TENDERED,  
   AMOUNT_CHANGED  as   AMOUNT_CHANGED 
  FROM DATAADMIN.CHECKCASHPAYMENTLEDGER_FACT
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''CHECKCASHPAYMENTLEDGER_FACT'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''CHECKCASHPAYMENTLEDGER_FACT'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADEMPLOYMENTPERIOD_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADEMPLOYMENTPERIOD_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.EMPLOYMENTPERIOD_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.EMPLOYMENTPERIOD_DIM(   
          EMPLOYMENTPERIOD_DIM_NK, 
          EMPLOYMENTPERIOD_ID, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          EMPLOYEE_DIM_FK, 
          JOBPOSITION_DIM_FK, 
          LOCATION_DIM_FK, 
          LOCATION_GROUP_DIM_FK, 
          CREATED_AT, 
          UPDATED_AT, 
          STARTED_AT, 
          ENDED_AT, 
          PAY_RATE_AMOUNT, 
          PAY_RATE_PER_SECOND 
) 
 SELECT   EMPLOYMENTPERIOD_DIM_NK  as   EMPLOYMENTPERIOD_DIM_NK,  
   EMPLOYMENTPERIOD_ID  as   EMPLOYMENTPERIOD_ID,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   EMPLOYEE_DIM_FK  as   EMPLOYEE_DIM_FK,  
   JOBPOSITION_DIM_FK  as   JOBPOSITION_DIM_FK,  
   LOCATION_DIM_FK  as   LOCATION_DIM_FK,  
   LOCATION_GROUP_DIM_FK  as   LOCATION_GROUP_DIM_FK,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   STARTED_AT  as   STARTED_AT,  
   ENDED_AT  as   ENDED_AT,  
   PAY_RATE_AMOUNT  as   PAY_RATE_AMOUNT,  
   PAY_RATE_PER_SECOND  as   PAY_RATE_PER_SECOND 
  FROM DATAADMIN.EMPLOYMENTPERIOD_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''EMPLOYMENTPERIOD_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''EMPLOYMENTPERIOD_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADERRORDWDATE_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADERRORDWDATE_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.ERRORDWDATE_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.ERRORDWDATE_DIM(   
          ERRORDWDATE_DIM_NK, 
          REPORTCATEGORY, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_ISCURRENTROW, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          ORGANIZATION_DIM_FK, 
          CREATED_AT, 
          MODIFIED_AT, 
          TESTERROR_AT, 
          TESTERROR_ID, 
          IS_BOOLEANTEST, 
          ERROR_VARIANT, 
          TEST_ID, 
          TEST_DECIMAL_TRUE, 
          TEST_NUMERIC_TRUE, 
          TEST_AMOUNT_FALSE, 
          TEST_BOOLEAN_TRUE, 
          V, 
          VTYPE_INT, 
          VTYPE_DEC, 
          VTYPE_STRING, 
          VTYPE_BOOLEAN, 
          VTYPE_DATE, 
          IS_NAMEBOOLEANERROR, 
          NAMEBOOLEANERROR_IS, 
          NAMENUMBRANERROR_COUNT 
) 
 SELECT   ERRORDWDATE_DIM_NK  as   ERRORDWDATE_DIM_NK,  
   REPORTCATEGORY  as   REPORTCATEGORY,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   ORGANIZATION_DIM_FK  as   ORGANIZATION_DIM_FK,  
   CREATED_AT  as   CREATED_AT,  
   MODIFIED_AT  as   MODIFIED_AT,  
   TESTERROR_AT  as   TESTERROR_AT,  
   TESTERROR_ID  as   TESTERROR_ID,  
   IS_BOOLEANTEST  as   IS_BOOLEANTEST,  
   ERROR_VARIANT  as   ERROR_VARIANT,  
   TEST_ID  as   TEST_ID,  
   TEST_DECIMAL_TRUE  as   TEST_DECIMAL_TRUE,  
   TEST_NUMERIC_TRUE  as   TEST_NUMERIC_TRUE,  
   TEST_AMOUNT_FALSE  as   TEST_AMOUNT_FALSE,  
   TEST_BOOLEAN_TRUE  as   TEST_BOOLEAN_TRUE,  
   V  as   V,  
   VTYPE_INT  as   VTYPE_INT,  
   VTYPE_DEC  as   VTYPE_DEC,  
   VTYPE_STRING  as   VTYPE_STRING,  
   VTYPE_BOOLEAN  as   VTYPE_BOOLEAN,  
   VTYPE_DATE  as   VTYPE_DATE,  
   IS_NAMEBOOLEANERROR  as   IS_NAMEBOOLEANERROR,  
   NAMEBOOLEANERROR_IS  as   NAMEBOOLEANERROR_IS,  
   NAMENUMBRANERROR_COUNT  as   NAMENUMBRANERROR_COUNT 
  FROM DATAADMIN.ERRORDWDATE_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''ERRORDWDATE_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''ERRORDWDATE_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,"SP_WRITESQLALLTABLES(VARCHAR, VARCHAR, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_WRITESQLALLTABLES""(""DBNAME"" VARCHAR(50), ""SCHEMANAME"" VARCHAR(50), ""SQLNAME"" VARCHAR(45))
RETURNS TABLE (""SQLTEXT"" VARCHAR(16777216))
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE
  -- DBNAME VARCHAR(45)             := ''DEV_HOSPENG_REPORTING'';
  -- SCHEMANAME VARCHAR(45)         := ''DATASTAGE'';
  -- SQLNAME VARCHAR(45)            := ''CALL_SP_CreateDWTable'';
----------------------------------------------------------------------------------------------------------------------
  DBName_VAR VARCHAR(075)        := UPPER(DBNAME);
  SchemaName_VAR VARCHAR(075)    := UPPER(SCHEMANAME);
  SQLText VARCHAR(500)           := (SELECT SQLTEXTVALUE FROM DW_SQLTEXT WHERE SQLTEXTNAME = :SQLNAME);
  res_list                       resultset ;
  
----------------------------------------------------------------------------------------------------------------------
BEGIN
----------------------------------------------------------------------------------------------------------------------
--Drop temp table if exists - used for dev as temp tables would be dropped when sproc session ends
DROP TABLE IF EXISTS all_tables_temp CASCADE;  

res_list := (
 SELECT listagg(REPLACE(REPLACE(REPLACE(:SQLText,''<TABLENAME>'',T.TABLE_NAME),''<DBNAME>'',:DBName_VAR),''<SCHEMANAME>'',:SchemaName_VAR)
   || '' \\n '')  AS SQLTEXT
   FROM information_schema.tables t
      WHERE t.table_type    = ''VIEW''
            and t.table_schema  = ''DATAADMIN''
    );
  
 RETURN TABLE(res_list);

END';"
PROCEDURE,DATAADMIN,SP_STAGELOADDISCOUNTITEM_FACT(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADDISCOUNTITEM_FACT""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.DISCOUNTITEM_FACT),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.DISCOUNTITEM_FACT(   
          DISCOUNTITEM_FACT_NK, 
          DISCOUNTNAME, 
          DW_STARTDATE, 
          FISCALDATE, 
          DW_ENDDATE, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISDELETED, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          CHEQUE_FACT_FK, 
          DAYPART_DIM_FK, 
          EMPLOYEE_DIM_FK_AS_ADDED_BY, 
          EMPLOYEE_DIM_FK_AS_APPROVED_BY, 
          EMPLOYEE_DIM_FK, 
          LOCATION_DIM_FK, 
          ITEM_FACT_FK, 
          STANDARDDISCOUNT_DIM_FK, 
          DO_AUTOAPPLY, 
          IS_TRAINING, 
          ADDED_AT, 
          CREATED_AT, 
          FISCAL_DATE, 
          OPENED_AT, 
          UPDATED_AT, 
          APPLICATION, 
          STATUS, 
          CHEQUESTATUS, 
          DISCOUNTREASON, 
          DISCOUNTLEVEL, 
          RECEIPTNAME, 
          PROMOCODE, 
          PROMODESCRIPTION, 
          REVENUECENTERNAME, 
          ROUNDINGMETHOD, 
          CHEQUENUMBER, 
          ITEM_ID, 
          PROMOCODE_ID, 
          DISCOUNT_TYPE, 
          DISCOUNT_PERCENT, 
          APPLIED_AMOUNT, 
          DISCOUNT_AMOUNT, 
          VALUE, 
          DISCOUNT, 
          DISCOUNTCHECK, 
          DISCOUNTITEM, 
          GROSS, 
          NET 
) 
 SELECT   DISCOUNTITEM_FACT_NK  as   DISCOUNTITEM_FACT_NK,  
   DISCOUNTNAME  as   DISCOUNTNAME,  
   DW_STARTDATE  as   DW_STARTDATE,  
   FISCALDATE  as   FISCALDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISDELETED  as   DW_ISDELETED,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   CHEQUE_FACT_FK  as   CHEQUE_FACT_FK,  
   DAYPART_DIM_FK  as   DAYPART_DIM_FK,  
   EMPLOYEE_DIM_FK_AS_ADDED_BY  as   EMPLOYEE_DIM_FK_AS_ADDED_BY,  
   EMPLOYEE_DIM_FK_AS_APPROVED_BY  as   EMPLOYEE_DIM_FK_AS_APPROVED_BY,  
   EMPLOYEE_DIM_FK  as   EMPLOYEE_DIM_FK,  
   LOCATION_DIM_FK  as   LOCATION_DIM_FK,  
   ITEM_FACT_FK  as   ITEM_FACT_FK,  
   STANDARDDISCOUNT_DIM_FK  as   STANDARDDISCOUNT_DIM_FK,  
   DO_AUTOAPPLY  as   DO_AUTOAPPLY,  
   IS_TRAINING  as   IS_TRAINING,  
   ADDED_AT  as   ADDED_AT,  
   CREATED_AT  as   CREATED_AT,  
   FISCAL_DATE  as   FISCAL_DATE,  
   OPENED_AT  as   OPENED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   APPLICATION  as   APPLICATION,  
   STATUS  as   STATUS,  
   CHEQUESTATUS  as   CHEQUESTATUS,  
   DISCOUNTREASON  as   DISCOUNTREASON,  
   DISCOUNTLEVEL  as   DISCOUNTLEVEL,  
   RECEIPTNAME  as   RECEIPTNAME,  
   PROMOCODE  as   PROMOCODE,  
   PROMODESCRIPTION  as   PROMODESCRIPTION,  
   REVENUECENTERNAME  as   REVENUECENTERNAME,  
   ROUNDINGMETHOD  as   ROUNDINGMETHOD,  
   CHEQUENUMBER  as   CHEQUENUMBER,  
   ITEM_ID  as   ITEM_ID,  
   PROMOCODE_ID  as   PROMOCODE_ID,  
   DISCOUNT_TYPE  as   DISCOUNT_TYPE,  
   DISCOUNT_PERCENT  as   DISCOUNT_PERCENT,  
   APPLIED_AMOUNT  as   APPLIED_AMOUNT,  
   DISCOUNT_AMOUNT  as   DISCOUNT_AMOUNT,  
   VALUE  as   VALUE,  
   DISCOUNT  as   DISCOUNT,  
   DISCOUNTCHECK  as   DISCOUNTCHECK,  
   DISCOUNTITEM  as   DISCOUNTITEM,  
   GROSS  as   GROSS,  
   NET  as   NET 
  FROM DATAADMIN.DISCOUNTITEM_FACT
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''DISCOUNTITEM_FACT'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''DISCOUNTITEM_FACT'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,"SP_CREATEDWTABLELOAD(VARCHAR, VARCHAR, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_CREATEDWTABLELOAD""(""DBNAME"" VARCHAR(50), ""SCHEMANAME"" VARCHAR(50), ""TABLENAME"" VARCHAR(50))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
        -- DBNAME VARCHAR(45)    := ''DEV_HOSPENG_REPORTING'';--''CHEQUE_FACT'';--
        -- SCHEMANAME VARCHAR(45):= ''DATASTAGE'';--''CHEQUE_FACT'';--
        -- TABLENAME VARCHAR(50) := ''SHIFT_DIM'';--''ITEM_FACT'';

        IsTableName            VARCHAR(50);
        col_list               RESULTSET;
        res                    RESULTSET;
        select_statement       VARCHAR;
        all_sqltext            VARCHAR;
        ErrorMessage resultset:= (SELECT ''Invalid Table or View Name'' AS ""Error Message"");
        db_name varchar       := UPPER(DBNAME);
        schema_name varchar   := UPPER(SCHEMANAME);
        table_name varchar    := UPPER(TABLENAME);
        sqlText1    varchar   := (SELECT LISTAGG( REPLACE(REPLACE(DST.SQLTEXTVALUE || ''\\n'',''<TABLENAME>''
                                  ,:table_name),''<DBNAME>'',:db_name))WITHIN GROUP (ORDER BY DST.SQLTEXTORDINAL)
                                  FROM DW_SQLText DST
                                    WHERE DST.SQLTEXTGROUP = ''SP_CREATEDATAWAREHOUSETABLELOAD''
                                      AND DST.SQLTEXTNAME = ''SQLTEXT1''
                                      AND DST.ISCURRENTVERSION
                                      AND NOT DST.ISDELETED
                                  ORDER BY DST.SQLTEXTORDINAL);
                                  
        sqlTextB    varchar  := (SELECT LISTAGG(REPLACE(REPLACE(DST.SQLTEXTVALUE || ''\\n'',''<TABLENAME>''
                                  ,:table_name),''<DBNAME>'',:db_name)) WITHIN GROUP (ORDER BY DST.SQLTEXTORDINAL)
                                  FROM DW_SQLText DST
                                    WHERE DST.SQLTEXTGROUP = ''SP_CREATEDATAWAREHOUSETABLELOAD''
                                      AND DST.SQLTEXTNAME = ''SQLTEXTB''
                                      AND DST.ISCURRENTVERSION
                                      AND NOT DST.ISDELETED
                                  ORDER BY DST.SQLTEXTORDINAL);

            
        sqlTextC    varchar  := (SELECT LISTAGG(REPLACE(REPLACE(REPLACE(DST.SQLTEXTVALUE || ''\\n'',''<TABLE_NAME>''
                                  ,:table_name),''<SCHEMA_NAME>'',:schema_name),''<DB_NAME>'',:db_name)) WITHIN GROUP (ORDER BY DST.SQLTEXTORDINAL)
                                  FROM DW_SQLText DST
                                    WHERE DST.SQLTEXTGROUP = ''SP_CREATEDATAWAREHOUSETABLELOAD''
                                      AND DST.SQLTEXTNAME = ''SQLTEXTC''
                                      AND DST.ISCURRENTVERSION
                                      AND NOT DST.ISDELETED
                                  ORDER BY DST.SQLTEXTORDINAL);

        
-----------------------------------------------------------------------------------------
begin
  drop table if exists all_cols_temp; 
  drop table if exists all_sql_temp;
  
  create temp table all_sql_temp (
    ordinal int
    ,sqlText varchar
  );

------------------------------------------------------------------------------------
  create temp table all_cols_temp as
      select  ''  ''
              || c.column_name 
              || case when c.ordinal_position = max(ordinal_position) over (partition by 1)
                     then '' ''
                   else '', ''
                   end as column_name
              ,c.ordinal_position
              ,min(c.ordinal_position) over(partition by 1) as minOrdinal
              ,max(c.ordinal_position) over(partition by 1) as maxOrdinal
      from information_schema.tables t
         inner join information_schema.columns c
            on t.table_schema      = c.table_schema
                and t.table_name   = c.table_name
                and t.table_type   = ''BASE TABLE''
                and t.table_schema = ''DATAWAREHOUSE''
                and t.table_name   = :table_name
                and c.column_name not in (''DW_UPDATETIME'',''DW_INSERTDATETIME'')  
                and NOT c.column_name ilike(''%_PK'')
                
            order by c.ordinal_position;
            
------------------------------------------------------------------------------------
--If the table is not found in the catalouge - retern an error message
IsTableName := (CASE WHEN (SELECT count(*)  FROM all_cols_temp t) = 0 THEN FALSE ELSE TRUE END) ;  
            
-----------------------------------------------------------------------------------------           
  insert into all_sql_temp (ordinal,sqlText)
     select  1 as ordinal
       ,:sqlText1 || listagg(''        '' || column_name || ''\\n'') within group (order by ordinal_position) 
         || '')'' as sqlText
        from all_cols_temp;

------------------------------------------------------------------------------------
col_list := (
  SELECT LISTAGG(sqlText) WITHIN GROUP (ORDER BY inlt1.ORDINAL)
    FROM (
      SELECT sqlText || '' \\n '' as sqlText, 1 AS ORDINAL 
      FROM all_sql_temp   
        UNION
      SELECT LISTAGG(case when ordinal_position = minordinal 
         then ''SELECT ''
         else '' '' 
         end
        || case  column_name  
           when ''  DW_RANGESTART, '' then ''  :highwater ''
           when ''  DW_RANGEEND, ''   then ''  MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1) ''           
           else replace(column_name,'','') 
           end
        || '' as '' 
        || case when ordinal_position = maxordinal 
             then replace(column_name,'','') || :sqlTextB || :sqlTextC
            else column_name
            end  || '' \\n'') WITHIN GROUP (ORDER BY ordinal_position) 
        as output_text
      , 2 AS ORDINAL 
      from all_cols_temp 
    ) inlt1
);
  
--======================================================================================  
 IF (:IsTableName IS NULL)  --ONLY RETURN RESULTS IF INPUT IS VALID TABLE NAME
    THEN
      RETURN TABLE(ErrorMessage);
    ELSE
      RETURN TABLE(col_list);
  END IF;

END';"
PROCEDURE,DATAADMIN,SP_CREATEDWTABLELOAD_CREATEALL(),"CREATE OR REPLACE PROCEDURE ""SP_CREATEDWTABLELOAD_CREATEALL""()
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
    SQLStmt resultset;
    ScriptIns varchar;
    SQLTextOut varchar;
    SQLIns varchar;
    SCRIPT resultset;
    BIGSCRIPTS resultset;

-----------------------------------------------------------------------------------------------------------
BEGIN
   --drop temp tables if they exist
   drop table if exists dwtable_lists; 
   drop table if exists dwtable_scripts; 

   create table dwtable_scripts (
     name varchar (100) 
     ,scripttext varchar
  );

   --create a table containing rows with the call statements to create the load stored procedures
   SELECT 
     REPLACE(''CALL DATAADMIN.SP_CreateDWTableLoad(\\''DEV_HOSPENG_REPORTING\\'',\\''DATASTAGE\\'',\\''<TABLENAME>\\'')''
       ,''<TABLENAME>'',TABLE_NAME) AS sqltext
     FROM information_schema.tables t
   WHERE TABLE_SCHEMA = ''DATAWAREHOUSE''
     AND TABLE_TYPE = ''BASE TABLE''
     AND TABLE_NAME not in  (''ORDER_SUMMARY'',''ITEM_SALES'',''ERRORDATE_DIM'',''DATE_DIM'')
     AND TABLE_NAME NOT ILIKE (''DW_%'')
     AND TABLE_NAME  ILIKE ANY (''%_FACT'',''%_DIM'',''%_XREF'',''%_SUMMARY'');
   
   CREATE TABLE dwtable_lists AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

  SQLStmt := (select * from dwtable_lists);

  --loop through all rows that create the load stored proceedure 1 per table
      BEGIN
          FOR record IN SQLStmt DO
            SQLTextOut := record.sqltext;
            SCRIPT := (EXECUTE IMMEDIATE record.sqltext);           
            ScriptIns := (SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID())));
            INSERT INTO dwtable_scripts(scripttext)    
                VALUES(:ScriptIns);   --works       
          END FOR;
     END;

  BIGSCRIPTS := (SELECT listagg(scripttext) from dwtable_scripts);   
  RETURN TABLE(BIGSCRIPTS);
  
END';"
PROCEDURE,DATAADMIN,"SP_DATASHARE_CRAFTABLE_MODIFIER(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_DATASHARE_CRAFTABLE_MODIFIER""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE
  reportSet resultset;
  -- startdate timestamp_tz      := ''2020-08-20T14:48:37.661Z'';
  -- enddate timestamp_tz        := ''2029-08-20T14:48:37.661Z'';
  -- locationid string           := ''[35]'';
  locationidS string          :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
  today char(11)              := CURRENT_DATE()::date::VARCHAR(10);
-----------------------------------------------------------------------------------------------------------------------
BEGIN
DROP TABLE if exists MODIFIER_DATA_TEMP;

CALL DATAADMIN.SP_REPORT_MODIFIER(:startdate,:enddate,:locationidS);
CREATE TEMP TABLE MODIFIER_DATA_TEMP AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));
;
-----------------------------------------------------------------------------------------------------------------------
     reportSet := (
         SELECT
             ORG.ORGANIZATION          AS ""Organization Name""
            ,ORG.ORGANIZATION_DIM_NK   AS ""Organization ID""
            ,MDT.""Location""            AS ""Location Name""
            ,MDT.""Location ID""         AS ""Location ID""
            ,MDT.""Fiscal Date""         AS ""Business Day"" 
            ,MDT.""Check ID""            AS ""Check ID""
            ,MDT.""Check""               AS ""Check Number""
            ,MDT.""Menu Item""           AS ""Item Name""
            ,MDT.""Item ID""             AS ""Item ID""
            ,MDT.""Modifier Group""      AS ""Modifier Group""
            ,MDT.""Modifier Group ID""   AS ""Modifier Group ID""
            ,FALSE                     AS ""Is Sub Modifier""
            ,MDT.""Menu Item""           AS ""Modifier Parent Name""
            ,MDT.""Item ID""             AS ""Modifier Parent ID""
            ,MDT.""Modifier""            AS ""Modifier Name""
            ,MDT.""Support ID""          AS ""Modifier ID""
            ,MDT.""Count""               AS ""Modifier Quantity""
            ,MDT.""Total Sales""         AS ""Modifier Amount""
         FROM 
         MODIFIER_DATA_TEMP                                 MDT
         LEFT JOIN DATAWAREHOUSE.ORGANIZATION_DIM           ORG
            ON MDT.""Location ID"" = ORG.ORGANIZATION_DIM_NK
            AND ORG.DW_ISCURRENTROW
     );
--=====================================================================================================================
RETURN TABLE(reportSet);
END';"
PROCEDURE,DATAADMIN,SP_DEPENDENCIES(),"CREATE OR REPLACE PROCEDURE ""SP_DEPENDENCIES""()
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS '
--Procedure to pull the dependent tables of all the views in public ending with _DIM/_FACT/_XREF
declare
--Declaring variables
  select_statement varchar;
  res resultset;
begin
--Sql statement to pull the dependent tables of all the views in public ending with _DIM/_FACT/_XREF
select_statement := (SELECT listagg(stmt, '''') as statment_text FROM (SELECT
     ''SELECT * from table(get_object_references(database_name=>\\''DEV_HOSPENG_REPORTING\\'', schema_name=>\\''DATAADMIN\\'', object_name=> \\'''' || table_name || ''\\''))''
      || CASE WHEN row_num < max(row_num) over()
            THEN '' UNION ''
        ELSE '' ''
      END as stmt
      FROM (SELECT TABLE_NAME
            ,rank() over (ORDER BY table_name) as row_num
            FROM INFORMATION_SCHEMA.TABLES
            WHERE TABLE_SCHEMA = ''DATAADMIN'' and
                  (TABLE_NAME like ''%_DIM'' or
                  TABLE_NAME like ''%_FACT'' or
                  TABLE_NAME like ''%_XREF''))));
--Executing the variable which is the sql statement
res := (execute immediate : select_statement);
--Returning the variable which is the result of sql statement
return table(res);
end;
';"
PROCEDURE,DATAADMIN,SP_LOADALLDWTABLES(),"CREATE OR REPLACE PROCEDURE ""SP_LOADALLDWTABLES""()
RETURNS VARCHAR(16777216)
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE
----------------------------------------------------------------------------------------------------------------------
  SQLText VARCHAR(75)            := ''CALL DATAADMIN.<SPROCNAME>();'';
  IsTableName                    BOOLEAN;
  res_list RESULTSET;

----------------------------------------------------------------------------------------------------------------------
BEGIN
----------------------------------------------------------------------------------------------------------------------
--put list of proceedures in a temp table
SHOW PROCEDURES 
  LIKE ''SP_STAGELOAD%''
    IN SCHEMA DATAADMIN; 

--read all of the load proceedures that eist into a result set
res_list := (SELECT REPLACE(:SQLText,''<SPROCNAME>'',""name"") AS ExecStmt
FROM TABLE(RESULT_SCAN(LAST_QUERY_ID())));

-- res_list := (SELECT * from proc_list_temp plt );
DECLARE cur1 CURSOR FOR res_list;
  BEGIN
    FOR row_variable IN cur1 DO
      EXECUTE IMMEDIATE row_variable.ExecStmt;
    END FOR;
  END;

-- ---------------------------------------------------------------------------------------------------------------------- 
--RETURN condition message
RETURN (''INFORMATIONAL MESSAGE:  Load Complete'');

--========================================================================================================================
END';"
PROCEDURE,DATAADMIN,"SP_LOAD_365_EMPLOYEES(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_365_EMPLOYEES""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2025-02-19T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2025-02-19T14:48:37.661Z''; 
  -- locationid string      := ''[15]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--================================================================================================================================
--ISSUES
--=================================================================================================================================
BEGIN
--=================================================================================================================================
DROP TABLE IF EXISTS TEMP_EMPS;

SELECT EMPLOYEE_DIM_FK
    FROM DATAWAREHOUSE.SHIFT_DIM SHD
    WHERE shd.fiscal_day::date
        >= dateadd(DAY,-10,:startdate)::date     --calculate data 10 days around selected dates so that  
      AND  shd.fiscal_day::date  
            <= dateadd(DAY,10,:enddate)::date    --the data in the selected range calcs overtime for full fiscal week
      AND SHD.LOCATION_DIM_FK IN ( SELECT table1.value 
            FROM table(split_to_table(:locationidS, '',''))  table1)
      AND SHD.DW_ISCURRENTROW
      AND NOT SHD.DW_ISDELETED
    GROUP BY EMPLOYEE_DIM_FK;

CREATE TEMP TABLE TEMP_EMPS AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

--==================================================================================================================================
reportSet := (  
------------------------------------------------------------------------------------------------------------------------------------
SELECT EMD.EMPLOYEE_DIM_NK                                 AS EmployeeId   --* string
  ,IFNULL(REPLACE(EMD.FIRST_NAME,'','',''''),''None'')           AS FirstName    --* string
  ,IFNULL(REPLACE(EMD.LAST_NAME,'','',''''),''None'')            AS LastName     --* string
  FROM DATAWAREHOUSE.EMPLOYEE_DIM            EMD
    INNER JOIN TEMP_EMPS                     TEM
      ON TEM.EMPLOYEE_DIM_FK = EMD.EMPLOYEE_DIM_NK
        AND EMD.DW_ISCURRENTROW
--==================================================================================================================================
);
RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,"SP_LOAD_AVERO_CHECKTRANSFER(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_AVERO_CHECKTRANSFER""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2020-08-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2029-08-20T14:48:37.661Z''; 
  -- locationid string      := ''[2,3,4,351,352]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--=================================================================================================================================
BEGIN

DROP TABLE IF EXISTS TEMP_TRANSFER;
DROP TABLE IF EXISTS TEMP_TRANSFER_DATA;

--get the checks that have changed revenue centers and related fks
SELECT inlt1.CHEQUE_FACT_NK
     ,inlt1.CHEQUE_FACT_PK
     ,inlt1.REVENUECENTER_DIM_FK
     ,inlt1.CHEQUE_FACT_PK_FROM
     ,inlt1.REVENUECENTER_DIM_NK_FROM
     ,inlt1.TOTAL_FROM     
     ,inlt1.CHEQUE_FACT_PK_TO
     ,inlt1.REVENUECENTER_DIM_NK_TO
     ,inlt1.TOTAL_TO
    FROM (
            SELECT CHF.DW_STARTDATE,CHF.CHEQUE_FACT_PK,CHF.CHEQUE_FACT_NK,CHF.REVENUECENTER_DIM_FK
            ,ROW_NUMBER() OVER (PARTITION BY CHF.CHEQUE_FACT_NK,CHF.REVENUECENTER_DIM_FK 
               ORDER BY DW_STARTDATE )      AS RANKIT
            ,ROW_NUMBER() OVER (PARTITION BY CHF.CHEQUE_FACT_NK
              ORDER BY DW_STARTDATE )       AS RANKIT2

            ,CHF.CHEQUE_FACT_PK                                  AS CHEQUE_FACT_PK_TO
            ,CHF.REVENUECENTER_DIM_FK                            AS REVENUECENTER_DIM_NK_TO
            ,CHF.TOTAL                                           AS TOTAL_TO            

            ,LAG (CHF.CHEQUE_FACT_PK) OVER (PARTITION BY CHF.CHEQUE_FACT_NK ORDER BY DW_STARTDATE) 
                                                                 AS CHEQUE_FACT_PK_FROM
            ,LAG (CHF.REVENUECENTER_DIM_FK) OVER (PARTITION BY CHF.CHEQUE_FACT_NK ORDER BY DW_STARTDATE) 
                                                                 AS REVENUECENTER_DIM_NK_FROM 
            ,LAG (CHF.TOTAL) OVER (PARTITION BY CHF.CHEQUE_FACT_NK ORDER BY DW_STARTDATE) 
                                                                 AS TOTAL_FROM                                                                   
           FROM  DATAWAREHOUSE.CHEQUE_FACT CHF
                         WHERE CHF.LOCATION_DIM_FK IN (--351,352
                SELECT table1.value 
              FROM table(split_to_table(:locationidS, '',''))  table1)  
                AND (CHF.FISCAL_DATE::date >= :startdate::date 
                AND CHF.FISCAL_DATE::date  <= :enddate::date)
                AND NOT CHF.IS_TRAINING
                AND NOT CHF.DW_ISDELETED
        ) inlt1
             WHERE inlt1.RANKIT = 1     --show only the times the revenuecenter changed 
                  AND inlt1.RANKIT2 > 1 --not the first row, it can never be a change
             ORDER BY inlt1.CHEQUE_FACT_NK,inlt1.DW_STARTDATE
             ;
-- SELECT * 
--   FROM (
--     SELECT inlt1.CHEQUE_FACT_NK  AS CHEQUE_FACT_NK
--      ,inlt1.CHEQUE_FACT_PK       AS CHEQUE_FACT_PK_TO
--      ,inlt1.REVENUECENTER_DIM_FK AS REVENUECENTER_DIM_FK_TO
--      ,LAG (inlt1.CHEQUE_FACT_PK) OVER (PARTITION BY inlt1.CHEQUE_FACT_NK ORDER BY inlt1.DW_STARTDATE) 
--                                  AS CHEQUE_FACT_PK_FROM
--      ,LAG (inlt1.REVENUECENTER_DIM_FK) OVER (PARTITION BY inlt1.CHEQUE_FACT_NK ORDER BY inlt1.DW_STARTDATE) 
--                                  AS REVENUECENTER_DIM_NK_FROM
--     FROM (
--             SELECT CHF.DW_STARTDATE,CHF.CHEQUE_FACT_PK,CHF.CHEQUE_FACT_NK,CHF.REVENUECENTER_DIM_FK
--                ,ROW_NUMBER() OVER (PARTITION BY CHF.CHEQUE_FACT_NK,CHF.REVENUECENTER_DIM_FK 
--                    ORDER BY CHF.REVENUECENTER_DIM_FK,CHF.DW_STARTDATE ) 
--                   AS RANKIT
--               FROM  DATAWAREHOUSE.CHEQUE_FACT CHF
--               WHERE CHF.LOCATION_DIM_FK IN (--351,352
--                 SELECT table1.value 
--               FROM table(split_to_table(:locationidS, '',''))  table1)  
--                 AND (CHF.FISCAL_DATE::date >= :startdate::date 
--                 AND CHF.FISCAL_DATE::date  <= :enddate::date)
--                 AND NOT CHF.IS_TRAINING
--                 AND NOT CHF.DW_ISDELETED
--              ) inlt1
--             WHERE inlt1.RANKIT = 1  --show when revenuecenter changed or first transaction
--             ORDER BY inlt1.CHEQUE_FACT_NK,inlt1.DW_STARTDATE
--     ) inlt2
--   WHERE inlt2.CHEQUE_FACT_PK_FROM IS NOT NULL
--   ORDER BY CHEQUE_FACT_NK;    

--write transfers to a temp table 
CREATE TEMP TABLE TEMP_TRANSFER AS
             SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));
 -- select * From   TEMP_TRANSFER  
--=================================================================================================================================
reportSet := (  
----------------------------------------------------------------------------------------------------------------------------------
SELECT CHF.CHEQUE_FACT_NK              AS ROWNUM        --Row number
  ,TO_CHAR(CHF.FISCAL_DATE,''YYYYMMDD'') AS BUSDATE       --Business day 
  ,CHF.REVENUECENTER_DIM_FK            AS RVCNUM        --Revenue center number
  ,CHF.REVENUECENTERNAME               AS RVCDESC       --Revenue center description
  ,CHF.CHEQUE_FACT_NK                  AS CHKSEQ        --Unique check sequence identifier 
  ,CHF.CHEQUENUMBER                    AS CHKNUM        --Check description
  ,NULL                                AS TRANSTORVCNUM --Transfer check revenue center number
  ,NULL                                AS TRANSTORVCDESC--Transfer check revenue center description
  ,CHF.CHEQUE_FACT_NK                  AS TRANSTOCHKSEQ --Transfer unique check sequence identifier 
  ,CHF.CHEQUENUMBER                    AS TRANSTOCHKNUM --Transfer check number
  ,CHF.TOTAL                           AS TRANSAMT      --Transfer amount
FROM DATAWAREHOUSE.CHEQUE_FACT                         CHF
  INNER JOIN TEMP_TRANSFER                             TMP
    ON CHF.CHEQUE_FACT_NK = TMP.CHEQUE_FACT_NK
  INNER JOIN DATAWAREHOUSE.EMPLOYEE_DIM EMD
    ON EMD.EMPLOYEE_DIM_NK = CHF.EMPLOYEE_DIM_FK
      AND CHF.DW_ISCURRENTROW
      AND EMD.DW_ISCURRENTROW
      AND CHF.LOCATION_DIM_FK IN (--351,352
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)
      AND NOT CHF.IS_TRAINING
      AND CHF.DW_ISCURRENTROW
      AND CHF.STATUS in (''Closed'')
      AND (CHF.FISCAL_DATE::date >= :startdate::date 
                AND CHF.FISCAL_DATE::date  <= :enddate::date)
  INNER JOIN DATAWAREHOUSE.LOCATION_DIM                 LOC
    ON LOC.LOCATION_DIM_NK = CHF.LOCATION_DIM_FK
      AND CHF.DW_ISCURRENTROW
      AND LOC.DW_ISCURRENTROW
  INNER JOIN DATAWAREHOUSE.SHIFT_DIM                    SHD
    ON SHD.SHIFT_DIM_NK = CHF.SHIFT_DIM_FK
      AND SHD.DW_ISCURRENTROW
  INNER JOIN DATAWAREHOUSE.JOBPOSITION_DIM              JPD
    ON JPD.JOBPOSITION_DIM_NK = SHD.JOBPOSITION_DIM_FK
      AND JPD.DW_ISCURRENTROW
  INNER JOIN DATAWAREHOUSE.REVENUECENTER_DIM            RCD
    ON RCD.REVENUECENTER_DIM_NK = CHF.REVENUECENTER_DIM_FK
      AND RCD.DW_ISCURRENTROW
--=================================================================================================================================

);
RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,SP_STAGELOADOVERTIMELABORRULE_JOBPOSITION_XREF(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADOVERTIMELABORRULE_JOBPOSITION_XREF""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.OVERTIMELABORRULE_JOBPOSITION_XREF),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.OVERTIMELABORRULE_JOBPOSITION_XREF(   
          OVERTIMELABORRULE_JOBPOSITION_XREF_NK, 
          OVERTIMELABORRULE_JOBPOSITION, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          JOBPOSITION_DIM_FK, 
          OVERTIMELABORRULE_DIM_FK 
) 
 SELECT   OVERTIMELABORRULE_JOBPOSITION_XREF_NK  as   OVERTIMELABORRULE_JOBPOSITION_XREF_NK,  
   OVERTIMELABORRULE_JOBPOSITION  as   OVERTIMELABORRULE_JOBPOSITION,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   JOBPOSITION_DIM_FK  as   JOBPOSITION_DIM_FK,  
   OVERTIMELABORRULE_DIM_FK  as   OVERTIMELABORRULE_DIM_FK 
  FROM DATAADMIN.OVERTIMELABORRULE_JOBPOSITION_XREF
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''OVERTIMELABORRULE_JOBPOSITION_XREF'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''OVERTIMELABORRULE_JOBPOSITION_XREF'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,"SP_DATASHARE_CRAFTABLE_CREATE_LOAD_SPROC(VARCHAR, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_DATASHARE_CRAFTABLE_CREATE_LOAD_SPROC""(""SOURCE_SPROC_NAME"" VARCHAR, ""TARGET_TABLE_NAME"" VARCHAR)
RETURNS VARCHAR
LANGUAGE PYTHON
RUNTIME_VERSION = '3.11'
PACKAGES = ('snowflake-snowpark-python')
HANDLER = 'main'
EXECUTE AS OWNER
AS '
""""""
This stored procedure dynamically generates de SQL string to create the 
loader stored procedures for craftable. (you have to copy the output and run it yourself).

It acts as a factory to create specific `SP_LOAD_DATASHARE_*` procedures.
The generated procedure will:
1. Execute a specified source stored procedure which returns a dataset.
2. Insert the results from the source procedure into a specified target table.

This automates the creation of boilerplate loading procedures.

Args:
    SOURCE_SPROC_NAME (VARCHAR): schema.sproc name of the source procedure
                                 that provides the data.
    TARGET_TABLE_NAME (VARCHAR): schema.table name of the target table
                                 where the data will be inserted.

Returns:
    VARCHAR: A string containing the SQL DDL for the newly created
             loader stored procedure, or an error message.
""""""
import snowflake.snowpark as snowpark

TARGET_SCHEMA_FOR_LOAD_SPROC = ''DATAADMIN''

def main(session: snowpark.Session, source_sproc_name: str, target_table_name: str) -> str:
    # 1. Parse schema and table name from the fully qualified input
    try:
        # Assuming the format is DATABASE.SCHEMA.TABLE, we only need the last two parts
        schema_name, table_name = target_table_name.upper().split(''.'')[-2:]
    except ValueError:
        return ""Error: TARGET_TABLE_NAME must be a fully qualified name (e.g., DB.SCHEMA.TABLE).""

    # 2. Derive the loader procedure name from the target table name
    loader_sproc_name = f""SP_LOAD_DATASHARE_{table_name}"".replace(''-'', ''_'').replace('' '', ''_'') 

    # 3. Fetch the column list for the target table
    try:
        # Use SHOW COLUMNS to get the column names in their correct order and case
        columns_df = session.sql(f""SHOW COLUMNS IN TABLE {target_table_name}"")
        
        # Collect the results and extract just the column names
        column_names = [row[''column_name''] for row in columns_df.collect()]
        
        # Format the list for inclusion in the SQL INSERT and SELECT statements.
        # Each column is double-quoted, and the list is indented for readability.
        column_list_str = '',\\n''.join([f''        ""{col}""'' for col in column_names])
    except Exception as e:
        return f""Error: Could not retrieve columns for table ''{target_table_name}''. Details: {e}""

    # 4. Use a Python f-string as a template for the generated SQL.
    # This template now follows the direct AS BEGIN...END syntax.
    generated_sql = f""""""CREATE OR REPLACE PROCEDURE {TARGET_SCHEMA_FOR_LOAD_SPROC}.{loader_sproc_name}(START_DATE VARCHAR, END_DATE VARCHAR, LOCATION_IDS VARCHAR)
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS CALLER
AS
BEGIN
    -- Execute the source procedure that returns the data
    CALL {source_sproc_name}(:START_DATE, :END_DATE, :LOCATION_IDS);

    -- Insert the results into the target table
    INSERT INTO {target_table_name} (
{column_list_str}
    )
    SELECT
{column_list_str}
    FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

    RETURN ''Success: Data loaded into {target_table_name}.'';
END;""""""

    return generated_sql
';"
PROCEDURE,DATAADMIN,"SP_LOAD_365_TAXDETAILS(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_365_TAXDETAILS""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2025-01-16'';  
  -- enddate timestamp_tz   := ''2025-01-16''; 
  -- locationid string      := ''[351]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--=================================================================================================================================
BEGIN
  DROP TABLE IF EXISTS TEMP_tax; 
  DROP TABLE IF EXISTS TEMP_feetax;   
  DROP TABLE IF EXISTS TEMP_header; 

-----------------------------------------------------------------------------------------------------------------------------------
 --Create empty table This has a row with all zero values.Sent when there are no tax details because 365 requires a file even when there is no data.
 SELECT ''CheckNumber'' as ""CheckNumber""
  ,''Tax_TaxNumber''  as ""Tax_TaxNumber""
  ,''Tax_Amount''  as ""Tax_Amount""
  ;
  
  CREATE TEMP TABLE TEMP_header AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

-----------------------------------------------------------------------------------------------------------------------------------
--grab the actual data  
  SELECT 
  to_char(itf.chequenumber) || ''.'' || to_char(itf.cheque_fact_fk)  AS CheckNumber          --* string
  ,to_char(tax.TAX_RATE_ID)                                        AS Tax_TaxNumber        --* string
  ,to_char(tax.AMOUNT::NUMBER(36,2))                               AS Tax_Amount           --* decimal
  FROM DATAWAREHOUSE.TAX_FACT                               tax
     INNER JOIN DATAWAREHOUSE.ITEM_FACT                     itf
        ON itf.ITEM_FACT_NK = tax.ITEM_FACT_FK
          AND itf.DW_ISCURRENTROW
          AND tax.ITEMSTATUS IN (''Added'',''Sent'')
          AND tax.CHECKSTATUS = ''Closed''
          AND tax.OPENED_AT is not null
          AND tax.DW_ISCURRENTROW  
          AND NOT tax.DW_ISDELETED
          AND NOT tax.IS_TRAINING
          AND tax.AMOUNT > 0.00
          AND tax.FISCAL_DATE::date
              >= :startdate::date 
          AND tax.FISCAL_DATE::date  
              <= :enddate::date 
          AND tax.LOCATION_DIM_FK IN ( 
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)  
   ORDER BY tax.FISCAL_DATE;

  CREATE TEMP TABLE TEMP_tax AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));
     
------------------------------------------------------------------------------------------------------------------------------------
SELECT 
  to_char(chk.chequenumber) || ''.'' || to_char(chk.CHEQUE_FACT_NK)  AS CheckNumber          --* string
  ,to_char(tax.TAXRATEDIM_DIM_FK::DECIMAL(18,0))                   AS Tax_TaxNumber        --* string
  ,to_char(tax.TAX::NUMBER(36,2))                                  AS Tax_Amount           --* decimal
  FROM DATAWAREHOUSE.FEETAX_FACT                                   tax
     INNER JOIN DATAWAREHOUSE.CHEQUE_FACT                          chk
        ON chk.CHEQUE_FACT_NK = tax.CHEQUE_FACT_FK
          AND chk.DW_ISCURRENTROW
          AND chk.STATUS = ''Closed''
          AND tax.OPENED_AT is not null
          AND tax.DW_ISCURRENTROW  
          AND NOT tax.DW_ISDELETED
          AND NOT tax.IS_TRAINING
          AND tax.TAX > 0.00
          AND chk.FISCAL_DATE::date
              >= :startdate::date 
          AND chk.FISCAL_DATE::date  
              <= :enddate::date 
          AND chk.LOCATION_DIM_FK IN ( 
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)  
   ORDER BY chk.FISCAL_DATE;

  CREATE TEMP TABLE TEMP_feetax AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));     
--=================================================================================================================================
reportSet := (  
------------------------------------------------------------------------------------------------------------------------------------
SELECT * FROM TEMP_header  
  UNION ALL
SELECT * FROM TEMP_tax
  UNION ALL
SELECT * FROM TEMP_feetax

--=================================================================================================================================
);
RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,"SP_LOAD_AVERO_MENUITEMDETAIL(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_AVERO_MENUITEMDETAIL""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2020-08-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2029-08-20T14:48:37.661Z''; 
  -- locationid string      := ''[2,3,4,351,352]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');

--=================================================================================================================================
BEGIN
--=================================================================================================================================
reportSet := (  
----------------------------------------------------------------------------------------------------------------------------------
SELECT TO_CHAR(:STARTDATE,''YYYYMMDD'') AS BUSDATE-- Business Date Date as YYYYMMD
,MEN.MENUITEMNAME_DIM_NK AS MINUM        --Item number  --Numeric identifierfor the menu item
,MEN.MENUITEMNAME AS MIDESC              --Item description -- ie ''hamburger''
,CCD.COGSCATEGORY_DIM_NK AS CATNUM       --Category number
,CCD.COGSCATEGORY AS CATDESC             --Category description
,MEG.REPORTCATEGORY_DIM_NK AS MINCATNUM  --Minor category number
,MEG.REPORTCATEGORY AS MINCATDESC        --Minor category description
 FROM DATAWAREHOUSE.MENUITEM_DIM                                MED
   INNER JOIN DATAWAREHOUSE.MENUITEMNAME_DIM                    MEN
     ON MED.MENUITEMNAME_DIM_FK = MEN.MENUITEMNAME_DIM_NK
       AND MED.DW_ISCURRENTROW
       AND MEN.DW_ISCURRENTROW
   INNER JOIN DATAWAREHOUSE.ORGANIZATION_DIM                    ORG
     ON MED.ORGANIZATION_DIM_FK = ORG.ORGANIZATION_DIM_NK
       AND ORG.DW_ISCURRENTROW
   INNER JOIN DATAWAREHOUSE.LOCATION_DIM                        LOC
     ON LOC.ORGANIZATION_DIM_FK = ORG.ORGANIZATION_DIM_NK
       AND LOC.DW_ISCURRENTROW
       AND LOC.LOCATION_DIM_NK in (SELECT table1.value 
        FROM table(split_to_table(:locationidS, '',''))  table1) 
    INNER JOIN DATAWAREHOUSE.REPORTCATEGORY_DIM                 MEG
        ON MEN.REPORTCATEGORY_DIM_FK = MEG.REPORTCATEGORY_DIM_NK
          AND MEG.DW_ISCURRENTROW = TRUE
      INNER JOIN DATAWAREHOUSE.COGSCATEGORY_DIM                 CCD
        ON CCD.COGSCATEGORY_DIM_NK = MEG.COGSCATEGORY_DIM_FK    
          AND CCD.DW_ISCURRENTROW  
 GROUP BY MEN.MENUITEMNAME_DIM_NK 
    ,MEN.MENUITEMNAME 
    ,CCD.COGSCATEGORY_DIM_NK
    ,CCD.COGSCATEGORY 
    ,MEG.REPORTCATEGORY_DIM_NK
    ,MEG.REPORTCATEGORY          
 ORDER BY MEN.MENUITEMNAME_DIM_NK,MEG.REPORTCATEGORY_DIM_NK,CCD.COGSCATEGORY_DIM_NK
--=================================================================================================================================
);
RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,"SP_REPORT_TAX_NEW(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_TAX_NEW""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS '
-- =======================================================================================================
--Example Call Statement
-- CALL DATAADMIN.SP_REPORTDATAGROOM(''SP_REPORT_TAX'',2,2)
-- CALL DATAADMIN.SP_REPORT_TAX_NEW(''2000-11-20T14:48:37.661Z'',''2027-11-20T14:48:37.661Z'',''[3,2]'');
-- GRANT usage ON procedure dataadmin.SP_REPORT_TAX(timestamp_tz,timestamp_tz,string) TO ROLE DATA_REPLICATION_HOSPENG;
-- Ticket https://nabancard.atlassian.net/browse/HOSPENG-10042 deals with check tax totals that do not match the sum of the items
-- =======================================================================================================
--NOTE:  include Discount amount in Tax basis if discount flag isposttax is true else not
--========================================================================================================
DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2024-09-18T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2024-09-18T14:48:37.661Z''; 
  -- locationid string      := ''[2]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--========================================================================================================
BEGIN

-------------------------------------------------------------------------------------------------------------
 reportSet:= (
SELECT 
    TAX_FACT_NK                                           as ""Support ID"" 
    , ''TAX-'' ||row_number() over (order by TAX_FACT_NK) 
                                                          as ""Detail ID""  
--Status, category, level------------------------------------------------------------------------------------
    ,IFNULL(tax.CHECKSTATUS,''None'')                       as ""Check Status""
    ,IFNULL(tax.ITEMSTATUS,''None'')                        as ""Item Status""
    ,IFNULL(ccd.COGSCATEGORY,''None'')                      as ""Category""
-- --Geography----------------------------------------------------------------------------------------------
    ,IFNULL(org.ORGANIZATION,''None'')                      as ""Organization""    
    ,IFNULL(loc.LOCATIONNAME,''None'')                      as ""Location""
    ,IFNULL(tax.REVENUECENTERNAME,''None'')                 as ""Revenue Center""
-- --Dates---------------------------------------------------------------------------------------------------
   ,LOC.TZ_NAME                                           as ""Time Zone""
    ,to_char(LEFT(tax.FISCAL_DATE,4))                     as ""Year""
    ,to_char(YEAR(tax.FISCAL_DATE)) || ''|'' 
        || TO_CHAR(LEFT(''0'' || MONTH(tax.FISCAL_DATE),2))
                                                          as ""Year and Month""
    ,IFNULL(dad.DAYPART,''None'')                           as ""Daypart""
    
    -- ,tax.CLOSED_AT::timestamp_ntz 
    ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,
       tax.CLOSED_AT::timestamp_ntz )::timestamp) 
                                                          as ""Closed At""
    ,to_char(tax.FISCAL_DATE)                             as ""Fiscal Date""

    ,IFNULL(DAYNAME(tax.FISCAL_DATE),''None'')              as ""Day of Week""
    ,CASE WHEN DAYNAME(tax.FISCAL_DATE) IN (''Sat'',''Sun'')  
       THEN TRUE ELSE FALSE END                           as ""Is Weekend"" 
-- --Flags---------------------------------------------------------------------------------------------------
    ,tax.IS_TAX_INCLUDED::BOOLEAN                         as ""Is Tax Included""
-- --People--------------------------------------------------------------------------------------------------
-- --Descriptors---------------------------------------------------------------------------------------------- 
    ,IFNULL(tax.CHEQUENUMBER ,''None'')                     as ""Check""
    ,IFNULL(med.MENUITEMNAME,'' None'')                     as ""Menu Item""
    ,IFNULL(ord.ORDER_TYPE,'' None'')                       as ""Order Type""
    ,IFNULL(tax.TAXRATENAME,'' None'')                      as ""Rate Name""
-- --Facts-----------------------------------------------------------------------------------------------------
    ,CASE WHEN split_part(tax.tax_fact_nk, ''.'',  3)  = 0
      THEN itf.GROSS::NUMBER(18,2)  
      ELSE NULL::NUMBER(18,2) 
      END                              
                                                          as ""Gross""                      
    ,CASE WHEN split_part(tax.tax_fact_nk, ''.'',  3)  = 0
      THEN itf.APPLIEDAMOUNT::NUMBER(18,2)  
      ELSE NULL::NUMBER(18,2) 
      END
                                                          as ""Applied Amount""
    
    ,(CASE WHEN ABS(tax.AMOUNT - (itf.GROSS * (tax.PERCENT/100))) < 0.009
      THEN itf.GROSS 
      ELSE itf.APPLIEDAMOUNT END) ::NUMBER(18,2)          as ""Tax Basis Amount""
    ,tax.AMOUNT::NUMBER(18,2)                             as ""Tax Amount""    
    ,tax.PERCENT::NUMBER(18,2)                            as ""Tax Percent""
----------------------------------------------------------------------------------------------------------------   
FROM DATAWAREHOUSE.TAX_FACT                               tax
     INNER JOIN DATAWAREHOUSE.ITEM_FACT                   itf
        ON itf.ITEM_FACT_NK = tax.ITEM_FACT_FK
          AND itf.TAX > 0.000
          AND itf.DW_ISCURRENTROW
          AND tax.ITEMSTATUS IN (''Added'',''Sent'')
          AND tax.CHECKSTATUS = ''Closed''
          AND tax.OPENED_AT is not null
          AND tax.DW_ISCURRENTROW  
          AND NOT tax.DW_ISDELETED
          AND NOT tax.IS_TRAINING
          AND tax.FISCAL_DATE::date
              >= :startdate::date 
          AND tax.FISCAL_DATE::date  
              <= :enddate::date 
          AND tax.LOCATION_DIM_FK IN ( 
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)
      INNER JOIN DATAWAREHOUSE.LOCATION_DIM                 loc
        ON tax.LOCATION_DIM_FK = loc.LOCATION_DIM_NK
          AND loc.DW_ISCURRENTROW
      INNER JOIN DATAWAREHOUSE.MENUITEMNAME_DIM             med
       ON med.MENUITEMNAME_DIM_NK = tax.MENUITEMNAME_DIM_FK
         AND med.DW_ISCURRENTROW
      INNER JOIN DATAWAREHOUSE.ORDERTYPE_DIM                ord
        ON ord.ORDERTYPE_DIM_NK = tax.ORDERTYPE_DIM_FK
          AND ord.DW_ISCURRENTROW
      INNER JOIN DATAWAREHOUSE.ORGANIZATION_DIM             org
        ON org.ORGANIZATION_DIM_NK = loc.ORGANIZATION_DIM_FK
          AND org.DW_ISCURRENTROW
      INNER JOIN DATAWAREHOUSE.DAYPART_DIM                  dad
        ON tax.DAYPART_DIM_FK = dad.DAYPART_DIM_NK
          AND dad.DW_ISCURRENTROW         
      INNER JOIN DATAWAREHOUSE.REPORTCATEGORY_DIM           meg
        ON med.REPORTCATEGORY_DIM_FK = meg.REPORTCATEGORY_DIM_NK
          AND meg.DW_ISCURRENTROW 
    INNER JOIN DATAWAREHOUSE.COGSCATEGORY_DIM               ccd
        ON ccd.COGSCATEGORY_DIM_NK = meg.COGSCATEGORY_DIM_FK    
          AND ccd.DW_ISCURRENTROW
order by itf.ITEM_FACT_NK, tax.tax_fact_nk
--==============================================================================================================
);
RETURN TABLE(reportSet); 
END;
-- ';"
PROCEDURE,DATAADMIN,SP_STAGELOADCHEQUE_FACT(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADCHEQUE_FACT""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.CHEQUE_FACT),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.CHEQUE_FACT(   
          CHEQUE_FACT_NK, 
          CHEQUENUMBER, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          DAYPART_DIM_FK, 
          EMPLOYEE_DIM_FK, 
          LOCATION_DIM_FK, 
          ORDERTYPE_DIM_FK, 
          ORGANIZATION_DIM_FK, 
          SHIFT_DIM_FK, 
          TAXSETTINGS_DIM_FK, 
          REVENUECENTER_DIM_FK, 
          VOIDREASON_DIM_FK, 
          HAS_DISCOUNT, 
          IS_TRAINING, 
          IS_VOID, 
          HAS_TRACKTAXESONCOMP, 
          FISCAL_DATE_INT, 
          FISCAL_DATE, 
          OPENED_AT, 
          BEGIN_PREP_AT, 
          CLOSED_AT, 
          SCHEDULED_AT, 
          CREATED_AT, 
          UPDATED_AT, 
          UUID, 
          AUDIT, 
          STATUS, 
          ROUNDINGMETHOD, 
          COMBINEDRECEIPTNAME, 
          RECEIPTOPTION, 
          TAXTRACKING, 
          REVENUECENTERNAME, 
          REVENUECENTERID, 
          STATUS_REASON_ID, 
          CHECK_ID, 
          TABLE_NAME, 
          FEES, 
          GIFTCARDS, 
          GRATUITIES, 
          PARTY_COUNT, 
          DISCOUNT_COUNT, 
          PAYMENT_COUNT, 
          DISCOUNT, 
          DISCOUNTCHECK, 
          DISCOUNTITEM, 
          GROSS, 
          INCLUSIVETAX, 
          NET, 
          PAID, 
          SURCHARGE, 
          TAX, 
          TIP, 
          TOTAL, 
          UNPAID 
) 
 SELECT   CHEQUE_FACT_NK  as   CHEQUE_FACT_NK,  
   CHEQUENUMBER  as   CHEQUENUMBER,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   DAYPART_DIM_FK  as   DAYPART_DIM_FK,  
   EMPLOYEE_DIM_FK  as   EMPLOYEE_DIM_FK,  
   LOCATION_DIM_FK  as   LOCATION_DIM_FK,  
   ORDERTYPE_DIM_FK  as   ORDERTYPE_DIM_FK,  
   ORGANIZATION_DIM_FK  as   ORGANIZATION_DIM_FK,  
   SHIFT_DIM_FK  as   SHIFT_DIM_FK,  
   TAXSETTINGS_DIM_FK  as   TAXSETTINGS_DIM_FK,  
   REVENUECENTER_DIM_FK  as   REVENUECENTER_DIM_FK,  
   VOIDREASON_DIM_FK  as   VOIDREASON_DIM_FK,  
   HAS_DISCOUNT  as   HAS_DISCOUNT,  
   IS_TRAINING  as   IS_TRAINING,  
   IS_VOID  as   IS_VOID,  
   HAS_TRACKTAXESONCOMP  as   HAS_TRACKTAXESONCOMP,  
   FISCAL_DATE_INT  as   FISCAL_DATE_INT,  
   FISCAL_DATE  as   FISCAL_DATE,  
   OPENED_AT  as   OPENED_AT,  
   BEGIN_PREP_AT  as   BEGIN_PREP_AT,  
   CLOSED_AT  as   CLOSED_AT,  
   SCHEDULED_AT  as   SCHEDULED_AT,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   UUID  as   UUID,  
   AUDIT  as   AUDIT,  
   STATUS  as   STATUS,  
   ROUNDINGMETHOD  as   ROUNDINGMETHOD,  
   COMBINEDRECEIPTNAME  as   COMBINEDRECEIPTNAME,  
   RECEIPTOPTION  as   RECEIPTOPTION,  
   TAXTRACKING  as   TAXTRACKING,  
   REVENUECENTERNAME  as   REVENUECENTERNAME,  
   REVENUECENTERID  as   REVENUECENTERID,  
   STATUS_REASON_ID  as   STATUS_REASON_ID,  
   CHECK_ID  as   CHECK_ID,  
   TABLE_NAME  as   TABLE_NAME,  
   FEES  as   FEES,  
   GIFTCARDS  as   GIFTCARDS,  
   GRATUITIES  as   GRATUITIES,  
   PARTY_COUNT  as   PARTY_COUNT,  
   DISCOUNT_COUNT  as   DISCOUNT_COUNT,  
   PAYMENT_COUNT  as   PAYMENT_COUNT,  
   DISCOUNT  as   DISCOUNT,  
   DISCOUNTCHECK  as   DISCOUNTCHECK,  
   DISCOUNTITEM  as   DISCOUNTITEM,  
   GROSS  as   GROSS,  
   INCLUSIVETAX  as   INCLUSIVETAX,  
   NET  as   NET,  
   PAID  as   PAID,  
   SURCHARGE  as   SURCHARGE,  
   TAX  as   TAX,  
   TIP  as   TIP,  
   TOTAL  as   TOTAL,  
   UNPAID  as   UNPAID 
  FROM DATAADMIN.CHEQUE_FACT
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''CHEQUE_FACT'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''CHEQUE_FACT'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,"SP_SUGGESTVARIANTDATATYPES(VARCHAR, VARCHAR, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_SUGGESTVARIANTDATATYPES""(""DBNAME"" VARCHAR(50), ""SCHEMANAME"" VARCHAR(50), ""TABLENAME"" VARCHAR(50))
RETURNS TABLE (""COLUMN_NAME"" VARCHAR(75), ""MESSAGE"" VARCHAR(999))
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE
  -- DBNAME VARCHAR(45)             := ''DEV_HOSPENG_REPORTING'';
  -- SCHEMANAME VARCHAR(45)         := ''DATAADMIN'';
  -- TABLENAME VARCHAR(45)          := ''ERRORDWDATE_DIM'';  --''ACTIVITY_FACT''--''WRONG_FACT'';--''CHEQUE_FACT'';--ERRORDWDATE_DIM''LOCATIONGROUP_DIM'';

----------------------------------------------------------------------------------------------------------------------
  DBName_VAR VARCHAR(075)        := UPPER(DBNAME);
  SchemaName_VAR VARCHAR(075)    := UPPER(SCHEMANAME);
  TableName_VAR VARCHAR(050)     := UPPER(TABLENAME);
  TableType_VAR  VARCHAR(75)     := ''VIEW''; 
  ColumnCount INT                ;
  TABLENAME_COUNT int            := 0;
  ResultList RESULTSET           := (SELECT ''Non-existant view or table.'' AS COLUMN_NAME,''Reiew input view or table.'' AS MESSAGE);
  dtypSQL    VARCHAR ;
  sqltext1 := 
  $$
  UNION

  SELECT ''<COLUMN_NAME>'' as COLUMN_NAME
    , ''<COLUMN_NAME>'' || '' is a VARIANT data type, but should be '' 
      || CASE WHEN MIN(typeof(<COLUMN_NAME>)) =  MAX(typeof(<COLUMN_NAME>))  THEN MIN(typeof(<COLUMN_NAME>))
        ELSE MIN(typeof(<COLUMN_NAME>)) || '' or '' ||  MAX(typeof(<COLUMN_NAME>)) END
      || ''.'' as Message
    FROM <TABLE_NAME>
$$;

----------------------------------------------------------------------------------------------------------------
BEGIN

DROP TABLE IF EXISTS Column_List CASCADE; 

----------------------------------------------------------------------------------------------------------------
--MAKEe sure this is a valid table or view name
TABLENAME_COUNT:= (
  SELECT count(t.table_name) FROM information_schema.tables t
   WHERE t.table_schema  = :SchemaName_VAR
     AND t.table_type    = :TableType_VAR
     AND t.table_name    = :TableName_VAR
);

----------------------------------------------------------------------------------------------------------------
--If there is a valid table
----------------------------------------------------------------------------------------------------------------
IF (TABLENAME_COUNT > 0 )  --if it''s a valid table name, look for any columns with type variant
THEN
        CREATE TEMP TABLE Column_List AS
              SELECT t.table_name,c.column_name,c.ordinal_position,c.data_type
              FROM information_schema.tables t
                INNER JOIN information_schema.columns c
                  ON t.table_schema     = c.table_schema
                    AND t.table_name    = c.table_name
                    AND t.table_schema  = :SchemaName_VAR
                    AND t.table_type    = ''VIEW''
                    AND t.table_name    = :TableName_VAR;

----------------------------------------------------------------------------------------------------------------
  ColumnCount:=(SELECT COUNT(*) FROM Column_List c where upper(c.data_type) = ''VARIANT'');
  ResultList:= (SELECT ''No Variant Columns.'' AS COLUMN_NAME,''No variant data type columns exist for thist table or view.'' AS MESSAGE);           
----------------------------------------------------------------------------------------------------------------        
END IF;  --end if there is a valid table

----------------------------------------------------------------------------------------------------------------
--Only execute this block if there are columns of a type variant as that is the only data type used by vtype
----------------------------------------------------------------------------------------------------------------
IF ( :ColumnCount > 0 )  --only continue if an actual table has been found
  THEN
   dtypSQL:=(
      SELECT SUBSTRING(LISTAGG(REPLACE(REPLACE(:SQLTEXT1,''<COLUMN_NAME>'',COLUMN_NAME),''<TABLE_NAME>'',:TableName_VAR)),9,99999999)
        AS SQLEXECTEXT
        FROM  Column_List C  where upper(c.data_type) = ''VARIANT'' 
        );
      
   ResultList := (EXECUTE IMMEDIATE :dtypSQL );
END IF;
    
 RETURN TABLE(ResultList);
END';"
PROCEDURE,DATAADMIN,"SP_DATAWAREHOUSE_MANAPP_SHIFT(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_DATAWAREHOUSE_MANAPP_SHIFT""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet      resultset;
  -- startdate      date     := ''2025-04-21'';  
  -- enddate        date     := ''2025-04-21''; 
  -- locationid     string   := ''[1,2,3,4,5,6,7,8,9,351]'';
  locationidS string      := REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
  today          char(11) := CURRENT_DATE()::DATE::VARCHAR(10);
  yesterdaydate  date     := dateadd(day,-1,:today);
  weekOffset     int      := (  
                              SELECT TOP 1 ORG.START_OF_BIZ_WEEK_INT  
                                FROM DATAWAREHOUSE.ORGANIZATION_DIM          ORG
                                  INNER JOIN DATAWAREHOUSE.LOCATION_DIM      LOC 
                                     ON LOC.ORGANIZATION_DIM_FK = ORG.ORGANIZATION_DIM_NK
                                        AND LOC.DW_ISCURRENTROW
                                        AND ORG.DW_ISCURRENTROW
                                        AND LOC.LOCATION_DIM_NK in (
                                             SELECT table1.value 
                                          FROM table(split_to_table(:locationidS, '',''))  table1) 
                             );
  lastWeekStart  date     := (DATEADD(DAY,
                                ((DAYOFWEEK(:today::date) - (:weekOffset )  ) * -1)  -7
                                + case when DAYOFWEEK(:today::date)< :weekOffset then -0 else 0 end
                                 , :today)) ::date;
  lastWeekEnd    date     := dateadd(day,6,:lastWeekStart);
  lastMonthStart date     := left(dateadd(month,-1,:today)::date::string,7) || ''-01'';
  lastMonthEnd   date     := dateadd(day,-1,dateadd(month,1,lastMonthStart))::date;
  
  thisWeekStart  date     := dateadd(day,1,dateadd(year,1,:lastWeekEnd));;
  ThisMonthStart date     :=dateadd(day,1,dateadd(year,1,:lastMonthEnd));;
  
  lastYearStart  date     := date_part(year,(dateadd(year,-1,:today))) || ''-01-01'';                  
  lastYearEnd    date     := dateadd(day,-1,dateadd(year,1,:lastYearStart));

---====================================================================================================================
BEGIN
  DROP TABLE if exists SHIFT_DATA_TEMP; 
  DROP TABLE if exists BREAK_DATA_TEMP; 

-----------------------------------------------------------------------------------------------------------------------
SELECT TO_CHAR(SHD.SHIFT_DIM_NK)                                                 AS ""Support ID""
  ,''DataWarehouse''                                                               AS ""Origin""
  ,''None''                                                                        AS ""Check Status""
  ,''Shift''                                                                       AS ""Level""
  ,SHD.SHIFT_DIM_NK                                                              AS ""Shift ID""
  ,SHD.LOCATION_DIM_FK                                                           AS ""Location ID""  
  ,SHD.EMPLOYEE_DIM_FK                                                           AS ""Employee ID""
  ,LOC.LOCATIONNAME                                                              AS ""Location""
  ,SHD.GETS_PAID_BREAK                                                           AS ""Gets Paid Break""
  ---------------------------------------------------------------------------------------
  ,SHD.FISCAL_DAY::DATE                                                          AS ""Fiscal Date""  
  ,TO_CHAR(TO_CHAR(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME
       ,SHD.CLOCKEDIN_AT::timestamp_ntz)::timestamp ) ::timestamp 
  , ''HH24'') ::NUMBER(5,0)                                                        AS ""Hour""    
  ,SHD.REGULAR_RATE::DECIMAL(36,2)                                               AS ""Rate""
  ,CASE WHEN TO_CHAR(SHD.FISCAL_DAY)::DATE  
    BETWEEN :startdate::DATE AND :enddate::DATE THEN TRUE ELSE FALSE END         AS ""Is Current""
  ,CASE WHEN TO_CHAR(SHD.FISCAL_DAY)::DATE  
    = :today::DATE THEN TRUE ELSE FALSE END                                      AS ""Is Today""                                                                              
  ,CASE WHEN TO_CHAR(SHD.FISCAL_DAY)::DATE  
    = :yesterdaydate::DATE THEN TRUE ELSE FALSE END                              AS ""Is Yesterday""
    
  ,CASE WHEN TO_CHAR(SHD.FISCAL_DAY)::DATE  
    BETWEEN :lastWeekStart::DATE AND :lastWeekEnd::DATE 
      THEN TRUE ELSE FALSE END                                                   AS ""Is Last Week""
      
  ,CASE WHEN TO_CHAR(SHD.FISCAL_DAY)::DATE  
    BETWEEN :lastMonthStart::DATE AND :lastMonthEnd::DATE 
       THEN TRUE ELSE FALSE END                                                  AS ""Is Last Month""

 ,CASE WHEN TO_CHAR(SHD.FISCAL_DAY)::DATE  
    <= :thisMonthStart::DATE 
       THEN TRUE ELSE FALSE END                                                  AS ""Is This Month""

 ,CASE WHEN TO_CHAR(SHD.FISCAL_DAY)::DATE  
    <= :thisWeekStart::DATE 
       THEN TRUE ELSE FALSE END                                                  AS ""Is This Week""         
       
  ,CASE WHEN TO_CHAR(SHD.FISCAL_DAY)::DATE  
    BETWEEN :lastYearStart::DATE AND :lastYearEnd::DATE 
        THEN TRUE ELSE FALSE END                                                 AS ""Is Last Year""
-----------------------------------------------------------------------------------------------------------------
--Facts 
  ,IFF( SHD.IS_SHIFTCOMPLETE,SHD.SHIFT_SECONDS, 
          ROUND(TIMEDIFF(second
               ,SHD.CLOCKEDIN_AT::timestamp_ntz 
               ,CONVERT_TIMEZONE(''UTC'', CURRENT_TIMESTAMP())::timestamp_ntz
              )::Number(36,0),0))
                                                                               AS ""Shift Seconds""  
  ,1::NUMBER(36,0)                                                             AS ""Shift Count""
  ,0::NUMBER(36,2)                                                             AS ""Labor Cost""
----------------------------------------------------------------------------------------------------------------- 
  FROM DATAWAREHOUSE.SHIFT_DIM                                                 SHD
          INNER JOIN DATAWAREHOUSE.LOCATION_DIM                                LOC
             ON SHD.LOCATION_DIM_FK = LOC.LOCATION_DIM_NK
                AND LOC.DW_ISCURRENTROW
                AND SHD.DW_ISCURRENTROW
                AND NOT SHD.DW_ISDELETED
                AND NOT SHD.IS_ARCHIVED
                AND SHD.FISCAL_DAY::date >= :lastYearEnd::date 
                AND SHD.FISCAL_DAY::date <= :today::date  
                AND SHD.LOCATION_DIM_FK in (
                  SELECT table1.value 
                     FROM table(split_to_table(:locationidS, '',''))  table1)
          INNER JOIN DATAWAREHOUSE.JOBPOSITION_DIM                 JBP
            ON JBP.JOBPOSITION_DIM_NK = SHD.JOBPOSITION_DIM_FK 
              AND JBP.DW_ISCURRENTROW
         ORDER BY SHD.CLOCKEDIN_AT DESC  
;

CREATE TEMP TABLE SHIFT_DATA_TEMP AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))
;

-----------------------------------------------------------------------------------------------------------------------
SELECT SHD_1.""Shift ID""                                         AS ""Shift ID""
 ,SHD_1.""Gets Paid Break""                                       AS ""Gets Paid Break""
 ,SUM(IFF( BRK.IS_BREAKCOMPLETE ,BRK.BREAK_SECONDS , 
          ROUND(TIMEDIFF(SECOND
            ,BRK.START_AT::timestamp_ntz 
            ,CURRENT_TIMESTAMP::timestamp_ntz 
                )::Number(38,0),0)) )                                                  
                                                                AS ""Break Seconds""

          FROM SHIFT_DATA_TEMP                                  SHD_1
            INNER JOIN DATAWAREHOUSE.SHIFTBREAK_FACT            BRK
              ON SHD_1.""Shift ID"" = BRK.SHIFT_DIM_FK
                 AND BRK.DW_ISCURRENTROW
                 AND NOT BRK.DW_ISDELETED
         GROUP BY SHD_1.""Shift ID""
            ,SHD_1.""Gets Paid Break""
;


CREATE TEMP TABLE BREAK_DATA_TEMP AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))
;

----------------------------------------------------------------------------------------------------------------------
UPDATE SHIFT_DATA_TEMP  shd_2
  SET shd_2.""Shift Seconds"" = shd_2.""Shift Seconds""
    - (IFNULL( brk_1.""Break Seconds"" ,0)) 

  FROM BREAK_DATA_TEMP  brk_1
  WHERE shd_2.""Shift ID"" = brk_1.""Shift ID""
    AND  brk_1.""Gets Paid Break""
;

select ""Rate"",""Shift Seconds"",""Labor Cost"" from SHIFT_DATA_TEMP;

UPDATE SHIFT_DATA_TEMP  shd_2
  SET ""Labor Cost"" = (""Rate""/3600) * ""Shift Seconds""
;  
  
--  ====================================================================================================================
 reportSet   := (
 
     SELECT ""Location ID""
        -- ,""Fiscal Date""
        ,""Is Current""
        ,""Is Today""                            
        ,""Is Yesterday""
        ,""Is Last Week""
        ,""Is Last Month""
        ,""Is This Month""  
        ,""Is This Week""   
        ,""Is Last Year""
       ,COUNT (DISTINCT ""Employee ID"") AS ""Employee Count""
       ,SUM(""Labor Cost"") AS ""Labor Cost""
     FROM SHIFT_DATA_TEMP  
       WHERE ""Is Current""
           OR ""Is Today""                            
           OR ""Is Yesterday""
           OR ""Is Last Week""
           OR ""Is Last Month""
           OR ""Is This Month""  
           OR ""Is This Week""   
           OR ""Is Last Year""
     GROUP BY ""Location ID""
        ,""Is Current""
        ,""Is Today""                            
        ,""Is Yesterday""
        ,""Is Last Week""
        ,""Is Last Month""
        ,""Is This Month""  
        , ""Is This Week""   
        ,""Is Last Year""
    -- ORDER BY ""Fiscal Date""     
   
--===================================================================================================
); 
 RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,"SP_REPORT_DISCOUNT(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_DISCOUNT""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2020-09-18'';  
  -- enddate timestamp_tz   := ''2024-09-18''; 
  -- locationid string      := ''[351,352]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--======================================================================================================
BEGIN
 reportSet   := (
        SELECT CHF.DISCOUNTitem_FACT_NK                      AS ""Support ID"" 
           , ''DISI-'' ||row_number() over (order by  CHF.DISCOUNTitem_FACT_NK ) 
                                                             AS ""Detail ID""
         --Status, categories and levels----------------------------------------------------------
            ,CHF.STATUS                                      AS ""Status"" 
            ,CHF.DISCOUNTLEVEL                               AS ""Discount Level""
        --geography--------------------------------------------------------------------------------
            ,IFNULL(LOC.LOCATIONNAME ,''None'')                AS ""Location""
            ,CHF.LOCATION_DIM_FK::DECIMAL(36,0)              AS ""Location ID""
            ,IFNULL(CHF.revenueCenterName ,''None'')           AS ""Revenue Center""
        --dates-------------------------------------------------------------------------------------  
        
            ,LOC.TZ_NAME                                     AS ""Time Zone""
            ,to_char(LEFT(CHF.FISCAL_DATE,4))                AS ""Year""
            ,to_char(YEAR(CHF.FISCAL_DATE)) || ''|'' || TO_CHAR(RIGHT(''0'' || MONTH(CHF.FISCAL_DATE),2))
                                                             AS ""Year and Month""
            ,IFNULL(dad.DAYPART,''None'')                      AS ""Daypart""
            ,to_char(CHF.FISCAL_DATE)                        AS ""Fiscal Date""
            ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHF.ADDED_AT::timestamp_ntz ))                           
                                                             AS ""Added At""

            ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHF.CREATED_AT::timestamp_ntz ))                                             
  
                                                             AS ""Created At""
            ,IFNULL(DAYNAME(CHF.FISCAL_DATE),''None'') 
                                                             AS ""Day of Week""
            ,CASE WHEN DAYNAME(CHF.FISCAL_DATE) IN (''Sat'',''Sun'')  
                THEN TRUE ELSE FALSE END                     AS ""Is Weekend""
    
        --flags-------------------------------------------------------------------------------------
        --people------------------------------------------------------------------------------------
            ,COALESCE(EMD_ADD.EMPLOYEE_NAME,''None'')          AS ""Added By""
            ,COALESCE(EMD_APP.EMPLOYEE_NAME,''None'')          AS ""Approved By""
        --Descriptors------------------------------------------------------------------------------
            ,STD.STANDARDDISCOUNTNAME                        AS ""Discount Name""
            ,CHF.DISCOUNTREASON                              AS ""Discount Reason""
            ,ORD.ORDER_TYPE                                  AS ""Order Type""
            ,CHF.PROMOCODE                                   AS ""Promo Code"" 
            ,CHF.CHEQUENUMBER                                AS ""Check""  
            ,CHF.CHEQUE_FACT_FK                              AS ""Check ID""
            ,STD.DISCOUNTTYPE                                AS ""Discount Type""
            ,CHF.DISCOUNT_TYPE                               AS ""Application""  
        --Facts-----------------------------------------------------------------------------------------
            ,1::NUMBER(10,0)                                 AS ""Count""   
            ,CHF.DISCOUNT_PERCENT::NUMBER(18,2)              AS ""Discount Percent""   
            ,CHF.NET             ::NUMBER(18,2)              AS ""Check Net Amount"" 
            ,CHF.GROSS           ::NUMBER(18,2)              AS ""Check Gross Amount""
            ,itf.APPLIEDAMOUNT   ::NUMBER(18,2)              AS ""Discount Net Sales""
            ,CHF.APPLIED_AMOUNT  ::NUMBER(18,2)              AS ""Discount Amount"" 
         
                                                    --Percentages must be calculated within pyarrow cube as numerator and denominator can be filtred dynamically
            -- ,NULL                                AS ""% of Total Discounts"" --ex: per discount id: total count / all discount count    
            -- ,NULL                                AS ""Discount % of Net Sales""  --example (total discount amount / net sales + total discount amount) * 100 
                                                    --This represents the presumed % of lost revenue
        --------------------------------------------------------------------------------------------------------
        FROM DATAWAREHOUSE.DISCOUNTITEM_FACT                  CHF
            INNER JOIN DATAWAREHOUSE.ITEM_FACT                ITF
              ON CHF.ITEM_FACT_FK = ITF.ITEM_FACT_NK
                  AND ITF.ITEMSTATUS IN (''Added'',''Sent'')
                  AND NOT CHF.STATUS  = ''Disabled''
                  AND CHF.CHEQUESTATUS  IN (''Closed'')
                  AND IFNULL(CHF.APPLIED_AMOUNT,0.00) > 0.00
                  -- AND CHF.DISCOUNTREASON <> ''CASHDISCOUNT''
                  AND CHF.FISCAL_DATE::date
                      >= :startdate::date
                  AND CHF.FISCAL_DATE::date   
                      <= :enddate ::date 
                  AND CHF.LOCATION_DIM_FK IN (
                     SELECT table1.value 
                       FROM table(split_to_table(:locationidS, '',''))  table1)
                  AND CHF.DW_ISCURRENTROW
                  AND ITF.DW_ISCURRENTROW
                  AND NOT CHF.DW_ISDELETED                
                  AND NOT CHF.IS_TRAINING
            INNER JOIN DATAWAREHOUSE.LOCATION_DIM            LOC  
              ON CHF.LOCATION_DIM_FK = LOC.LOCATION_DIM_NK
                 AND LOC.DW_ISCURRENTROW  
            INNER JOIN DATAWAREHOUSE.STANDARDDISCOUNT_DIM    STD
               ON STD.STANDARDDISCOUNT_DIM_NK = CHF.STANDARDDISCOUNT_DIM_FK
                 AND STD.DW_ISCURRENTROW
            INNER JOIN DATAWAREHOUSE.DAYPART_DIM             DAD
              ON CHF.DAYPART_DIM_FK = DAD.DAYPART_DIM_NK
                  AND DAD.DW_ISCURRENTROW
            INNER JOIN DATAWAREHOUSE.ORDERTYPE_DIM           ORD
              ON ITF.ORDERTYPE_DIM_FK = ORD.ORDERTYPE_DIM_NK
                AND ORD.DW_ISCURRENTROW            
            LEFT JOIN DATAWAREHOUSE.EMPLOYEE_DIM             EMD_ADD
              ON EMPLOYEE_DIM_FK_AS_ADDED_BY = EMD_ADD.EMPLOYEE_DIM_NK
                AND EMD_ADD.DW_ISCURRENTROW
            LEFT JOIN DATAWAREHOUSE.EMPLOYEE_DIM            EMD_APP
              ON EMPLOYEE_DIM_FK_AS_APPROVED_BY = EMD_APP.EMPLOYEE_DIM_NK
                AND EMD_APP.DW_ISCURRENTROW
UNION ALL

        SELECT CHF.DISCOUNTCHECK_FACT_NK                    AS ""Support ID"" 
                   ,''DISC-'' || row_number() over (order by  CHF.DISCOUNTCHECK_FACT_NK ) 
                                                            AS ""Detail ID""
         --Status, categories and levels----------------------------------------------------------
            ,CHF.STATUS                                     AS ""Status""
            ,CHF.DISCOUNTLEVEL                              AS ""Discount Level""
        --geography--------------------------------------------------------------------------------
            ,IFNULL(LOC.LOCATIONNAME ,''None'')               AS ""Location""
            ,CHF.LOCATION_DIM_FK::DECIMAL(36,0)             AS ""Location ID""
            ,IFNULL(CHF.revenueCenterName ,''None'')          AS ""Revenue Center""
        --dates-------------------------------------------------------------------------------------  
            ,LOC.TZ_NAME                                    AS ""Time Zone""        
            ,to_char(LEFT( CHF.FISCAL_DATE,4))              AS ""Year""
            ,to_char(YEAR(CHF.FISCAL_DATE)) || ''|'' || TO_CHAR(RIGHT(''0'' || MONTH(CHF.FISCAL_DATE),2))
                                                            AS ""Year and Month""
            ,IFNULL(dad.DAYPART,''None'')                     AS ""Daypart""
            ,to_char(CHF.FISCAL_DATE)                      
                                                            AS ""Fiscal Date""
            ,to_char(CHF.ADDED_AT::timestamp_ntz)                            
                                                            AS ""Added At""
            ,to_char(CHF.CREATED_AT::timestamp_ntz)                          
                                                            AS ""Created At""
            ,IFNULL(DAYNAME(
            CHF.FISCAL_DATE 
            )
            ,''None'')                                        AS ""Day of Week""
            ,CASE WHEN DAYNAME(
            CHF.FISCAL_DATE 
            ) IN (''Sat'',''Sun'')  
            THEN TRUE ELSE FALSE END                        AS ""Is Weekend""
        --flags-------------------------------------------------------------------------------------
        --people------------------------------------------------------------------------------------
            ,COALESCE(EMD_ADD.EMPLOYEE_NAME,''None'')         AS ""Added By""
            ,COALESCE(EMD_APP.EMPLOYEE_NAME,''None'')         AS ""Approved By"" 
        --Descriptors------------------------------------------------------------------------------
            ,STD.STANDARDDISCOUNTNAME                       AS ""Discount Name""
            ,CHF.DISCOUNTREASON                             AS ""Discount Reason""
            ,ORD.ORDER_TYPE                                 AS ""Order Type""            
            ,CHF.PROMOCODE                                  AS ""Promo Code"" 
            ,CHF.CHEQUENUMBER                               AS ""Check"" 
            ,CHF.CHEQUE_FACT_FK                             AS ""Check ID""
            ,STD.DISCOUNTTYPE                               AS ""Discount Type""
            ,CHF.DISCOUNT_TYPE                              AS ""Application""  
        --Facts-----------------------------------------------------------------------------------------
            ,1                           ::NUMBER(10,0)     AS ""Count""          
            ,CHF.DISCOUNT_PERCENT        ::NUMBER(18,2)     AS ""Discount Percent""   
            ,CHF.NET                     ::NUMBER(18,2)     AS ""Check Net Amount"" 
            ,CHF.GROSS                   ::NUMBER(18,2)     AS ""Check Gross Amount""
            ,(CHF.GROSS - CHF.DISCOUNT)  ::NUMBER(18,2)     AS ""Discount Net Sales""
            ,CHF.APPLIED_AMOUNT          ::NUMBER(18,2)     AS ""Discount Amount"" 
         
                                                    --Percentages must be calculated within pyarrow cube as numerator and denominator can be filtred dynamically
            -- ,NULL                                AS ""% of Total Discounts"" --ex: per discount id: total count / all discount count    
            -- ,NULL                                AS ""Discount % of Net Sales""  --example (total discount amount / net sales + total discount amount) * 100 
                                                    --This represents the presumed % of lost revenue
        --------------------------------------------------------------------------------------------------------
        FROM DATAWAREHOUSE.DISCOUNTCHECK_FACT                CHF
            INNER JOIN DATAWAREHOUSE.LOCATION_DIM            LOC
              ON CHF.LOCATION_DIM_FK = LOC.LOCATION_DIM_NK
                AND IFNULL(CHF.APPLIED_AMOUNT,0.00) > 0.00
                  AND CHF.FISCAL_DATE::date
                      >= :startdate::date
                  AND CHF.FISCAL_DATE::date   
                      <= :enddate ::date 
                  AND CHF.LOCATION_DIM_FK IN (
                     SELECT table1.value 
                       FROM table(split_to_table(:locationidS, '',''))  table1)
                  AND CHF.CHEQUESTATUS IN (''Closed'')
                  AND NOT CHF.STATUS = ''Disabled''
                  AND CHF.DW_ISCURRENTROW
                  AND NOT CHF.DW_ISDELETED
                  AND LOC.DW_ISCURRENTROW          
                  AND NOT CHF.IS_TRAINING
            INNER JOIN DATAWAREHOUSE.DAYPART_DIM                 DAD
              ON CHF.DAYPART_DIM_FK = DAD.DAYPART_DIM_NK
                  AND DAD.DW_ISCURRENTROW 
            INNER JOIN DATAWAREHOUSE.CHEQUE_FACT                 CF 
                ON CHF.CHEQUE_FACT_FK = CF.CHEQUE_FACT_NK
                AND CF.DW_ISCURRENTROW     
            INNER JOIN DATAWAREHOUSE.ORDERTYPE_DIM               ORD
              ON CF.ORDERTYPE_DIM_FK = ORD.ORDERTYPE_DIM_NK
                AND ORD.DW_ISCURRENTROW                  
            LEFT JOIN DATAWAREHOUSE.STANDARDDISCOUNT_DIM         STD
               ON STD.STANDARDDISCOUNT_DIM_NK = CHF.STANDARDDISCOUNT_DIM_FK
                 AND STD.DW_ISCURRENTROW
            LEFT JOIN DATAWAREHOUSE.EMPLOYEE_DIM                 EMD_ADD
              ON EMPLOYEE_DIM_FK_AS_ADDED_BY = EMD_ADD.EMPLOYEE_DIM_NK
                AND EMD_ADD.DW_ISCURRENTROW
            LEFT JOIN DATAWAREHOUSE.EMPLOYEE_DIM                 EMD_APP
              ON EMPLOYEE_DIM_FK_AS_APPROVED_BY = EMD_APP.EMPLOYEE_DIM_NK
                AND EMD_APP.DW_ISCURRENTROW  

--==========================================================================================
); 
 RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,"SP_REPORT_GIFTCARDLIABILITY(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_GIFTCARDLIABILITY""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2020-02-13 00:00:00.000 -0800'';  
  -- enddate timestamp_tz   := ''2029-02-13 00:00:00.000 -0800''; 
  -- locationid string      := ''[1,2,3,4,5,6,7,8,9,351,352]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
  
---====================================================================================================================
BEGIN

--================================================================================================================================
--Find all of the locations for a merchant
DROP TABLE if exists TEMP_LOCS;
DROP TABLE if exists TEMP_TRANS;
DROP TABLE if exists TEMP_CARDS;
DROP TABLE if exists TEMP_ISSUELOC;
DROP TABLE if exists TEMP_RPT;

SELECT MOD.MERCHANT_DIM_NK
  ,MAX(MOD.MERCHANT) AS ""Merchant""
  FROM DATAADMIN.MERCHANT_DIM             MOD
    INNER JOIN DATAWAREHOUSE.MERCHANT_ORGANIZATION_XREF MOX
      ON MOD.MERCHANT_DIM_NK = MOX.MERCHANT_DIM_FK
        AND MOD.DW_ISCURRENTROW
        AND MOX.DW_ISCURRENTROW
    INNER JOIN DATAWAREHOUSE.ORGANIZATION_DIM           ORG
      ON ORG.ORGANIZATION_DIM_NK = MOX.ORGANIZATION_DIM_FK
        AND ORG.DW_ISCURRENTROW
    INNER JOIN DATAWAREHOUSE.LOCATION_DIM               LOC
      ON LOC.ORGANIZATION_DIM_FK = ORG.ORGANIZATION_DIM_NK
        AND LOC.DW_ISCURRENTROW
        AND LOCATION_DIM_NK in (SELECT table1.value 
          FROM table(split_to_table(:locationidS, '',''))  table1)
    GROUP BY MOD.MERCHANT_DIM_NK;

 CREATE TEMP TABLE TEMP_LOCS AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));  

--================================================================================================================================
--Get all card transactions beween the start and end dates
    SELECT GCF.GIFTCARD_DIM_FK                                                AS GIFTCARD_DIM_FK
        ,GCF.GIFTCARDTRANSACTION_FACT_NK                                      AS GIFTCARDTRANSACTION_FACT_NK
        ,GCD.GIFTCARD                                                         AS ""Gift Card Number""  
        ,CHF.CHEQUENUMBER                                                     AS ""Check""
        ,GCD.IS_LEGACY                                                        AS ""Is Imported""
        ,CHF.FISCAL_DATE                                                      AS ""Fiscal Date""
        ,GCD.ISSUED_AT                                                        AS ""Issued At""
        ,LOD.LOCATIONNAME                                                     AS ""Transaction Location""
        ,(CASE WHEN GCF.COMMAND IN (''Reload'',''VoidReload'') THEN 
            CASE WHEN GCF.OPENING_BALANCE IS  NULL OR GCF.GIFTCARD_DIM_Fk = 1 
              THEN GCF.TRANSACTION_AMOUNT ELSE GCF.CLOSING_BALANCE - GCF.OPENING_BALANCE  END  ELSE 0 END )  
                                                                              AS ""Reload Amount""
          ,(CASE WHEN GCF.COMMAND IN (''Reload'',''VoidReload'') THEN CHF.FISCAL_DATE ELSE NULL END)          
                                                                              AS ""Reloaded At""  
           ,(CASE WHEN GCF.COMMAND IN (''Adjust'',''NoNSFSale'',''VoidSale'') THEN 
                          CASE WHEN GCF.OPENING_BALANCE IS NULL OR GCF.GIFTCARD_DIM_Fk = 1  
                            THEN GCF.TRANSACTION_AMOUNT * (-1) ELSE GCF.CLOSING_BALANCE - GCF.OPENING_BALANCE  END  ELSE 0 END )  
                                                                              AS ""Redeemed Amount""  
            ,(CASE WHEN GCF.COMMAND IN (''Adjust'',''NoNSFSale'',''VoidSale'') THEN CHF.FISCAL_DATE ELSE NULL END)          
                                                                              AS ""Redeemed At""  
            ,GCD.BALANCE                                                      AS ""Balance"" 
            ,GCF.OPENING_BALANCE                                              AS ""Opening Balance""
            ,GCF.CLOSING_BALANCE                                              AS ""Closing Balance""
        FROM DATAWAREHOUSE.GIFTCARD_DIM                             GCD
           INNER JOIN TEMP_LOCS                                     LOC
              ON LOC.MERCHANT_DIM_nK = GCD.MERCHANT_DIM_FK
                    AND GCD.DW_ISCURRENTROW
                    AND GCD.IS_ISSUED
                    AND NOT gcd.DW_ISDELETED
            INNER JOIN DATAWAREHOUSE.GIFTCARDTRANSACTION_FACT        GCF  
               ON GCD.GIFTCARD_DIM_NK = GCF.GIFTCARD_DIM_FK
                    AND GCF.DW_ISCURRENTROW
                    AND NOT GCF.DW_ISDELETED
                    AND  GCF.COMMAND IN (''Adjust'',''NoNSFSale'',''VoidSale'',''Reload'',''VoidReload'')
            INNER JOIN DATAWAREHOUSE.CHEQUE_FACT                     CHF
                ON CHF.CHEQUE_FACT_NK = GCF.CHEQUE_FACT_FK
                    AND CHF.STATUS = ''Closed''
                    AND CHF.DW_ISCURRENTROW
                    AND (CHF.FISCAL_DATE::date >= :startdate::date 
                         AND CHF.FISCAL_DATE::date  <= :enddate::date)
            INNER JOIN DATAWAREHOUSE.LOCATION_DIM                    LOD
                ON LOD.LOCATION_DIM_NK = CHF.LOCATION_DIM_FK
                   AND LOD.DW_ISCURRENTROW
         ;          
                           
   CREATE TEMP TABLE TEMP_TRANS AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));  

--================================================================================================================================
--Get a list of all Gift Cards with a redeem or relaod between the start and end dates.
SELECT GIFTCARD_DIM_FK, MAX(""Is Imported"") AS ""Is Imported""
  FROM TEMP_TRANS
  GROUP BY GIFTCARD_DIM_FK;

  CREATE TEMP TABLE TEMP_CARDS AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID())); 

--================================================================================================================================

--Get the issuing location for all Gift Cards with a redeem or relaod between the start and end dates.    
SELECT GCF.GIFTCARD_DIM_FK
,TCD.GIFTCARD_DIM_FK
,TCD.""Is Imported""     AS ""Is Imported""
,LOC.LOCATIONNAME    AS ""Issuing Location""
  FROM DATAWAREHOUSE.GIFTCARDTRANSACTION_FACT GCF
    INNER JOIN TEMP_CARDS                    TCD
      ON TO_CHAR(GCF.GIFTCARD_DIM_FK) = TO_CHAR(TCD.GIFTCARD_DIM_FK)
        AND GCF.DW_ISCURRENTROW
        AND GCF.COMMAND = ''Issue''
     INNER JOIN CHEQUE_FACT                    CHF
       ON CHF.CHEQUE_FACT_NK = GCF.CHEQUE_FACT_FK
         AND CHF.DW_ISCURRENTROW
     INNER JOIN LOCATION_DIM                   LOC
       ON LOC.LOCATION_DIM_NK = CHF.LOCATION_DIM_FK
         AND LOC.DW_ISCURRENTROW
       ;

    CREATE TEMP TABLE TEMP_ISSUELOC AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID())); 
     
--================================================================================================================================
--Assign a issuing location to all cards with transactions between start and end dates
SELECT TPT.GIFTCARDTRANSACTION_FACT_NK                                  AS  ""Support ID"" 
    ,''GCD-'' ||ROW_NUMBER() OVER(ORDER BY TPT.GIFTCARDTRANSACTION_FACT_NK) 
                                                                        AS ""Detail ID"" 
    ,IFNULL(TPT.""Gift Card Number"",''None'')                              AS ""Gift Card Number"" 
    ,TIL.""Is Imported""                                                        AS ""Is Imported""
    -- ,IFNULL(TPT.""Check"",''None'')                                      AS ""Check""
    ,IFNULL(TO_CHAR(TPT.""Issued At""::DATE),''Imported'')                  AS ""Issued At""    
    ,TO_CHAR(TPT.""Redeemed At""::DATE)                                   AS ""Redeemed At""
    ,TO_CHAR(TPT.""Reloaded At""::DATE)                                   AS ""Reloaded At""
    ,IFNULL(TIL.""Issuing Location"",''None'')                              AS ""Earned Location""    
    ,IFNULL(TIL.""Issuing Location"",''None'')                              AS ""Issuing Location""
    ,IFNULL(TPT.""Transaction Location"",''None'')                          AS ""Spending Locaton""
    ,IFNULL(TPT.""Redeemed Amount"",0.00)::NUMBER(18,2)                   AS ""Redeemed Amount""
    ,IFNULL(TPT.""Reload Amount"",0.00)::NUMBER(18,2)                     AS ""Reload Amount""    
    ,IFNULL(TPT.""Opening Balance"",0.00)::NUMBER(18,2)                   AS ""Opening Balance""  
    ,IFNULL(TPT.""Closing Balance"",0.00)::NUMBER(18,2)                   AS ""Closing Balance"" 
    ,IFNULL(TPT.""Balance"",0.00)::NUMBER(18,2)                           AS ""Current Balance""
  FROM TEMP_ISSUELOC                                                    TIL
      INNER JOIN TEMP_TRANS                                             TPT
        ON TIL.GIFTCARD_DIM_FK = TPT.GIFTCARD_DIM_FK
;

  CREATE TEMP TABLE TEMP_RPT AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID())); 
     
--================================================================================================================================
reportSet := (  

SELECT * from TEMP_RPT
  ORDER BY 
                ""Gift Card Number""
); 

-----------------------------------------------------------------------------------------------------------------------------------
RETURN TABLE(reportSet);
--=================================================================================================================================
END';"
PROCEDURE,DATAADMIN,"SP_REPORT_MODIFIER(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_MODIFIER""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2020-08-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2029-08-20T14:48:37.661Z''; 
  -- locationid string      := ''[2,3,4,351]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--=========================================================================================
BEGIN
 reportSet:= (
SELECT mod.ITEMMODIFIER_DIM_NK                            as ""Support ID"" 
    , ''mod-'' ||row_number() over (order by mod.ITEMMODIFIER_DIM_NK) 
                                                          as ""Detail ID""
--status, category, level-------------------------------------------------------------------
    ,IFNULL(itf.CHECKSTATUS,''None'')                       as ""Check Status""
    ,IFNULL(itf.ITEMSTATUS,''None'')                        as ""Item Status""
    ,IFNULL(itf.STATUSREASON,''None'')                      as ""Status Reason""
    ,IFNULL(ccd.COGSCATEGORY,''None'')                      as ""Category""
    -- ,IFNULL(ccd.COGSCATEGORY,''None'')                   as ""COGS Category""
-- --geography--------------------------------------------------------------------------------
    ,IFNULL(loc.LOCATIONNAME,''None'')                      as ""Location""
    ,chk.LOCATION_DIM_FK::DECIMAL(36,0)                   as ""Location ID""    
    ,IFNULL(itf.REVENUECENTERNAME,''None'')                 as ""Revenue Center""
-- --dates-------------------------------------------------------------------------------------
    ,LOC.TZ_NAME                                          as ""Time Zone""
    ,to_char(LEFT(chk.FISCAL_DATE,4))                     as ""Year""
    ,to_char(YEAR(chk.FISCAL_DATE)) || ''|'' || TO_CHAR(RIGHT(''0'' || MONTH(chk.FISCAL_DATE),2))                                       
                                                          as ""Year and Month""
    ,IFNULL(dad.DAYPART,''None'')                           as ""Daypart""
    ,to_char(chk.FISCAL_DATE)                             as ""Fiscal Date""
    ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,chk.OPENED_AT::timestamp_ntz )::timestamp )                                                                           
                                                          as ""Opened At""                                                           
    ,IFNULL(DAYNAME(chk.FISCAL_DATE),''None'')              as ""Day of Week""
    ,CASE WHEN DAYNAME(chk.FISCAL_DATE) IN (''Sat'',''Sun'')  
             THEN TRUE ELSE FALSE END                     as ""Is Weekend""
-- --flags--------------------------------------------------------------------------------------
    ,IFNULL(itf.HASMODIFIERS,FALSE)                       as ""Has Modifiers""
-- --people-------------------------------------------------------------------------------------
    ,IFNULL(emd.EMPLOYEE_NAME,''None'')                     as ""Employee""
-- --Descriptors-------------------------------------------------------------------------------- 
    ,IFNULL(itf.chequenumber ,''None'')                     as ""Check""
    ,itf.cheque_fact_fk                                   as ""Check ID""    
    ,IFNULL(med.MENUITEMNAME,'' None'')                     as ""Menu Item""
    ,itf.ITEM_FACT_NK                                     as ""Item ID""
    ,IFNULL(mod.MODIFIER,''None'')                          as ""Modifier""
    ,IFNULL(mod.MODIFIER_GROUP,''None'')                    as ""Modifier Group""
    ,IFNULL(mod.MODIFIERGROUP_DIM_FK,''None'')              as ""Modifier Group ID""    
    ,IFNULL(itf.NOTE,''None'')                              as ""Note""
    ,IFNULL(itf.DESCRIPTION,''None'')                       as ""Description""
    ,IFNULL(itf.COMBINEDNAME,''Regular'')                   as ""Variant""     
-- --Facts---------------------------------------------------------------------------------------
    ,itf.QUANTITY::NUMBER(10,0)                           as ""Count""
    ,mod.PRICE::NUMBER(18,2)                              as ""Price""
    ,(itf.QUANTITY * mod.PRICE)::NUMBER(18,2)             as ""Total Sales""
-------------------------------------------------------------------------------------------------   
FROM DATAWAREHOUSE.ITEM_FACT                                  itf
     INNER JOIN DATAWAREHOUSE.MENUITEMNAME_DIM                med
       ON med.MENUITEMNAME_DIM_NK = itf.MENUITEMNAME_DIM_FK
          AND itf.ITEMSTATUS IN (''Added'',''Sent'')
          AND itf.CHECKSTATUS = ''Closed''
          AND itf.DW_ISCURRENTROW  
          AND med.DW_ISCURRENTROW  
          AND NOT itf.DW_ISDELETED
          AND NOT itf.IS_TRAINING
          AND itf.LOCATION_DIM_FK IN (--351,352
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)
      INNER JOIN DATAWAREHOUSE.CHEQUE_FACT                                chk
        ON chk.CHEQUE_FACT_NK = itf.CHEQUE_FACT_FK
          AND chk.DW_ISCURRENTROW
          AND chk.STATUS = ''Closed''
          AND itf.ITEMSTATUS IN (''Added'',''Sent'')
          AND (chk.FISCAL_DATE::date >= :startdate::date 
                AND chk.FISCAL_DATE::date  <= :enddate::date)
                -- select * from itemmodifier_dim;
      INNER JOIN DATAWAREHOUSE.ITEMMODIFIER_DIM                           mod
        ON itf.ITEM_FACT_NK = mod.ITEM_FACT_FK
          AND mod.DW_ISCURRENTROW
      INNER JOIN DATAWAREHOUSE.LOCATION_DIM                     loc
        ON itf.LOCATION_DIM_FK = loc.LOCATION_DIM_NK
          AND loc.DW_ISCURRENTROW
      INNER JOIN DATAWAREHOUSE.EMPLOYEE_DIM                     emd
        ON itf.employee_dim_fk = emd.employee_dim_Nk
          AND emd.DW_ISCURRENTROW 
      INNER JOIN DATAWAREHOUSE.DAYPART_DIM                      dad
        ON itf.daypart_dim_fk = dad.daypart_dim_NK
          AND dad.DW_ISCURRENTROW = TRUE         
      INNER JOIN DATAWAREHOUSE.REPORTCATEGORY_DIM               meg
        ON med.REPORTCATEGORY_DIM_FK = meg.REPORTCATEGORY_DIM_NK
          AND meg.DW_ISCURRENTROW = TRUE
      INNER JOIN DATAWAREHOUSE.COGSCATEGORY_DIM                  ccd
        ON ccd.COGSCATEGORY_DIM_NK = meg.COGSCATEGORY_DIM_FK    
          AND ccd.DW_ISCURRENTROW         
--==========================================================================================
);
RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,SP_STAGELOADFEETAX_FACT(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADFEETAX_FACT""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.FEETAX_FACT),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.FEETAX_FACT(   
          FEETAX_FACT_NK, 
          FEENAME, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          CHEQUE_FACT_FK, 
          DAYPART_DIM_FK, 
          EMPLOYEE_DIM_FK, 
          LOCATION_DIM_FK, 
          TAXRATEDIM_DIM_FK, 
          IS_AUTOAPPLIED, 
          IS_GRATUITY, 
          IS_TAXABLE, 
          IS_TAXINCLUDED, 
          IS_TRAINING, 
          IS_PRINTONRECEIPT, 
          CREATED_AT, 
          FISCAL_DATE, 
          OPENED_AT, 
          UPDATED_AT, 
          STATUS, 
          CHEQUENUMBER, 
          SURCHARGE_TYPE, 
          TAXRATENAME, 
          PERCENT, 
          APPLIEDAMOUNT, 
          TAX, 
          TAXBASIS 
) 
 SELECT   FEETAX_FACT_NK  as   FEETAX_FACT_NK,  
   FEENAME  as   FEENAME,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   CHEQUE_FACT_FK  as   CHEQUE_FACT_FK,  
   DAYPART_DIM_FK  as   DAYPART_DIM_FK,  
   EMPLOYEE_DIM_FK  as   EMPLOYEE_DIM_FK,  
   LOCATION_DIM_FK  as   LOCATION_DIM_FK,  
   TAXRATEDIM_DIM_FK  as   TAXRATEDIM_DIM_FK,  
   IS_AUTOAPPLIED  as   IS_AUTOAPPLIED,  
   IS_GRATUITY  as   IS_GRATUITY,  
   IS_TAXABLE  as   IS_TAXABLE,  
   IS_TAXINCLUDED  as   IS_TAXINCLUDED,  
   IS_TRAINING  as   IS_TRAINING,  
   IS_PRINTONRECEIPT  as   IS_PRINTONRECEIPT,  
   CREATED_AT  as   CREATED_AT,  
   FISCAL_DATE  as   FISCAL_DATE,  
   OPENED_AT  as   OPENED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   STATUS  as   STATUS,  
   CHEQUENUMBER  as   CHEQUENUMBER,  
   SURCHARGE_TYPE  as   SURCHARGE_TYPE,  
   TAXRATENAME  as   TAXRATENAME,  
   PERCENT  as   PERCENT,  
   APPLIEDAMOUNT  as   APPLIEDAMOUNT,  
   TAX  as   TAX,  
   TAXBASIS  as   TAXBASIS 
  FROM DATAADMIN.FEETAX_FACT
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable(''PROD_HOSPENG_REPORTING'', ''DATASTAGE'', ''FEETAX_FACT'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''FEETAX_FACT'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADREFUNDS_FACT(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADREFUNDS_FACT""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.REFUNDS_FACT),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.REFUNDS_FACT(   
          REFUNDS_FACT_NK, 
          PAYMENTNUMBER, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          CCTRANSACTION_FACT_FK, 
          CHEQUE_FACT_FK, 
          DAYPART_DIM_FK, 
          EMPLOYEE_DIM_FK_AS_CREATOR, 
          EMPLOYEE_DIM_FK_AS_PAYEE, 
          LOCATION_DIM_FK, 
          PAYMENTMETHOD_DIM_FK, 
          REVENUECENTER_DIM_FK, 
          TRANSACTION_FACT_FK, 
          TERMINAL_DIM_FK, 
          IS_TRAINING, 
          OPENED_AT, 
          PAID_AT, 
          REFUNDED_AT, 
          FISCALDATE, 
          BATCHNUMBER, 
          REFUNDED_BY, 
          CARDBRAND, 
          CARDHOLDERNAME, 
          CHEQUENUMBER, 
          CURRENCY_ID, 
          FLOORPLAN_ID, 
          LASTFOURCCNUMBER, 
          NEXTFOURCCNUMBER, 
          PAYMENTTYPE, 
          PAYMENTSTATUS, 
          REVENUECENTERNAME, 
          TABLENAME, 
          CHECK_TOTAL_AMOUNT, 
          REFUND_AMOUNT 
) 
 SELECT   REFUNDS_FACT_NK  as   REFUNDS_FACT_NK,  
   PAYMENTNUMBER  as   PAYMENTNUMBER,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   CCTRANSACTION_FACT_FK  as   CCTRANSACTION_FACT_FK,  
   CHEQUE_FACT_FK  as   CHEQUE_FACT_FK,  
   DAYPART_DIM_FK  as   DAYPART_DIM_FK,  
   EMPLOYEE_DIM_FK_AS_CREATOR  as   EMPLOYEE_DIM_FK_AS_CREATOR,  
   EMPLOYEE_DIM_FK_AS_PAYEE  as   EMPLOYEE_DIM_FK_AS_PAYEE,  
   LOCATION_DIM_FK  as   LOCATION_DIM_FK,  
   PAYMENTMETHOD_DIM_FK  as   PAYMENTMETHOD_DIM_FK,  
   REVENUECENTER_DIM_FK  as   REVENUECENTER_DIM_FK,  
   TRANSACTION_FACT_FK  as   TRANSACTION_FACT_FK,  
   TERMINAL_DIM_FK  as   TERMINAL_DIM_FK,  
   IS_TRAINING  as   IS_TRAINING,  
   OPENED_AT  as   OPENED_AT,  
   PAID_AT  as   PAID_AT,  
   REFUNDED_AT  as   REFUNDED_AT,  
   FISCALDATE  as   FISCALDATE,  
   BATCHNUMBER  as   BATCHNUMBER,  
   REFUNDED_BY  as   REFUNDED_BY,  
   CARDBRAND  as   CARDBRAND,  
   CARDHOLDERNAME  as   CARDHOLDERNAME,  
   CHEQUENUMBER  as   CHEQUENUMBER,  
   CURRENCY_ID  as   CURRENCY_ID,  
   FLOORPLAN_ID  as   FLOORPLAN_ID,  
   LASTFOURCCNUMBER  as   LASTFOURCCNUMBER,  
   NEXTFOURCCNUMBER  as   NEXTFOURCCNUMBER,  
   PAYMENTTYPE  as   PAYMENTTYPE,  
   PAYMENTSTATUS  as   PAYMENTSTATUS,  
   REVENUECENTERNAME  as   REVENUECENTERNAME,  
   TABLENAME  as   TABLENAME,  
   CHECK_TOTAL_AMOUNT  as   CHECK_TOTAL_AMOUNT,  
   REFUND_AMOUNT  as   REFUND_AMOUNT 
  FROM DATAADMIN.REFUNDS_FACT
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''REFUNDS_FACT'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''REFUNDS_FACT'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADTAXASSOCIATION_MENUITEM_XREF(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADTAXASSOCIATION_MENUITEM_XREF""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.TAXASSOCIATION_MENUITEM_XREF),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.TAXASSOCIATION_MENUITEM_XREF(   
          TAXASSOCIATION_MENUITEM_XREF_NK, 
          TAXASSOCIATION_MENUITEM, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          TAXASSOCIATION_DIM_FK, 
          MENUITEM_DIM_FK 
) 
 SELECT   TAXASSOCIATION_MENUITEM_XREF_NK  as   TAXASSOCIATION_MENUITEM_XREF_NK,  
   TAXASSOCIATION_MENUITEM  as   TAXASSOCIATION_MENUITEM,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   TAXASSOCIATION_DIM_FK  as   TAXASSOCIATION_DIM_FK,  
   MENUITEM_DIM_FK  as   MENUITEM_DIM_FK 
  FROM DATAADMIN.TAXASSOCIATION_MENUITEM_XREF
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''TAXASSOCIATION_MENUITEM_XREF'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''TAXASSOCIATION_MENUITEM_XREF'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADJOBCATEGORY_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADJOBCATEGORY_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.JOBCATEGORY_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.JOBCATEGORY_DIM(   
          JOBCATEGORY_DIM_NK, 
          JOBCATEGORY, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          CREATED_AT, 
          UPDATED_AT 
) 
 SELECT   JOBCATEGORY_DIM_NK  as   JOBCATEGORY_DIM_NK,  
   JOBCATEGORY  as   JOBCATEGORY,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT 
  FROM DATAADMIN.JOBCATEGORY_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''JOBCATEGORY_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''JOBCATEGORY_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADITEM_FACT(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADITEM_FACT""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.ITEM_FACT),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.ITEM_FACT(   
          ITEM_FACT_NK, 
          COMBINEDNAME, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          CHEQUE_FACT_FK, 
          DAYPART_DIM_FK, 
          EMPLOYEE_DIM_FK, 
          LOCATION_DIM_FK, 
          ORDERTYPE_DIM_FK, 
          MENUITEM_DIM_FK, 
          MENUITEMNAME_DIM_FK, 
          VOIDREASON_DIM_FK, 
          VARIANT_DIM_FK, 
          HASMODIFIERS, 
          IS_TRAINING, 
          IS_VOID, 
          FISCAL_DATE_INT, 
          FISCAL_DATE, 
          OPENED_AT, 
          BEGIN_PREP_AT, 
          CLOSED_AT, 
          SCHEDULED_AT, 
          CREATED_AT, 
          UPDATED_AT, 
          SPLITBY, 
          ITEMSTATUS, 
          CHECKSTATUS, 
          STATUSREASON_ID, 
          STATUSREASON, 
          MODIFIERS, 
          NOTE, 
          DESCRIPTION, 
          NAME, 
          PATH, 
          VARIANTNAME, 
          REVENUECENTERNAME, 
          CHECK_ID, 
          EMPLOYEE_ID, 
          ITEM_ID, 
          LOCATION_ID, 
          REVENUECENTER_ID, 
          ORDER_TYPE_ID, 
          CHEQUENUMBER, 
          APPLIEDAMOUNT, 
          QUANTITY, 
          REPORTQUANTITY, 
          BASEPRICE, 
          INCLUSIVETAX, 
          TAB, 
          DISCOUNTCHECK, 
          DISCOUNTITEM, 
          PRICE, 
          GROSS, 
          NET, 
          TAX, 
          TOTAL, 
          CHECKGROSS, 
          CHECKTOTAL 
) 
 SELECT   ITEM_FACT_NK  as   ITEM_FACT_NK,  
   COMBINEDNAME  as   COMBINEDNAME,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   CHEQUE_FACT_FK  as   CHEQUE_FACT_FK,  
   DAYPART_DIM_FK  as   DAYPART_DIM_FK,  
   EMPLOYEE_DIM_FK  as   EMPLOYEE_DIM_FK,  
   LOCATION_DIM_FK  as   LOCATION_DIM_FK,  
   ORDERTYPE_DIM_FK  as   ORDERTYPE_DIM_FK,  
   MENUITEM_DIM_FK  as   MENUITEM_DIM_FK,  
   MENUITEMNAME_DIM_FK  as   MENUITEMNAME_DIM_FK,  
   VOIDREASON_DIM_FK  as   VOIDREASON_DIM_FK,  
   VARIANT_DIM_FK  as   VARIANT_DIM_FK,  
   HASMODIFIERS  as   HASMODIFIERS,  
   IS_TRAINING  as   IS_TRAINING,  
   IS_VOID  as   IS_VOID,  
   FISCAL_DATE_INT  as   FISCAL_DATE_INT,  
   FISCAL_DATE  as   FISCAL_DATE,  
   OPENED_AT  as   OPENED_AT,  
   BEGIN_PREP_AT  as   BEGIN_PREP_AT,  
   CLOSED_AT  as   CLOSED_AT,  
   SCHEDULED_AT  as   SCHEDULED_AT,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   SPLITBY  as   SPLITBY,  
   ITEMSTATUS  as   ITEMSTATUS,  
   CHECKSTATUS  as   CHECKSTATUS,  
   STATUSREASON_ID  as   STATUSREASON_ID,  
   STATUSREASON  as   STATUSREASON,  
   MODIFIERS  as   MODIFIERS,  
   NOTE  as   NOTE,  
   DESCRIPTION  as   DESCRIPTION,  
   NAME  as   NAME,  
   PATH  as   PATH,  
   VARIANTNAME  as   VARIANTNAME,  
   REVENUECENTERNAME  as   REVENUECENTERNAME,  
   CHECK_ID  as   CHECK_ID,  
   EMPLOYEE_ID  as   EMPLOYEE_ID,  
   ITEM_ID  as   ITEM_ID,  
   LOCATION_ID  as   LOCATION_ID,  
   REVENUECENTER_ID  as   REVENUECENTER_ID,  
   ORDER_TYPE_ID  as   ORDER_TYPE_ID,  
   CHEQUENUMBER  as   CHEQUENUMBER,  
   APPLIEDAMOUNT  as   APPLIEDAMOUNT,  
   QUANTITY  as   QUANTITY,  
   REPORTQUANTITY  as   REPORTQUANTITY,  
   BASEPRICE  as   BASEPRICE,  
   INCLUSIVETAX  as   INCLUSIVETAX,  
   TAB  as   TAB,  
   DISCOUNTCHECK  as   DISCOUNTCHECK,  
   DISCOUNTITEM  as   DISCOUNTITEM,  
   PRICE  as   PRICE,  
   GROSS  as   GROSS,  
   NET  as   NET,  
   TAX  as   TAX,  
   TOTAL  as   TOTAL,  
   CHECKGROSS  as   CHECKGROSS,  
   CHECKTOTAL  as   CHECKTOTAL 
  FROM DATAADMIN.ITEM_FACT
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''ITEM_FACT'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''ITEM_FACT'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,"GET_TOP_10_DUPLICATE_ROWS_DELETE(VARCHAR, VARCHAR, ARRAY, BOOLEAN, BOOLEAN)","CREATE OR REPLACE PROCEDURE ""GET_TOP_10_DUPLICATE_ROWS_DELETE""(""DB_NAME"" VARCHAR, ""SCHEMA_NAME"" VARCHAR, ""TARGET_TABLES"" ARRAY, ""EVALUATE_PK"" BOOLEAN, ""PERFORM_DELETE"" BOOLEAN)
RETURNS TABLE (""DATABASE_NAME"" VARCHAR, ""SCHEMA_NAME"" VARCHAR, ""TABLE_NAME"" VARCHAR, ""DUP_COUNT"" NUMBER(38,0), ""MTLN_CDC_LOAD_TIMESTAMP"" TIMESTAMP_LTZ(9), ""ROW_DATA"" VARIANT)
LANGUAGE SQL
EXECUTE AS OWNER
AS '
DECLARE
    -- Cursors and variables
    object_list CURSOR FOR SELECT ""name"" FROM temp_object_list;
    table_name VARCHAR;
    column_list VARCHAR;
    dynamic_sql VARCHAR;
    delete_sql VARCHAR;
    info_schema_path VARCHAR;
    schema_identifier VARCHAR;
    evaluate_pk_effective BOOLEAN;
    perform_delete_effective BOOLEAN;
    final_results RESULTSET;

BEGIN
    -- Temporary tables
    CREATE OR REPLACE TEMPORARY TABLE temp_object_list (""name"" VARCHAR);
    CREATE OR REPLACE TEMPORARY TABLE temp_duplicate_results (
        DATABASE_NAME VARCHAR, SCHEMA_NAME VARCHAR, TABLE_NAME VARCHAR,
        DUP_COUNT INTEGER, MTLN_CDC_LOAD_TIMESTAMP TIMESTAMP_LTZ, ROW_DATA VARIANT
    );

    -- Set effective parameters with safe defaults
    evaluate_pk_effective := COALESCE(:EVALUATE_PK, TRUE);
    perform_delete_effective := COALESCE(:PERFORM_DELETE, FALSE);
    schema_identifier := :DB_NAME || ''.'' || :SCHEMA_NAME;

    -- Get list of all tables and views
    SHOW TABLES IN SCHEMA IDENTIFIER(:schema_identifier);
    INSERT INTO temp_object_list (""name"") SELECT ""name"" FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));
    SHOW VIEWS IN SCHEMA IDENTIFIER(:schema_identifier);
    INSERT INTO temp_object_list (""name"") SELECT ""name"" FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

    -- Loop through each object
    FOR rec IN object_list DO
        table_name := rec.""name"";

        IF (TARGET_TABLES IS NULL OR ARRAY_SIZE(TARGET_TABLES) = 0 OR ARRAY_CONTAINS(:table_name::VARIANT, TARGET_TABLES)) THEN
            info_schema_path := :DB_NAME || ''.INFORMATION_SCHEMA.COLUMNS'';

            -- Get the list of columns to check for duplicates
            SELECT LISTAGG(IFF(REGEXP_LIKE(column_name, ''^[a-zA-Z0-9_]+$''), column_name, ''""'' || column_name || ''""''), '', '')
            INTO column_list
            FROM IDENTIFIER(:info_schema_path)
            WHERE table_schema = :SCHEMA_NAME AND table_name = :table_name
              AND (:evaluate_pk_effective = TRUE OR NOT ENDSWITH(UPPER(column_name), ''_PK''));

            IF (column_list IS NOT NULL AND column_list != '''') THEN
                -- Step 1: Identify and store the single instance of each duplicate group
                --  CORRECTED THIS LINE by removing the erroneous ""(...)""
                dynamic_sql := ''
                    INSERT INTO temp_duplicate_results
                    SELECT '''''' || DB_NAME || '''''', '''''' || SCHEMA_NAME || '''''', '''''' || table_name || '''''',
                           COUNT(*) OVER (PARTITION BY '' || column_list || ''),
                           MTLN_CDC_LOAD_TIMESTAMP, OBJECT_CONSTRUCT(*)
                    FROM '' || DB_NAME || ''.'' || SCHEMA_NAME || ''.""'' || table_name || ''""
                    QUALIFY COUNT(*) OVER (PARTITION BY '' || column_list || '') > 1
                        AND ROW_NUMBER() OVER (PARTITION BY '' || column_list || '' ORDER BY MTLN_CDC_LOAD_TIMESTAMP DESC) = 1;'';
                EXECUTE IMMEDIATE dynamic_sql;

                -- Step 2: If PERFORM_DELETE is true, run the surgical delete
                IF (perform_delete_effective) THEN
                    delete_sql := ''
                        DELETE FROM '' || DB_NAME || ''.'' || SCHEMA_NAME || ''.""'' || table_name || ''""
                        WHERE SYSTEM$HASH(*) IN (
                            SELECT row_hash FROM (
                                SELECT SYSTEM$HASH(*) as row_hash,
                                       ROW_NUMBER() OVER (PARTITION BY '' || column_list || '' ORDER BY MTLN_CDC_LOAD_TIMESTAMP DESC) as rn
                                FROM '' || DB_NAME || ''.'' || SCHEMA_NAME || ''.""'' || table_name || ''""
                            )
                            WHERE rn > 1 -- Target all rows EXCEPT the one we want to keep (rn=1)
                        );'';
                    EXECUTE IMMEDIATE delete_sql;
                END IF;

            END IF;
        END IF;
    END FOR;

    -- Final result set of identified duplicates
    final_results := (
        SELECT DATABASE_NAME, SCHEMA_NAME, TABLE_NAME, DUP_COUNT, MTLN_CDC_LOAD_TIMESTAMP, ROW_DATA
        FROM temp_duplicate_results
        ORDER BY DUP_COUNT DESC, MTLN_CDC_LOAD_TIMESTAMP DESC
    );

    RETURN TABLE(final_results);
END;
';"
PROCEDURE,DATAADMIN,"GET_TOP_10_DUPLICATE_ROWS_TEST(VARCHAR, VARCHAR, ARRAY, BOOLEAN)","CREATE OR REPLACE PROCEDURE ""GET_TOP_10_DUPLICATE_ROWS_TEST""(""DB_NAME"" VARCHAR, ""SCHEMA_NAME"" VARCHAR, ""TARGET_TABLES"" ARRAY, ""EVALUATE_PK"" BOOLEAN)
RETURNS TABLE (""DATABASE_NAME"" VARCHAR, ""SCHEMA_NAME"" VARCHAR, ""TABLE_NAME"" VARCHAR, ""DUP_COUNT"" NUMBER(38,0), ""MTLN_CDC_LOAD_TIMESTAMP"" TIMESTAMP_LTZ(9), ""ROW_DATA"" VARIANT)
LANGUAGE SQL
EXECUTE AS OWNER
AS '
DECLARE
    object_list CURSOR FOR SELECT ""name"" FROM temp_object_list;
    table_name VARCHAR;
    column_list VARCHAR;
    dynamic_sql VARCHAR;
    info_schema_path VARCHAR;
    schema_identifier VARCHAR;
    evaluate_pk_effective BOOLEAN;
    final_results RESULTSET;

BEGIN
    CREATE OR REPLACE TEMPORARY TABLE temp_object_list (""name"" VARCHAR);
    
    --  Added DUP_COUNT to the temp table definition
    CREATE OR REPLACE TEMPORARY TABLE temp_duplicate_results (
        DATABASE_NAME VARCHAR,
        SCHEMA_NAME VARCHAR,
        TABLE_NAME VARCHAR,
        DUP_COUNT INTEGER,
        MTLN_CDC_LOAD_TIMESTAMP TIMESTAMP_LTZ,
        ROW_DATA VARIANT
    );

    evaluate_pk_effective := COALESCE(:EVALUATE_PK, TRUE);
    schema_identifier := :DB_NAME || ''.'' || :SCHEMA_NAME;

    SHOW TABLES IN SCHEMA IDENTIFIER(:schema_identifier);
    INSERT INTO temp_object_list (""name"")
    SELECT ""name"" FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

    SHOW VIEWS IN SCHEMA IDENTIFIER(:schema_identifier);
    INSERT INTO temp_object_list (""name"")
    SELECT ""name"" FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

    FOR rec IN object_list DO
        table_name := rec.""name"";

        IF (TARGET_TABLES IS NULL OR ARRAY_SIZE(TARGET_TABLES) = 0 OR ARRAY_CONTAINS(:table_name::VARIANT, TARGET_TABLES)) THEN

            info_schema_path := :DB_NAME || ''.INFORMATION_SCHEMA.COLUMNS'';

            SELECT
                LISTAGG(IFF(REGEXP_LIKE(column_name, ''^[a-zA-Z0-9_]+$''), column_name, ''""'' || column_name || ''""''), '', '')
            INTO column_list
            FROM IDENTIFIER(:info_schema_path)
            WHERE
                table_schema = :SCHEMA_NAME
                AND table_name = :table_name
                AND (:evaluate_pk_effective = TRUE OR NOT ENDSWITH(UPPER(column_name), ''_PK''));

            IF (column_list IS NOT NULL AND column_list != '''') THEN
                --  Modified to use QUALIFY to select one instance and get the count
                dynamic_sql := ''
                    INSERT INTO temp_duplicate_results (DATABASE_NAME, SCHEMA_NAME, TABLE_NAME, DUP_COUNT, MTLN_CDC_LOAD_TIMESTAMP, ROW_DATA)
                    SELECT
                        '''''' || DB_NAME || '''''',
                        '''''' || SCHEMA_NAME || '''''',
                        '''''' || table_name || '''''',
                        COUNT(*) OVER (PARTITION BY '' || column_list || ''),
                        MTLN_CDC_LOAD_TIMESTAMP,
                        OBJECT_CONSTRUCT(*)
                    FROM '' || DB_NAME || ''.'' || SCHEMA_NAME || ''.""'' || table_name || ''""
                    QUALIFY COUNT(*) OVER (PARTITION BY '' || column_list || '') > 1
                        AND ROW_NUMBER() OVER (PARTITION BY '' || column_list || '' ORDER BY MTLN_CDC_LOAD_TIMESTAMP DESC) = 1;
                '';

                EXECUTE IMMEDIATE dynamic_sql;
            END IF;
        END IF;
    END FOR;

    --  Updated final select to include DUP_COUNT
    final_results := (
        SELECT DATABASE_NAME, SCHEMA_NAME, TABLE_NAME, DUP_COUNT, MTLN_CDC_LOAD_TIMESTAMP, ROW_DATA
        FROM temp_duplicate_results
        ORDER BY MTLN_CDC_LOAD_TIMESTAMP DESC
    );

    RETURN TABLE(final_results);

END;
';"
PROCEDURE,DATAADMIN,SP_CHECKFORFOREIGNKEY_ALL(VARCHAR),"CREATE OR REPLACE PROCEDURE ""SP_CHECKFORFOREIGNKEY_ALL""(""REPORTTYPE"" VARCHAR(1))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
    -- REPORTTYPE VARCHAR(1)      := ''L'';  --valid values {L,P,S}
    
    SQLStmt resultset;
    ScriptInsM varchar;
    ScriptInsC varchar;
    SQLTextOut varchar;
    SQLIns varchar;
    SCRIPT resultset;
    BIGSCRIPTS resultset;
  
    TableType_VAR  VARCHAR(075)  := CASE UPPER(REPORTTYPE)
                                        WHEN ''L''THEN ''VIEW'' 
                                        WHEN ''P'' THEN ''BASE TABLE''
                                        WHEN ''S'' THEN ''BASE TABLE''
                                        ELSE ''WRONG'' END; 
    SchemaName_VAR VARCHAR(075)  := CASE UPPER(REPORTTYPE) 
                                        WHEN ''L'' THEN ''DATAADMIN'' 
                                        WHEN ''P'' THEN ''DATAWAREHOUSE''
                                        WHEN ''S'' THEN ''DATAWAREHOUSE_TEMP''
                                        ELSE ''WRONG'' END;
                                        
    RunSQLText     VARCHAR(100)  := ''CALL DATAADMIN.SP_CHECKFORFOREIGNKEY('' 
                                      || ''\\'''' || REPORTTYPE || ''\\'',''
                                      || ''\\'''' || ''<TABLENAME>''
                                      || ''\\''''
                                      || '');'';
                                        
-----------------------------------------------------------------------------------------------------------
BEGIN
   --drop temp tables if they exist
   drop table if exists dwtable_lists; 
   drop table if exists dwtable_scripts; 

   create table dwtable_scripts (
      ""TABLE""    VARCHAR(250)
      ,""COLUMN""  VARCHAR(250)
      ,""COUNT""   INT
  );

   --create a table containing rows with the call statements to create the load stored procedures
   SELECT 
     REPLACE(:RunSQLText,''<TABLENAME>'',TABLE_NAME) AS sqltext
     FROM information_schema.tables t
   WHERE  TABLE_SCHEMA = :SchemaName_VAR
     AND TABLE_TYPE    = :TableType_VAR
     AND TABLE_NAME not in ( ''ORDER_SUMMARY'',''DATASHARE_VIEW'',''DATASHARE_SECURE_VIEW'',''VW_REPORT_TENDER'',''ERRORDWDATE_DIM'')
     AND NOT TABLE_NAME ILIKE (''%REPORT%'')
     AND NOT TABLE_NAME ILIKE (''%XREF%'')
     ;
   
   CREATE TABLE dwtable_lists AS
     SELECT sqltext FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

   SQLStmt := (select sqltext from dwtable_lists);

   

   -- RETURN TABLE(SQLStmt);

  --loop through all rows that create the load stored proceedure 1 per table
      BEGIN
          FOR record IN SQLStmt DO
            SQLTextOut := record.sqltext;
                BEGIN  
                   SCRIPT := (EXECUTE IMMEDIATE record.sqltext);         
                END;

                INSERT INTO dwtable_scripts(""TABLE"",""COLUMN"",""COUNT"") 
                    SELECT ""TABLE"",""COLUMN"",""COUNT"" FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

          END FOR;
     END;

  BIGSCRIPTS := (SELECT * from dwtable_scripts);   
  RETURN TABLE(BIGSCRIPTS);
  
END';"
PROCEDURE,DATAADMIN,"SP_CHECKVARIANTDATATYPES_ALL(VARCHAR, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_CHECKVARIANTDATATYPES_ALL""(""REPORTTYPE"" VARCHAR(1), ""TABLENAME"" VARCHAR(50))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
        -- REPORTTYPE VARCHAR(1)  := ''L'';

        SCHEMANAME VARCHAR(075)  := CASE UPPER(REPORTTYPE) 
                                        WHEN ''L'' THEN ''DATAADMIN'' 
                                        WHEN ''P'' THEN ''DATAWAREHOUSE''
                                        WHEN ''S'' THEN ''DATAWAREHOUSE_TEMP''
                                        ELSE ''WRONG'' END;

        TableType_VAR  VARCHAR(75) := CASE UPPER(REPORTTYPE) WHEN ''L''THEN ''VIEW'' ELSE ''BASE TABLE'' END;                                         
        HAS_RESULTS    int;
        VAR_RESULTS    resultset;
        VAR_NORESULTS  resultset;

BEGIN

   DROP TABLE IF EXISTS dwtable_lists; 
   DROP TABLE IF EXISTS REPORT_OUTPUT;  
    
   CREATE TABLE REPORT_OUTPUT (
     ""TABLE"" varchar
     ,""COLUMN"" varchar
     ,""COUNT""  int
    );

    SELECT c.table_name                 as ""Table""
        ,c.column_name                  as ""Column""
        ,c.data_type                    as ""Count""
    FROM information_schema.columns c
         WHERE c.table_name    = c.table_name
            AND c.table_schema = :SCHEMANAME
            AND c.data_type    = ''VARIANT''
            AND c.table_name   <> ''ERRORDWDATE_DIM''
        ;
        
    CREATE TABLE dwtable_lists AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));
     
    VAR_NORESULTS := (
      SELECT :SCHEMANAME                                            as ""Table""
        ,''This Schema has NO Variant Columns.''                      as ""Column""
        ,0                                                          as ""Count""
      );
   
   HAS_RESULTS:=(SELECT COUNT(*) FROM dwtable_lists);        
   VAR_RESULTS := (SELECT * from dwtable_lists);   

IF (:HAS_RESULTS > 0)  --Has VARiant COLUMNS.
    THEN
      RETURN TABLE(VAR_RESULTS); 
    ELSE
      RETURN TABLE(VAR_NORESULTS);
  END IF;
                    
END';"
PROCEDURE,DATAADMIN,"SP_COPY_AVEROFILES_FROM_S3_TO_SFTP(VARCHAR, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_COPY_AVEROFILES_FROM_S3_TO_SFTP""(""DATE_NAME"" VARCHAR, ""LOCATION_ID"" VARCHAR)
RETURNS VARCHAR
LANGUAGE PYTHON
RUNTIME_VERSION = '3.11'
PACKAGES = ('snowflake-snowpark-python','pysftp')
HANDLER = 'run'
EXTERNAL_ACCESS_INTEGRATIONS = (SFTP_EXTERNAL_ACCESS_INTEGRATION)
SECRETS = ('cred'=DATAADMIN.SFTP_CREDENTIALS)
EXECUTE AS OWNER
AS '
import snowflake.snowpark as snowpark
import pysftp
import os
import _snowflake
import json

def run(session: snowpark.Session, date_name: str, location_id: str) -> str:
    """"""
    Copies files from a specified path in a Snowflake S3 stage to a corresponding
    path on an SFTP server.

    Args:
        session: The Snowflake Snowpark session object.
        date_name: The date for which to process files, in ''YYYY-MM-DD'' format.
        location_id: The location identifier.

    Returns:
        A string containing logs of the operation.
    
    Raises:
        RuntimeError: If there are critical errors, e.g., connecting to SFTP,
                      listing S3 files, or retrieving credentials.
        IOError: If creating the remote directory on the SFTP server fails.
    """"""
    # --- CONFIGURATION ---
    #retrieve env vars
    required_vars = [''S3_STAGE_NAME'', ''SFTP_BASE_DIR'']    
    fetched_vars : dict = json.loads(session.call(''DATAADMIN.SP_GET_ENVVARS'', required_vars))
    S3_STAGE_NAME, SFTP_BASE_DIR = [fetched_vars.get(key) for key in required_vars]

    # Hardcoded variables that don''t change accross dev and prod account.
    S3_BASE_PATH = ''AVEROFTP''
    SFTP_HOST = ''sftp.averoinc.com''
    SFTP_SECRET_NAME = ''cred'' # Alias for the Snowflake secret
    TEMP_DIR = ''/tmp'' # Snowflake''s temporary directory for staging files

    logs = []
    files_copied_count = 0
    
    try:
        # --- 1. Path Construction ---
        # Convert ''YYYY-MM-DD'' to ''YYYYMMDD''
        date_text = date_name.replace(''-'', '''')
        logs.append(f""Processing for Location: {location_id}, Date: {date_name} ({date_text})"")

        # Construct source and destination paths
        s3_source_path = f""{S3_BASE_PATH}/Location{location_id}/{date_text}""
        sftp_target_dir = f""{SFTP_BASE_DIR}/Location{location_id}/{date_text}""
        
        logs.append(f""Source S3 path: @{S3_STAGE_NAME}/{s3_source_path}"")
        logs.append(f""Target SFTP path: {sftp_target_dir}"")

        # --- 2. List files in S3 Stage ---
        try:
            s3_files_to_copy = session.sql(f""LIST @{S3_STAGE_NAME}/{s3_source_path}"").collect()
            if not s3_files_to_copy:
                message = f""Warning: No files found in S3 path ''@{S3_STAGE_NAME}/{s3_source_path}''. Procedure finished successfully with no files to copy.""
                logs.append(message)
                return ""\\n"".join(logs)
            logs.append(f""Found {len(s3_files_to_copy)} files in S3 to copy."")
        except Exception as e:
            # This could be a legitimate error if the path doesn''t exist.
            raise RuntimeError(f""Error listing files from S3 stage path ''@{S3_STAGE_NAME}/{s3_source_path}'': {e}"")

        # --- 3. Get SFTP Credentials ---
        try:
            creds = _snowflake.get_username_password(SFTP_SECRET_NAME)
            SFTP_USER = creds.username
            SFTP_PASS = creds.password
            logs.append(""Successfully retrieved SFTP credentials."")
        except Exception as e:
            raise RuntimeError(f""Error retrieving SFTP credentials: {e}"")

        # --- 4. Connect to SFTP and Transfer Files ---
        cnopts = pysftp.CnOpts()
        cnopts.hostkeys = None  # In production, it''s more secure to use known host keys.

        with pysftp.Connection(host=SFTP_HOST, username=SFTP_USER, password=SFTP_PASS, cnopts=cnopts) as sftp:
            logs.append(f"" Successfully connected to SFTP server: {SFTP_HOST}"")

            # --- 4a. Create remote directory if it doesn''t exist ---
            if not sftp.exists(sftp_target_dir):
                logs.append(f""Target directory ''{sftp_target_dir}'' does not exist. Creating it."")
                try:
                    sftp.makedirs(sftp_target_dir)
                    logs.append(f"" Successfully created directory: {sftp_target_dir}"")
                except Exception as e:
                    raise IOError(f""Failed to create remote directory ''{sftp_target_dir}'': {e}"")
            else:
                logs.append(f""Target directory ''{sftp_target_dir}'' already exists."")

            # --- 4b. Loop through files and transfer ---
            for file_row in s3_files_to_copy:
                full_s3_path = file_row[''name'']
                file_name = os.path.basename(full_s3_path)
                
                # Correctly construct the relative path for the GET command.
                # It should be relative to the stage''s root directory, using the same
                # path prefix that was used to list the files.
                stage_file_path = f""@{S3_STAGE_NAME}/{s3_source_path}/{file_name}""
                local_temp_path = os.path.join(TEMP_DIR, file_name)
                sftp_remote_path = f""{sftp_target_dir}/{file_name}"" # pysftp uses forward slashes

                try:
                    # Download from S3 stage to local /tmp
                    logs.append(f""  - Downloading {stage_file_path} to {TEMP_DIR}..."")
                    session.file.get(stage_file_path, TEMP_DIR)
                    
                    # Upload from local /tmp to SFTP
                    logs.append(f""  - Uploading {local_temp_path} to {sftp_remote_path}..."")
                    sftp.put(local_temp_path, sftp_remote_path)
                    logs.append(f""  -  Success: Uploaded {file_name}."")
                    files_copied_count += 1
                    
                except Exception as e:
                    # Log file-specific error and re-raise to fail the entire procedure
                    logs.append(f""  -  Error copying file {file_name}: {e}"")
                    raise # Re-raise the exception to be caught by the outer block
                finally:
                    # Clean up the temp file
                    if os.path.exists(local_temp_path):
                        os.remove(local_temp_path)

        summary = f""Process finished. Copied {files_copied_count}/{len(s3_files_to_copy)} files.""
        logs.append(summary)
        return ""\\n"".join(logs)

    except Exception as e:
        logs.append(f"" An unexpected error occurred: {e}"")
        # Re-raise the exception to make the SP fail, so the calling DAG can log it.
        raise e
';"
PROCEDURE,DATAADMIN,"SP_COPY_AVEROFILES_FROM_S3_TO_SFTP(VARCHAR, VARCHAR, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_COPY_AVEROFILES_FROM_S3_TO_SFTP""(""DATE_NAME"" VARCHAR, ""LOCATION_ID"" VARCHAR, ""AVERO_LOC_ID"" VARCHAR)
RETURNS VARCHAR
LANGUAGE PYTHON
RUNTIME_VERSION = '3.11'
PACKAGES = ('snowflake-snowpark-python','pysftp')
HANDLER = 'run'
EXTERNAL_ACCESS_INTEGRATIONS = (SFTP_EXTERNAL_ACCESS_INTEGRATION)
SECRETS = ('cred'=DATAADMIN.SFTP_CREDENTIALS)
EXECUTE AS OWNER
AS '
import snowflake.snowpark as snowpark
import pysftp
import os
import _snowflake
import json

def run(session: snowpark.Session, date_name: str, location_id: str, avero_loc_id: str) -> str:
    """"""
    Copies files from a specified path in a Snowflake S3 stage to a corresponding
    path on an SFTP server.

    Args:
        session: The Snowflake Snowpark session object.
        date_name: The date for which to process files, in ''YYYY-MM-DD'' format.
        location_id: The location identifier.
        avero_loc_id: The Avero location identifier, used for the destination filename.

    Returns:
        A string containing logs of the operation.
    
    Raises:
        RuntimeError: If there are critical errors, e.g., connecting to SFTP,
                      listing S3 files, or retrieving credentials.
        IOError: If creating the remote directory on the SFTP server fails.
    """"""
    # --- CONFIGURATION ---
    #retrieve env vars
    required_vars = [''S3_STAGE_NAME'', ''SFTP_BASE_DIR'']    
    fetched_vars : dict = json.loads(session.call(''DATAADMIN.SP_GET_ENVVARS'', required_vars))
    S3_STAGE_NAME, SFTP_BASE_DIR = [fetched_vars.get(key) for key in required_vars]

    # Hardcoded variables that don''t change accross dev and prod account.
    S3_BASE_PATH = ''AVEROFTP''
    SFTP_HOST = ''sftp.averoinc.com''
    SFTP_SECRET_NAME = ''cred'' # Alias for the Snowflake secret
    TEMP_DIR = ''/tmp'' # Snowflake''s temporary directory for staging files

    logs = []
    files_copied_count = 0
    
    try:
        # --- 1. Path Construction ---
        # Convert ''YYYY-MM-DD'' to ''YYYYMMDD''
        date_text = date_name.replace(''-'', '''')
        logs.append(f""Processing for Location: {location_id}, Avero Location: {avero_loc_id}, Date: {date_name} ({date_text})"")

        # Construct source and destination paths
        s3_source_path = f""{S3_BASE_PATH}/Location{location_id}/{date_text}""
        sftp_target_dir = SFTP_BASE_DIR
        
        logs.append(f""Source S3 path: @{S3_STAGE_NAME}/{s3_source_path}"")
        logs.append(f""Target SFTP path: {sftp_target_dir}"")

        # --- 2. List files in S3 Stage ---
        try:
            s3_files_to_copy = session.sql(f""LIST @{S3_STAGE_NAME}/{s3_source_path}"").collect()
            if not s3_files_to_copy:
                message = f""Warning: No files found in S3 path ''@{S3_STAGE_NAME}/{s3_source_path}''. Procedure finished successfully with no files to copy.""
                logs.append(message)
                return ""\\n"".join(logs)
            logs.append(f""Found {len(s3_files_to_copy)} files in S3 to copy."")
        except Exception as e:
            # This could be a legitimate error if the path doesn''t exist.
            raise RuntimeError(f""Error listing files from S3 stage path ''@{S3_STAGE_NAME}/{s3_source_path}'': {e}"")

        # --- 3. Get SFTP Credentials ---
        try:
            creds = _snowflake.get_username_password(SFTP_SECRET_NAME)
            SFTP_USER = creds.username
            SFTP_PASS = creds.password
            logs.append(""Successfully retrieved SFTP credentials."")
        except Exception as e:
            raise RuntimeError(f""Error retrieving SFTP credentials: {e}"")

        # --- 4. Connect to SFTP and Transfer Files ---
        cnopts = pysftp.CnOpts()
        cnopts.hostkeys = None  # In production, it''s more secure to use known host keys.

        with pysftp.Connection(host=SFTP_HOST, username=SFTP_USER, password=SFTP_PASS, cnopts=cnopts) as sftp:
            logs.append(f"" Successfully connected to SFTP server: {SFTP_HOST}"")

            # --- 4a. Create remote directory if it doesn''t exist ---
            if not sftp.exists(sftp_target_dir):
                logs.append(f""Target directory ''{sftp_target_dir}'' does not exist. Creating it."")
                try:
                    sftp.makedirs(sftp_target_dir)
                    logs.append(f"" Successfully created directory: {sftp_target_dir}"")
                except Exception as e:
                    raise IOError(f""Failed to create remote directory ''{sftp_target_dir}'': {e}"")
            else:
                logs.append(f""Target directory ''{sftp_target_dir}'' already exists."")

            # --- 4b. Loop through files and transfer ---
            for file_row in s3_files_to_copy:
                full_s3_path = file_row[''name'']
                file_name = os.path.basename(full_s3_path)
                
                # Correctly construct the relative path for the GET command.
                # It should be relative to the stage''s root directory, using the same
                # path prefix that was used to list the files.
                stage_file_path = f""@{S3_STAGE_NAME}/{s3_source_path}/{file_name}""
                local_temp_path = os.path.join(TEMP_DIR, file_name)
                
                # New filename pattern:
                sftp_file_name = f""avero_{avero_loc_id}_{date_text}_{file_name}""
                if sftp_file_name.lower().endswith(''.csv''):
                    sftp_file_name = sftp_file_name[:-4] + ''.txt''
                sftp_remote_path = f""{sftp_target_dir}/{sftp_file_name}"" # pysftp uses forward slashes

                try:
                    # Download from S3 stage to local /tmp
                    logs.append(f""  - Downloading {stage_file_path} to {TEMP_DIR}..."")
                    session.file.get(stage_file_path, TEMP_DIR)
                    
                    # Upload from local /tmp to SFTP
                    logs.append(f""  - Uploading {local_temp_path} to {sftp_remote_path}..."")
                    sftp.put(local_temp_path, sftp_remote_path)
                    logs.append(f""  -  Success: Uploaded {sftp_file_name}."")
                    files_copied_count += 1
                    
                except Exception as e:
                    # Log file-specific error and re-raise to fail the entire procedure
                    logs.append(f""  -  Error copying file {file_name}: {e}"")
                    raise # Re-raise the exception to be caught by the outer block
                finally:
                    # Clean up the temp file
                    if os.path.exists(local_temp_path):
                        os.remove(local_temp_path)

        summary = f""Process finished. Copied {files_copied_count}/{len(s3_files_to_copy)} files.""
        logs.append(summary)
        return ""\\n"".join(logs)

    except Exception as e:
        logs.append(f"" An unexpected error occurred: {e}"")
        # Re-raise the exception to make the SP fail, so the calling DAG can log it.
        raise e
';"
PROCEDURE,DATAADMIN,"SP_CREATEDWTABLE(VARCHAR, VARCHAR, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_CREATEDWTABLE""(""DBNAME"" VARCHAR(50), ""SCHEMANAME"" VARCHAR(50), ""TABLENAME"" VARCHAR(50))
RETURNS TABLE (""SQLTEXT"" VARCHAR(16777216))
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE
  -- DBNAME VARCHAR(45)             := ''DEV_HOSPENG_REPORTING'';
  -- SCHEMANAME VARCHAR(45)         := ''DATASTAGE'';
  -- TABLENAME VARCHAR(45)          := ''DAYPART_DIM'';--''CHEQUE_FACT'';--ERRORDWDATE_DIM''LOCATIONGROUP_DIM'';ACTIVITIY_FACT

----------------------------------------------------------------------------------------------------------------------
  DBName_VAR VARCHAR(075)        := UPPER(DBNAME);
  SchemaName_VAR VARCHAR(075)    := UPPER(SCHEMANAME);
  TableName_VAR VARCHAR(050)     := UPPER(TABLENAME);
  FullTableName_VAR VARCHAR(500) := :DBName_VAR || ''.'' || :SchemaName_VAR ||  ''.'' || :TableName_VAR;
  TableType_VAR  VARCHAR(10)     := ''VIEW'' ;
  res_list                       resultset:= (SELECT ''Invalid Table or View Name'' AS ""Error Message"");
  dateError_list                 resultset:= (SELECT :TableName_VAR as MESSAGE , 0 as COUNT);
  variantError_list              resultset:= (SELECT :TableName_VAR as MESSAGE , 0 as COUNT);
  IsTableName                    BOOLEAN;
  count_requiredErr_list  INT    := 0;
  count_variantErr_list  INT     := 0;  

  ERROR_NOT_NUMERIC_text         := ''--WARNING: <COLUMN_NAME> is type <DATA_TYPE>, but based on naming conventions, number or decimal may be required.'';
  ERROR_NOT_BOOLEAN_text         := ''--WARNING: <COLUMN_NAME> is type <DATA_TYPE>. but based on naming conventions,boolean may be required.'';
  ERROR_NOT_DATE_text            := ''--ALERT: <COLUMN_NAME> is type <DATA_TYPE>. but based on naming conventions, a datatype like date or timestamp is required.  Try  to_timestamp_tz(<COLUMN_NAME>) '';
  ERROR_VARIANT_text             := ''--ALERT: <COLUMN_NAME> is <DATA_TYPE>. but the Datawarehouse should not store variant data.'';
  ERROR_UPDATED_COLUMN_NAME_text := ''--ALERT: <COLUMN_NAME> should be renamed as to UPDATED_AT for consistency.'';

----------------------------------------------------------------------------------------------------------------------
BEGIN
----------------------------------------------------------------------------------------------------------------------
--Drop temp table if exists - used for dev as temp tables would be dropped when sproc session ends
DROP TABLE IF EXISTS column_list_temp CASCADE;  
DROP TABLE IF EXISTS all_columns_temp CASCADE; 
DROP TABLE IF EXISTS dwDateError_list CASCADE;
DROP TABLE IF EXISTS dwVariantError_list CASCADE;
DROP TABLE IF EXISTS requiredCols_list CASCADE; 
DROP TABLE IF EXISTS requiredErr_list CASCADE; 
DROP TABLE IF EXISTS resultsTable_list CASCADE;

----------------------------------------------------------------------------------------------------------------------
--get table and columns to be used for both audit and sql text creation.  If something that is NOT a table nane
--  is passed in, we will stop the proc.
 CREATE TEMP TABLE all_columns_temp AS
   SELECT t.TABLE_NAME
     ,c.ORDINAL_POSITION 
     ,c.COLUMN_NAME 
     ,c.DATA_TYPE 
     ,c.DATETIME_PRECISION
     ,c.CHARACTER_OCTET_LENGTH 
     ,c.NUMERIC_PRECISION 
     ,c.CHARACTER_MAXIMUM_LENGTH
     ,c.NUMERIC_SCALE
     ,FALSE as ERROR_NOT_NUMERIC
     ,FALSE as ERROR_NOT_DATE
     ,FALSE as ERROR_NOT_BOOLEAN
     ,FALSE as ERROR_VARIANT 
     ,FALSE AS ERROR_UPDATED_COLUMN_NAME --source column names vary - but data warehouse only uses updated_at
   from information_schema.tables t
      inner join information_schema.columns c
          on t.table_schema     = c.table_schema
            and t.table_name    = c.table_name
            and t.table_type    = ''VIEW''
            and t.table_schema  = ''DATAADMIN''
            and t.table_name    = :TableName_VAR
;

-- ----------------------------------------------------------------------------------------------------------------------
--If the table is not found in the catalouge - retern an error message
IsTableName := (CASE WHEN (SELECT count(*)  FROM all_columns_temp t) = 0 THEN FALSE ELSE TRUE END) ;  

-- ----------------------------------------------------------------------------------------------------------------------
IF (:IsTableName)  --dont run any additional sql if input is not a real table name - prevent sql injection
  THEN
 CREATE TEMP TABLE column_list_temp AS
    SELECT LISTAGG(INLT2.SQLTextValue  || '' \\n '') WITHIN GROUP (ORDER BY INLT2.SQLTextOrdinal) AS sqlText
      FROM(
      --additional columns added to the view for the dw table
      SELECT INLT1.SQLTextOrdinal
          ,REPLACE(INLT1.SQLTextValue, ''<TableName>'', MAX(INLT1.TableName)OVER(PARTITION BY 1)) as SQLTextValue
        FROM (
           SELECT SQT.SQLTextOrdinal     AS SQLTextOrdinal
             ,NULL                       AS TableName
             ,SQT.SQLTextValue           AS SQLTextValue
             FROM DataAdmin.DW_SQLText  SQT
            WHERE SQT.SQLTextGroup = ''DWAdditionalColumns''
              AND SQT.IsCurrentVersion 
              AND NOT SQT.ISDELETED
        
           UNION
         
--grab all of the columns from the conforming view to include in the dw table
        SELECT
             c.Ordinal_position, c.table_name
             ,'' '' || c.column_name || '''' || '' '' 
                  --|| CASE WHEN  c.column_name ILIKE (''%_PK'') THEN c.DATA_TYPE ELSE '' '' END
                  || CASE WHEN c.column_name ilike (''%_PK'') THEN ''INT IDENTITY(1,1)''
                      ELSE
                   DATA_TYPE 
                  || CASE WHEN DATA_TYPE NOT IN (''BOOLEAN'',''VARIANT'',''DATE'') AND  c.column_name NOT ilike (''%_PK'')
                      THEN '' (''  || COALESCE(CAST(c.CHARACTER_MAXIMUM_LENGTH as STRING)
                               ,CAST(c.DATETIME_PRECISION as STRING)
                               ,CAST(c.CHARACTER_OCTET_LENGTH as STRING)
                               ,CAST(c.NUMERIC_PRECISION as STRING),'' '')
                   ELSE '' ''
                     END 
                  END
               || CASE WHEN DATA_TYPE  = ''NUMBER'' AND c.column_name NOT ilike (''%_PK'') THEN '','' || CAST(NUMERIC_SCALE AS STRING)  ELSE '' '' END
               || CASE WHEN DATA_TYPE NOT IN (''BOOLEAN'',''VARIANT'',''DATE'') AND  c.column_name NOT ilike (''%_PK'') THEN '')'' ELSE '' '' END
              

               || CASE WHEN c.ordinal_position = MAX(c.ordinal_position) OVER (PARTITION BY 1) THEN '');'' ELSE '', '' END
                        AS sqlText
      FROM all_columns_temp c
      ) INLT1
     
        ) INLT2
          ;

-- ---------------------------------------------------------------------------------------------------------------------- 
--Warning for any conforming view that dosen''t set up the dw start and end dates OR create a table from non existant view
dateError_list := ( CALL SP_VALIDATEDWDATES(''l'',:TableName_VAR,''COUNT'') );  --get any dw date warnnings

CREATE TEMP TABLE dwDateError_list 
     AS
SELECT *
FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

--Get a suggested data type for any columns that are of type variant-no Data Warehouse cols should be variant
variantError_list := (CALL SP_SUGGESTVARIANTDATATYPES(:DBName_VAR, ''DATAADMIN'', :TableName_VAR));

CREATE TEMP TABLE dwVariantError_list 
     AS
SELECT *
FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

count_variantErr_list := (CASE WHEN (SELECT TOP 1 MESSAGE FROM dwVariantError_list) ILIKE ''review%'' THEN 0 ELSE (SELECT COUNT(*) FROM dwVariantError_list ) END);

-- ---------------------------------------------------------------------------------------------------------------------- 
--Warning to ensure all required columns exist in the table
CREATE TEMP TABLE requiredCols_list
  as
SELECT :TableName_var || ''_PK'' as ColName_Required,''Required_Column'' as ColTypes_Required
    UNION
SELECT :TableName_var || ''_NK'' as ColName_Required,''Required_Column'' as ColTypes_Required
    UNION    
SELECT ''DW_STARTDATE'' as ColName_Required,''Required_Column'' as ColTypes_Required
    UNION
SELECT ''DW_ENDDATE'',''Required Column''
  UNION
SELECT ''DW_ISDELETED'',''Required Column''
  UNION
SELECT ''DW_ISCURRENTROW'',''Required Column''
  UNION
SELECT ''MTLN_CDC_LAST_CHANGE_TYPE'',''Required Column''
  UNION
SELECT ''MTLN_CDC_LAST_COMMIT_TIMESTAMP'',''Required Column''
  UNION
SELECT ''MTLN_CDC_SEQUENCE_NUMBER'',''Required Column''
  UNION
SELECT ''MTLN_CDC_LOAD_BATCH_ID'',''Required Column''
  UNION
SELECT ''MTLN_CDC_LOAD_TIMESTAMP'',''Required Column''
  UNION
SELECT ''MTLN_CDC_PROCESSED_DATE_HOUR'',''Required Column''
  UNION
SELECT ''MTLN_CDC_SRC_VERSION'',''Required Column''
  UNION
SELECT ''MTLN_CDC_FILENAME'',''Required Column''
  UNION
SELECT ''MTLN_CDC_FILEPATH'',''Required Column''
  UNION
SELECT ''MTLN_CDC_SRC_DATABASE'',''Required Column''
  UNION
SELECT ''MTLN_CDC_SRC_SCHEMA'',''Required Column''
  UNION
SELECT ''MTLN_CDC_SRC_TABLE'',''Required Column''
  UNION
SELECT ''CREATED_AT'',''Required Column''
  UNION
SELECT ''UPDATED_AT'',''Required Column''
;

--find required columns that are not in the dw table being created
CREATE TEMP TABLE requiredErr_list
  AS
SELECT req.ColName_Required ,tab.COLUMN_NAME ,ColTypes_Required
  FROM requiredCols_list           req
    LEFT JOIN all_columns_temp     tab
      ON UPPER(req.ColName_Required) = UPPER(tab.COLUMN_NAME)
 WHERE tab.COLUMN_NAME is null
;

count_requiredErr_list := (SELECT COUNT(*) FROM requiredErr_list AS COUNTROW) ;

-- ---------------------------------------------------------------------------------------------------------------------- 
--Mark all columns whose data type may need to be changed
 UPDATE all_columns_temp
   SET ERROR_NOT_NUMERIC = CASE 
     WHEN upper(COLUMN_NAME) LIKE ANY (''%^_FK'',''%^_ID'',''%^_PK'',''%^_COUNT'',''%^_AMOUNT'',''%NET%'',''%GROSS%'',''TIP'',''%ID'') ESCAPE ''^''
           AND NOT (UPPER(COLUMN_NAME) LIKE ANY(''%UUID%'',''IS_%'',''%^_GUID'')  ESCAPE ''^'') 
           AND NOT (UPPER(DATA_TYPE) LIKE ANY(''%NUMBER%'',''%DECIMAL%'')  ESCAPE ''^'') 
           THEN TRUE ELSE FALSE END
       ,ERROR_NOT_BOOLEAN = CASE WHEN upper(COLUMN_NAME) 
         LIKE ANY (''%^_IS^_%'',''%^_HAS^_%'',''IS^_%'',''HAS^_%'',''%ENABLED%'',''%DELETED%'')  ESCAPE ''^''
           AND NOT (UPPER(COLUMN_NAME) LIKE ANY (''%_AT'')ESCAPE ''^'') 
           AND NOT (UPPER(DATA_TYPE) LIKE ANY (''%BOOLEAN%'')ESCAPE ''^'')  
             THEN TRUE ELSE FALSE END
       ,ERROR_NOT_DATE = CASE WHEN upper(COLUMN_NAME) 
         LIKE ANY (''%^_AT'',''%^_DATE'')  ESCAPE ''^''
           AND NOT DATA_TYPE  LIKE ANY (''%DATE%'',''%TIME%'')   ESCAPE ''^''
           THEN TRUE ELSE FALSE END
       ,ERROR_UPDATED_COLUMN_NAME = CASE WHEN UPPER(COLUMN_NAME) = ''MODIFIED_AT'' THEN TRUE ELSE FALSE END
   ;   

ALTER TABLE all_columns_temp ADD COLUMN ERROR_MESSAGE string;

UPDATE all_columns_temp 
SET ERROR_MESSAGE =
  CASE WHEN ERROR_NOT_NUMERIC THEN :ERROR_NOT_NUMERIC_text
  WHEN ERROR_NOT_DATE THEN :ERROR_NOT_DATE_text
  WHEN ERROR_NOT_BOOLEAN THEN :ERROR_NOT_BOOLEAN_text
  WHEN ERROR_VARIANT THEN :ERROR_VARIANT_text
  WHEN ERROR_UPDATED_COLUMN_NAME THEN :ERROR_UPDATED_COLUMN_NAME_text
END;

--Put all results together into single temp table
CREATE TEMP TABLE resultsTable_list
  AS
  SELECT LISTAGG( Statement)  AS ""SQL Text""
     FROM (
    
      SELECT ''\\n--=========================================================================================== \\n'' 
        AS Statement, 1 AS ORDINAL_T
         
      UNION
        
      SELECT ''\\n--Review any messages shown below and modify the Conforming view as needed. \\n'' 
        , 2 AS ORDINAL_T
        
         UNION
         
        SELECT LISTAGG(CASE WHEN COUNT = 0 THEN ''--INFORMATIONAL MESSAGE:  '' ELSE 
           CASE WHEN MESSAGE ILIKE ''No Variant%'' 
           THEN ''--INFORMATIONAL MESSAGE :'' ELSE ''--CRITICAL ALERT :'' END
           END 
             || MESSAGE || '' has '' || COUNT || '' date errors.  '' || CASE WHEN COUNT = 0 THEN '' \\n'' ELSE ''  Execute '' 
             ||  '' CALL SP_VALIDATEDWDATES(\\''l\\'',\\'''' || :TableName_VAR || ''\\'',\\''ERROR\\'')   ''  ||  ''for Details.  \\n'' END) AS MESSAGE
               , 2 fROM dwDateError_list           

         UNION
         
        SELECT CASE WHEN :count_variantErr_list > 0
          THEN  LISTAGG( ''--'' ||
            CASE WHEN MESSAGE ILIKE ''No Variant%'' 
           THEN ''INFORMATIONAL MESSAGE :  '' ELSE ''CRITICAL ALERT :'' END
             || MESSAGE ||  ''\\n'') 
          ELSE NULL END
            , 3 
        FROM dwVariantError_list
               
        UNION

        SELECT 
          CASE WHEN :count_requiredErr_list > 0 
           THEN
                ''--CRITICAL ALERT:  The following require columns are missing from the conforming view: \\n--'' || LISTAGG(''      '' 
               || ColName_Required || '', '')
               || ''\\n--      Cut and paste the columns and definitions from the template to correct. \\n'' 
           ELSE  NULL END
             ,4
         FROM  requiredErr_list 

       
      UNION
       
      SELECT LISTAGG( REPLACE(REPLACE(t.ERROR_MESSAGE,''<DATA_TYPE>'',t.DATA_TYPE),''<COLUMN_NAME>'',t.COLUMN_NAME) || ''\\n'')
        , 5 AS ORDINAL_T 
        FROM all_columns_temp t 
          WHERE ERROR_NOT_NUMERIC OR ERROR_NOT_BOOLEAN OR ERROR_NOT_DATE OR ERROR_VARIANT OR ERROR_UPDATED_COLUMN_NAME
      
      UNION
      
      SELECT *, 6 AS ORDINAL_T FROM column_list_temp C
    ORDER BY ORDINAL_T
);

 
res_list  := (SELECT * FROM resultsTable_list);
 
-- ---------------------------------------------------------------------------------------------------------------------- 
END IF;

--========================================================================================================================
RETURN TABLE(res_list);

--========================================================================================================================
END';"
PROCEDURE,DATAADMIN,"SP_LOAD_365_TAXDEFINITIONS(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_365_TAXDEFINITIONS""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2020-08-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2029-08-20T14:48:37.661Z''; 
  -- locationid string      := ''[351]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');

--=================================================================================================================================
BEGIN
--=================================================================================================================================
reportSet := (  

------------------------------------------------------------------------------------------------------------------------------------
SELECT TRD.TAXRATE_DIM_NK                     AS Number --* string
    ,TRD.TAXRATE                              AS Name   --* string
  FROM DATAWAREHOUSE.TAXRATE_DIM              TRD
    INNER JOIN DATAWAREHOUSE.ORGANIZATION_DIM ORG
      ON TRD.ORGANIZATION_DIM_FK = ORG.ORGANIZATION_DIM_NK 
        AND TRD.DW_ISCURRENTROW
        AND ORG.DW_ISCURRENTROW
    INNER JOIN DATAWAREHOUSE.LOCATION_DIM      LOC
      ON LOC.ORGANIZATION_DIM_FK = ORG.ORGANIZATION_DIM_NK
      AND (LOC.LOCATION_DIM_NK IN (
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)   
            OR TRD.TAXRATE_DIM_NK = -1    )
    GROUP BY TRD.TAXRATE_DIM_NK,TRD.TAXRATE
--=================================================================================================================================
);
RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,SP_DQ_DISCOUNT_ARRAY_ISSUE(),"CREATE OR REPLACE PROCEDURE ""SP_DQ_DISCOUNT_ARRAY_ISSUE""()
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS OWNER
AS '
DECLARE
    -- Runtime metadata
    run_metadata VARIANT;
    parent_query_id VARCHAR;
    task_run_group_id VARCHAR;
    attempt_number NUMBER;
    session_id VARCHAR;
    task_name VARCHAR;

    -- Procedure specific variables
    yesterday_date DATE;
    validation_query_id VARCHAR;
    row_count NUMBER;
    error_message VARCHAR;

BEGIN
    -- Get runtime metadata for logging and traceability
    CALL dataadmin.sp_get_dag_run_metadata(COALESCE(last_query_id(), ''NOT_FOUND'')) INTO :run_metadata;
    parent_query_id := :run_metadata:parent_query_id::VARCHAR;
    task_run_group_id := :run_metadata:graph_run_group_id::VARCHAR;
    attempt_number := :run_metadata:run_attempt_number::NUMBER;
    session_id := :run_metadata:session_id::VARCHAR;
    task_name := COALESCE(:run_metadata:task_name::VARCHAR, ''sp_dq_discount_array_issue'');

    -- Set the target date for the validation
    yesterday_date := DATEADD(day, -1, CURRENT_DATE());

    --===========================
    --start validation query
    --===========================
    WITH current_cheques_raw AS (
    -- Step 1: Get the raw data for current cheques on a specific day and location
        SELECT
            ppc.ID,
            ppc.info,
            ppc.balance,
            ppc.ITEMS,
            cf.fiscal_date,
            cf.location_dim_fk
        FROM datalanding.POSAPI_PUBLIC_CHEQUE ppc
        -- (select * FROM DATALANDING.POSAPI_PUBLIC_CHEQUE WHERE ITEMS <> ''__value_not_modified__'') ppc --to exclude non toast column issue
        INNER JOIN (
            --cheques from warehouse
            SELECT CHEQUE_FACT_NK, MTLN_CDC_SEQUENCE_NUMBER, fiscal_date, location_dim_fk
            FROM datawarehouse.cheque_fact
            WHERE dw_iscurrentrow
            AND status in (''Closed'')
            AND location_dim_fk IN (37,7,1,35,9,38,32,27,13,4,41,29,43,11,21,25,3,6,39) -- Target Location ID from example
            AND fiscal_date = :yesterday_date -- Parameterized date
        ) cf ON ppc.ID = cf.CHEQUE_FACT_NK AND ppc.MTLN_CDC_SEQUENCE_NUMBER = cf.MTLN_CDC_SEQUENCE_NUMBER
        WHERE 1=1
            AND ppc.ITEMS <> ''__value_not_modified__'' 
        ),
        check_discounts_sum AS (
            -- Step 2a: Flatten the discounts array from the INFO column (check-level discounts) and sum the appliedValue
            SELECT
                ID,
                SUM(d.value:appliedValue::DECIMAL(38, 2)) as sum_applied_value_from_info
            FROM current_cheques_raw,
            LATERAL FLATTEN(INPUT => TRY_PARSE_JSON(''{discounts:'' || TRY_PARSE_JSON(info):discounts || ''}''), PATH => ''discounts'') d
            WHERE d.value:appliedValue IS NOT NULL
            GROUP BY ID
        ),
        item_discounts_sum AS (
            -- Step 2b: Flatten the ITEMS array and their internal discounts array (item-level discounts) and sum the appliedValue
            SELECT
                ID,
                SUM(d.value:appliedValue::DECIMAL(38, 2)) as sum_applied_value_from_items
            FROM current_cheques_raw,
            LATERAL FLATTEN(INPUT => TRY_PARSE_JSON(ITEMS)) i,
            LATERAL FLATTEN(INPUT => TRY_PARSE_JSON(''{discounts:'' || i.value:discounts || ''}''), PATH => ''discounts'') d
            WHERE i.value:status IN (''Added'', ''Sent'')
            AND d.value:appliedValue IS NOT NULL
            GROUP BY ID
        )
    -- Step 3: Compare the aggregated discount values from BALANCE against the sums from INFO and ITEMS
    SELECT
        ccr.ID AS CHEQUE_ID,
        ccr.fiscal_date,
        ccr.location_dim_fk,

        -- Check-level discount comparison
        TRY_PARSE_JSON(ccr.balance):discountCheck::DECIMAL(38, 4) AS discountCheck_from_balance,
        COALESCE(cds.sum_applied_value_from_info, 0) AS sum_applied_value_from_info,
        ABS((COALESCE(discountCheck_from_balance, 0) - COALESCE(sum_applied_value_from_info, 0))) AS difference_check_discount,

        -- Item-level discount comparison
        TRY_PARSE_JSON(ccr.balance):discountItem::DECIMAL(38, 4) AS discountItem_from_balance,
        COALESCE(ids.sum_applied_value_from_items, 0) AS sum_applied_value_from_items,
        ABS((COALESCE(discountItem_from_balance, 0) - COALESCE(sum_applied_value_from_items, 0))) AS difference_item_discount,

        -- Total discount for reference
        TRY_PARSE_JSON(ccr.balance):discount::DECIMAL(38, 4) AS total_discount_from_balance,

        (ABS(difference_check_discount) + ABS(difference_item_discount)) as total_delta,

        -- Raw data for inspection
        ccr.info,
        ccr.balance,
        ccr.items
    FROM current_cheques_raw ccr
    LEFT JOIN check_discounts_sum cds ON ccr.ID = cds.ID
    LEFT JOIN item_discounts_sum ids ON ccr.ID = ids.ID
    WHERE
        -- Filtering for records where the values do not match, allowing for small floating point differences
        ABS(difference_check_discount) > 0.001 OR ABS(difference_item_discount) > 0.001
    ORDER BY (ABS(difference_check_discount) + ABS(difference_item_discount)) DESC
    ;
    --===========================
    --END VALIDATION QUERY
    --===========================

    validation_query_id := last_query_id();

    CREATE OR REPLACE TEMP TABLE dq_discount_array_issue_results AS
        SELECT * FROM TABLE(RESULT_SCAN(:validation_query_id)); 

    SELECT COUNT(*) INTO :row_count FROM dq_discount_array_issue_results;

    IF (row_count > 0) THEN
        -- If there are deltas, construct the summary error message
        -- We first need to aggregate the deltas per location, and then list-aggregate the results.
        SELECT ''For '' || :yesterday_date || '' the following locations have deltas: '' ||
               LISTAGG(location_summary, '' ; '') WITHIN GROUP (ORDER BY LOCATION_DIM_FK)
        INTO :error_message
        FROM (
            SELECT 
                LOCATION_DIM_FK,
                LOCATION_DIM_FK || '': '' || SUM(total_delta) AS location_summary
            FROM dq_discount_array_issue_results
            GROUP BY LOCATION_DIM_FK
        );

        -- Log the single, summarized error message
        INSERT INTO DATAADMIN.error_logs (
            parent_query_id, task_run_group_id, attempt_number, session_id, task_name,
            failed_query_id, error_type_id, severity, sql_error_code, sql_error_message, sql_state, details
        )
        SELECT
            :parent_query_id, :task_run_group_id, :attempt_number, :session_id, :task_name,
            :validation_query_id, 3, ''WARNING'', NULL, :error_message, NULL,
            OBJECT_CONSTRUCT(''validation_name'', ''SP_DQ_DISCOUNT_ARRAY_ISSUE'', ''fiscal_date_checked'', :yesterday_date);

        RETURN ''Data quality check failed. Details logged: '' || :error_message;
    ELSE
        -- If there are no deltas, return a success message
        RETURN ''Data quality check passed for '' || :yesterday_date || ''. No discount calculation deltas found.'';
    END IF;

END;
';"
PROCEDURE,DATAADMIN,SP_GET_YESTERDAY_DATES(),"CREATE OR REPLACE PROCEDURE ""SP_GET_YESTERDAY_DATES""()
RETURNS VARIANT
LANGUAGE SQL
EXECUTE AS OWNER
AS '
/*
 * Stored Procedure: SP_GET_YESTERDAY_DATES
 *
 * Description:
 * This procedure calculates and retrieves yesterday''s date in two common string formats.
 * It''s designed as a reusable utility to provide consistent date values for other
 * stored procedures or queries that rely on the previous day''s date.
 *
 * Returns:
 * A VARIANT (JSON object) containing two key-value pairs:
 * - ""dateName"": VARCHAR - Yesterday''s date in ''YYYY-MM-DD'' format.
 * - ""dateText"": VARCHAR - Yesterday''s date in ''YYYYMMDD'' format.
 *
 * Example Return Value:
 * {
 * ""dateName"": ""2025-09-01"",
 * ""dateText"": ""20250901""
 * }
 *
 * Usage:
 * CALL SP_GET_YESTERDAY_DATES();
 *
 */
DECLARE
    -- Declare variables to hold the calculated date values
    date_name_val VARCHAR;
    date_text_val VARCHAR;
    return_object VARIANT;
BEGIN
    -- Execute the query and store the results into the variables
    SELECT
        TO_CHAR(DATEADD(day, -1, CURRENT_DATE()), ''YYYY-MM-DD''),
        REPLACE(TO_CHAR(DATEADD(day, -1, CURRENT_DATE()), ''YYYY-MM-DD''), ''-'', '''')
    INTO
        :date_name_val,
        :date_text_val;

    -- Construct a JSON object to return both values
    SELECT OBJECT_CONSTRUCT(''dateName'', :date_name_val, ''dateText'', :date_text_val)
    INTO :return_object;

    RETURN return_object;
END;
';"
PROCEDURE,DATAADMIN,"SP_REPORTDATAGROOM(VARCHAR, NUMBER, NUMBER)","CREATE OR REPLACE PROCEDURE ""SP_REPORTDATAGROOM""(""REPORT"" VARCHAR(500), ""DAYS"" NUMBER(38,0), ""LOCATIONID"" NUMBER(38,0))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS '
--=================================================================================================================
--This sproc interrogates report output.
--    creates perspective schemas
--    looks for cardinality issues with report data
--call DATAADMIN.SP_ReportDataGroom(''SP_REPORT_PMIX'',365,351)
--=================================================================================================================
DECLARE 
  dataout resultset; 
--------------------------------------------------------------------------------------------------------------------
 -- report VARCHAR(500):= ''SP_REPORT_DISCOUNT'';
 -- days number        := 365;  
 -- locationid number  := 351;
------------------------------------------------------------------------------------------------------------------
 sprocname VARCHAR(500);
 maxordinal number;
 enddate timestamp_tz   := (select current_timestamp()); 
 startdate timestamp_tz := dateadd(day,days * -1,enddate); 
 calltext VARCHAR(500)  := ''CALL DATAADMIN.'' || :report
                            || ''('''''' || :startdate  || '''''','''''' || :enddate || '''''','' || :locationid || '')''
                            ;

BEGIN
   drop table if exists report_data; 
   drop table if exists sproc_lists;
   drop table if exists error_lists;
   drop table if exists schema_lists;
   drop table if exists perspective_schema;
   drop table if exists column_list;
   drop table if exists aggregate_list;
   
  --get all the reporting sprocs
  SELECT * 
    FROM INFORMATION_SCHEMA.PROCEDURES
  WHERE PROCEDURE_NAME ILIKE ''%_REPORT_%''
    AND PROCEDURE_SCHEMA = ''DATAADMIN''
    AND PROCEDURE_NAME = :report
    ;

  CREATE TABLE sproc_lists AS
    SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

  --load report data into temp table  
  sprocname:= (SELECT TOP 1 PROCEDURE_NAME FROM sproc_lists);

--return(''SPROCNAME:'' || :sprocname || ''\\n'' || ''calltext: '' || :calltext);
-- return(:calltext);
  
  EXECUTE IMMEDIATE :calltext;
  CREATE TABLE report_data AS
    SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID())); 


--BEGIN:  look for cardinality issues
    BEGIN
      SELECT ''For the SQL: '' || :calltext || ''\\n'' || ''Error Count: '' || Count(*)  || ''\\n''|| LISTAGG(""ID Count"") AS ""Error List""
            FROM (SELECT  COUNT(*) || '' rows for Support ID '' || ""Support ID"" || '' \\n '' AS ""ID Count""
                  FROM report_data GROUP BY ""Support ID"" HAVING COUNT(*)  > 1 ORDER BY COUNT(*) DESC);
                  
    CREATE TABLE error_lists AS 
        SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID())); 
    END;  

--BEGIN:  create perspective schema  
    BEGIN
     
        SELECT  
        ''""schema"": {\\n''
          || LISTAGG (''  '' || ''""'' 
          || COLUMN_NAME   
          || ''"" : '' 
          || CASE WHEN DATA_TYPE = ''NUMBER'' AND  NUMERIC_SCALE  > 0 THEN ''""float""'' 
               ELSE CASE WHEN DATA_TYPE = ''NUMBER'' AND  NUMERIC_SCALE  = 0 THEN ''""int""'' 
                 ELSE CASE WHEN DATA_TYPE =''TEXT'' THEN ''""str""'' 
                   ELSE CASE WHEN DATA_TYPE = ''TIMESTAMP_TZ'' THEN ''""datetime""''
                     ELSE CASE WHEN DATA_TYPE = ''TIMESTAMP_NTZ'' THEN ''""datetime""''
                       ELSE CASE WHEN DATA_TYPE = ''BOOLEAN'' THEN ''""bool""''
                         ELSE CASE WHEN DATA_TYPE = ''DATE'' THEN ''""date""''
                           ELSE DATA_TYPE
          
          END END END END END END END 
           || '','' 
           || ''\\n''
        )  WITHIN GROUP (ORDER BY ORDINAL_POSITION)
        || ''}''
          AS DATA_TYPE 
     FROM information_schema.columns 
    WHERE table_name=''REPORT_DATA'';

  
    CREATE TABLE perspective_schema AS
        SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));      
  END; 


  BEGIN

  SELECT LISTAGG (''  '' || ''""'' 
          || COLUMN_NAME   
          || ''"",'' 
          || ''\\n''
        )  WITHIN GROUP (ORDER BY ORDINAL_POSITION) 
          AS DATA_COLUMNS 
     FROM information_schema.columns 
    WHERE table_name=''REPORT_DATA'';

 CREATE TABLE column_list AS
        SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));  
  END;

  BEGIN

  SELECT LISTAGG (''  '' || ''""'' 
          || COLUMN_NAME  
          || ''"" : '' 
          || CASE WHEN DATA_TYPE = ''NUMBER'' AND COLUMN_NAME <> ''Support ID'' AND COLUMN_NAME NOT ILIKE ''%percent%''
           AND COLUMN_NAME NOT ILIKE ''% ID'' AND COLUMN_NAME NOT ILIKE ''%year%''
          AND NUMERIC_SCALE  > 0 THEN ''""sum""'' 
               ELSE CASE WHEN DATA_TYPE = ''NUMBER'' AND  NUMERIC_SCALE  = 0 AND COLUMN_NAME <> ''Support ID'' 
               AND COLUMN_NAME NOT ILIKE ''%percent%'' AND COLUMN_NAME NOT ILIKE ''% ID'' AND COLUMN_NAME NOT ILIKE ''%year%''
                 THEN ''""sum""'' 
                 ELSE CASE WHEN DATA_TYPE =''TEXT'' THEN ''""unique""'' 
                   ELSE CASE WHEN DATA_TYPE = ''TIMESTAMP_TZ'' THEN ''""unique""'' 
                     ELSE CASE WHEN DATA_TYPE = ''TIMESTAMP_NTZ'' THEN ''""unique""'' 
                       ELSE CASE WHEN DATA_TYPE = ''BOOLEAN'' THEN ''""unique""'' 
                         ELSE CASE WHEN DATA_TYPE = ''DATE'' THEN ''""unique""'' 
                           ELSE ''""unique""'' 
                   END END END END END END END

          
          || '','' 
          || ''\\n''
        )  WITHIN GROUP (ORDER BY ORDINAL_POSITION) 
          AS DATA_COLUMNS 
     FROM information_schema.columns 
    WHERE table_name=''REPORT_DATA''
      AND column_name <> ''Support ID'';

 CREATE TABLE aggregate_list AS
        SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));  
  END;

  

  dataout := (SELECT ''Error List'' AS "" ""
                 ,IFNULL(""Error List"",''No Errors'') as ""Report Info"" 
                FROM error_lists
                   UNION
              SELECT ''Perspective Schema'',* FROM perspective_schema
                   UNION
              SELECT ''Column List'',left(DATA_COLUMNS,LENGTH(DATA_COLUMNS) - 2) FROM column_list   
                   UNION
              SELECT ''Aggregate List'',left(DATA_COLUMNS,LENGTH(DATA_COLUMNS) - 2) FROM aggregate_list
               );
               
  return table(dataout);
  
END;  --end of sproc
';"
PROCEDURE,DATAADMIN,"SP_REPORT_FEES(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_FEES""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2020-08-22T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2025-08-22T14:48:37.661Z''; 
  -- locationid string      := ''[2,351]'';
  locationidS string        :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--=============================================================================================
BEGIN
 reportSet:= (
SELECT SURCHARGE_FACT_NK                                                       as ""Support ID"" 
    , ''FEE-'' ||row_number() over (order by surcharge_FACT_NK) 
                                                                               as ""Detail ID""  
--status, category, level-----------------------------------------------------------------------
    ,IFNULL(chk.STATUS,''None'')                                                 as ""Check Status""
-- --geography----------------------------------------------------------------------------------
    ,IFNULL(loc.LOCATIONNAME,''None'')                                           as ""Location""
    ,loc.LOCATION_DIM_NK                                                       as ""Location ID""    
-- --dates---------------------------------------------------------------------------------------
   ,LOC.TZ_NAME                                                                as ""Time Zone""
    ,to_char(LEFT(CHK.FISCAL_DATE,4))                                          as ""Year""
    ,to_char(YEAR(CHK.FISCAL_DATE)) || ''|'' || TO_CHAR(RIGHT(''0'' || MONTH(CHK.FISCAL_DATE),2))
                                                                               as ""Year and Month""
    ,IFNULL(dad.DAYPART,''None'')                                                as ""Daypart""
    
    ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,chk.CLOSED_AT::timestamp_ntz )::timestamp) 
                                                                               as ""Closed At""
    ,to_char(chk.FISCAL_DATE)                                                  as ""Fiscal Date""

    ,IFNULL(DAYNAME(chk.FISCAL_DATE),''None'')                                   as ""Day of Week""
    ,CASE WHEN DAYNAME(chk.FISCAL_DATE) IN (''Sat'',''Sun'')  
       THEN TRUE ELSE FALSE END                                                as ""Is Weekend""
   --people-------------------------------------------------------------------------------------
    ,IFNULL(emd.EMPLOYEE_NAME,''None'')                                          as ""Employee""
-- --flags--------------------------------------------------------------------------------------
   ,SUF.IS_TAXABLE                                                             as ""Is Taxable""
-- --Descriptors-------------------------------------------------------------------------------- 
    ,IFNULL(SUD.SURCHARGE, ''None'')                                             as ""Fee""   
    ,IFNULL(CHK.chequenumber ,''None'')                                          as ""Check""
    ,SUF.SURCHARGE_TYPE                                                        as ""Type""       
 
-- --Facts--------------------------------------------------------------------------------------
    ,1::NUMBER(18,0)                                                           as ""Count""
    ,SUF.APPLIEDAMOUNT::NUMBER(18,2)                                           as ""Total""
------------------------------------------------------------------------------------------------  
FROM DATAADMIN.CHEQUE_FACT                           CHK
      INNER JOIN DATAADMIN.SURCHARGE_FACT            SUF
          ON SUF.CHEQUE_FACT_FK = CHK.CHEQUE_FACT_NK
             AND CHK.DW_ISCURRENTROW
             AND SUF.DW_ISCURRENTROW
             AND NOT CHK.DW_ISDELETED
             AND NOT CHK.IS_TRAINING
             AND CHK.STATUS = ''Closed''
             -- AND NOT SUF.SURCHARGE_TYPE = ''None''
             AND NOT SUF.STATUS = ''Disabled''
             AND NOT SUF.IS_GRATUITY
             AND CHK.FISCAL_DATE::date
                >= :startdate::date 
            AND CHK.FISCAL_DATE::date  
                <= :enddate::date 
            AND CHK.LOCATION_DIM_FK IN ( 
               SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)
      INNER JOIN DATAWAREHOUSE.EMPLOYEE_DIM            EMD
        ON EMD.EMPLOYEE_DIM_NK= CHK.EMPLOYEE_DIM_FK
          AND EMD.DW_ISCURRENTROW                           
      INNER JOIN DATAWAREHOUSE.LOCATION_DIM            LOC
        ON CHK.LOCATION_DIM_FK = loc.LOCATION_DIM_NK
          AND loc.DW_ISCURRENTROW
      INNER JOIN DATAWAREHOUSE.DAYPART_DIM             DAD
        ON CHK.daypart_dim_fk = dad.daypart_dim_Nk
          AND dad.DW_ISCURRENTROW = TRUE  
      INNER JOIN DATAWAREHOUSE.SURCHARGE_DIM           SUD
        ON SUF.SURCHARGE_DIM_NK = SUD.SURCHARGE_DIM_NK
          AND SUD.DW_ISCURRENTROW

   
--=============================================================================================
);
RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,"SP_REPORT_GIFTCARDDETAIL(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_GIFTCARDDETAIL""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2020-02-13 00:00:00.000 -0800'';  
  -- enddate timestamp_tz   := ''2029-02-13 00:00:00.000 -0800''; 
  -- locationid string      := ''[1,2,3,4,5,6,7,8,9,351,352]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
  
---====================================================================================================================
BEGIN
DROP TABLE if exists TEMP_LOCS;
DROP TABLE if exists TEMP_TRANS;
DROP TABLE if exists TEMP_REPORT;

------------------------------------------------------------------------------------------------------------------------
--Get all of the locations assocaited with a merchant - use to apply filters for legacy gift cards
SELECT MOD.MERCHANT_DIM_NK
  FROM MERCHANT_DIM                       MOD
    INNER JOIN MERCHANT_ORGANIZATION_XREF MOX
      ON MOD.MERCHANT_DIM_NK = MOX.MERCHANT_DIM_FK
        AND MOD.DW_ISCURRENTROW
        AND MOX.DW_ISCURRENTROW
    INNER JOIN ORGANIZATION_DIM           ORG
      ON ORG.ORGANIZATION_DIM_NK = MOX.ORGANIZATION_DIM_FK
        AND ORG.DW_ISCURRENTROW
    INNER JOIN LOCATION_DIM               LOC
      ON LOC.ORGANIZATION_DIM_FK = ORG.ORGANIZATION_DIM_NK
        AND LOC.DW_ISCURRENTROW
        AND LOCATION_DIM_NK in (SELECT table1.value 
        FROM table(split_to_table(:locationidS, '',''))  table1)
    GROUP BY MOD.MERCHANT_DIM_NK;

 CREATE TEMP TABLE TEMP_LOCS AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));  

-----------------------------------------------------------------------------------------------
--get information on cards issued wilthin a certain date - NON LEGACY ONLY
SELECT GCD.GIFTCARD_DIM_NK  AS GIFTCARD_DIM_NK
    ,CHF.FISCAL_DATE        AS ""Fiscal Date""
    ,CHF.CHEQUE_FACT_NK     AS ""Check ID""
    ,CHF.LOCATION_DIM_FK    AS ""Location ID""    
    ,CHF.CHEQUENUMBER       AS ""Check""
    ,EMD.EMPLOYEE_NAME      AS ""Employee""
    ,LOC.LOCATIONNAME       AS ""Location""
    ,RCD.REVENUECENTER      AS ""Revenue Center""
    ,DAD.DAYPART            AS ""Daypart""
    ,GCD.ISSUED_AT          AS ""Issued At""   
    ,GCD.IS_LEGACY          AS ""Is Imported""
    ,GCD.START_BALANCE      AS ""Issued Amount""
   FROM GIFTCARD_DIM                               GCD
    INNER JOIN TEMP_LOCS                           TLC
       ON GCD.MERCHANT_DIM_FK = TLC.MERCHANT_DIM_NK 
     INNER JOIN GIFTCARDTRANSACTION_FACT           GCF
       ON GCD.GIFTCARD_DIM_NK = GCF.GIFTCARD_DIM_FK
         AND GCF.DW_ISCURRENTROW
         AND GCD.DW_ISCURRENTROW
         AND GCD.IS_ISSUED
         AND NOT GCD.DW_ISDELETED
         AND GCD.DW_ISCURRENTROW
         AND GCF.COMMAND = ''Issue''
         AND GCD.ISSUED_AT::date >= :startdate::date
         AND GCD.ISSUED_AT::date <= :enddate::date   
      INNER JOIN CHEQUE_FACT                       CHF
        ON CHF.CHEQUE_FACT_NK = GCf.CHEQUE_FACT_FK
          AND CHF.DW_ISCURRENTROW
          AND CHF.STATUS = ''Closed''
      INNER JOIN EMPLOYEE_DIM                      EMD
        ON EMD.EMPLOYEE_DIM_NK = CHF.EMPLOYEE_DIM_FK
          AND EMD.DW_ISCURRENTROW
      INNER JOIN DAYPART_DIM                       DAD
        ON DAD.DAYPART_DIM_NK = CHF.DAYPART_DIM_FK
          AND DAD.DW_ISCURRENTROW
      INNER JOIN LOCATION_DIM                     LOC
        ON CHF.LOCATION_DIM_FK = LOC.LOCATION_DIM_NK
          AND LOC.DW_ISCURRENTROW
      INNER JOIN REVENUECENTER_DIM                RCD
        ON CHF.REVENUECENTER_DIM_FK = RCD.REVENUECENTER_DIM_NK
          AND RCD.DW_ISCURRENTROW
     
  ORDER BY GCD.ISSUED_AT  
;

 CREATE TEMP TABLE TEMP_TRANS AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID( )));  

----------------------------------------------------------------------------------------------------
--For final report - left join all transactions to all gift cards to pick up legacy cards.
--  an equivalent loj in temp_trans runs longer since Snowflake dosen''t apply filters for the
--  and clauses but instead waits for a where.
SELECT  TO_CHAR(GCD.GIFTCARD_DIM_NK)                                  AS ""Support ID"" 
    ,''GCD-'' ||row_number() over (order by GCD.GIFTCARD_DIM_NK) 
                                                                      AS ""Detail ID"" 
    ,IFNULL(gcd.GIFTCARD,''None'')                                      AS ""Gift Card Number""    
    ,(MAX(TTRANS.""Check ID""))                                         AS ""Check ID""  
    ,(MAX(TTRANS.""Fiscal Date""))                                      AS ""Fiscal Date""
    ,(MAX(TTRANS.""Location ID""))                                      AS ""Location ID""
    ,IFNULL(MAX(TTRANS.""Check""),''None'')                               AS ""Check""
    ,IFNULL(MAX(TTRANS.""Employee""),''None'')                            AS ""Employee""
    ,IFNULL(MAX(TTRANS.""Location""),''None'')                            AS ""Location""
    ,IFNULL(MAX(TTRANS.""Daypart""),''None'')                             AS ""Daypart""
    ,IFNULL(MAX(TTRANS.""Revenue Center""),''None'')                      AS ""Revenue Center""
    ,IFNULL(MAX(COALESCE(GCD.ISSUED_AT,TTRANS.""Issued At"")) ::DATE ::STRING,''None'')          
                                                                      AS ""Issued At""   
    ,MAX(CASE WHEN TTRANS.""Is Imported"" = ''false'' 
      then FALSE ELSE TRUE END)::BOOLEAN                               AS ""Is Imported""
    ,MAX(IFNULL(COALESCE(GCD.START_BALANCE,TTRANS. ""Issued Amount""),0))
    ::NUMBER(18,2)  
                                                                      AS ""Issued Amount""
                                                                      
  FROM GIFTCARD_DIM                                                   GCD
    INNER JOIN TEMP_LOCS                                              TLC
       ON GCD.MERCHANT_DIM_FK = TLC.MERCHANT_DIM_NK   
          AND GCD.ISSUED_AT::date >= :startdate::date
          AND GCD.ISSUED_AT::date <= :enddate::date       
    LEFT OUTER JOIN TEMP_TRANS                                        TTRANS
      ON GCD.GIFTCARD_DIM_NK = TTRANS.GIFTCARD_DIM_NK
    GROUP BY ""Gift Card Number"" ,GCD.GIFTCARD_DIM_NK
;

 CREATE TEMP TABLE TEMP_REPORT AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));  
    
----------------------------------------------------------------------------------------------------
 reportSet   := (
   SELECT * FROM TEMP_REPORT 

--===================================================================================================
); 
 RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,"SP_SEND_ERROR_TYPES_OVER_SLACK(VARCHAR, ARRAY)","CREATE OR REPLACE PROCEDURE ""SP_SEND_ERROR_TYPES_OVER_SLACK""(""CHANNEL"" VARCHAR, ""ERROR_TYPES"" ARRAY)
RETURNS VARCHAR
LANGUAGE PYTHON
RUNTIME_VERSION = '3.11'
PACKAGES = ('snowflake-snowpark-python')
HANDLER = 'send_alert'
EXTERNAL_ACCESS_INTEGRATIONS = (SLACK_EXTERNAL_ACCESS_INTEGRATION)
SECRETS = ('webhook_secret'=DATAADMIN.SLACK_WEBHOOK_PROD_DATAWAREHOUSE_ALERTS)
EXECUTE AS OWNER
AS '
""""""
-- Description:
--   Queries the `dataadmin.error_logs` table for unnotified errors that match a specific list
--   of error types. It then aggregates these errors, formats them into a structured and readable
--   message using the Slack Block Kit API, and sends the alert to a pre-configured Slack channel
--   via a webhook.
--
--   After successfully sending the notification, it updates the processed error log entries
--   with a notification timestamp and a unique batch ID. This prevents the same error from
--   being sent in subsequent runs. The procedure is designed to be idempotent and is ideal
--   for automated execution within a Snowflake Task for near real-time error monitoring.
--
-- Parameters:
--   channel (VARCHAR): The name of the target Slack channel (e.g., ''#data-alerts'').
--     Note: This parameter is for logging and logical separation. The actual destination is
--     determined by the webhook URL stored in the `webhook_secret`.
--
--   error_types (ARRAY): An array of strings representing the `ERROR_TYPE_ID`s to query for.
--     The procedure will only look for errors whose type is present in this array.
--
-- Returns:
--   VARCHAR: A status message indicating the outcome.
--     - ''No new errors to report.'' -> No matching, unnotified errors were found.
--     - ''Alert sent for {error_count} error(s).'' -> The notification was sent successfully.
--     - A descriptive error message if the API call to Slack fails.
--
-- Dependencies:
--   - Table: `dataadmin.error_logs` must exist and contain the error records.
--   - External Access Integration: `slack_external_access_integration` must be configured to allow
--     network egress to `hooks.slack.com`.
--   - Secret: `dataadmin.SLACK_WEBHOOK_PROD_DATAWAREHOUSE_ALERTS` must be created and contain the
--     unique path/token of the Slack incoming webhook URL (the part after `https://hooks.slack.com/services/`).
--
-- Usage Example:
--   -- Call the procedure to send alerts for specific data quality and timeout errors.
--   CALL dataadmin.sp_send_error_types_over_slack(
--     ''datawarehouse-alerts'',
--     [2,3]
--   );
""""""
import _snowflake
import json
import urllib.request
from snowflake.snowpark.functions import col, lit, array_contains, count, listagg, when, current_timestamp

def trim_message(message, max_len=800, front_len=200, back_len=300):
    message = message.replace(''`'', ""''"")
    if len(message) > max_len:
        return message[:front_len] + ""... (trimmed) ..."" + message[-back_len:]
    return message

def send_alert(session, channel, error_types):
    # 1. Query for unnotified errors using Snowpark DataFrames
    error_logs_df = session.table(''dataadmin.error_logs'')

    unnotified_errors_df = error_logs_df.filter(
        (col(''ERROR_NOTIFICATION_TS'').is_null()) &
        (array_contains(col(''ERROR_TYPE_ID'').cast(''variant''), lit(error_types)))
    )

    # Cache the result to avoid re-querying
    unnotified_errors_df.cache_result()

    error_count = unnotified_errors_df.count()
    if error_count == 0:
        return ''No new errors to report.''

    # This ID will be used to mark these errors as part of this notification batch.
    get_graph_run_id_query = """"""
    BEGIN
        -- Attempt to get the real ID
        RETURN SYSTEM$TASK_RUNTIME_INFO(''CURRENT_TASK_GRAPH_RUN_GROUP_ID'');
    EXCEPTION
        -- If any error occurs (like not being in a task), run this block instead
        WHEN OTHER THEN
            RETURN UUID_STRING();
    END;
    """"""
    notification_id = session.sql(get_graph_run_id_query).collect()[0][0]

    # Collect the IDs for the final UPDATE statement
    error_ids_to_update = [row[''ID''] for row in unnotified_errors_df.select(''ID'').collect()]

    # 2. Aggregate and format the error data in Python
    # Group by task name to structure the alert
    grouped_errors = unnotified_errors_df.group_by(''TASK_NAME'').agg(
        listagg(''SQL_ERROR_MESSAGE'', ''\\n'').alias(''MESSAGES''),
        count(''*'').alias(''ERROR_COUNT'')
    ).collect()

    # 3. Build the Slack Block Kit Payload in Python
    # This gives us much more control over formatting.
    blocks = [
        {
            ""type"": ""section"",
            ""text"": {
                ""type"": ""mrkdwn"",
                ""text"": f"":alert: *{error_count} new error(s) found in Snowflake!*""
            }
        },
        {""type"": ""divider""}
    ]

    for row in grouped_errors:
        task_name = row[''TASK_NAME''] or ''MANUAL_RUN''
        task_error_count = row[''ERROR_COUNT'']
        
        task_header_block = {
            ""type"": ""section"",
            ""text"": {
                ""type"": ""mrkdwn"",
                ""text"": f""*{task_name}:* {task_error_count} error(s)""
            }
        }
        blocks.append(task_header_block)

        messages = row[''MESSAGES''].split(''\\n'')
        
        # Show up to 5 errors to avoid huge messages
        for msg in messages[:5]:
            error_block = {
                ""type"": ""section"",
                ""text"": {
                    ""type"": ""mrkdwn"",
                    ""text"": f""   `{trim_message(msg)}`""
                }
            }
            blocks.append(error_block)

        if len(messages) > 5:
            more_errors_block = {
                 ""type"": ""context"",
                ""elements"": [
                    {
                        ""type"": ""mrkdwn"",
                        ""text"": f""...and {len(messages) - 5} more.""
                    }
                ]
            }
            blocks.append(more_errors_block)

        blocks.append({""type"": ""divider""})


    slack_payload = {""blocks"": blocks}

    # 4. Send the message to Slack
    webhook_secret = _snowflake.get_generic_secret_string(''webhook_secret'')
    webhook_url = f""https://hooks.slack.com/services/{webhook_secret}""
    payload_json = json.dumps(slack_payload).encode(''utf-8'')
    
    req = urllib.request.Request(
        webhook_url,
        data=payload_json,
        headers={''Content-Type'': ''application/json''}
    )
    
    try:
        with urllib.request.urlopen(req) as response:
            if response.status != 200:
                return f""Failed to send message. Status: {response.status}, Body: {response.read().decode()}""
    except Exception as e:
        return f""Error sending Slack message: {e}""

     # 5. Update the log table to mark errors as notified
    session.table(''dataadmin.error_logs'').update(
        {
            ""ERROR_NOTIFICATION_TS"": current_timestamp(),
            ""ERROR_NOTIFICATION_ID"": lit(notification_id)
        },
        col(''ID'').in_(error_ids_to_update)
    )

    return f""Alert sent for {error_count} error(s).""
';"
PROCEDURE,DATAADMIN,SP_STAGELOADBATCH_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADBATCH_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.BATCH_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.BATCH_DIM(   
          BATCH_DIM_NK, 
          BATCH_NUMBER, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          LOCATION_DIM_FK, 
          PAYMENTMETHOD_DIM_FK, 
          IS_TRUNCATED, 
          FISCAL_DATE_INT, 
          FISCAL_DATE, 
          CREATED_AT, 
          UPDATED_AT, 
          BATCH_NUMBER_SUFFIX, 
          STATE, 
          TRANSACTION_NUMBER 
) 
 SELECT   BATCH_DIM_NK  as   BATCH_DIM_NK,  
   BATCH_NUMBER  as   BATCH_NUMBER,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   LOCATION_DIM_FK  as   LOCATION_DIM_FK,  
   PAYMENTMETHOD_DIM_FK  as   PAYMENTMETHOD_DIM_FK,  
   IS_TRUNCATED  as   IS_TRUNCATED,  
   FISCAL_DATE_INT  as   FISCAL_DATE_INT,  
   FISCAL_DATE  as   FISCAL_DATE,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   BATCH_NUMBER_SUFFIX  as   BATCH_NUMBER_SUFFIX,  
   STATE  as   STATE,  
   TRANSACTION_NUMBER  as   TRANSACTION_NUMBER 
  FROM DATAADMIN.BATCH_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''BATCH_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''BATCH_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADCASHPAYMENTLEDGER_FACT(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADCASHPAYMENTLEDGER_FACT""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.CASHPAYMENTLEDGER_FACT),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.CASHPAYMENTLEDGER_FACT(   
          CASHPAYMENTLEDGER_FACT_NK, 
          CASHPAYMENTLEDGER, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          CHEQUE_DIM_FK, 
          PAYMENTS_FACT_FK, 
          PAYMENTMETHOD_DIM_ID, 
          SHIFT_DIM_FK, 
          IS_VOIDED, 
          CREATED_AT, 
          UPDATED_AT, 
          TENDERED_AMOUNT, 
          CHANGE_AMOUNT 
) 
 SELECT   CASHPAYMENTLEDGER_FACT_NK  as   CASHPAYMENTLEDGER_FACT_NK,  
   CASHPAYMENTLEDGER  as   CASHPAYMENTLEDGER,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   CHEQUE_DIM_FK  as   CHEQUE_DIM_FK,  
   PAYMENTS_FACT_FK  as   PAYMENTS_FACT_FK,  
   PAYMENTMETHOD_DIM_ID  as   PAYMENTMETHOD_DIM_ID,  
   SHIFT_DIM_FK  as   SHIFT_DIM_FK,  
   IS_VOIDED  as   IS_VOIDED,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   TENDERED_AMOUNT  as   TENDERED_AMOUNT,  
   CHANGE_AMOUNT  as   CHANGE_AMOUNT 
  FROM DATAADMIN.CASHPAYMENTLEDGER_FACT
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''CASHPAYMENTLEDGER_FACT'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''CASHPAYMENTLEDGER_FACT'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,"SP_REPORT_ACCOUNTSUMMARY_PAYMENTS_BACK(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_ACCOUNTSUMMARY_PAYMENTS_BACK""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet           resultset;
  -- startdate string    := ''2020-07-10'';  
  -- enddate string      := ''2029-07-10''; 
  -- locationid string   := ''[351]'';
  locationidS string  :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--=========================================================================================
BEGIN
  DROP TABLE IF EXISTS TEMP_GCPURCHASE;
  DROP TABLE IF EXISTS TEMP_PMIX;
  DROP TABLE IF EXISTS TEMP_CHECK;
  DROP TABLE IF EXISTS TEMP_GIFTCARDS;  
  DROP TABLE IF EXISTS TEMP_TAXDETAILSFEE;
  DROP TABLE IF EXISTS TEMP_TAXDETAILSTENDER;
  DROP TABLE IF EXISTS TEMP_REFUNDS;  
  DROP TABLE IF EXISTS TEMP_FEES;
  DROP TABLE IF EXISTS TEMP_PAYINOUT;

  DROP TABLE IF EXISTS TEMP_TABLE_PAYMENTS_1AA; 
  DROP TABLE IF EXISTS TEMP_TABLE_PAYMENTS_1AB;
  DROP TABLE IF EXISTS TEMP_TABLE_PAYMENTS_1AC;
  DROP TABLE IF EXISTS TEMP_TABLE_PAYMENTS_1A;   
--=========================================================================================

CREATE TEMP TABLE TEMP_PAYINOUT  AS
 SELECT ''PayInOut''                                                            as ""Level""   
     ,SHD.FISCAL_DAY                                                          as ""Fiscal Date""
    ,CASE WHEN PAR.IS_PAY_IN THEN ''Pay In'' ELSE ''Pay Out''END                  as ""Type""  
    ,SHD.LOCATION_DIM_FK::decimal(36,0)                                       as ""Location ID""  
    ,CASE WHEN PMD.PAYMENTMETHODTYPE IN (''CC'',''EPX'') 
       THEN ''Credit Card'' ELSE PMD.PAYMENTMETHODTYPE  END                                                             
                                                                              as ""Group 1B""
    ,CASE WHEN PMD.PAYMENTMETHODTYPE IN (''CC'',''EPX'')  
             THEN CCT.CARD_TYPE
        ELSE ''None'' END                                                       as ""Group 2B""  
    ,1                                                                        as ""CountPIO""
    ,IFNULL(PMD.PAYMENTMETHODTYPE ,''None'')                                    as ""Payment Type""
    ,IFNULL(PMD.PAYMENTMETHODTYPE ,''None'')                                    as ""Payment Method""
    ,IFNULL(CCT.CARD_TYPE,''None'')                                             as ""Card Brand""   
    ,SUM(1::NUMBER(18,0))                                                     as ""Count""
    ,SUM(PIO.AMOUNT * CASE WHEN PAR.IS_PAY_IN THEN 1 ELSE -1 END
          ) ::DECIMAL(36,2)                                                   as ""Amount"" 
       FROM DATAWAREHOUSE.PAYINOUT_FACT                                       PIO  
            INNER JOIN DATAWAREHOUSE.SHIFT_DIM                                SHD
              ON PIO.SHIFT_DIM_FK = SHD.SHIFT_DIM_NK
                  AND SHD.DW_ISCURRENTROW
                  AND PIO.DW_ISCURRENTROW
                  AND NOT PIO.DW_ISDELETED
                  AND NOT PIO.IS_VOID
                  AND PIO.STATUS = ''Success''
                  AND SHD.FISCAL_DAY::date >= :startdate::date 
                  AND SHD.FISCAL_DAY::date <= :enddate::date  
                  AND SHD.LOCATION_DIM_FK in (
                    SELECT table1.value 
                      FROM table(split_to_table(:locationidS, '',''))  table1) 
            INNER JOIN DATAWAREHOUSE.PAYMENTMETHOD_DIM                         PMD
              ON PMD.PAYMENTMETHOD_DIM_NK = PIO.PAYMENTMETHOD_DIM_FK
                  AND PMD.DW_ISCURRENTROW
            INNER JOIN DATAWAREHOUSE.PAYINPAYOUTREASON_DIM                     PAR
              ON PAR.PAYINPAYOUTREASON_DIM_NK = PIO.PAYINPAYOUTREASON_DIM_FK
                  AND PAR.DW_ISCURRENTROW                
            LEFT JOIN DATAWAREHOUSE.CCTRANSACTION_FACT                         CCT
              ON CCT.CCTRANSACTION_FACT_NK = PIO.CCTRANSATION_FACT_FK
                  AND CCT.DW_ISCURRENTROW
            GROUP BY ""Level"" 
                ,""Type""
                ,""Group 1B""
                ,""Group 2B""
                ,""Fiscal Date""
                ,""Location ID""  
                ,""Payment Method""
                ,""Payment Type""
                ,""Card Brand""  ;

-------------------------------------------------------------------------------------------
 CREATE TEMP TABLE TEMP_REFUNDS
    AS
 SELECT ''Refunds''                                                       AS ""Level""
    ,''Refunds''                                                          AS ""Group 1C""
    ,''Refunds''                                                          AS ""Group 2C""    
    ,CHK.FISCAL_DATE                                                    AS ""Fiscal Date""
    ,IFNULL(PMD.PAYMENTMETHODTYPE ,''None'')                              AS ""Payment Type""
    ,IFNULL(PMD.PAYMENTMETHODTYPE ,''None'')                              AS ""Payment Method""
    ,ref.LOCATION_DIM_FK                                                AS ""Location ID""
    ,1                                                                  AS ""Count""
    ,ref.REFUND_AMOUNT::DECIMAL(18,2)                                   AS ""Refund Amount""  
        FROM DATAWAREHOUSE.REFUNDS_FACT                                 ref
          INNER JOIN DATAWAREHOUSE.CHEQUE_FACT                          chk
            ON chk.CHEQUE_FACT_NK = ref.CHEQUE_FACT_FK
              AND chk.DW_ISCURRENTROW
              AND NOT chk.dw_isdeleted
              AND chk.STATUS = ''Closed''
              AND ref.PAYMENTSTATUS = ''Success''
              AND (chk.FISCAL_DATE::date >= :startdate::date 
              AND chk.FISCAL_DATE::date  <= :enddate::date)
                              AND ref.opened_at::timestamp_ntz  >= :startdate::timestamp_ntz 
              AND ref.LOCATION_DIM_FK in (
                    SELECT table1.value 
                      FROM table(split_to_table(:locationidS, '',''))  table1)                               
              AND ref.DW_ISCURRENTROW
              AND NOT ref.IS_TRAINING
              AND NOT ref.dw_isdeleted
            INNER JOIN DATAWAREHOUSE.PAYMENTMETHOD_DIM                  pmd
              ON pmd.PAYMENTMETHOD_DIM_NK = ref.PAYMENTMETHOD_DIM_FK
                AND pmd.DW_ISCURRENTROW
;         

--===========================================================================================
CREATE TEMP TABLE TEMP_GCPURCHASE AS
  SELECT CHF.FISCAL_DATE   AS  FISCAL_DATE
      ,CHF.LOCATION_DIM_FK AS  LOCATION_DIM_FK
      ,GCF.CHEQUE_FACT_FK  AS  CHEQUE_FACT_FK
      ,SUM(GCF.AMOUNT)     AS ""Gift Card Purchase Amount""
     FROM DATAWAREHOUSE.GIFTCARDTRANSACTION_FACT                       GCF  
        INNER JOIN DATAWAREHOUSE.CHEQUE_FACT                           CHF
            ON CHF.CHEQUE_FACT_NK = GCF.CHEQUE_FACT_FK
                AND CHF.STATUS = ''Closed''
                AND GCF.COMMAND = ''Issue''
                AND CHF.DW_ISCURRENTROW
                AND GCF.DW_ISCURRENTROW
                AND NOT GCF.DW_ISDELETED
                AND CHF.FISCAL_DATE::date >= :startdate::date 
                AND CHF.FISCAL_DATE::date <= :enddate::date  
                AND CHF.LOCATION_DIM_FK in (
                  SELECT table1.value 
                     FROM table(split_to_table(:locationidS, '',''))  table1)                 
     GROUP BY CHF.FISCAL_DATE
       ,CHF.LOCATION_DIM_FK
       ,GCF.CHEQUE_FACT_FK;

-- -------------------------------------------------------------------------------------
CREATE TEMP TABLE TEMP_CHECK AS 
SELECT ''Cheque''                                                         as ""Level""   
    ,pay.fiscaldate                                                     as ""Fiscal Date""
    ,loc.location_dim_nk::decimal(36,0)                                 as ""Location ID""  
    ,CASE WHEN PAYMENTTYPE IN (''CC'',''EPX'') 
       THEN ''Credit Card'' ELSE PAYMENTTYPE  END                                                             
                                                                        as ""Group 1B""
    ,CASE WHEN PAYMENTTYPE IN (''CC'',''EPX'') 
             THEN pay.cardbrand
        ELSE  ptd.paymentmethodname END                                 as ""Group 2B""    
    ,PAYMENTTYPE                                                        as ""Payment Type""    
    ,IFNULL(ptd.paymentmethodname ,''None'')                              as ""Payment Method""

    ,IFNULL(case pay.cardbrand when '''' 
             THEN ''Not a Credit Card'' 
            else pay.cardbrand end,''None'')  
                                                                        as ""Card Brand"" 
-------------------------------------------------------------------------------------
    ,ROW_NUMBER() OVER (PARTITION BY CHF.CHEQUE_FACT_NK 
        ORDER BY PAY.PAYMENTS_FACT_NK)                                  as ""Check Count""
    ,CHF.CHEQUE_FACT_NK                                                 as CHEQUE_FACT_NK
    ,PAY.PAYMENTS_FACT_NK                                               as PAYMENTS_FACT_NK
    ,SUM(IFNULL(CHF.TAX       ,0.00))::DECIMAL(36,2)                    as ""Taxes""
    ,SUM(IFNULL(CHF.SURCHARGE ,0.00))::DECIMAL(36,2)                    as ""Surcharges""
    ,SUM(IFNULL(CHF.UNPAID    ,0.00))::DECIMAL(36,2)                    as ""Unpaid""
    ,SUM(IFNULL(CHF.GRATUITIES,0.00))::DECIMAL(36,2)                    as ""Gratuities""    
    ,SUM(IFNULL(CHF.FEES      ,0.00))::DECIMAL(36,2)                    as ""Fees""    
    ,SUM(CASE WHEN  ptd.paymentmethodname ILIKE ''%Event Deposit%''
      THEN CASE WHEN pay.PAYMENTTYPE = ''Cash'' THEN pay.AMOUNTAPPLIEDTOCHECK 
                  ELSE pay.TOTAL END ELSE 0 END        
        - IFNULL(pay.Tip,0))                       ::DECIMAL(36,2)      as ""Deposits""
    ,SUM(IFNULL(GCF.""Gift Card Purchase Amount"",0.00)) ::DECIMAL(36,2)  as ""Gift Card Sales""
    ,SUM(IFNULL(CHF.TIP       ,0.00))::DECIMAL(36,2)                    as ""Tips2""           
    ,SUM(0.00)::DECIMAL(36,2)                                           as ""Pay In/Out""
    ,SUM(0.00)::DECIMAL(36,2)                                           as ""Deposit Applied""
    ,SUM(IFNULL(CHF.net,0) - IFNULL(CHF.tax,0) - IFNULL(CHF.SURCHARGE,0) - IFNULL(GCF.""Gift Card Purchase Amount"",0)
    -- - CASE WHEN  ptd.paymentmethodname ILIKE ''%Event Deposit%''
    --   THEN CASE WHEN pay.PAYMENTTYPE = ''Cash'' THEN pay.AMOUNTAPPLIEDTOCHECK 
    --               ELSE pay.TOTAL END ELSE 0 END 
    
    )::DECIMAL(36,2) 
                                                                        as ""Net Sales"" 
    -- ,SUM(tpr.""Applied Amount"")::DECIMAL(36,2)                        as ""Net Sates from Item""
-------------------------------------------------------------------------------------
    ,SUM(1::NUMBER(36,0))                                               as ""Count""
    ,SUM(IFNULL(pay.Tip,0))::DECIMAL(36,2)                              as ""Tips"" 
    ,(SUM( CASE WHEN pay.PAYMENTTYPE = ''Cash'' THEN pay.AMOUNTAPPLIEDTOCHECK 
                  ELSE pay.TOTAL END   )    
        - SUM(IFNULL(pay.Tip,0))
        
        - SUM(IFNULL(CASE WHEN  ptd.paymentmethodname ILIKE ''%Event Deposit%''
      THEN CASE WHEN pay.PAYMENTTYPE = ''Cash'' THEN pay.AMOUNTAPPLIEDTOCHECK 
                  ELSE pay.TOTAL END ELSE 0 END,0)
        
        ))::DECIMAL(18,2)          
                                                                       as ""Sales""       
 
    ,SUM(CASE WHEN ptd.paymentmethodname ilike ''%Event Deposit%'' 
             THEN CASE WHEN pay.PAYMENTTYPE = ''Cash'' 
                THEN pay.AMOUNTAPPLIEDTOCHECK::DECIMAL(18,2) 
             ELSE pay.TOTAL END  
           ELSE 0 END) ::DECIMAL(36,2)                                  as ""Deposit""     
    ,SUM(CASE WHEN pay.PAYMENTTYPE = ''Cash'' 
          THEN pay.AMOUNTAPPLIEDTOCHECK 
                  ELSE pay.TOTAL END )::DECIMAL(36,2)                   as ""Total""            
        FROM DATAWAREHOUSE.CHEQUE_FACT                                  chf
          INNER JOIN DATAWAREHOUSE.PAYMENTS_FACT                        pay
            ON pay.CHEQUE_FACT_FK = chf.CHEQUE_FACT_NK
              AND chf.DW_ISCURRENTROW
              AND pay.DW_ISCURRENTROW
              AND chf.FISCAL_DATE::date >= :startdate::date 
              AND chf.FISCAL_DATE::date <= :enddate::date  
              AND chf.LOCATION_DIM_FK in (
                SELECT table1.value 
                   FROM table(split_to_table(:locationidS, '',''))  table1) 
               AND NOT chf.IS_TRAINING
               AND NOT chf.DW_ISDELETED
               AND pay.PAYMENTSTATUS = ''Success''
               AND chf.STATUS = ''Closed''
          INNER JOIN DATAWAREHOUSE.location_DIM                          loc
            ON pay.location_DIM_FK = loc.location_DIM_NK
              AND loc.DW_ISCURRENTROW
          INNER JOIN DATAWAREHOUSE.PaymentMethod_DIM                     ptd      
            ON pay.PaymentMethod_DIM_FK = ptd.PaymentMethod_DIM_NK
              AND ptd.DW_ISCURRENTROW
              AND NOT ptd.DW_ISDELETED  
          LEFT JOIN TEMP_GCPURCHASE                                      gcf
            ON chf.CHEQUE_FACT_NK = gcf.CHEQUE_FACT_FK
    GROUP BY ""Level""   
    ,""Location ID"" 
    ,loc.LOCATION_DIM_NK
    ,CHF.CHEQUE_FACT_NK
    ,PAY.PAYMENTS_FACT_NK
    ,""Group 1B""
    ,""Group 2B""
    ,""Payment Method""
    ,""Payment Type""
    ,""Card Brand"" 
    ,""Fiscal Date""

UNION
 
 SELECT pio.""Level""              as ""Level""   
    ,pio.""Fiscal Date""           as ""Fiscal Date""
    ,pio.""Location ID""           as ""Location ID""  
    ,pio.""Group 1B""              as ""Group 1B""
    ,pio.""Group 2B""              as ""Group 2B""    
    ,pio.""Payment Type""          as ""Payment Type""    
    ,pio.""Payment Method""        as ""Payment Method""
    ,pio.""Card Brand""            as ""Card Brand"" 
-------------------------------------------------------------------------------------
    ,0                           as ""Check Count""
    ,NULL                        as CHEQUE_FACT_NK
    ,NULL                        as PAYMENTS_FACT_NK
    ,0                           as ""Taxes""
    ,0                           as ""Surcharges""
    ,0                           as ""Unpaid""
    ,0                           as ""Gratuities""    
    ,0                           as ""Fees""    
    ,0                           as ""Deposits""
    ,0                           as ""Gift Card Sales""
    ,0                           as ""Tips2""           
    ,pio.""Amount""                as ""Pay In/Out""
    ,0                           as ""Deposit Applied""
    ,0                           as ""Net Sales"" 
-------------------------------------------------------------------------------------
    ,1                           as ""Count""
    ,0                           as ""Tips"" 
    ,0                           as ""Sales""       
    ,0                           as ""Deposit""     
    ,pio.""Amount""                as ""Total""      
FROM TEMP_PAYINOUT               pio
;    

-------------------------------------------------------------------------------------------
-- UNPIVOT CHECK BALANCES TO CREATE ROWS FOR THE ''Total Payments'' Row
-- DROP TABLE TEMP_TABLE_PAYMENTS_1AA
CREATE TEMP TABLE TEMP_TABLE_PAYMENTS_1AA AS
 SELECT ''Total Payments''  as ""Group 1A""
  ,""Level""                as ""Group 2A""
  ,""Fiscal Date""          as ""Fiscal Date""
  ,""Location ID""          as ""Location ID""
  ,SUM(""Amount"")          as ""Total1"" 
    FROM TEMP_PAYINOUT
    GROUP BY ""Group 1A"",""Group 2A"",""Fiscal Date"",""Location ID""  
    ;
    
CREATE TEMP TABLE TEMP_TABLE_PAYMENTS_1AC AS
 SELECT ''Total Payments''  as ""Group 1A""
  ,''Refunds''              as ""Group 2A""
  ,""Fiscal Date""          as ""Fiscal Date""
  ,""Location ID""          as ""Location ID""
  ,SUM(""Count"")           as ""Count""
  ,SUM(""Refund Amount"")   as ""Total1"" 
    FROM TEMP_REFUNDS
    GROUP BY ""Group 1A"",""Group 2A"",""Fiscal Date"",""Location ID""      
;

CREATE TEMP TABLE TEMP_TABLE_PAYMENTS_1AB AS
SELECT ''Total Payments'' as ""Group 1A""
  ,""Group 2""            as ""Group 2A""
  ,""Fiscal Date""        as ""Fiscal Date""
  ,""Location ID""        as ""Location ID""
  ,SUM(""Total1"")        as ""Total1""
  FROM TEMP_CHECK
    UNPIVOT (""Total1"" FOR ""Group 2"" IN (""Taxes"",""Surcharges"",""Fees"",""Deposit Applied"",""Gift Card Sales"",""Tips2"",""Pay In/Out"",""Net Sales""/*,""Net Sates from Item""*/,""Gratuities""))
    WHERE ""Check Count"" = 1 --get only one row per check for check level details
  GROUP BY ""Group 1A"",""Group 2A"",""Fiscal Date"",""Location ID""   
  ;

-- select * from TEMP_TABLE_PAYMENTS_1A  whERE ""Group 1"" = ''Refunds'';
-- select ""Group 1"",""Group 2"" from TEMP_TABLE_PAYMENTS_1A group by ""Group 1"", ""Group 2"" order by ""Group 1"", ""Group 2""
--===========================================================================================
CREATE TEMP TABLE TEMP_TABLE_PAYMENTS_1A AS --don''t change to join since not all groups of brand and type will exist as pio and checks
SELECT ''Payments 1''                                                                             AS ""Display Table ID""
      ,INLT1.""Fiscal Date""                                                                      AS ""Fiscal Date""
      ,INLT1.""Group 1""                                                                          AS ""Group 1""                                                                                    
      ,INLT1.""Group 2""                                                                          AS ""Group 2"" 
      ,INLT1.""Location ID""                                                                      AS ""Location ID""
      ,IFNULL(SUM(INLT1.""Count"")     ,0)                                                        AS ""Count""
      ,IFNULL(SUM(INLT1.""Tips"")      ,0)                                                        AS ""Tips""  
      ,IFNULL(SUM(INLT1.""Sales"")     ,0)                                                        AS ""Sales""
      ,IFNULL(SUM(INLT1.""Pay In"")    ,0)                                                        AS ""Pay In""
      ,IFNULL(SUM(INLT1.""Deposit"")   ,0)                                                        AS ""Deposit""
      
      ,SUM(CASE WHEN INLT1.""Level"" = ''Summary''
        THEN INLT1.""Total1""
        ELSE
        IFNULL(INLT1.""Tips""         ,0)
        + IFNULL(INLT1.""Sales""      ,0) 
        + IFNULL(INLT1.""Pay In""     ,0) 
        + IFNULL(INLT1.""Deposit""    ,0)  
        END )
                                                                                                AS ""Total"" 
  FROM (
          SELECT CHK.""Level""       AS ""Level""
              ,CHK.""Group 1B""      AS ""Group 1""
              ,CHK.""Group 2B""      AS ""Group 2""  
              ,CHK.""Fiscal Date""   AS ""Fiscal Date"" 
              ,CHK.""Location ID""   AS ""Location ID""
              ,CHK.""Payment Type""  AS ""Payment Type""
              ,CHK.""Payment Method""AS ""Payment Method""
              ,CHK.""Card Brand""    AS ""Card Brand""
              ,CHK.""Count""         AS ""Count""
              ,CHK.""Tips""          AS ""Tips""  
              ,CHK.""Sales""         AS ""Sales""
              ,0                   AS ""Pay In""
              ,CHK.""Deposit""       AS ""Deposit""
              ,0                    AS ""Total1""
            FROM TEMP_CHECK        CHK
          UNION ALL
           SELECT PIO.""Level""       AS ""Level""
              ,""Group 1B""           AS ""Group 1""
              ,""Group 2B""           AS ""Group 2""  
              ,PIO.""Fiscal Date""    AS ""Fiscal Date"" 
              ,PIO.""Location ID""    AS ""Location ID""
              ,PIO.""Payment Type""   AS ""Payment Type""
              ,PIO.""Payment Method"" AS ""Payment Method""
              ,PIO.""Card Brand""     AS ""Card Brand""
              ,0                    AS ""Count"" 
              ,0                    AS ""Tips"" 
              ,0                    AS ""Sales""
              ,PIO.""Amount""         AS ""Pay In""
              ,0                    AS ""Deposit""
              ,0                    AS ""Total1""
            FROM TEMP_PAYINOUT      PIO
           UNION ALL
            SELECT REF.""Level""      AS ""Level""
              ,REF.""Group 1C""       AS ""Group 1""
              ,REF.""Group 2C""       AS ""Group 2""              
              ,REF.""Fiscal Date""    AS ""Fiscal Date"" 
              ,REF.""Location ID""    AS ""Location ID""
              ,REF.""Payment Type""   AS ""Payment Type""
              ,REF.""Payment Method"" AS ""Payment Method""
              ,NULL                 AS ""Card Brand""
              ,REF.""Count""          AS ""Count"" 
              ,0                    AS ""Tips"" 
              ,REF.""Refund Amount""  AS ""Sales""
              ,0                    AS ""Pay In""
              ,0                    AS ""Deposit""
              ,0                    AS ""Total1""
           FROM TEMP_REFUNDS       REF    
               UNION ALL
           SELECT ''Summary''         AS ""Level""
              ,SPY.""Group 1A""       AS ""Group 1""
              ,SPY.""Group 2A""       AS ""Group 2""
              ,SPY.""Fiscal Date""    AS ""Fiscal Date"" 
              ,SPY.""Location ID""    AS ""Location ID""
              ,NULL                 AS ""Payment Type""
              ,NULL                 AS ""Payment Method""
              ,NULL                 AS ""Card Brand""
              ,0                    AS ""Count"" 
              ,0                    AS ""Tips"" 
              ,0                    AS ""Sales""
              ,0                    AS ""Pay In""
              ,0                    AS ""Deposit""
              ,SPY.""Total1""         AS ""Total1""
            FROM TEMP_TABLE_PAYMENTS_1AA     SPY   
               UNION ALL   
           SELECT ''Summary''         AS ""Level""
              ,SPI.""Group 1A""       AS ""Group 1""
              ,SPI.""Group 2A""       AS ""Group 2""
              ,SPI.""Fiscal Date""    AS ""Fiscal Date"" 
              ,SPI.""Location ID""    AS ""Location ID""
              ,NULL                 AS ""Payment Type""
              ,NULL                 AS ""Payment Method""
              ,NULL                 AS ""Card Brand""
              ,0                    AS ""Count"" 
              ,0                    AS ""Tips"" 
              ,0                    AS ""Sales""
              ,0                    AS ""Pay In""
              ,0                    AS ""Deposit""
              ,SPI.""Total1""         AS ""Total1""
            FROM TEMP_TABLE_PAYMENTS_1AB    SPI  
               UNION ALL   
           SELECT ''Summary''         AS ""Level""
              ,SPR.""Group 1A""       AS ""Group 1""
              ,SPR.""Group 2A""       AS ""Group 2""
              ,SPR.""Fiscal Date""    AS ""Fiscal Date"" 
              ,SPR.""Location ID""    AS ""Location ID""
              ,NULL                 AS ""Payment Type""
              ,NULL                 AS ""Payment Method""
              ,NULL                 AS ""Card Brand""
              ,0                    AS ""Count"" 
              ,0                    AS ""Tips"" 
              ,0                    AS ""Sales""
              ,0                    AS ""Pay In""
              ,0                    AS ""Deposit""
              ,SPR.""Total1""         AS ""Total1""
            FROM TEMP_TABLE_PAYMENTS_1AC    SPR              
            
         ) INLT1
  GROUP BY INLT1.""Location ID""   
     ,""Fiscal Date""
      ,""Level""     
      ,""Group 1""
      ,""Group 2""
  ;
-- SELECT * FROM TEMP_TABLE_PAYMENTS_1AA WHERE ""Group 2A"" = ''PayInOut'';
--SELECT * FROM TEMP_TABLE_PAYMENTS_1A WHERE ""Group 2"" = ''PayInOut'';
--=========================================================================================== 
 reportSet:= (
 -- SELECT ''SS''  AS TESTCIK
 -- SELECT * FROM TEMP_CHECK
 -- SELECT * FROM TEMP_GIFTCARDS
 -- SELECT * FROM  TEMP_PAYINOUTS
 -- SELECT * FROM TEMP_TAXDETAILSFEE
 -- SELECT * FROM TEMP_TAXDETAILSTENDER
 -- SELECT * FROM TEMP_REFUNDS  
 -- SELECT * FROM TEMP_FEES    
 -- SELECT * FROM TEMP_TABLE_PAYMENTS_1A
 SELECT ROW_NUMBER() OVER (ORDER BY ""Location ID"")            AS  ""Support ID"" 
   ,* from TEMP_TABLE_PAYMENTS_1A
);

--===========================================================================================
RETURN TABLE(reportSet); 

END';"
PROCEDURE,DATAADMIN,"SP_REPORT_PMIX(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_PMIX""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2020-08-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2029-08-20T14:48:37.661Z''; 
  -- locationid string      := ''[351,2,3,4]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
BEGIN  

DROP TABLE IF EXISTS TEMP_TAXBASIS;
DROP TABLE IF EXISTS TEMP_FEE;

--get tax basis - can be multiple taxes per item - select the max tax basis for that item 
CREATE TEMP TABLE TEMP_TAXBASIS AS
SELECT tax.ITEM_FACT_FK
   ,MAX(CASE WHEN ABS(tax.AMOUNT - (itf.GROSS * (tax.PERCENT/100))) < 0.009
      THEN itf.GROSS 
      ELSE itf.APPLIEDAMOUNT END) ::NUMBER(18,2)          as ""Tax Basis Amount""
FROM DATAWAREHOUSE.TAX_FACT                               tax
     INNER JOIN DATAWAREHOUSE.ITEM_FACT                   itf
        ON itf.ITEM_FACT_NK = tax.ITEM_FACT_FK
          AND itf.TAX > 0.000
          AND itf.DW_ISCURRENTROW
    WHERE tax.ITEMSTATUS IN (''Added'',''Sent'')
          AND tax.CHECKSTATUS = ''Closed''
          AND tax.OPENED_AT is not null
          AND tax.DW_ISCURRENTROW  
          AND NOT tax.DW_ISDELETED
          AND NOT tax.IS_TRAINING
          AND tax.FISCAL_DATE::date
              >= :startdate::date 
          AND tax.FISCAL_DATE::date  
              <= :enddate::date 
          AND tax.LOCATION_DIM_FK IN ( 
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)
  GROUP BY tax.ITEM_FACT_FK
;

--=========================================================================================
--get FEES PER Item- can be multiple FEES per item so sum them up to the item total level
CREATE TEMP TABLE TEMP_FEE AS
SELECT itf.ITEM_FACT_NK                                   as ITEM_FACT_NK
   ,SUM(applied_allocated_item_surcharge) ::NUMBER(18,2)  as ""Fee Amount""
FROM DATAWAREHOUSE.SURCHARGECHEQUEBYITEM_FACT             fee
     INNER JOIN DATAWAREHOUSE.ITEM_FACT                   itf
        ON itf.ITEM_FACT_NK = fee.ITEM_FACT_FK
          AND itf.MTLN_CDC_SEQUENCE_NUMBER = fee.MTLN_CDC_SEQUENCE_NUMBER
          AND itf.DW_ISCURRENTROW
          AND fee.DW_ISCURRENTROW
          -- AND itf.ITEMSTATUS IN (''Added'',''Sent'')
          AND itf.CHECKSTATUS = ''Closed''  
          AND NOT itf.DW_ISDELETED
          AND NOT itf.IS_TRAINING
          AND NOT IS_GRATUITY
          AND itf.FISCAL_DATE::date
              >= :startdate::date 
          AND itf.FISCAL_DATE::date  
              <= :enddate::date 
          AND itf.LOCATION_DIM_FK IN ( 
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)
  GROUP BY itf.ITEM_FACT_nK
;

--=========================================================================================
 reportSet:= (
SELECT itf.ITEM_FACT_NK                                   as ""Support ID"" 
    , ''PMIX-'' ||row_number() over (order by itf.ITEM_FACT_NK) 
                                                          as ""Detail ID""
--status, category, level-------------------------------------------------------------------
    ,IFNULL(itf.CHECKSTATUS,''None'')                       as ""Check Status""
    ,IFNULL(itf.ITEMSTATUS,''None'')                        as ""Item Status""
    ,IFNULL(itf.STATUSREASON,''None'')                      as ""Status Reason""
    ,IFNULL(ccd.COGSCATEGORY,''None'')                      as ""Category""
    -- ,IFNULL(ccd.COGSCATEGORY,''None'')                   as ""COGS Category""
-- --geography
    ,IFNULL(loc.LOCATIONNAME,''None'')                      as ""Location""
    ,itf.LOCATION_DIM_FK::DECIMAL(36,0)                   as ""Location ID""
    ,IFNULL(itf.REVENUECENTERNAME,''None'')                 as ""Revenue Center""
-- --dates-------------------------------------------------------------------------------------
    ,LOC.TZ_NAME                                          as ""Time Zone""
    ,to_char(LEFT(chk.FISCAL_DATE,4))                     as ""Year""
    ,to_char(YEAR(chk.FISCAL_DATE)) || ''|'' || TO_CHAR(RIGHT(''0'' || MONTH(chk.FISCAL_DATE),2))                                       
                                                          as ""Year and Month""
    ,IFNULL(dad.DAYPART,''None'')                           as ""Daypart""
    ,to_char(chk.FISCAL_DATE)                             as ""Fiscal Date""
    ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,chk.OPENED_AT::timestamp_ntz )::timestamp )                                                                           
                                                          as ""Opened At""                                                           
    ,IFNULL(DAYNAME(chk.FISCAL_DATE),''None'')              as ""Day of Week""
    ,CASE WHEN DAYNAME(chk.FISCAL_DATE) IN (''Sat'',''Sun'')  
             THEN TRUE ELSE FALSE END                     as ""Is Weekend""
-- --flags--------------------------------------------------------------------------------------
    ,IFNULL(itf.HASMODIFIERS,FALSE)                       as ""Has Modifiers""
-- --people-------------------------------------------------------------------------------------
    ,IFNULL(emd.EMPLOYEE_NAME,''None'')                     as ""Employee""
-- --Descriptors-------------------------------------------------------------------------------- 
    ,IFNULL(itf.chequenumber ,''None'')                     as ""Check""
    ,IFNULL(itf.cheque_fact_fk::decimal(10,0)::string ,''None'')                   
                                                          as ""Check ID""    
    ,IFNULL(med.MENUITEMNAME,'' None'')                     as ""Menu Item""
    ,IFNULL(itf.NOTE,''None'')                              as ""Note""
    ,IFNULL(itf.DESCRIPTION,''None'')                       as ""Description""
    ,IFNULL(itf.COMBINEDNAME,''Regular'')                   as ""Variant""     
    ,itf.SPLITBY::NUMBER(18,0)                            as ""Split By""
-- --Facts-----------------------------------------------------------------------------------------
    ,itf.QUANTITY::NUMBER(10,0)                           as ""Count""
    ,itf.REPORTQUANTITY::NUMBER(18,2)                     as ""Report Quantity""   
    ,itf.APPLIEDAMOUNT::NUMBER(18,2)                      as ""Applied Amount""
    ,itf.BASEPRICE::NUMBER(18,2)                          as ""Base Price""
    ,itf.PRICE::NUMBER(18,2)                              as ""Price""
    ,itf.GROSS::NUMBER(18,2)                              as ""Gross"" 
    ,dis.""Item Discount Amount""::NUMBER(18,2)             as ""Item Discount Amount""
    ,(IFNULL(itf.GROSS,0) - IFNULL(dis.""Item Discount Amount"",0))::NUMBER(18,2)                      
                                                          as ""Net""  
    ,itf.INCLUSIVETAX::NUMBER(18,2)                       as ""Inclusive Tax""    
    ,fee.""Fee Amount""::NUMBER(18,2)                       as ""Fee Amount""
    ,itf.TAX::NUMBER(18,2)                                as ""Tax""
    ,ttb.""Tax Basis Amount""                               as ""Tax Basis Amount""
    ,itf.TOTAL::NUMBER(18,2)                              as ""Total"" 
--------------------------------------------------------------------------------------------   
FROM DATAWAREHOUSE.ITEM_FACT                                  itf
     INNER JOIN DATAWAREHOUSE.MENUITEMNAME_DIM                med
       ON med.MENUITEMNAME_DIM_NK = itf.MENUITEMNAME_DIM_FK
          AND itf.ITEMSTATUS IN (''Added'',''Sent'')
          AND itf.CHECKSTATUS = ''Closed''
          AND itf.DW_ISCURRENTROW  
          AND med.DW_ISCURRENTROW  
          AND NOT itf.DW_ISDELETED
          AND NOT itf.IS_TRAINING
          AND itf.LOCATION_DIM_FK IN (--351,352
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)
      INNER JOIN DATAWAREHOUSE.CHEQUE_FACT                     chk
        ON chk.CHEQUE_FACT_NK = itf.CHEQUE_FACT_FK
          AND chk.DW_ISCURRENTROW
          AND chk.STATUS = ''Closed''
          AND itf.ITEMSTATUS IN (''Added'',''Sent'')
          AND (chk.FISCAL_DATE::date >= :startdate::date 
                AND chk.FISCAL_DATE::date  <= :enddate::date)
      INNER JOIN DATAWAREHOUSE.LOCATION_DIM                     loc
        ON itf.LOCATION_DIM_FK = loc.LOCATION_DIM_NK
          AND loc.DW_ISCURRENTROW
      INNER JOIN DATAWAREHOUSE.EMPLOYEE_DIM                     emd
        ON itf.employee_dim_fk = emd.employee_dim_Nk
          AND emd.DW_ISCURRENTROW 
      INNER JOIN DATAWAREHOUSE.DAYPART_DIM                      dad
        ON itf.daypart_dim_fk = dad.daypart_dim_nk
          AND dad.DW_ISCURRENTROW = TRUE         
      INNER JOIN DATAWAREHOUSE.REPORTCATEGORY_DIM               meg
        ON med.REPORTCATEGORY_DIM_FK = meg.REPORTCATEGORY_DIM_NK
          AND meg.DW_ISCURRENTROW = TRUE
      INNER JOIN DATAWAREHOUSE.COGSCATEGORY_DIM                 ccd
        ON ccd.COGSCATEGORY_DIM_NK = meg.COGSCATEGORY_DIM_FK    
          AND ccd.DW_ISCURRENTROW
      LEFT JOIN (
          SELECT daf.ITEM_FACT_FK, SUM(daf.APPLIED_AMOUNT) AS ""Item Discount Amount""
              FROM DATAWAREHOUSE.DISCOUNTITEM_FACT daf
                WHERE daf.DW_ISCURRENTROW 
                  AND (daf.FISCAL_DATE::date >= :startdate::date 
                  AND daf.FISCAL_DATE::date  <= :enddate::date)
                  AND daf.LOCATION_DIM_FK IN (--351,352
                     SELECT table1.value 
                        FROM table(split_to_table(:locationidS, '',''))  table1)
                  AND NOT daf.IS_TRAINING
                GROUP BY daf.ITEM_FACT_FK
                                                          )dis 
            ON dis.ITEM_FACT_FK  = itf.ITEM_FACT_NK
      LEFT JOIN TEMP_TAXBASIS                              ttb
            ON  ttb.item_fact_fk = itf.ITEM_FACT_NK
      LEFT JOIN TEMP_FEE                                   fee
            ON fee.ITEM_FACT_NK  = itf.ITEM_FACT_NK
          
--==========================================================================================
);
RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,"SP_SEND_SOFT_FAILS_OVER_SLACK(VARCHAR, ARRAY)","CREATE OR REPLACE PROCEDURE ""SP_SEND_SOFT_FAILS_OVER_SLACK""(""CHANNEL"" VARCHAR, ""ERROR_TYPES"" ARRAY)
RETURNS VARCHAR
LANGUAGE PYTHON
RUNTIME_VERSION = '3.11'
PACKAGES = ('snowflake-snowpark-python')
HANDLER = 'send_alert'
EXTERNAL_ACCESS_INTEGRATIONS = (SLACK_EXTERNAL_ACCESS_INTEGRATION)
SECRETS = ('webhook_secret'=DATAADMIN.SLACK_WEBHOOK_PROD_DATAWAREHOUSE_ALERTS)
EXECUTE AS OWNER
AS '
import _snowflake
import json
import urllib.request
from snowflake.snowpark.functions import col, lit, array_contains, count, listagg, when, current_timestamp

def trim_message(message, max_len=800, front_len=200, back_len=300):
    message = message.replace(''`'', ""''"")
    if len(message) > max_len:
        return message[:front_len] + ""... (trimmed) ..."" + message[-back_len:]
    return message

def send_alert(session, channel, error_types):
    # 1. Query for unnotified errors using Snowpark DataFrames
    error_logs_df = session.table(''dataadmin.error_logs'')

    unnotified_errors_df = error_logs_df.filter(
        (col(''ERROR_NOTIFICATION_TS'').is_null()) &
        (array_contains(col(''ERROR_TYPE_ID'').cast(''variant''), lit(error_types)))
    )

    # Cache the result to avoid re-querying
    unnotified_errors_df.cache_result()

    error_count = unnotified_errors_df.count()
    if error_count == 0:
        return ''No new errors to report.''

    # This ID will be used to mark these errors as part of this notification batch.
    get_graph_run_id_query = """"""
    BEGIN
        -- Attempt to get the real ID
        RETURN SYSTEM$TASK_RUNTIME_INFO(''CURRENT_TASK_GRAPH_RUN_GROUP_ID'');
    EXCEPTION
        -- If any error occurs (like not being in a task), run this block instead
        WHEN OTHER THEN
            RETURN UUID_STRING();
    END;
    """"""
    notification_id = session.sql(get_graph_run_id_query).collect()[0][0]

    # Collect the IDs for the final UPDATE statement
    error_ids_to_update = [row[''ID''] for row in unnotified_errors_df.select(''ID'').collect()]

    # 2. Aggregate and format the error data in Python
    # Group by task name to structure the alert
    grouped_errors = unnotified_errors_df.group_by(''TASK_NAME'').agg(
        listagg(''SQL_ERROR_MESSAGE'', ''\\n'').alias(''MESSAGES''),
        count(''*'').alias(''ERROR_COUNT'')
    ).collect()

    # 3. Build the Slack Block Kit Payload in Python
    # This gives us much more control over formatting.
    blocks = [
        {
            ""type"": ""section"",
            ""text"": {
                ""type"": ""mrkdwn"",
                ""text"": f"":alert: *{error_count} new error(s) found in Snowflake!*""
            }
        },
        {""type"": ""divider""}
    ]

    for row in grouped_errors:
        task_name = row[''TASK_NAME''] or ''MANUAL_RUN''
        task_error_count = row[''ERROR_COUNT'']
        
        task_header_block = {
            ""type"": ""section"",
            ""text"": {
                ""type"": ""mrkdwn"",
                ""text"": f""*{task_name}:* {task_error_count} error(s)""
            }
        }
        blocks.append(task_header_block)

        messages = row[''MESSAGES''].split(''\\n'')
        
        # Show up to 5 errors to avoid huge messages
        for msg in messages[:5]:
            error_block = {
                ""type"": ""section"",
                ""text"": {
                    ""type"": ""mrkdwn"",
                    ""text"": f""   `{trim_message(msg)}`""
                }
            }
            blocks.append(error_block)

        if len(messages) > 5:
            more_errors_block = {
                 ""type"": ""context"",
                ""elements"": [
                    {
                        ""type"": ""mrkdwn"",
                        ""text"": f""...and {len(messages) - 5} more.""
                    }
                ]
            }
            blocks.append(more_errors_block)

        blocks.append({""type"": ""divider""})


    slack_payload = {""blocks"": blocks}

    # 4. Send the message to Slack
    webhook_secret = _snowflake.get_generic_secret_string(''webhook_secret'')
    webhook_url = f""https://hooks.slack.com/services/{webhook_secret}""
    payload_json = json.dumps(slack_payload).encode(''utf-8'')
    
    req = urllib.request.Request(
        webhook_url,
        data=payload_json,
        headers={''Content-Type'': ''application/json''}
    )
    
    try:
        with urllib.request.urlopen(req) as response:
            if response.status != 200:
                return f""Failed to send message. Status: {response.status}, Body: {response.read().decode()}""
    except Exception as e:
        return f""Error sending Slack message: {e}""

     # 5. Update the log table to mark errors as notified
    session.table(''dataadmin.error_logs'').update(
        {
            ""ERROR_NOTIFICATION_TS"": current_timestamp(),
            ""ERROR_NOTIFICATION_ID"": lit(notification_id)
        },
        col(''ID'').in_(error_ids_to_update)
    )

    return f""Alert sent for {error_count} error(s).""
';"
PROCEDURE,DATAADMIN,SP_STAGELOADCLOSEOUTSUMMARY_FACT(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADCLOSEOUTSUMMARY_FACT""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.CLOSEOUTSUMMARY_FACT),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.CLOSEOUTSUMMARY_FACT(   
          CLOSEOUTSUMMARY_FACT_NK, 
          NAME, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          LOCATION_DIM_FK, 
          CREATED_AT, 
          UPDATED_AT, 
          FISCAL_DATE, 
          TAX, 
          TIPS, 
          VOIDS, 
          DISCOUNTS, 
          FEES, 
          GRATUITIES, 
          GROSS_RECEIPTS, 
          GROSS_SALES 
) 
 SELECT   CLOSEOUTSUMMARY_FACT_NK  as   CLOSEOUTSUMMARY_FACT_NK,  
   NAME  as   NAME,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   LOCATION_DIM_FK  as   LOCATION_DIM_FK,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   FISCAL_DATE  as   FISCAL_DATE,  
   TAX  as   TAX,  
   TIPS  as   TIPS,  
   VOIDS  as   VOIDS,  
   DISCOUNTS  as   DISCOUNTS,  
   FEES  as   FEES,  
   GRATUITIES  as   GRATUITIES,  
   GROSS_RECEIPTS  as   GROSS_RECEIPTS,  
   GROSS_SALES  as   GROSS_SALES 
  FROM DATAADMIN.CLOSEOUTSUMMARY_FACT
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''CLOSEOUTSUMMARY_FACT'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''CLOSEOUTSUMMARY_FACT'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADDISCOUNTCHECK_FACT(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADDISCOUNTCHECK_FACT""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.DISCOUNTCHECK_FACT),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.DISCOUNTCHECK_FACT(   
          DISCOUNTCHECK_FACT_NK, 
          DISCOUNTNAME, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          CHEQUE_FACT_FK, 
          DAYPART_DIM_FK, 
          EMPLOYEE_DIM_FK_AS_ADDED_BY, 
          EMPLOYEE_DIM_FK_AS_APPROVED_BY, 
          EMPLOYEE_DIM_FK, 
          LOCATION_DIM_FK, 
          STANDARDDISCOUNT_DIM_FK, 
          DO_AUTOAPPLY, 
          IS_TRAINING, 
          ADDED_AT, 
          CREATED_AT, 
          FISCAL_DATE, 
          OPENED_AT, 
          UPDATED_AT, 
          APPLICATION, 
          STATUS, 
          CHEQUESTATUS, 
          DISCOUNTREASON, 
          DISCOUNTLEVEL, 
          RECEIPTNAME, 
          PROMOCODE, 
          PROMODESCRIPTION, 
          REVENUECENTERNAME, 
          ROUNDINGMETHOD, 
          CHEQUENUMBER, 
          ITEM_ID, 
          PROMOCODE_ID, 
          DISCOUNT_TYPE, 
          DISCOUNT_PERCENT, 
          APPLIED_AMOUNT, 
          DISCOUNT_AMOUNT, 
          VALUE, 
          DISCOUNT, 
          DISCOUNTCHECK, 
          DISCOUNTITEM, 
          GROSS, 
          NET 
) 
 SELECT   DISCOUNTCHECK_FACT_NK  as   DISCOUNTCHECK_FACT_NK,  
   DISCOUNTNAME  as   DISCOUNTNAME,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   CHEQUE_FACT_FK  as   CHEQUE_FACT_FK,  
   DAYPART_DIM_FK  as   DAYPART_DIM_FK,  
   EMPLOYEE_DIM_FK_AS_ADDED_BY  as   EMPLOYEE_DIM_FK_AS_ADDED_BY,  
   EMPLOYEE_DIM_FK_AS_APPROVED_BY  as   EMPLOYEE_DIM_FK_AS_APPROVED_BY,  
   EMPLOYEE_DIM_FK  as   EMPLOYEE_DIM_FK,  
   LOCATION_DIM_FK  as   LOCATION_DIM_FK,  
   STANDARDDISCOUNT_DIM_FK  as   STANDARDDISCOUNT_DIM_FK,  
   DO_AUTOAPPLY  as   DO_AUTOAPPLY,  
   IS_TRAINING  as   IS_TRAINING,  
   ADDED_AT  as   ADDED_AT,  
   CREATED_AT  as   CREATED_AT,  
   FISCAL_DATE  as   FISCAL_DATE,  
   OPENED_AT  as   OPENED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   APPLICATION  as   APPLICATION,  
   STATUS  as   STATUS,  
   CHEQUESTATUS  as   CHEQUESTATUS,  
   DISCOUNTREASON  as   DISCOUNTREASON,  
   DISCOUNTLEVEL  as   DISCOUNTLEVEL,  
   RECEIPTNAME  as   RECEIPTNAME,  
   PROMOCODE  as   PROMOCODE,  
   PROMODESCRIPTION  as   PROMODESCRIPTION,  
   REVENUECENTERNAME  as   REVENUECENTERNAME,  
   ROUNDINGMETHOD  as   ROUNDINGMETHOD,  
   CHEQUENUMBER  as   CHEQUENUMBER,  
   ITEM_ID  as   ITEM_ID,  
   PROMOCODE_ID  as   PROMOCODE_ID,  
   DISCOUNT_TYPE  as   DISCOUNT_TYPE,  
   DISCOUNT_PERCENT  as   DISCOUNT_PERCENT,  
   APPLIED_AMOUNT  as   APPLIED_AMOUNT,  
   DISCOUNT_AMOUNT  as   DISCOUNT_AMOUNT,  
   VALUE  as   VALUE,  
   DISCOUNT  as   DISCOUNT,  
   DISCOUNTCHECK  as   DISCOUNTCHECK,  
   DISCOUNTITEM  as   DISCOUNTITEM,  
   GROSS  as   GROSS,  
   NET  as   NET 
  FROM DATAADMIN.DISCOUNTCHECK_FACT
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''DISCOUNTCHECK_FACT'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''DISCOUNTCHECK_FACT'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADLOCATION_LOCATIONGROUP_XREF(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADLOCATION_LOCATIONGROUP_XREF""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.LOCATION_LOCATIONGROUP_XREF),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.LOCATION_LOCATIONGROUP_XREF(   
          LOCATION_LOCATIONGROUP_XREF_NK, 
          LOCATION_LOCATION_GROUP, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          LOCATIONGROUP_DIM_FK, 
          LOCATION_DIM_FK, 
          CREATED_AT, 
          UPDATED_AT 
) 
 SELECT   LOCATION_LOCATIONGROUP_XREF_NK  as   LOCATION_LOCATIONGROUP_XREF_NK,  
   LOCATION_LOCATION_GROUP  as   LOCATION_LOCATION_GROUP,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   LOCATIONGROUP_DIM_FK  as   LOCATIONGROUP_DIM_FK,  
   LOCATION_DIM_FK  as   LOCATION_DIM_FK,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT 
  FROM DATAADMIN.LOCATION_LOCATIONGROUP_XREF
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''LOCATION_LOCATIONGROUP_XREF'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''LOCATION_LOCATIONGROUP_XREF'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADMODIFIER_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADMODIFIER_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.MODIFIER_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.MODIFIER_DIM(   
          MODIFIER_DIM_NK, 
          MODIFIER, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          MODIFIERGROUP_DIM_FK, 
          INGREDIENT_DIM_FK, 
          CREATED_AT, 
          UPDATED_AT 
) 
 SELECT   MODIFIER_DIM_NK  as   MODIFIER_DIM_NK,  
   MODIFIER  as   MODIFIER,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   MODIFIERGROUP_DIM_FK  as   MODIFIERGROUP_DIM_FK,  
   INGREDIENT_DIM_FK  as   INGREDIENT_DIM_FK,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT 
  FROM DATAADMIN.MODIFIER_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''MODIFIER_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''MODIFIER_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADPAYMENTS_FACT(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADPAYMENTS_FACT""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.PAYMENTS_FACT),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.PAYMENTS_FACT(   
          PAYMENTS_FACT_NK, 
          PAYMENTNUMBER, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          CHEQUE_FACT_FK, 
          DAYPART_DIM_FK, 
          EMPLOYEE_DIM_FK_AS_CREATOR, 
          EMPLOYEE_DIM_FK_AS_PAYEE, 
          LOCATION_DIM_FK, 
          ORDERTYPE_DIM_FK, 
          PAYMENTMETHOD_DIM_FK, 
          REVENUECENTER_DIM_FK, 
          TRANSACTION_FACT_FK, 
          TERMINAL_DIM_FK, 
          SHOULD_VERIFYID, 
          IS_PARTIALAPPROVAL, 
          IS_TRAINING, 
          CREATED_AT, 
          UPDATED_AT, 
          OPENED_AT, 
          PAID_AT, 
          FISCALDATE, 
          SEQ, 
          BATCHNUMBER, 
          CARDBRAND, 
          CARDHOLDERNAME, 
          CHEQUENUMBER, 
          CURRENCY_ID, 
          FLOORPLAN_ID, 
          LASTFOURCCNUMBER, 
          NEXTFOURCCNUMBER, 
          PAYMENTTYPE, 
          PAYMENTSTATUS, 
          REVENUECENTERNAME, 
          TABLENAME, 
          PARTYSIZE, 
          TIP, 
          AMOUNTAPPLIEDTOCHECK, 
          CHANGE, 
          TOTAL 
) 
 SELECT   PAYMENTS_FACT_NK  as   PAYMENTS_FACT_NK,  
   PAYMENTNUMBER  as   PAYMENTNUMBER,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   CHEQUE_FACT_FK  as   CHEQUE_FACT_FK,  
   DAYPART_DIM_FK  as   DAYPART_DIM_FK,  
   EMPLOYEE_DIM_FK_AS_CREATOR  as   EMPLOYEE_DIM_FK_AS_CREATOR,  
   EMPLOYEE_DIM_FK_AS_PAYEE  as   EMPLOYEE_DIM_FK_AS_PAYEE,  
   LOCATION_DIM_FK  as   LOCATION_DIM_FK,  
   ORDERTYPE_DIM_FK  as   ORDERTYPE_DIM_FK,  
   PAYMENTMETHOD_DIM_FK  as   PAYMENTMETHOD_DIM_FK,  
   REVENUECENTER_DIM_FK  as   REVENUECENTER_DIM_FK,  
   TRANSACTION_FACT_FK  as   TRANSACTION_FACT_FK,  
   TERMINAL_DIM_FK  as   TERMINAL_DIM_FK,  
   SHOULD_VERIFYID  as   SHOULD_VERIFYID,  
   IS_PARTIALAPPROVAL  as   IS_PARTIALAPPROVAL,  
   IS_TRAINING  as   IS_TRAINING,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   OPENED_AT  as   OPENED_AT,  
   PAID_AT  as   PAID_AT,  
   FISCALDATE  as   FISCALDATE,  
   SEQ  as   SEQ,  
   BATCHNUMBER  as   BATCHNUMBER,  
   CARDBRAND  as   CARDBRAND,  
   CARDHOLDERNAME  as   CARDHOLDERNAME,  
   CHEQUENUMBER  as   CHEQUENUMBER,  
   CURRENCY_ID  as   CURRENCY_ID,  
   FLOORPLAN_ID  as   FLOORPLAN_ID,  
   LASTFOURCCNUMBER  as   LASTFOURCCNUMBER,  
   NEXTFOURCCNUMBER  as   NEXTFOURCCNUMBER,  
   PAYMENTTYPE  as   PAYMENTTYPE,  
   PAYMENTSTATUS  as   PAYMENTSTATUS,  
   REVENUECENTERNAME  as   REVENUECENTERNAME,  
   TABLENAME  as   TABLENAME,  
   PARTYSIZE  as   PARTYSIZE,  
   TIP  as   TIP,  
   AMOUNTAPPLIEDTOCHECK  as   AMOUNTAPPLIEDTOCHECK,  
   CHANGE  as   CHANGE,  
   TOTAL  as   TOTAL 
  FROM DATAADMIN.PAYMENTS_FACT
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''PAYMENTS_FACT'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''PAYMENTS_FACT'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADREFUNDSCHEQUEBYITEM_FACT(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADREFUNDSCHEQUEBYITEM_FACT""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.REFUNDSCHEQUEBYITEM_FACT),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.REFUNDSCHEQUEBYITEM_FACT(   
          REFUNDSCHEQUEBYITEM_FACT_NK, 
          PAYMENTNUMBER, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          CCTRANSACTION_FACT_FK, 
          CHEQUE_FACT_FK, 
          DAYPART_DIM_FK, 
          EMPLOYEE_DIM_FK_AS_CREATOR, 
          EMPLOYEE_DIM_FK_AS_PAYEE, 
          LOCATION_DIM_FK, 
          PAYMENTMETHOD_DIM_FK, 
          REVENUECENTER_DIM_FK, 
          TRANSACTION_FACT_FK, 
          TERMINAL_DIM_FK, 
          ITEM_FACT_FK, 
          REFUNDS_FACT_FK, 
          MENUITEM_DIM_FK, 
          MENUITEMNAME_DIM_FK, 
          IS_TRAINING, 
          OPENED_AT, 
          PAID_AT, 
          REFUNDED_AT, 
          FISCALDATE, 
          BATCHNUMBER, 
          REFUNDED_BY, 
          CARDBRAND, 
          CARDHOLDERNAME, 
          CHEQUENUMBER, 
          CURRENCY_ID, 
          FLOORPLAN_ID, 
          LASTFOURCCNUMBER, 
          NEXTFOURCCNUMBER, 
          PAYMENTTYPE, 
          PAYMENTSTATUS, 
          REVENUECENTERNAME, 
          TABLENAME, 
          ITEM_ID, 
          ITEMSTATUS, 
          CHECK_TOTAL_AMOUNT, 
          REFUND_AMOUNT, 
          ITEM_QUANTITY, 
          TOTAL_ITEMS_ON_CHECK, 
          ITEM_ROW_NUMBER, 
          SINGLE_ITEM_BASE_ALLOCATION, 
          CHECK_REMAINDER, 
          ALLOCATED_ITEM_REFUND 
) 
 SELECT   REFUNDSCHEQUEBYITEM_FACT_NK  as   REFUNDSCHEQUEBYITEM_FACT_NK,  
   PAYMENTNUMBER  as   PAYMENTNUMBER,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   CCTRANSACTION_FACT_FK  as   CCTRANSACTION_FACT_FK,  
   CHEQUE_FACT_FK  as   CHEQUE_FACT_FK,  
   DAYPART_DIM_FK  as   DAYPART_DIM_FK,  
   EMPLOYEE_DIM_FK_AS_CREATOR  as   EMPLOYEE_DIM_FK_AS_CREATOR,  
   EMPLOYEE_DIM_FK_AS_PAYEE  as   EMPLOYEE_DIM_FK_AS_PAYEE,  
   LOCATION_DIM_FK  as   LOCATION_DIM_FK,  
   PAYMENTMETHOD_DIM_FK  as   PAYMENTMETHOD_DIM_FK,  
   REVENUECENTER_DIM_FK  as   REVENUECENTER_DIM_FK,  
   TRANSACTION_FACT_FK  as   TRANSACTION_FACT_FK,  
   TERMINAL_DIM_FK  as   TERMINAL_DIM_FK,  
   ITEM_FACT_FK  as   ITEM_FACT_FK,  
   REFUNDS_FACT_FK  as   REFUNDS_FACT_FK,  
   MENUITEM_DIM_FK  as   MENUITEM_DIM_FK,  
   MENUITEMNAME_DIM_FK  as   MENUITEMNAME_DIM_FK,  
   IS_TRAINING  as   IS_TRAINING,  
   OPENED_AT  as   OPENED_AT,  
   PAID_AT  as   PAID_AT,  
   REFUNDED_AT  as   REFUNDED_AT,  
   FISCALDATE  as   FISCALDATE,  
   BATCHNUMBER  as   BATCHNUMBER,  
   REFUNDED_BY  as   REFUNDED_BY,  
   CARDBRAND  as   CARDBRAND,  
   CARDHOLDERNAME  as   CARDHOLDERNAME,  
   CHEQUENUMBER  as   CHEQUENUMBER,  
   CURRENCY_ID  as   CURRENCY_ID,  
   FLOORPLAN_ID  as   FLOORPLAN_ID,  
   LASTFOURCCNUMBER  as   LASTFOURCCNUMBER,  
   NEXTFOURCCNUMBER  as   NEXTFOURCCNUMBER,  
   PAYMENTTYPE  as   PAYMENTTYPE,  
   PAYMENTSTATUS  as   PAYMENTSTATUS,  
   REVENUECENTERNAME  as   REVENUECENTERNAME,  
   TABLENAME  as   TABLENAME,  
   ITEM_ID  as   ITEM_ID,  
   ITEMSTATUS  as   ITEMSTATUS,  
   CHECK_TOTAL_AMOUNT  as   CHECK_TOTAL_AMOUNT,  
   REFUND_AMOUNT  as   REFUND_AMOUNT,  
   ITEM_QUANTITY  as   ITEM_QUANTITY,  
   TOTAL_ITEMS_ON_CHECK  as   TOTAL_ITEMS_ON_CHECK,  
   ITEM_ROW_NUMBER  as   ITEM_ROW_NUMBER,  
   SINGLE_ITEM_BASE_ALLOCATION  as   SINGLE_ITEM_BASE_ALLOCATION,  
   CHECK_REMAINDER  as   CHECK_REMAINDER,  
   ALLOCATED_ITEM_REFUND  as   ALLOCATED_ITEM_REFUND 
  FROM DATAADMIN.REFUNDSCHEQUEBYITEM_FACT
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''REFUNDSCHEQUEBYITEM_FACT'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''REFUNDSCHEQUEBYITEM_FACT'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADSURCHARGECHEQUEBYITEM_FACT(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADSURCHARGECHEQUEBYITEM_FACT""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.SURCHARGECHEQUEBYITEM_FACT),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.SURCHARGECHEQUEBYITEM_FACT(   
          SURCHARGECHEQUEBYITEM_FACT_NK, 
          SURCHARGENAME, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          CHEQUE_FACT_FK, 
          DAYPART_DIM_FK, 
          EMPLOYEE_DIM_FK, 
          LOCATION_DIM_FK, 
          SURCHARGE_DIM_NK, 
          ITEM_FACT_FK, 
          IS_AUTOAPPLIED, 
          IS_GRATUITY, 
          IS_TAXABLE, 
          IS_TRAINING, 
          IS_PRINTONRECEIPT, 
          CREATED_AT, 
          FISCAL_DATE, 
          OPENED_AT, 
          UPDATED_AT, 
          STATUS, 
          CHEQUENUMBER, 
          SURCHARGE_TYPE, 
          ITEM_ID, 
          MENUITEM_DIM_FK, 
          MENUITEMNAME_DIM_FK, 
          SURCHARGE_QUANTITY, 
          SURCHARGE_AMOUNT, 
          SURCHARGE_APPLIEDAMOUNT, 
          ITEM_QUANTITY, 
          TOTAL_ITEMS_ON_CHECK, 
          ITEM_ROW_NUMBER, 
          AMOUNT_SINGLE_ITEM_BASE_ALLOCATION, 
          AMOUNT_CHECK_REMAINDER, 
          AMOUNT_ALLOCATED_ITEM_SURCHARGE, 
          APPLIED_SINGLE_ITEM_BASE_ALLOCATION, 
          APPLIED_CHECK_REMAINDER, 
          APPLIED_ALLOCATED_ITEM_SURCHARGE 
) 
 SELECT   SURCHARGECHEQUEBYITEM_FACT_NK  as   SURCHARGECHEQUEBYITEM_FACT_NK,  
   SURCHARGENAME  as   SURCHARGENAME,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   CHEQUE_FACT_FK  as   CHEQUE_FACT_FK,  
   DAYPART_DIM_FK  as   DAYPART_DIM_FK,  
   EMPLOYEE_DIM_FK  as   EMPLOYEE_DIM_FK,  
   LOCATION_DIM_FK  as   LOCATION_DIM_FK,  
   SURCHARGE_DIM_NK  as   SURCHARGE_DIM_NK,  
   ITEM_FACT_FK  as   ITEM_FACT_FK,  
   IS_AUTOAPPLIED  as   IS_AUTOAPPLIED,  
   IS_GRATUITY  as   IS_GRATUITY,  
   IS_TAXABLE  as   IS_TAXABLE,  
   IS_TRAINING  as   IS_TRAINING,  
   IS_PRINTONRECEIPT  as   IS_PRINTONRECEIPT,  
   CREATED_AT  as   CREATED_AT,  
   FISCAL_DATE  as   FISCAL_DATE,  
   OPENED_AT  as   OPENED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   STATUS  as   STATUS,  
   CHEQUENUMBER  as   CHEQUENUMBER,  
   SURCHARGE_TYPE  as   SURCHARGE_TYPE,  
   ITEM_ID  as   ITEM_ID,  
   MENUITEM_DIM_FK  as   MENUITEM_DIM_FK,  
   MENUITEMNAME_DIM_FK  as   MENUITEMNAME_DIM_FK,  
   SURCHARGE_QUANTITY  as   SURCHARGE_QUANTITY,  
   SURCHARGE_AMOUNT  as   SURCHARGE_AMOUNT,  
   SURCHARGE_APPLIEDAMOUNT  as   SURCHARGE_APPLIEDAMOUNT,  
   ITEM_QUANTITY  as   ITEM_QUANTITY,  
   TOTAL_ITEMS_ON_CHECK  as   TOTAL_ITEMS_ON_CHECK,  
   ITEM_ROW_NUMBER  as   ITEM_ROW_NUMBER,  
   AMOUNT_SINGLE_ITEM_BASE_ALLOCATION  as   AMOUNT_SINGLE_ITEM_BASE_ALLOCATION,  
   AMOUNT_CHECK_REMAINDER  as   AMOUNT_CHECK_REMAINDER,  
   AMOUNT_ALLOCATED_ITEM_SURCHARGE  as   AMOUNT_ALLOCATED_ITEM_SURCHARGE,  
   APPLIED_SINGLE_ITEM_BASE_ALLOCATION  as   APPLIED_SINGLE_ITEM_BASE_ALLOCATION,  
   APPLIED_CHECK_REMAINDER  as   APPLIED_CHECK_REMAINDER,  
   APPLIED_ALLOCATED_ITEM_SURCHARGE  as   APPLIED_ALLOCATED_ITEM_SURCHARGE 
  FROM DATAADMIN.SURCHARGECHEQUEBYITEM_FACT
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''SURCHARGECHEQUEBYITEM_FACT'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''SURCHARGECHEQUEBYITEM_FACT'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,CALC_PHASH(VARCHAR),"CREATE OR REPLACE PROCEDURE ""CALC_PHASH""(""FILE_PATH"" VARCHAR(16777216))
RETURNS VARCHAR(16777216)
LANGUAGE PYTHON
RUNTIME_VERSION = '3.8'
PACKAGES = ('snowflake-snowpark-python','imagehash','pillow')
HANDLER = 'run'
EXECUTE AS OWNER
AS '
from PIL import Image
import imagehash
from snowflake.snowpark.files import SnowflakeFile

def run(ignored_session, file_path):
    with SnowflakeFile.open(file_path, ''rb'') as f:
        return imagehash.average_hash(Image.open(f))
';"
PROCEDURE,DATAADMIN,"GET_TOP_10_DUPLICATE_ROWS(VARCHAR, VARCHAR, ARRAY, BOOLEAN)","CREATE OR REPLACE PROCEDURE ""GET_TOP_10_DUPLICATE_ROWS""(""DB_NAME"" VARCHAR, ""SCHEMA_NAME"" VARCHAR, ""TARGET_TABLES"" ARRAY, ""EVALUATE_PK"" BOOLEAN)
RETURNS TABLE (""DATABASE_NAME"" VARCHAR, ""SCHEMA_NAME"" VARCHAR, ""TABLE_NAME"" VARCHAR, ""MTLN_CDC_LOAD_TIMESTAMP"" TIMESTAMP_LTZ(9), ""ROW_DATA"" VARIANT)
LANGUAGE SQL
EXECUTE AS OWNER
AS '
DECLARE
    --  Changed to a temporary table to hold both tables and views
    object_list CURSOR FOR SELECT ""name"" FROM temp_object_list;
    table_name VARCHAR;
    column_list VARCHAR;
    dynamic_sql VARCHAR;
    info_schema_path VARCHAR;
    schema_identifier VARCHAR;
    evaluate_pk_effective BOOLEAN;
    final_results RESULTSET;

BEGIN
    -- Create a temporary table to hold results from SHOW commands
    CREATE OR REPLACE TEMPORARY TABLE temp_object_list (""name"" VARCHAR);
    
    CREATE OR REPLACE TEMPORARY TABLE temp_duplicate_results (
        DATABASE_NAME VARCHAR,
        SCHEMA_NAME VARCHAR,
        TABLE_NAME VARCHAR,
        MTLN_CDC_LOAD_TIMESTAMP TIMESTAMP_LTZ,
        ROW_DATA VARIANT
    );

    evaluate_pk_effective := COALESCE(:EVALUATE_PK, TRUE);
    schema_identifier := :DB_NAME || ''.'' || :SCHEMA_NAME;

    --  Step 1: Get all tables and insert into the temp list
    SHOW TABLES IN SCHEMA IDENTIFIER(:schema_identifier);
    INSERT INTO temp_object_list (""name"")
    SELECT ""name"" FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

    --  Step 2: Get all views and insert into the temp list
    SHOW VIEWS IN SCHEMA IDENTIFIER(:schema_identifier);
    INSERT INTO temp_object_list (""name"")
    SELECT ""name"" FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));


    --  Step 3: Loop through the combined list of objects
    FOR rec IN object_list DO
        table_name := rec.""name"";

        IF (TARGET_TABLES IS NULL OR ARRAY_SIZE(TARGET_TABLES) = 0 OR ARRAY_CONTAINS(:table_name::VARIANT, TARGET_TABLES)) THEN

            info_schema_path := :DB_NAME || ''.INFORMATION_SCHEMA.COLUMNS'';

            SELECT
                LISTAGG(IFF(REGEXP_LIKE(column_name, ''^[a-zA-Z0-9_]+$''), column_name, ''""'' || column_name || ''""''), '', '')
            INTO column_list
            FROM IDENTIFIER(:info_schema_path)
            WHERE
                table_schema = :SCHEMA_NAME
                AND table_name = :table_name
                AND (:evaluate_pk_effective = TRUE OR NOT ENDSWITH(UPPER(column_name), ''_PK''));

            IF (column_list IS NOT NULL AND column_list != '''') THEN
                dynamic_sql := ''
                    INSERT INTO temp_duplicate_results (DATABASE_NAME, SCHEMA_NAME, TABLE_NAME, MTLN_CDC_LOAD_TIMESTAMP, ROW_DATA)
                    SELECT
                        '''''' || DB_NAME || '''''',
                        '''''' || SCHEMA_NAME || '''''',
                        '''''' || table_name || '''''',
                        MTLN_CDC_LOAD_TIMESTAMP,
                        OBJECT_CONSTRUCT(*)
                    FROM (
                        SELECT *, COUNT(*) OVER (PARTITION BY '' || column_list || '') as dup_count
                        FROM '' || DB_NAME || ''.'' || SCHEMA_NAME || ''.""'' || table_name || ''""
                    )
                    WHERE dup_count > 1;
                '';

                EXECUTE IMMEDIATE dynamic_sql;
            END IF;
        END IF;
    END FOR;

    final_results := (
        SELECT DATABASE_NAME, SCHEMA_NAME, TABLE_NAME, MTLN_CDC_LOAD_TIMESTAMP, ROW_DATA
        FROM temp_duplicate_results
        ORDER BY MTLN_CDC_LOAD_TIMESTAMP DESC
        
    );

    RETURN TABLE(final_results);

END;
';"
PROCEDURE,DATAADMIN,OUTPUT_MESSAGE(VARCHAR),"CREATE OR REPLACE PROCEDURE ""OUTPUT_MESSAGE""(""MESSAGE"" VARCHAR(16777216))
RETURNS VARCHAR(16777216)
LANGUAGE SQL
EXECUTE AS OWNER
AS 'BEGIN
  RETURN message;
END';"
PROCEDURE,DATAADMIN,SP_DAG_SFTPJOBS(),"CREATE OR REPLACE PROCEDURE ""SP_DAG_SFTPJOBS""()
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS OWNER
AS '
DECLARE
     -- Runtime metadata
    run_metadata VARIANT;
    parent_query_id VARCHAR;
    task_run_group_id VARCHAR;
    attempt_number NUMBER;
    session_id VARCHAR;
    task_name VARCHAR;
    --actual variables for pipeline
    dateName VARCHAR;
    yesterday_dates VARIANT;

    loc_id VARCHAR;
    avero_loc_id VARCHAR;
BEGIN
    CALL dataadmin.sp_get_dag_run_metadata(COALESCE(last_query_id(), ''NOT_FOUND'')) INTO :run_metadata;
    parent_query_id := :run_metadata:parent_query_id::VARCHAR;
    task_run_group_id := :run_metadata:graph_run_group_id::VARCHAR;
    attempt_number := :run_metadata:run_attempt_number::NUMBER;
    session_id := :run_metadata:session_id::VARCHAR;
    task_name := :run_metadata:task_name::VARCHAR;

    --TODO add query tags in future sprints

    CALL SP_GET_YESTERDAY_DATES() INTO :yesterday_dates;
    dateName := :yesterday_dates:dateName;

    CALL SP_LOAD_AVERO_GETLOCATIONS();
    LET locations_cursor CURSOR FOR SELECT locationId, averoLocationId FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

    -- Loop through the cursor, row by row.
    FOR location_row IN locations_cursor DO
        -- Access the columns from the cursor using the row variable
        loc_id := location_row.locationId::VARCHAR ;
        avero_loc_id := location_row.averoLocationId::VARCHAR ;

        BEGIN
            -- execute worker procedures as soft fails.
            CALL dataadmin.SP_LOAD_AVERO_EXTRACTALLFILES(:dateName,:loc_id);
            CALL dataadmin.SP_COPY_AVEROFILES_FROM_S3_TO_SFTP(:dateName,:loc_id, :avero_loc_id);
        EXCEPTION
            -- If the worker fails, log the error here and continue the loop.
            WHEN OTHER THEN
                INSERT INTO dataadmin.error_logs (
                    parent_query_id,
                    task_run_group_id,
                    attempt_number,
                    session_id,
                    task_name,
                    failed_query_id,
                    error_type_id,
                    severity,
                    sql_error_code,
                    sql_error_message,
                    sql_state,
                    details
                )
                VALUES (
                    :parent_query_id,
                    :task_run_group_id,
                    :attempt_number,
                    :session_id,
                    :task_name,
                    COALESCE(last_query_id(), ''NOT_FOUND''), --it should return the query_id of the failed command in the BEGIN block.
                    2, --1 are hard fails and 2 soft fails
                    ''ERROR'',
                    :SQLCODE,
                    :SQLERRM,
                    :SQLSTATE,
                    null
                );
        END;
    END FOR;

RETURN ''Graph Run Group ID: ''||:run_metadata:graph_run_group_id || '', Attempt: ''||:run_metadata:run_attempt_number;
END;
';"
PROCEDURE,DATAADMIN,"SP_DATASHARE_CRAFTABLE_FEES(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_DATASHARE_CRAFTABLE_FEES""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE
  reportSet resultset;
--   startdate timestamp_tz      := ''2020-08-20T14:48:37.661Z'';
--   enddate timestamp_tz        := ''2029-08-20T14:48:37.661Z'';
--   locationid string           := ''[35]'';
  locationidS string          :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
  today char(11)              := CURRENT_DATE()::date::VARCHAR(10);
-----------------------------------------------------------------------------------------------------------------------
BEGIN
DROP TABLE if exists FEES_DATA_TEMP;

CALL DATAADMIN.SP_REPORT_FEES(:startdate,:enddate,:locationidS);
CREATE TEMP TABLE FEES_DATA_TEMP AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));
;
-----------------------------------------------------------------------------------------------------------------------
     reportSet := (
         SELECT 
            ORG.ORGANIZATION             AS ""Organization Name"",
            ORG.ORGANIZATION_DIM_NK      AS ""Organization ID"",
            FDT.""Location""               AS ""Location Name"",
            FDT.""Location ID""            AS ""Location ID"",
            FDT.""Fiscal Date""            AS ""Business Day"",
            FDT.""Check""                  AS ""Check Number""
            ,null                        AS ""Check ID"" --We will have to add Check ID to the fee report
            ,FDT.""Fee""                   AS ""Fee Name""
            ,FDT.""Support ID""            AS ""Fee ID""
            ,FDT.""Total""                 AS ""Fee Amount""
            ,null                        AS ""Fee Tax"" --TODO pending to decide with Diane how to get this
         FROM 
         FEES_DATA_TEMP FDT
         LEFT JOIN DATAWAREHOUSE.ORGANIZATION_DIM                                        ORG
            ON FDT.""Location ID""  = ORG.ORGANIZATION_DIM_NK
            AND ORG.DW_ISCURRENTROW
     );
--=====================================================================================================================
RETURN TABLE(reportSet);
END';"
PROCEDURE,DATAADMIN,"SP_DATAWAREHOUSE_MANAPP_CHECK(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_DATAWAREHOUSE_MANAPP_CHECK""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet      resultset;
  -- startdate      date     := ''2025-10-28'';  
  -- enddate        date     := ''2025-10-29''; 
  -- locationid     string   := ''[351]'';
  locationidS string      :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
  today          char(11) := CURRENT_DATE()::DATE::VARCHAR(10);
  yesterdaydate  date     := dateadd(day,-1,:today);
  weekOffset     int      := (  
                              SELECT TOP 1 ORG.START_OF_BIZ_WEEK_INT  
                                FROM DATAWAREHOUSE.ORGANIZATION_DIM          ORG
                                  INNER JOIN DATAWAREHOUSE.LOCATION_DIM      LOC 
                                     ON LOC.ORGANIZATION_DIM_FK = ORG.ORGANIZATION_DIM_NK
                                        AND LOC.DW_ISCURRENTROW
                                        AND ORG.DW_ISCURRENTROW
                                        AND LOC.LOCATION_DIM_NK in (
                                             SELECT table1.value 
                                          FROM table(split_to_table(:locationidS, '',''))  table1) 
                             );
  lastWeekStart  date     := (DATEADD(DAY,
                                ((DAYOFWEEK(:today::date) - (:weekOffset )  ) * -1)  -7
                                + case when DAYOFWEEK(:today::date)< :weekOffset then -0 else 0 end
                                 , :today)) ::date;
  lastWeekEnd    date     := dateadd(day,6,:lastWeekStart);
  lastMonthStart date     := left(dateadd(month,-1,:today)::date::string,7) || ''-01'';
  lastMonthEnd   date     := dateadd(day,-1,dateadd(month,1,lastMonthStart))::date;

  thisWeekStart  date     := dateadd(day,1,:lastWeekEnd);
  thisMonthStart date     := dateadd(day,1,:lastMonthEnd);
  
  lastYearStart  date     := date_part(year,(dateadd(year,-1,:today))) || ''-01-01'';                  
  lastYearEnd    date     := dateadd(day,-1,dateadd(year,1,:lastYearStart));

---====================================================================================================================
BEGIN
  DROP TABLE if exists CHK_DATA_TEMP;
  DROP TABLE if exists ITEM_DATA_TEMP;  

-----------------------------------------------------------------------------------------------------------------------
--Get history data from the Warehouse. Faster than streaming data-the warehouse has already processed JSON, etc
SELECT TO_CHAR(CHK.CHEQUE_FACT_NK)                                            AS ""Support ID""
  ,''DataWarehouse''                                                            AS ""Origin""
  ,CHK.STATUS                                                                 AS ""Check Status""
  ,''Check''                                                                    AS ""Level""
  ,CHK.CHEQUE_FACT_NK                                                         AS ""Check ID""
  ,CHK.SHIFT_DIM_FK                                                           AS ""Shift ID""
  ,CHK.LOCATION_DIM_FK                                                        AS ""Location ID""  
  ,CHK.REVENUECENTERNAME                                                      AS ""Revenue Center""
  ,CHK.EMPLOYEE_DIM_FK                                                        AS ""Employee ID""
  ,CHK.DAYPART_DIM_FK                                                         AS ""Daypart ID""
  ,CHK.ORDERTYPE_DIM_FK                                                       AS ""Order Type ID""   
  ,DPD.DAYPART                                                                AS ""Daypart""
  ,ORD.ORDER_TYPE                                                             AS ""Order Type""
  ,LOC.LOCATIONNAME                                                           AS ""Location""
  ,null                                                                       AS ""Menu Item""
  ,null                                                                       AS ""Category"" 
  ,null                                                                       AS ""Gets Paid Break""  
  ---------------------------------------------------------------------------------------
  ,CHK.FISCAL_DATE::DATE                                                      AS ""Fiscal Date"" 
  ,TO_CHAR(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME
      ,chk.OPENED_AT::timestamp_ntz)::timestamp ) ::DATE                                                                                                                                                    AS ""Opened At""  
  ,TO_CHAR(TO_CHAR(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME
       ,chk.OPENED_AT::timestamp_ntz)::timestamp ) ::timestamp 
  , ''HH24'') ::NUMBER(18,0)                                                    AS ""Hour""  
  ,NULL/*(SHD.PAY_RATE/1000000)::DECIMAL(18,2)*/                              AS ""Rate""
  ,CASE WHEN TO_CHAR(CHK.FISCAL_DATE)::DATE  
    BETWEEN :startdate::DATE AND :enddate::DATE THEN TRUE ELSE FALSE END  
                                                                              AS ""Is Current""
  ,CASE WHEN TO_CHAR(CHK.FISCAL_DATE)::DATE  
    = :today::DATE THEN TRUE ELSE FALSE END                                   AS ""Is Today""    
    
  ,CASE WHEN TO_CHAR(CHK.FISCAL_DATE)::DATE  
    = :yesterdaydate::DATE THEN TRUE ELSE FALSE END                           AS ""Is Yesterday""
    
  ,CASE WHEN TO_CHAR(CHK.FISCAL_DATE)::DATE  
    BETWEEN :lastWeekStart::DATE AND :lastWeekEnd::DATE 
      THEN TRUE ELSE FALSE END                                                AS ""Is Last Week""
      
  ,CASE WHEN TO_CHAR(CHK.FISCAL_DATE)::DATE  
    BETWEEN :lastMonthStart::DATE AND :lastMonthEnd::DATE 
       THEN TRUE ELSE FALSE END                                               AS ""Is Last Month""
       
 ,CASE WHEN TO_CHAR(CHK.FISCAL_DATE)::DATE  
    >= :thisMonthStart::DATE 
       THEN TRUE ELSE FALSE END                                               AS ""Is This Month""

 ,CASE WHEN TO_CHAR(CHK.FISCAL_DATE)::DATE  
    >= :thisWeekStart::DATE 
       THEN TRUE ELSE FALSE END                                               AS ""Is This Week""       
       
  ,CASE WHEN TO_CHAR(CHK.FISCAL_DATE)::DATE  
    BETWEEN :lastYearStart::DATE AND :lastYearEnd::DATE 
        THEN TRUE ELSE FALSE END                                              AS ""Is Last Year""
-----------------------------------------------------------------------------------------------------------------
--Facts CHECK LEVEL
 ,(CASE WHEN CHK.IS_VOID THEN 0 ELSE CHK.PARTY_COUNT END)::DECIMAL(36,2)::DECIMAL(36,0)                                                                                                                      AS ""Guest Count""
 ,(CASE WHEN CHK.IS_VOID THEN 0 ELSE CHK.FEES END)::DECIMAL(36,2)              AS ""Fee Amount""
 ,(CASE WHEN CHK.IS_VOID THEN 0 ELSE CHK.GRATUITIES END) ::DECIMAL(36,2)       AS ""Gratuity Amount""
 ,DATEDIFF(MINUTE
  ,IFNULL(CHK.OPENED_AT,IFNULL(CHK.CLOSED_AT,CURRENT_TIMESTAMP))
  ,IFNULL(CHK.CLOSED_AT,CURRENT_TIMESTAMP))::NUMBER(36,0)                   
                                                                               AS ""Table Time""  
  -----------------------------------------------------------------------------------------------------------------
 --Facts  ITEM LEVEL (all item level amounts should be filtered for voids)
  ,0::NUMBER(36,0)                                                             AS ""Shift Seconds"" 
  ,0::NUMBER(36,0)                                                             AS ""Shift Count""
  ,0::NUMBER(36,0)                                                             AS ""Item Count""  
  ,(CASE WHEN CHK.STATUS = ''Voided'' THEN 0 ELSE 1 END)::NUMBER(36,0)           AS ""Check Count"" 
  ,(CASE WHEN CHK.STATUS = ''Voided'' THEN 1 ELSE 0 END)::NUMBER(36,0)           AS ""Void Count""
  ,(CASE WHEN CHK.STATUS = ''Voided'' THEN CHK.GROSS ELSE 0 END)::NUMBER(36,2)   AS ""Void Amount"" 
  ,0::DECIMAL(36,2)                                                            AS ""Net Amount""
  ,(CASE WHEN NOT CHK.STATUS = ''Voided'' THEN CHK.DISCOUNTCHECK ELSE 0 END)::DECIMAL(36,2)                                             
                                                                               AS ""Discount Amount""
  ,0::DECIMAL(36,2)                                                            AS ""Gross Amount""  

----------------------------------------------------------------------------------------------------------------- 
FROM DATAWAREHOUSE.CHEQUE_FACT                                                 CHK
  INNER JOIN DATAWAREHOUSE.LOCATION_DIM                                        LOC
    ON CHK.LOCATION_DIM_FK = LOC.LOCATION_DIM_NK
      AND LOC.DW_ISCURRENTROW
      AND CHK.DW_ISCURRENTROW
      AND NOT CHK.IS_TRAINING
      AND NOT CHK.DW_ISDELETED
      AND CHK.STATUS IN (''Closed'',''Opened'',''Voided'') 
      AND NOT (CHK.STATUS = ''Opened'' AND CHK.FISCAL_DATE::date <= :today::date )
      AND CHK.FISCAL_DATE::date >= :lastYearEnd::date 
              AND CHK.FISCAL_DATE::date <= :today::date  
              AND CHK.LOCATION_DIM_FK in (
                SELECT table1.value 
                   FROM table(split_to_table(:locationidS, '',''))  table1) 
  INNER JOIN DATAWAREHOUSE.DAYPART_DIM                                         DPD
    ON CHK.DAYPART_DIM_FK = DPD.DAYPART_DIM_NK
      AND DPD.DW_ISCURRENTROW
  INNER JOIN DATAWAREHOUSE.ORDERTYPE_DIM                                       ORD
    ON CHK.ORDERTYPE_DIM_FK = ORD.ORDERTYPE_DIM_NK
      AND ORD.DW_ISCURRENTROW      
;
-- SELEcT ""Check ID"",COUNT(*) FROM CHK_DATA_TEMP GROUP BY ""Check ID"" ORDER BY COUNT(*) DESC;

CREATE TEMP TABLE CHK_DATA_TEMP AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))
;
-- ====================================================================================================================
SELECT  TO_CHAR(ITM.ITEM_FACT_NK)                                            AS ""Support ID""
  ,''DataWarehouse''                                                           AS ""Origin""
  ,ITM.ITEMSTATUS                                                            AS ""Check Status""
  ,''Item''                                                                    AS ""Level""
  ,CHK.""Check ID""                                                            AS ""Check ID""
  ,CHK.""Shift ID""                                                            AS ""Shift ID""
  ,CHK.""Location ID""                                                         AS ""Location ID""  
  ,CHK.""Revenue Center""                                                      AS ""Revenue Center""
  ,CHK.""Employee ID""                                                         AS ""Employee ID""
  ,CHK.""Daypart ID""                                                          AS ""Daypart ID""
  ,CHK.""Order Type ID""                                                       AS ""Order Type ID""   
  ,CHK.""Daypart""                                                             AS ""Daypart""
  ,CHK.""Order Type""                                                          AS ""Order Type""
  ,CHK.""Location""                                                            AS ""Location""
  ,ITM.NAME                                                                  AS ""Menu Item""
  ,IFNULL(ccd.COGSCATEGORY,''None'')                                           AS ""Category""  
  ,null                                                                      AS ""Gets Paid Break"" 
  ---------------------------------------------------------------------------------------
  ,CHK.""Fiscal Date""                                                         AS ""Fiscal Date"" 
  ,CHK.""Opened At""                                                           AS ""Opened At""  
  ,CHK.""Hour""                                                                AS ""Hour""  
  ,NULL/*(SHD.PAY_RATE/1000000)::DECIMAL(18,2)*/                             AS ""Rate""
  ,CHK.""Is Current""                                                          AS ""Is Current""
  ,CHK.""Is Today""                                                            AS ""Is Today""                            
  ,CHK.""Is Yesterday""                                                        AS ""Is Yesterday""
  ,CHK.""Is This Week""                                                        AS ""Is This Week""
  ,CHK.""Is This Month""                                                       AS ""Is This Month""
  ,CHK.""Is Last Week""                                                        AS ""Is Last Week""
  ,CHK.""Is Last Month""                                                       AS ""Is Last Month""
  ,CHK.""Is Last Year""                                                        AS ""Is Last Year""
-----------------------------------------------------------------------------------------------------------------
--Facts CHECK LEVEL
  ,0::DECIMAL(36,0)                                                           AS ""Guest Count""
  ,0::DECIMAL(36,0)                                                           AS ""Fee Amount""
  ,0::DECIMAL(36,0)                                                           AS ""Gratuity Amount""
  ,0::DECIMAL(36,0)                                                           AS ""Table Time""   
  -----------------------------------------------------------------------------------------------------------------
   --Facts ITEM LEVEL (all item level amounts should be filtered for voids)
  ,0::NUMBER(36,0)                                                            AS ""Shift Seconds"" 
  ,0::NUMBER(36,0)                                                            AS ""Shift Count""
  ,CAST(CASE WHEN NOT ITM.ITEMSTATUS = ''Voided'' AND NOT CHK.""Check Status"" = ''Voided''
    THEN ITM.QUANTITY ELSE 0 END AS DECIMAL(36,0))                            AS ""Item Count""  
 ,0:: DECIMAL(36,0)                                                           AS ""Check Count""   
  ,CAST(CASE WHEN  ITM.ITEMSTATUS = ''Voided''
    THEN ITM.QUANTITY ELSE 0 END AS DECIMAL(36,0))                            AS ""Void Count""
  ,(CASE WHEN  ITM.ITEMSTATUS = ''Voided''
    THEN
    CASE WHEN ITM.PRICE > 0.0000 THEN ITM.PRICE * ITM.QUANTITY ELSE ITM.baseprice END
     + (ifnull(IMF.PRICE,0)) * (ITM.QUANTITY) 
     ELSE 0 END )
      ::  DECIMAL(38,2)                            
                                                                              AS ""Void Amount"" 
  ,CAST(CASE WHEN NOT ITM.ITEMSTATUS = ''Voided'' AND NOT CHK.""Check Status"" = ''Voided''
    THEN ITM.APPLIEDAMOUNT ELSE 0 END AS DECIMAL(38,2))                       AS ""Net Amount""
  ,CAST(CASE WHEN NOT ITM.ITEMSTATUS = ''Voided'' AND NOT CHK.""Check Status"" = ''Voided''
    THEN ITM.DISCOUNTITEM ELSE 0 END AS DECIMAL(36,2))                        AS ""Discount Amount""
  ,CAST(CASE WHEN NOT ITM.ITEMSTATUS = ''Voided'' AND NOT CHK.""Check Status"" = ''Voided'' 
    THEN ITM.GROSS ELSE 0 END AS DECIMAL(36,2))                               AS ""Gross Amount""  
----------------------------------------------------------------------------------------------------------------- 
FROM CHK_DATA_TEMP                                                            CHK 
  INNER JOIN DATAWAREHOUSE.ITEM_FACT                                          ITM
    ON CHK.""Check ID"" = ITM.CHEQUE_FACT_FK
      AND ITM.DW_ISCURRENTROW
      AND ITM.ITEMSTATUS IN (''Added'',''Sent'',''Voided'')
    INNER JOIN DATAWAREHOUSE.MENUITEMNAME_DIM                                  MED
       ON med.MENUITEMNAME_DIM_NK = itm.MENUITEMNAME_DIM_FK
          AND med.DW_ISCURRENTROW  
    INNER JOIN DATAWAREHOUSE.REPORTCATEGORY_DIM                                MEG
        ON med.REPORTCATEGORY_DIM_FK = meg.REPORTCATEGORY_DIM_NK
          AND meg.DW_ISCURRENTROW = TRUE
    INNER JOIN DATAWAREHOUSE.COGSCATEGORY_DIM                                  CCD
        ON ccd.COGSCATEGORY_DIM_NK = meg.COGSCATEGORY_DIM_FK    
          AND ccd.DW_ISCURRENTROW

      LEFT JOIN (SELECT ITEM_FACT_FK,SUM(PRICE) AS PRICE 
                    FROM DATAWAREHOUSE.ITEMMODIFIER_DIM 
                 WHERE DW_ISCURRENTROW
                 GROUP BY ITEM_FACT_FK
                                                                        )    IMF
              ON ITM.ITEM_FACT_NK = IMF.ITEM_FACT_FK 
;

CREATE TEMP TABLE ITEM_DATA_TEMP AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))
;
--xxx
-- select ""Support ID"" from ITEM_DATA_TEMP;
-- select * From ITEM_DATA_TEMP where ""Support ID"" in (9095315,9098419);
-- ====================================================================================================================

 reportSet   := (
  SELECT ROW_NUMBER() OVER (ORDER BY ""Location ID"")                      AS ""Support ID""
  ,""Location""                                                            AS ""Location""
  ,""Location ID""                                                         AS ""Location ID""  
  ,""Order Type""                                                          AS ""Order Type""
  ,""Location""                                                            AS ""Location""
  ,""Menu Item""                                                           AS ""Menu Item""
  ,""Category""                                                            AS ""Category""
  -----------------------------------------------------------------------------------------------------------------
  ,""Is Current""                                                          AS ""Is Current""
  ,""Is Today""                                                            AS ""Is Today""                            
  ,""Is Yesterday""                                                        AS ""Is Yesterday""
  ,""Is Last Week""                                                        AS ""Is Last Week""
  ,""Is Last Month""                                                       AS ""Is Last Month""
  ,""Is This Month""                                                       AS ""Is This Month""  
  ,""Is This Week""                                                        AS ""Is This Week""   
  ,""Is Last Year""                                                        AS ""Is Last Year""
-----------------------------------------------------------------------------------------------------------------
--Facts CHECK LEVEL
  ,SUM(""Guest Count"")::DECIMAL(36,0)                                     AS ""Guest Count""    
  ,SUM(""Fee Amount"")::DECIMAL(36,2)                                      AS ""Fee Amount""    
  ,SUM(""Gratuity Amount"")::DECIMAL(36,2)                                 AS ""Gratuity Amount"" 
  ,SUM(""Table Time"")::DECIMAL(36,0)                                      AS ""Table Time""    
  -----------------------------------------------------------------------------------------------------------------
   --Facts ITEM LEVEL (all item level amounts should be filtered for voids)
  ,SUM(""Check Count"")::DECIMAL(36,0)                                     AS ""Check Count""  
  ,SUM(""Item Count"")::DECIMAL(36,0)                                      AS ""Item Count""  
  ,SUM(""Void Amount"")::DECIMAL(36,2)                                     AS ""Void Amount""    
  ,SUM(""Net Amount"")::DECIMAL(36,2)                                      AS ""Net Amount""    
  ,SUM(""Discount Amount"")::DECIMAL(36,2)                                 AS ""Discount Amount""    
  ,SUM(""Gross Amount"")::DECIMAL(36,2)                                    AS ""Gross Amount""  
FROM (
 SELECT * FROM ITEM_DATA_TEMP  --74
 UNION ALL
 SELECT * FROM CHK_DATA_TEMP 
 )  
 WHERE ""Is Current""
   OR ""Is Today""                            
   OR ""Is Yesterday""
   OR ""Is Last Week""
   OR ""Is Last Month""
   OR ""Is This Month""  
   OR ""Is This Week""   
   OR ""Is Last Year""
 GROUP BY  ""Location""
  , ""Location ID""  
  , ""Order Type""
  , ""Location""
  , ""Menu Item""
  , ""Category""
  -----------------------------------------------------------------------------------------------------------------
  , ""Is Current""
  , ""Is Today""                            
  , ""Is Yesterday""
  , ""Is Last Week""
  , ""Is Last Month""
  , ""Is This Month""  
  , ""Is This Week""   
  , ""Is Last Year""

-- SELECT :weekOffset as ""weekoffset""
--   ,:today as ""today""
--   ,:yesterdaydate as ""yesterdaydate""
--   ,:lastWeekStart as ""lastWeekStart""
--   ,:lastWeekEnd as ""lastWeekEnd"" 
--   ,:thisWeekStart as ""thisWeekStart""   
--   ,:lastMonthStart as ""lastMonthStart""
--   ,:lastMonthEnd as ""lastMonthEnd""
--   ,:thisMonthStart as ""thisMonthStart""
--   ,:lastYearStart as ""lastYearStart""
--   ,:lastYearEnd as ""lastYearEnd""
   
--===================================================================================================
); 
 RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,"SP_LOAD_365_MENUITEMS(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_365_MENUITEMS""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2020-08-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2029-08-20T14:48:37.661Z''; 
  -- locationid string      := ''[2,3,4,351,352]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--==================================================================================================================================
BEGIN
  DROP TABLE IF EXISTS TEMP_item; 
  DROP TABLE IF EXISTS TEMP_header; 

----------------------------------------------------------------------------------------------------------------------------------  
  SELECT ''ItemNumber''
  ,''ItemName''     
  ,''CategoryName''  
;  

 CREATE TEMP TABLE TEMP_header AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID())); 
     
------------------------------------------------------------------------------------------------------------------------------------
SELECT  IFNULL(REPLACE(MEN.MENUITEMNAME_DIM_NK,'','',''''),''None'')  AS ItemNumber     --*  Menu Item ID
  ,IFNULL(REPLACE(MEN.MENUITEMNAME,'','',''''),''None'')              AS ItemName       --* string Name of the Menu Item.
  ,IFNULL(REPLACE(CCD.COGSCATEGORY,'','',''''),''None'')              AS CategoryName   --* string Cogs category
 FROM DATAWAREHOUSE.MENUITEM_DIM                                MED
   INNER JOIN DATAWAREHOUSE.MENUITEMNAME_DIM                    MEN
     ON MED.MENUITEMNAME_DIM_FK = MEN.MENUITEMNAME_DIM_NK
       AND MED.DW_ISCURRENTROW
       AND MEN.DW_ISCURRENTROW
   INNER JOIN DATAWAREHOUSE.ORGANIZATION_DIM                    ORG
     ON MED.ORGANIZATION_DIM_FK = ORG.ORGANIZATION_DIM_NK
       AND ORG.DW_ISCURRENTROW
   INNER JOIN DATAWAREHOUSE.LOCATION_DIM                        LOC
     ON LOC.ORGANIZATION_DIM_FK = ORG.ORGANIZATION_DIM_NK
       AND LOC.DW_ISCURRENTROW
       AND LOC.LOCATION_DIM_NK in (SELECT table1.value 
        FROM table(split_to_table(:locationidS, '',''))  table1) 
    INNER JOIN DATAWAREHOUSE.REPORTCATEGORY_DIM                 MEG
        ON MEN.REPORTCATEGORY_DIM_FK = MEG.REPORTCATEGORY_DIM_NK
          AND MEG.DW_ISCURRENTROW = TRUE
      INNER JOIN DATAWAREHOUSE.COGSCATEGORY_DIM                 CCD
        ON CCD.COGSCATEGORY_DIM_NK = MEG.COGSCATEGORY_DIM_FK    
          AND CCD.DW_ISCURRENTROW        
GROUP BY IFNULL(REPLACE(MEN.MENUITEMNAME_DIM_NK,'','',''''),''None'') 
  ,IFNULL(REPLACE(MEN.MENUITEMNAME,'','',''''),''None'')       
  ,IFNULL(REPLACE(CCD.COGSCATEGORY,'','',''''),''None'') 
ORDER BY  IFNULL(REPLACE(MEN.MENUITEMNAME_DIM_NK,'','',''''),''None'') 
  ,IFNULL(REPLACE(MEN.MENUITEMNAME,'','',''''),''None'')       
  ,IFNULL(REPLACE(CCD.COGSCATEGORY,'','',''''),''None'') 
  ;

  CREATE TEMP TABLE TEMP_item AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID())); 
  
--==================================================================================================================================
 
reportSet := ( 
  SELECT * FROM TEMP_header
    UNION ALL
  SELECT * FROM TEMP_item
--==================================================================================================================================
);
RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,"SP_LOAD_AVERO_EXTRACTONEFILE(VARCHAR, VARCHAR, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_AVERO_EXTRACTONEFILE""(""FISCALDATE"" VARCHAR(16777216), ""LOCATIONID"" VARCHAR(16777216), ""FILE"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  -- locationid   string := ''[351]'';
  -- fiscaldate   string := ''2024-12-18'';
  -- file         string := ''CheckHeader'';
  reportSet    resultset;  
  sproc        string := ''DATAADMIN.SP_LOAD_AVERO_'' || :file; 
  fiscalform   string := to_char(to_date(:fiscaldate),''YYYYMMDD'');
  filelocation string := REPLACE(REPLACE(locationid,''['',''''),'']'');
  stagename    string := ''@DATAADMIN.STAGE-AVERO/AVEROFTP/Location'' || :filelocation || ''/'' || :fiscalform || ''/'' 
                            -- || :file || ''_Location'' || :filelocation || ''_'' || :fiscalform  || ''.csv'';
                            || :file ||  ''.csv'';
  sqlstatement string := ''COPY INTO <@stagename>   
                          FROM (SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID())))
                          FILE_FORMAT=(TYPE = CSV COMPRESSION=\\''NONE\\'')
                          HEADER     = TRUE
                          SINGLE     = TRUE
                          OVERWRITE  = TRUE'';
--=================================================================================================================================
BEGIN
    --Retreive the data from the Datawarehouse via stored procedure
    CALL IDENTIFIER(:sproc)(:fiscaldate,:fiscaldate,:locationid);
  
--=================================================================================================================================
reportSet := (  
  EXECUTE IMMEDIATE (REPLACE(:sqlstatement,''<@stagename>'',:stagename))

--=================================================================================================================================
);
RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,"SP_LOAD_DATASHARE_CRAFTABLE_MODIFIER(VARCHAR, VARCHAR, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_DATASHARE_CRAFTABLE_MODIFIER""(""START_DATE"" VARCHAR, ""END_DATE"" VARCHAR, ""LOCATION_IDS"" VARCHAR)
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS CALLER
AS 'BEGIN
    -- Execute the source procedure that returns the data
    CALL DATAADMIN.SP_DATASHARE_CRAFTABLE_MODIFIER(:START_DATE, :END_DATE, :LOCATION_IDS);

    -- Insert the results into the target table
    INSERT INTO DATASHARE_DEV.CRAFTABLE_MODIFIER (
        ""Organization Name"",
        ""Organization ID"",
        ""Location Name"",
        ""Location ID"",
        ""Business Day"",
        ""Check ID"",
        ""Check Number"",
        ""Item Name"",
        ""Item ID"",
        ""Modifier Group"",
        ""Modifier Group ID"",
        ""Is Sub Modifier"",
        ""Modifier Parent Name"",
        ""Modifier Parent ID"",
        ""Modifier Name"",
        ""Modifier ID"",
        ""Modifier Quantity"",
        ""Modifier Amount""
    )
    SELECT
        ""Organization Name"",
        ""Organization ID"",
        ""Location Name"",
        ""Location ID"",
        ""Business Day"",
        ""Check ID"",
        ""Check Number"",
        ""Item Name"",
        ""Item ID"",
        ""Modifier Group"",
        ""Modifier Group ID"",
        ""Is Sub Modifier"",
        ""Modifier Parent Name"",
        ""Modifier Parent ID"",
        ""Modifier Name"",
        ""Modifier ID"",
        ""Modifier Quantity"",
        ""Modifier Amount""
    FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

    RETURN ''Success: Data loaded into DATASHARE_DEV.CRAFTABLE_MODIFIER.'';
END';"
PROCEDURE,DATAADMIN,"SP_STREAM_DASHBOARD_CHECK(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_STREAM_DASHBOARD_CHECK""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet      resultset;
  -- startdate      date     := ''2025-05-07'';  
  -- enddate        date     := ''2025-05-07''; 
  -- locationid     string   := ''351'';
  locationidS string      :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
  today          char(11) := CURRENT_DATE()::DATE::VARCHAR(10);
  yesterdaydate  date     := dateadd(day,-1,:today);
  weekOffset     int      := (  
                              SELECT TOP 1 ORG.START_OF_BIZ_WEEK_INT  
                                FROM DATAWAREHOUSE.ORGANIZATION_DIM          ORG
                                  INNER JOIN DATAWAREHOUSE.LOCATION_DIM      LOC 
                                     ON LOC.ORGANIZATION_DIM_FK = ORG.ORGANIZATION_DIM_NK
                                        AND LOC.DW_ISCURRENTROW
                                        AND LOC.DW_ISCURRENTROW
                                        AND LOC.LOCATION_DIM_NK in (
                                             SELECT table1.value 
                                          FROM table(split_to_table(:locationidS, '',''))  table1) 
                             );
  lastWeekStart  date     := (DATEADD(DAY,
                                ((DAYOFWEEK(:today::date) - (:weekOffset )  ) * -1)  -7
                                + case when DAYOFWEEK(:today::date)< :weekOffset then -0 else 0 end
                                 , :today)) ::date;
  lastWeekEnd    date     := dateadd(day,6,:lastWeekStart);
  lastMonthStart date     := left(dateadd(month,-1,:today)::date::string,7) || ''-01'';
  lastMonthEnd   date     := dateadd(day,-1,dateadd(month,1,lastMonthStart))::date;
  lastYearStart  date     := date_part(year,(dateadd(year,-1,:today))) || ''-01-01'';                  
  lastYearEnd    date     := dateadd(day,-1,dateadd(year,1,:lastYearStart));

---====================================================================================================================
BEGIN
  DROP TABLE if exists CHK_DATA_TEMP;
  DROP TABLE if exists ITEM_DATA_TEMP;  

-----------------------------------------------------------------------------------------------------------------------
--Get history data from the Warehouse. Faster than streaming data-the warehouse has already processed JSON, etc
SELECT TO_CHAR(CHK.""id"")                                                      AS ""Support ID""
  ,''Stream''                                                                   AS ""Origin""
  ,CHK.""items""                                                                AS ""items""
  ,CHK.""status""                                                               AS ""Check Status""
  ,''Check''                                                                    AS ""Level""
  ,CHK.""id""                                                                   AS ""Check ID""
  ,TRY_PARSE_JSON(CHK.""info""):shiftID::DECIMAL(36,0)                          AS ""Shift ID""
  ,CHK.""location_id""                                                          AS ""Location ID""  
  ,TO_CHAR(REPLACE(TRY_PARSE_JSON(CHK.""info""):revenueCenterName,''""'',''''))      AS ""Revenue Center""
  ,CHK.""employee_id""                                                          AS ""Employee ID""
  ,CHK.""day_part_id""                                                          AS ""Daypart ID""
  ,CHK.""order_type_id""                                                        AS ""Order Type ID""   
  ,DPD.DAYPART                                                                AS ""Daypart""
  ,ORD.ORDER_TYPE                                                             AS ""Order Type""
  ,LOC.LOCATIONNAME                                                           AS ""Location""
  ,null                                                                       AS ""Menu Item""
  ,null                                                                       AS ""Gets Paid Break""  
--   ---------------------------------------------------------------------------------------
  ,TO_CHAR(TRY_PARSE_JSON(CHK.""info""):fiscalDate)::DATE::date                 AS ""Fiscal Date"" 
  ,TO_CHAR(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME
      ,chk.""opened_at""::timestamp_ntz)::timestamp ) ::DATE                                                                                                                                                AS ""Opened At""  
----------------------------------------      
  ,TO_CHAR(TO_CHAR(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME
       ,chk.""opened_at""::timestamp_ntz)::timestamp ) ::timestamp 
  , ''HH24'')::NUMBER(18,0)                                                      AS ""Hour""  
  ---------------
  -- ,TO_CHAR(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME
  --      ,chk.""opened_at""::timestamp_ntz)::timestamp ) ::timestamp            AS hourcheck
  --------------
  ,NULL                                                                        AS ""Rate""
  ,TRUE                                                                        AS ""Is Current""
  ,TRUE                                                                        AS ""Is Today""                         
  ,FALSE                                                                       AS ""Is Yesterday""
  ,FALSE                                                                       AS ""Is Last Week"" 
  ,FALSE                                                                       AS ""Is Last Month"" 
  ,FALSE                                                                       AS ""Is Last Year""
-- -----------------------------------------------------------------------------------------------------------------
-- --Facts CHECK LEVEL
 ,TRY_PARSE_JSON(chk.""info""):partySize::number(36,0)                           AS ""Guest Count""
 ,TRY_TO_NUMBER(TO_CHAR(TRY_PARSE_JSON(CHK.""balance""):fees), 36,2)             AS ""Fee Amount""
 ,(CASE WHEN CHK.""status"" = ''Voided''
     THEN 0 ELSE ((TRY_PARSE_JSON(CHK.""balance""):gratuities) )  END)::DECIMAL(36,2)      
                                                                               AS ""Gratuity Amount""
  ,DATEDIFF(MINUTE
  ,IFNULL(CHK.""opened_at"",IFNULL(CHK.""closed_at"",CURRENT_TIMESTAMP))
  ,IFNULL(CHK.""closed_at"",CURRENT_TIMESTAMP))::NUMBER(36,0)                   
                                                                               AS ""Table Time""  
--   -----------------------------------------------------------------------------------------------------------------
--  --Facts  ITEM LEVEL (all item level amounts should be filtered for voids)
  ,0::NUMBER(36,0)                                                             AS ""Shift Seconds"" 
  ,0::NUMBER(36,0)                                                             AS ""Shift Count""
  ,0::NUMBER(36,0)                                                             AS ""Item Count""  
  ,1::NUMBER(36,0)                                                             AS ""Check Count"" 
  ,(CASE WHEN CHK.""status"" = ''Voided'' THEN 1 ELSE 0 END)::NUMBER(36,0)         AS ""Void Count""
  ,((CASE WHEN CHK.""status"" = ''Voided'' THEN TRY_TO_NUMBER(TO_CHAR(TRY_PARSE_JSON(CHK.""balance""):gross), 38,4) 
         ELSE 0 END)
         )
         ::DECIMAL(36,2)
                                                                               AS ""Void Amount"" 
  ,0::DECIMAL(36,2)                                                            AS ""Net Amount""
  ,(CASE WHEN CHK.""status"" = ''Voided''
     THEN 0 ELSE TO_CHAR(TRY_PARSE_JSON(chk.""balance""):discountCheck) END) ::DECIMAL(36,2)                                  
                                                                               AS ""Discount Amount""
  ,0::DECIMAL(36,2)                                                            AS ""Gross Amount""  
--------------------------------------------------------------------------------------------------------------- 
FROM  DATASTREAMING.POSAPI_PUBLIC_CHEQUE                                       CHK
  INNER JOIN DATAWAREHOUSE.LOCATION_DIM                                        LOC
    ON CHK.""location_id"" = LOC.LOCATION_DIM_NK
      AND LOC.DW_ISCURRENTROW
      AND NOT CHK.""is_training""
      AND CHK.""status"" IN (''Closed'',''Voided'',''Opened'')  
      AND NOT (CHK.""status"" = ''Opened'' AND TO_CHAR(TRY_PARSE_JSON(CHK.""info""):fiscalDate)::DATE <= :today::date )
      AND TO_CHAR(TRY_PARSE_JSON(CHK.""info""):fiscalDate)::DATE = :today::date  
      AND LOC.LOCATION_DIM_NK in (
                SELECT table1.value 
                   FROM table(split_to_table(:locationidS, '',''))  table1) 
  INNER JOIN DATAWAREHOUSE.DAYPART_DIM                                         DPD
    ON CHK.""day_part_id"" = DPD.DAYPART_DIM_NK
      AND DPD.DW_ISCURRENTROW
 LEFT JOIN DATAWAREHOUSE.ORDERTYPE_DIM                                        ORD
    ON CHK.""order_type_id"" = ORD.ORDERTYPE_DIM_NK
      AND ORD.DW_ISCURRENTROW          
;

CREATE TEMP TABLE CHK_DATA_TEMP AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))
;

-- ====================================================================================================================
SELECT  CHK.""Check ID"" || ''.''  ||replace(ITM.VALUE:id,''""'','''')                AS ""Support ID""
  ,''Stream''                                                                  AS ""Origin""
  , CHK.""Check Status""                                                       AS ""Check Status""
  ,''Item''                                                                    AS ""Level""
  ,CHK.""Check ID""                                                            AS ""Check ID""
  ,CHK.""Shift ID""                                                            AS ""Shift ID""
  ,CHK.""Location ID""                                                         AS ""Location ID""  
  ,CHK.""Revenue Center""                                                      AS ""Revenue Center""
  ,CHK.""Employee ID""                                                         AS ""Employee ID""
  ,CHK.""Daypart ID""                                                          AS ""Daypart ID""
  ,CHK.""Order Type ID""                                                       AS ""Order Type ID""   
  ,CHK.""Daypart""                                                             AS ""Daypart""
  ,CHK.""Order Type""                                                          AS ""Order Type""
  ,CHK.""Location""                                                            AS ""Location""
  ,replace(ITM.value:menuItem:name,'''','''')                                    AS ""Menu Item""
  ,null                                                                      AS ""Gets Paid Break"" 
--   ---------------------------------------------------------------------------------------
  ,CHK.""Fiscal Date""                                                         AS ""Fiscal Date"" 
  ,CHK.""Opened At""                                                           AS ""Opened At""  
  ,CHK.""Hour""                                                                AS ""Hour""  
  ,NULL::DECIMAL(18,2)                                                       AS ""Rate""
  ,CHK.""Is Current""                                                          AS ""Is Current""
  ,CHK.""Is Today""                                                            AS ""Is Today""                            
  ,CHK.""Is Yesterday""                                                        AS ""Is Yesterday""
  ,CHK.""Is Last Week""                                                        AS ""Is Last Week""
  ,CHK.""Is Last Month""                                                       AS ""Is Last Month""
  ,CHK.""Is Last Year""                                                        AS ""Is Last Year""
-- -----------------------------------------------------------------------------------------------------------------
-- --Facts CHECK LEVEL
  ,0::DECIMAL(36,0)                                                           AS ""Guest Count""
  ,0::DECIMAL(36,0)                                                           AS ""Fee Amount""
  ,0::DECIMAL(36,0)                                                           AS ""Gratuity Amount""
  ,0::DECIMAL(36,0)                                                           AS ""Table Time""   
--   -----------------------------------------------------------------------------------------------------------------
--    --Facts ITEM LEVEL (all item level amounts should be filtered for voids)
  ,0::NUMBER(36,0)                                                            AS ""Shift Seconds"" 
  ,0::NUMBER(36,0)                                                            AS ""Shift Count""
  ,CASE WHEN NOT replace(ITM.value:status,''""'','''') = ''Voided'' 
     AND NOT CHK.""Check Status"" = ''Voided''
      THEN CAST(ITM.value:quantity AS DECIMAL(36,0)) END                      AS ""Item Count""  
  ,0::DECIMAL(36,0)                                                           AS ""Check Count"" 
  ,CASE WHEN  replace(ITM.value:status,''""'','''') = ''Voided'' 
     OR  CHK.""Check Status"" = ''Voided''  
      THEN CAST(ITM.value:quantity AS DECIMAL(36,0))  END                     AS ""Void Count""
  ,CASE WHEN  replace(ITM.value:status,''""'','''') = ''Voided'' 
      THEN CAST(ITM.value:gross AS DECIMAL(36,0)) ELSE 0 END ::DECIMAL(36,2)                                                                                                                              AS ""Void Amount"" 
  ,CAST(CASE WHEN NOT replace(ITM.value:status,''""'','''') = ''Voided'' 
      AND NOT CHK.""Check Status"" = ''Voided''
    THEN CAST(ITM.value:gross AS DECIMAL(38,4)) ELSE 0.00 END AS DECIMAL(38,2))  
       - CAST(ITM.value:discountItem AS DECIMAL(38,4)) 
                                                                               AS ""Net Amount""
  ,CAST(CASE WHEN NOT replace(ITM.value:status,''""'','''') = ''Voided'' 
      AND NOT CHK.""Check Status"" = ''Voided''
    THEN CAST(ITM.value:discountItem AS DECIMAL(38,4)) ELSE 0 END AS DECIMAL(36,2)) 
                                                                               AS ""Discount Amount""
  ,CAST(CASE WHEN NOT replace(ITM.value:status,''""'','''') = ''Voided'' 
      AND NOT CHK.""Check Status"" = ''Voided''
    THEN CAST(ITM.value:gross AS DECIMAL(38,4))  ELSE 0 END AS DECIMAL(36,2))  AS ""Gross Amount""  
-- ----------------------------------------------------------------------------------------------------------------- 
FROM CHK_DATA_TEMP                                                             CHK 
 ,LATERAL FLATTEN(INPUT => 
    TRY_PARSE_JSON( ''{ITEMS:'' || CHK.""items"" || ''}'' ), PATH => ''ITEMS'')        ITM                                   
 WHERE   replace(ITM.value:status,''""'','''') IN (''Added'',''Sent'',''Voided'')                                                               ;

CREATE TEMP TABLE ITEM_DATA_TEMP AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))
;

ALTER TABLE CHK_DATA_TEMP DROP COLUMN ""items"";
-- ====================================================================================================================

 reportSet   := (
 SELECT * FROM ITEM_DATA_TEMP  
 UNION ALL
 SELECT * FROM CHK_DATA_TEMP 
  --  SELECT :weekOffset as ""weekoffset""
  --  ,:today as ""today""
  -- ,:yesterdaydate as ""yesterdaydate""
  -- ,:lastWeekStart as ""lastWeekStart""
  -- ,:lastWeekEnd as ""lastWeekEnd"" 
  -- ,:lastMonthStart as ""lastMonthStart""
  -- ,:lastMonthEnd as ""lastMonthEnd""
  -- ,:lastYearStart as ""lastYearStart""
  -- ,:lastYearEnd as ""lastYearEnd""
   
--===================================================================================================
); 
 RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,"SP_DATASHARE_CRAFTABLE_CHECK(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_DATASHARE_CRAFTABLE_CHECK""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE
  reportSet resultset;
  -- startdate timestamp_tz      := ''2020-08-20T14:48:37.661Z'';
  -- enddate timestamp_tz        := ''2029-08-20T14:48:37.661Z'';
  -- locationid string           := ''[35]'';
  locationidS string          :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
  today char(11)              := CURRENT_DATE()::date::VARCHAR(10);
-----------------------------------------------------------------------------------------------------------------------
  BEGIN
    --drop temp tables
      DROP TABLE if exists CHK_DATA_TEMP;
      DROP TABLE if exists ITEM_DATA_TEMP;
-----------------------------------------------------------------------------------------------------------------------
  CREATE OR REPLACE  TEMPORARY TABLE CHK_DATA_TEMP
    AS
SELECT
    ORG.ORGANIZATION                                                                              AS ""Organization Name"",
    ORG.ORGANIZATION_DIM_NK                                                                       AS ""Organization ID"",
    LOC.LOCATIONNAME                                                                              AS ""Location Name"",
    CHK.LOCATION_DIM_FK                                                                           AS ""Location ID"",
    CHK.FISCAL_DATE::DATE                                                                         AS ""Business Day"",
    CHK.CHEQUENUMBER                                                                              AS ""Check Number"",
    CHK.CHEQUE_FACT_NK                                                                            AS ""Check ID"",
    CHK.REVENUECENTERNAME                                                                         AS ""Rev Center Name"",
    CHK.REVENUECENTERID                                                                           AS ""Rev Center ID"",
    DPD.DAYPART                                                                                   AS ""Meal Period/Day Part Name"",
    CHK.DAYPART_DIM_FK                                                                            AS ""Meal Period/Day Part ID"",
    TO_CHAR(CONVERT_TIMEZONE(''UTC'', LOC.TZ_NAME, chk.OPENED_AT::timestamp_ntz)::timestamp)::DATE  AS ""Ticket Open"",
    TO_CHAR(CONVERT_TIMEZONE(''UTC'', LOC.TZ_NAME, chk.CLOSED_AT::timestamp_ntz)::timestamp)::DATE  AS ""Ticket Closed"",
    ORD.ORDER_TYPE                                                                                AS ""Order Type Name"",
    CHK.ORDERTYPE_DIM_FK                                                                          AS ""Order Type ID"",
    EMP.EMPLOYEE_NAME                                                                             AS ""Server Name"",
    CHK.EMPLOYEE_DIM_FK                                                                           AS ""Server ID"",
    CHK.TOTAL::DECIMAL(36, 2)                                                                     AS ""Check Total"",
    CHK.TIP::DECIMAL(36, 2)                                                                       AS ""Check Total Tips"",
    CHK.GRATUITIES::DECIMAL(36, 2)                                                                AS ""Gratuity Total"",
    --columns for debug
    -- CHK.DISCOUNT::DECIMAL(36, 2)                                                               AS ""Discount Total"",
    -- CHK.TAX::DECIMAL(36, 2)                                                                       AS ""Tax Total"",
    -- CHK.GROSS as ""Gross"" --this is not a req column but at the moment it is used for validations.
    -- ,CHK.MTLN_CDC_SEQUENCE_NUMBER   as ""MTLN_CDC_SEQUENCE_NUMBER""

FROM DATAWAREHOUSE.CHEQUE_FACT                                                 CHK
  INNER JOIN DATAWAREHOUSE.LOCATION_DIM                                        LOC
    ON CHK.LOCATION_DIM_FK = LOC.LOCATION_DIM_NK
      AND LOC.DW_ISCURRENTROW
      AND CHK.DW_ISCURRENTROW
      AND NOT CHK.IS_TRAINING
      AND NOT CHK.DW_ISDELETED
      AND CHK.STATUS IN (''Closed'')
      AND (CHK.FISCAL_DATE::date >= :startdate::date
                  AND CHK.FISCAL_DATE::date  <= :enddate::date)
      AND CHK.LOCATION_DIM_FK IN (--351,352
          SELECT table1.value
            FROM table(split_to_table(:locationidS, '',''))  table1)
      -- AND NOT (CHK.STATUS = ''Opened'' AND CHK.FISCAL_DATE::date <= :today::date )
      -- AND CHK.FISCAL_DATE::date >= :lastYearEnd::date
      --         AND CHK.FISCAL_DATE::date <= :today::date
      --         AND CHK.LOCATION_DIM_FK in (
      --           SELECT table1.value
      --              FROM table(split_to_table(:locationidS, '',''))  table1)
  INNER JOIN DATAWAREHOUSE.DAYPART_DIM                                         DPD
    ON CHK.DAYPART_DIM_FK = DPD.DAYPART_DIM_NK
      AND DPD.DW_ISCURRENTROW
 LEFT JOIN DATAWAREHOUSE.ORDERTYPE_DIM                                        ORD
    ON CHK.ORDERTYPE_DIM_FK = ORD.ORDERTYPE_DIM_NK
      AND ORD.DW_ISCURRENTROW
LEFT JOIN DATAWAREHOUSE.EMPLOYEE_DIM                                        EMP
ON CHK.EMPLOYEE_DIM_FK = EMP.EMPLOYEE_DIM_NK
    AND EMP.DW_ISCURRENTROW
LEFT JOIN DATAWAREHOUSE.ORGANIZATION_DIM                                        ORG
ON LOC.ORGANIZATION_DIM_FK = ORG.ORGANIZATION_DIM_NK
    AND ORG.DW_ISCURRENTROW
;
-----------------------------------------------------------------------------------------------------------------------
    --return values from the sproc with validated columns only
     reportSet := (
         SELECT * FROM CHK_DATA_TEMP
     );
--=====================================================================================================================
RETURN TABLE(reportSet);
END';"
PROCEDURE,DATAADMIN,"SP_LOAD_AVERO_DAYPART(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_AVERO_DAYPART""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2020-08-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2029-08-20T14:48:37.661Z''; 
  -- locationid string      := ''[2,3,4,351,352]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');

--=================================================================================================================================
BEGIN
--=================================================================================================================================
reportSet := (  
----------------------------------------------------------------------------------------------------------------------------------
SELECT TO_CHAR(:STARTDATE,''YYYYMMDD'')               AS BUSDATE-- Business Date Date as YYYYMMD
    ,CHF.REVENUECENTER_DIM_FK                       AS RVCNUM -- Revenue Center Number Number--""Revenue center number"" 
    ,RCD.REVENUECENTER                              AS RVCDESC --Revenue Center Description String 40 characters--""Revenue center 
    ,DAD.DAYPART                                    AS DPDESC --Day Part Description String 40 characters Day part description LUNC
    ,TO_CHAR(TIMESTAMPADD(SECONDS,DAS.START_TIME/1000,''2024-01-01''::TIMESTAMP),''HH:MM'')                   
                                                    AS DPSTARTTIME --Day Part Period Start Time Time as HH24:MM 23:59 Start of da                                                 
FROM DATAWAREHOUSE.CHEQUE_FACT                      CHF
  INNER JOIN DATAWAREHOUSE.DAYPART_DIM              DAD
    ON CHF.DAYPART_DIM_FK = DAD.DAYPART_DIM_NK
      AND DAD.DW_ISCURRENTROW
      AND CHF.DW_ISCURRENTROW
      AND CHF.LOCATION_DIM_FK IN (--351,352
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)
      AND NOT CHF.IS_TRAINING
      AND CHF.STATUS in (''Closed'')
          AND (CHF.FISCAL_DATE::date >= :startdate::date 
                AND CHF.FISCAL_DATE::date  <= :enddate::date) 
  INNER JOIN DATAWAREHOUSE.DAYPARTSCHEDULE_DIM        DAS
    ON DAD.DAYPART_DIM_NK = DAS.DAYPART_DIM_FK
      AND DAD.DW_ISCURRENTROW
      AND DAS.DW_ISCURRENTROW 
  INNER JOIN DATAWAREHOUSE.REVENUECENTER_DIM           RCD
    ON RCD.REVENUECENTER_DIM_NK = CHF.REVENUECENTER_DIM_FK
      AND RCD.DW_ISCURRENTROW
    
-- SELECT TO_CHAR(:STARTDATE,''YYYYMMDD'') AS BUSDATE-- Business Date Date as YYYYMMD
--     ,NULL AS RVCNUM -- Revenue Center Number Number--""Revenue center number"" 
--     ,NULL AS RVCDESC --Revenue Center Description String 40 characters--""Revenue center description""
--     ,DAD.DAYPART AS DPDESC --Day Part Description String 40 characters Day part description LUNCH""Day part description""
--     ,DAS.START_TIME AS DPSTARTTIME --Day Part Period Start Time Time as HH24:MM 23:59 Start of day part.
-- FROM DATAWAREHOUSE.DAYPART_DIM                 DAD
--   INNER JOIN DATAWAREHOUSE.DAYPARTSCHEDULE_DIM DAS
--     ON DAD.DAYPART_DIM_NK = DAS.DAYPART_DIM_FK
--       AND DAD.DW_ISCURRENTROW
--       AND DAS.DW_ISCURRENTROW
--       AND DAS.LOCATION_DIM_FK IN (--351,352
--              SELECT table1.value 
--                   FROM table(split_to_table(:locationidS, '',''))  table1)
--     INNER JOIN REVENUECENTER_DIM                RCD
--       ON RCD.LOCATION_DIM_FK = DAD.LOCATION_DIM_FK
--         AND RCD.DW_ISCURRENTROW


--=================================================================================================================================
);
RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,"SP_REPORT_ACCOUNTSUMMARY_SALES(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_ACCOUNTSUMMARY_SALES""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet           resultset;
  -- startdate string    := ''2025-10-05'';  
  -- enddate string      := ''2025-10-09''; 
  -- locationid string   := ''[351]'';
  locationidS string  :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
  
--=========================================================================================
BEGIN
  DROP TABLE IF EXISTS TEMP_SALES;
  
--=========================================================================================== 
CREATE TEMP TABLE TEMP_SALES AS
SELECT 
   itf.LOCATION_DIM_FK                                        AS ""Location ID""
  ,itf.CHEQUE_FACT_FK                                         AS ""Check ID""
  ,itf.ITEM_FACT_NK                                           AS ""Item ID""
  ,itf.FISCAL_DATE                                            AS ""Fiscal Day""
  ------Slicing Dimensions
 , ccd.COGSCATEGORY                                           AS ""By Category""
 , dad.DAYPART                                                AS ""By DayPart""
 , otd.ORDER_TYPE                                             AS ""By Order Type""
 , itf.REVENUECENTERNAME                                      AS ""By Revenue Center""
  ------Facts
  ,IFNULL(vif.VOIDAMOUNT,0)::NUMBER(36,2)                     AS ""Voids""
  ,IFNULL(CASE WHEN itf.ITEMSTATUS = ''Voided'' 
    OR itf.CHECKSTATUS = ''Voided'' 
    THEN 0 ELSE itf.GROSS END,0)::NUMBER(36,2)                          
                                                              AS ""Sales"" 
  ,IFNULL(CASE WHEN itf.ITEMSTATUS = ''Voided'' 
    OR itf.CHECKSTATUS = ''Voided'' 
    THEN 0 ELSE IFNULL(dif.DISCOUNTCHECKAMOUNT,0) 
    + IFNULL(itf.DISCOUNTITEM,0) END,0) ::NUMBER(36,2)        AS ""Discounts""
    
  ,CASE WHEN itf.ITEMSTATUS = ''Voided'' 
    OR itf.CHECKSTATUS = ''Voided'' 
    THEN 0 ELSE dif.DISCOUNTCHECKAMOUNT END ::NUMBER(36,2)    AS ""Check Discounts""

  ,IFNULL(CASE WHEN itf.ITEMSTATUS = ''Voided'' 
    OR itf.CHECKSTATUS = ''Voided'' 
    THEN 0 ELSE itf.DISCOUNTITEM END ,0)::NUMBER(36,2)                   
                                                              AS ""Item Discounts""
                                                              
  ,IFNULL(CASE WHEN itf.ITEMSTATUS = ''Voided'' 
    OR itf.CHECKSTATUS = ''Voided'' 
    THEN 0 ELSE rif.REFUNDAMOUNT END,0)::NUMBER(36,2)         AS ""Refunds""
    
  ,IFNULL(CASE WHEN itf.ITEMSTATUS = ''Voided'' 
    OR itf.CHECKSTATUS = ''Voided'' 
    THEN 0 ELSE itf.APPLIEDAMOUNT END,0)::NUMBER(36,2)        AS ""Net Sales""
  FROM DATAWAREHOUSE.ITEM_FACT                                itf  
      INNER JOIN DATAWAREHOUSE.CHEQUE_FACT                    chk
        ON chk.CHEQUE_FACT_NK = itf.CHEQUE_FACT_FK
          AND chk.STATUS in (''Closed'',''Voided'')
          AND itf.ITEMSTATUS IN (''Added'',''Sent'',''Voided'')
          AND itf.DW_ISCURRENTROW  
          AND chk.DW_ISCURRENTROW  
          AND NOT itf.DW_ISDELETED
          AND NOT itf.IS_TRAINING
          AND (chk.FISCAL_DATE::date >= :startdate::date 
                AND chk.FISCAL_DATE::date  <= :enddate::date)
          AND itf.LOCATION_DIM_FK IN (--351,352
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)
      INNER JOIN DATAWAREHOUSE.ORDERTYPE_DIM                     otd
        ON otd.ORDERTYPE_DIM_NK = itf.ORDERTYPE_DIM_FK
          AND otd.DW_ISCURRENTROW   
      INNER JOIN DATAWAREHOUSE.DAYPART_DIM                       dad
        ON itf.daypart_dim_fk = dad.daypart_dim_nk
          AND dad.DW_ISCURRENTROW 
      INNER JOIN DATAWAREHOUSE.MENUITEMNAME_DIM                  med
         ON med.MENUITEMNAME_DIM_NK = itf.MENUITEMNAME_DIM_FK
           AND med.DW_ISCURRENTROW  
      INNER JOIN DATAWAREHOUSE.REPORTCATEGORY_DIM                meg
        ON med.REPORTCATEGORY_DIM_FK = meg.REPORTCATEGORY_DIM_NK
          AND meg.DW_ISCURRENTROW 
      INNER JOIN DATAWAREHOUSE.COGSCATEGORY_DIM                  ccd
        ON ccd.COGSCATEGORY_DIM_NK = meg.COGSCATEGORY_DIM_FK    
          AND ccd.DW_ISCURRENTROW
      LEFT JOIN (
        SELECT dcf.ITEM_FACT_FK             AS ITEM_FACT_FK
          ,SUM(dcf.ALLOCATED_ITEM_DISCOUNT) AS DISCOUNTCHECKAMOUNT  
         FROM DATAWAREHOUSE.DISCOUNTCHEQUEBYITEM_FACT  dcf                      
          WHERE dcf.DW_ISCURRENTROW
            AND NOT dcf.STATUS  = ''Disabled''
            AND CHEQUESTATUS IN (''Closed'') 
            AND (dcf.FISCAL_DATE::date >= :startdate::date AND dcf.FISCAL_DATE::date  <= :enddate::date)
             AND dcf.LOCATION_DIM_FK IN (--351,352
               SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)
            GROUP BY dcf.ITEM_FACT_FK
          )                                                       dif
                ON itf.ITEM_FACT_NK = dif.ITEM_FACT_FK  
      LEFT JOIN (
        SELECT rcf.ITEM_FACT_FK             AS ITEM_FACT_FK
          ,SUM(rcf.ALLOCATED_ITEM_REFUND)   AS REFUNDAMOUNT 
         FROM DATAWAREHOUSE.REFUNDSCHEQUEBYITEM_FACT        rcf                      
          WHERE rcf.DW_ISCURRENTROW
            AND (rcf.FISCALDATE::date >= :startdate::date AND rcf.FISCALDATE::date  <= :enddate::date)
             AND rcf.LOCATION_DIM_FK IN (--351,352
               SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)
            GROUP BY rcf.ITEM_FACT_FK
            
          )                                                        rif
                ON itf.ITEM_FACT_NK = rif.ITEM_FACT_FK 
        LEFT JOIN (
        SELECT vcf.ITEM_FACT_FK                            AS ITEM_FACT_FK
          ,SUM(vcf.ALLOCATED_ITEM_VOID  * CASE WHEN vcf.VOID_LEVEL = ''item'' THEN vcf.QUANTITY ELSE 1 END)    AS VOIDAMOUNT 
         FROM DATAWAREHOUSE.VOIDCHECKBYITEM_FACT  vcf                   
          WHERE vcf.DW_ISCURRENTROW
            AND (vcf.FISCAL_DATE::date >= :startdate::date AND vcf.FISCAL_DATE::date  <= :enddate::date)
             AND vcf.LOCATION_DIM_FK IN (--351,352
               SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)
            GROUP BY vcf.ITEM_FACT_FK
            
          )                                                       vif
                ON itf.ITEM_FACT_NK = vif.ITEM_FACT_FK 
                
                       
ORDER BY ""Item ID""         
    ;
    
--=========================================================================================== 
 reportSet:= (
SELECT ROW_NUMBER() OVER (ORDER BY INLT1.""Location ID"")   AS ""Support ID"" ,INLT1.* 
  FROM (
    SELECT ''By Category''          AS ""Name"" 
          ,TNS.""By Category""      AS ""Name Group""
          ,TNS.""Location ID""      AS ""Location ID""
          ,SUM(TNS.""Voids"")       AS ""Voids""
          ,SUM(TNS.""Sales"")       AS ""Sales""
          ,SUM(TNS.""Discounts"")   AS ""Discounts""
          ,SUM(TNS.""Refunds"")     AS ""Refunds""
          ,SUM(TNS.""Net Sales"")   AS ""Net Sales""
      FROM TEMP_SALES             TNS
      GROUP BY ""Name""
        ,""Name Group""
        ,""Location ID""
    UNION
    SELECT ''By DayPart''           AS ""Name"" 
          ,TNS.""By DayPart""       AS ""Name Group""
          ,TNS.""Location ID""      AS ""Location ID""
          ,SUM(TNS.""Voids"")       AS ""Voids""
          ,SUM(TNS.""Sales"")       AS ""Sales""
          ,SUM(TNS.""Discounts"")   AS ""Discounts""
          ,SUM(TNS.""Refunds"")     AS ""Refunds""
          ,SUM(TNS.""Net Sales"")   AS ""Net Sales""
      FROM TEMP_SALES             TNS
      GROUP BY ""Name""
        ,""Name Group""
        ,""Location ID""    
    UNION
    SELECT ''By Order Type''        AS ""Name"" 
          ,TNS.""By Order Type""    AS ""Name Group""
          ,TNS.""Location ID""      AS ""Location ID""
          ,SUM(TNS.""Voids"")       AS ""Voids""
          ,SUM(TNS.""Sales"")       AS ""Sales""
          ,SUM(TNS.""Discounts"")   AS ""Discounts""
          ,SUM(TNS.""Refunds"")     AS ""Refunds""
          ,SUM(TNS.""Net Sales"")   AS ""Net Sales""
      FROM TEMP_SALES             TNS
      GROUP BY ""Name""
        ,""Name Group""
        ,""Location ID""   
 UNION
    SELECT ''By Revenue Center''             AS ""Name"" 
          ,TNS.""By Revenue Center""         AS ""Name Group""
          ,TNS.""Location ID""               AS ""Location ID""
          ,SUM(TNS.""Voids"")                AS ""Voids""
          ,SUM(TNS.""Sales"")                AS ""Sales""
          ,SUM(TNS.""Discounts"")            AS ""Discounts""
          ,SUM(TNS.""Refunds"")              AS ""Refunds""
          ,SUM(TNS.""Net Sales"")            AS ""Net Sales""
      FROM TEMP_SALES                      TNS
      GROUP BY ""Name""
        ,""Name Group""
        ,""Location ID""           
 )  INLT1
);

--===========================================================================================
RETURN TABLE(reportSet); 

END';"
PROCEDURE,DATAADMIN,SP_REPORT_SUMMARY(DATE),"CREATE OR REPLACE PROCEDURE ""SP_REPORT_SUMMARY""(""DAY"" DATE)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS '
-- -- =====================================================================================
--Example Call Statement
-- CALL DATAADMIN.SP_REPORT_SUMMARY(''2024-06-13'');
-- GRANT usage ON procedure dataadmin.SP_REPORT_PMIX(timestamp_tz,timestamp_tz,string) TO ROLE HOSPENG_ADMIN;
-- --=========================================================================================
DECLARE 
  reportSet resultset;
  -- day date := ''2024-06-13'';

--=========================================================================================
BEGIN
 reportSet:= (

SELECT DATE(CHK.CLOSED_AT)                                       AS ""Date""
   ,CHK.NET::DECIMAL(18,2)                                       AS ""Net Sales""
   ,CHK.SURCHARGE::DECIMAL(18,2) - CHK.GRATUITIES::DECIMAL(18,2) AS ""Service Charge""
   ,CHK.TAX::DECIMAL(18,2)                                       AS ""Tax Collected""
   --------------------------------
   ,CHK.DISCOUNTITEM                                             AS ""Item Discounts""
   ,CHK.DISCOUNTCHECK                                            AS ""Check Discounts""
   ,CHK.DISCOUNT                                                 AS ""Total Discounts""

  FROM DATAADMIN.CHEQUE_FACT  CHK
    WHERE location_dim_fk = 2
      AND CHK.STATUS = ''Closed''
      AND DATE(CHK.CLOSED_AT) = :day--DATE(''2024-06-13'')


);
RETURN TABLE(reportSet); 
END;
-- ';"
PROCEDURE,DATAADMIN,SP_REPORT_SUMMARY_NETSALES(DATE),"CREATE OR REPLACE PROCEDURE ""SP_REPORT_SUMMARY_NETSALES""(""DAY"" DATE)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS '
-- =====================================================================================
--Example Call Statement
-- CALL DATAADMIN.SP_REPORT_SUMMARY_NETSALES(''2024-06-11'');
-- GRANT usage ON procedure dataadmin.SP_REPORT_SUMMARY_NETSALES(date) TO ROLE HOSPENG_ADMIN;
-- --=========================================================================================
DECLARE 
  reportSet resultset;
  -- day date := ''2024-06-11'';

--=========================================================================================
BEGIN
      DROP TABLE IF EXISTS TEMP_SUM;
      DROP TABLE IF EXISTS TEMP_CAT;
      DROP TABLE IF EXISTS TEMP_DISCHECK;
      DROP TABLE IF EXISTS TEMP_DISITEM;
      DROP TABLE IF EXISTS TEMP_PAY;
      DROP TABLE IF EXISTS TEMP_FISCALDATE;

      SELECT PAY.CHEQUE_FACT_FK
       ,MAX(PAY.FISCALDATE) AS ""Fiscal Date""
          FROM PAYMENTS_FACT PAY
            WHERE PAY.DW_ISCURRENTROW
               AND PAY.FISCALDATE = :day--
       GROUP BY CHEQUE_FACT_FK
     ;

      CREATE TEMP TABLE TEMP_FISCALDATE AS
      SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));
      
      SELECT  MAX(""Fiscal Date"") AS ""Fiscal Date""
          ,SUM(""Net Sales"")      AS ""Net Sales""
          ,SUM(""Service Charge"") AS ""Service Charge""
          ,SUM(""Tax Collected"")  AS ""Tax Collected""
          ,SUM(""Net Sales"") + SUM(""Service Charge"") + SUM(""Tax Collected"")  as ""Total Revenue""

          ,SUM(""Item Discounts"")  AS ""Item Discounts""
          ,SUM(""Check Discounts"") AS ""Check Discounts""
          ,SUM(""Total Discounts"") AS ""Total Discounts""      
      FROM (
        SELECT DATE(FSD.""Fiscal Date"")                                                  AS ""Fiscal Date""
           ,IFNULL(CHK.NET::DECIMAL(18,2),0)  - IFNULL(CHK.SURCHARGE::DECIMAL(18,2),0)  AS ""Net Sales""
           ,IFNULL(CHK.SURCHARGE::DECIMAL(18,2),0)                                      AS ""Service Charge""
           ,IFNULL(CHK.TAX::DECIMAL(18,2),0)                                            AS ""Tax Collected""
           --------------------------------
           ,CHK.DISCOUNTITEM                                             AS ""Item Discounts""
           ,CHK.DISCOUNTCHECK                                            AS ""Check Discounts""
           ,CHK.DISCOUNT                                                 AS ""Total Discounts""
        
          FROM DATAADMIN.CHEQUE_FACT  CHK
            INNER JOIN TEMP_FISCALDATE                            fsd
            ON fsd.CHEQUE_FACT_FK = CHK.CHEQUE_FACT_nK
               AND ""Fiscal Date"" = :day--DATE(''2024-06-11'')--:day
               AND location_dim_fk = 2
               AND CHK.DW_ISCURRENTROW
               AND NOT CHK.DW_ISDELETED
               AND NOT CHK.IS_TRAINING
               AND CHK.STATUS = ''Closed''
               -- AND DATE(CHK.CLOSED_AT) = DATE(''2024-06-11'')--:day--
        ) GROUP BY ""Fiscal Date"" ;

         CREATE TEMP TABLE TEMP_SUM AS
             SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

        ---------------------------------------------------------
        SELECT IFNULL(meg.REPORTCATEGORY,''None'')                  as ""Category""
           ,itf.net  AS ""NET""
        FROM DATAADMIN.ITEM_FACT                              itf
         INNER JOIN DATAADMIN.MENUITEMNAME_DIM                med
           ON med.MENUITEMNAME_DIM_NK = itf.MENUITEMNAME_DIM_FK
              AND itf.ITEMSTATUS IN (''Added'',''Sent'')
              AND itf.CHECKSTATUS = ''Closed''
              AND itf.OPENED_AT is not null
              AND itf.DW_ISCURRENTROW  
              AND med.DW_ISCURRENTROW  
              AND NOT itf.DW_ISDELETED
              AND NOT itf.IS_TRAINING
              AND itf.LOCATION_DIM_FK = 2 
              --AND DATE(itf.closed_at) =  DATE(''2024-06-11'')--:day--
          INNER JOIN DATAADMIN.REPORTCATEGORY_DIM               meg
            ON med.REPORTCATEGORY_DIM_FK = meg.REPORTCATEGORY_DIM_NK
              AND med.DW_ISCURRENTROW = TRUE
          INNER JOIN TEMP_FISCALDATE                            fsd
            ON fsd.CHEQUE_FACT_FK = itf.CHEQUE_FACT_FK
               AND ""Fiscal Date"" = :day--DATE(''2024-06-11'')--DATE(''2024-06-11'')--:day--
           ;

         CREATE TEMP TABLE TEMP_CAT AS
             SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

    --------------------------------------------------------------------------------------
SELECT CHF.CHEQUENUMBER
    ,CHF.CHEQUE_FACT_FK
    ,CHF.APPLIED_AMOUNT  ::NUMBER(18,2)      AS ""Discount Amount"" 
    ,CHK.DISCOUNTCHECK
    ,SUM(CHF.APPLIED_AMOUNT) OVER (PARTITION BY 1) AS TOT_DET
    ,SUM(CHK.DISCOUNTCHECK) OVER (PARTITION BY 1) AS TOT_SUM    
    ,CHF.MTLN_CDC_SEQUENCE_NUMBER
    ,CHK.MTLN_CDC_SEQUENCE_NUMBER
    ,STD.STANDARDDISCOUNTNAME AS ""Discount Name""
    
  FROM DATAADMIN.DISCOUNTCHECK_FACT                     CHF
    INNER JOIN DATAADMIN.CHEQUE_FACT                  CHK
      ON CHF.CHEQUE_FACT_FK = CHK.CHEQUE_FACT_NK
         AND CHF.LOCATION_DIM_FK = 2
         -- AND DATE(CHK.CLOSED_AT) =  DATE(''2024-06-11'')--:day--
         AND CHF.DW_ISCURRENTROW
         AND NOT CHF.DW_ISDELETED
         AND NOT CHF.IS_TRAINING
         AND CHK.DW_ISCURRENTROW
         AND NOT CHK.DW_ISDELETED
         AND NOT CHK.IS_TRAINING
         AND CHK.STATUS = ''Closed''
    INNER JOIN TEMP_FISCALDATE                            fsd
            ON fsd.CHEQUE_FACT_FK = CHf.CHEQUE_FACT_FK
              AND ""Fiscal Date"" = :day--DATE(''2024-06-11'')--         DATE(''2024-06-11'')--
    INNER JOIN DATAADMIN.STANDARDDISCOUNT_DIM         STD
               ON STD.STANDARDDISCOUNT_DIM_NK = CHF.STANDARDDISCOUNT_DIM_FK
                 AND STD.DW_ISCURRENTROW    
                 ;
                 
    CREATE TEMP TABLE TEMP_DISCHECK AS
             SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));
-------------------------------------------------------
SELECT CHF.CHEQUENUMBER
    ,CHF.CHEQUE_FACT_FK
    ,CHF.APPLIED_AMOUNT  ::NUMBER(18,2)      AS ""Discount Amount"" 
    ,CHK.DISCOUNTCHECK
    ,SUM(CHF.APPLIED_AMOUNT) OVER (PARTITION BY 1) AS TOT_DET
    ,SUM(CHK.DISCOUNTCHECK) OVER (PARTITION BY 1) AS TOT_SUM    
    ,CHF.MTLN_CDC_SEQUENCE_NUMBER
    ,CHK.MTLN_CDC_SEQUENCE_NUMBER
    ,STD.STANDARDDISCOUNTNAME AS ""Discount Name""
    
FROM DATAADMIN.DISCOUNTITEM_FACT                     CHF
    INNER JOIN DATAADMIN.CHEQUE_FACT                  CHK
      ON CHF.CHEQUE_FACT_FK = CHK.CHEQUE_FACT_NK
         AND CHF.LOCATION_DIM_FK = 2
         -- AND DATE(CHK.CLOSED_AT) =  DATE(''2024-06-11'')--:day--
         AND CHF.DW_ISCURRENTROW
         AND NOT CHF.DW_ISDELETED
         AND NOT CHF.IS_TRAINING
         AND CHK.DW_ISCURRENTROW
         AND NOT CHK.DW_ISDELETED
         AND NOT CHK.IS_TRAINING
         -- AND CHK.STATUS = ''Closed''
    INNER JOIN TEMP_FISCALDATE                            fsd
            ON fsd.CHEQUE_FACT_FK = CHf.CHEQUE_FACT_FK
              AND ""Fiscal Date"" = :day--DATE(''2024-06-11'')--         
    INNER JOIN DATAADMIN.STANDARDDISCOUNT_DIM         STD
               ON STD.STANDARDDISCOUNT_DIM_NK = CHF.STANDARDDISCOUNT_DIM_FK
                 AND STD.DW_ISCURRENTROW    
                 ;
                 
    CREATE TEMP TABLE TEMP_DISITEM AS
             SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));       
------------------------------------------------------------- 

SELECT CHK.CHEQUE_FACT_NK
   ,PAY.CHEQUENUMBER
   ,PAD.PAYMENTMETHODNAME
   ,OTD.ORDER_TYPE  AS ""Order Type""
   ,pay.cardbrand   AS ""Card Brand"" 
   ,PAY.AMOUNTAPPLIEDTOCHECK
   ,CASE WHEN PAD.PAYMENTMETHODNAME = ''Cash'' THEN pay.AMOUNTAPPLIEDTOCHECK::DECIMAL(18,2) else pay.TOTAL::DECIMAL(18,2) end as ""Amount""

FROM DATAADMIN.CHEQUE_FACT  CHK
  INNER JOIN PAYMENTS_FACT  PAY
     ON CHK.CHEQUE_FACT_NK = PAY.CHEQUE_FACT_FK
       AND PAY.DW_ISCURRENTROW
       AND CHK.location_dim_fk = 2
       AND CHK.DW_ISCURRENTROW
       AND NOT CHK.DW_ISDELETED
       AND NOT CHK.IS_TRAINING
       AND CHK.STATUS = ''Closed''
       AND PAY.PAYMENTSTATUS = ''Success''
       AND date(pay.fiscaldate) = :day  --DATE(''2024-06-11'')--''2024-06-11''
       --AND DATE(CHK.CLOSED_AT) = :day--
    INNER JOIN PAYMENTMETHOD_DIM PAD
      ON PAY.PAYMENTMETHOD_DIM_FK = PAD.PAYMENTMETHOD_DIM_NK
        AND PAD.DW_ISCURRENTROW 
    INNER JOIN ORDERTYPE_DIM   OTD
      ON OTD.ORDERTYPE_DIM_NK = CHK.ORDERTYPE_DIM_FK
        AND OTD.DW_ISCURRENTROW
        ;
        
CREATE TEMP TABLE TEMP_PAY AS
             SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));          
-------------------------------------------------------------         
 reportSet:= ( 
      SELECT "" "",""  "" from (
            
        SELECT 0 as ""Order"",''Fiscal Date '' || ""Fiscal Date""::DATE as "" "" , NULL as ""  "" FROM TEMP_SUM
        
        UNION
        SELECT 1 as ""Order"",''Net Sales'' as "" ""  ,""Net Sales""::DECIMAL(18,2)  as ""  "" FROM TEMP_SUM
        
        UNION
        SELECT 2 as ""Order"",''Service Charge'' as "" ""  ,""Service Charge""::DECIMAL(18,2) FROM TEMP_SUM
        
        UNION
        SELECT 3 as ""Order"",''Tax Collected'' as "" ""  ,""Tax Collected""::DECIMAL(18,2) FROM TEMP_SUM
        
        UNION
        SELECT 4 as ""Order"",''Total Revenue'' as "" ""  ,""Total Revenue""::DECIMAL(18,2) FROM TEMP_SUM
        
         UNION
        SELECT 5 as ""Order"",''  '' as "" ""  , NULL 

        UNION
        SELECT 6 as ""Order"",''Item Discounts'' as "" ""  ,""Item Discounts""::DECIMAL(18,2) FROM TEMP_SUM
        
        UNION
        SELECT 7 as ""Order"",''Check Discounts'' as "" ""  ,""Check Discounts""::DECIMAL(18,2) FROM TEMP_SUM
        
        UNION
        SELECT 8 as ""Order"",''Total Discounts'' as "" ""  , ""Total Discounts""::DECIMAL(18,2) FROM TEMP_SUM

        UNION
        SELECT 9 as ""Order"",''  '' as "" ""  , NULL 
----------------
        UNION
        SELECT  10  ,""Order Type"", sum(""Amount"")::DECIMAL(18,2) from TEMP_pay    group by ""Order Type""
        
        UNION
        SELECT  11  ,''Total'', sum(""Amount"")::DECIMAL(18,2) from TEMP_pay 
  -----------------------      
        
        UNION
        SELECT 12 as ""Order"",''  '' as "" ""  , NULL 

        UNION 
        SELECT 13 as ""Order"", ""Category"" ,SUM(""NET"")::DECIMAL(18,2) FROM TEMP_CAT GROUP BY ""Category""
          
        UNION 
        SELECT 14 as ""Order"",''Total''    ,SUM(""NET"")::DECIMAL(18,2) FROM TEMP_CAT

        UNION
        SELECT 15 ,''   ''   , NULL 
        
        --DISCOUNTS
        UNION
        SELECT  16  ,""Discount Name"", sum(""Discount Amount"") from TEMP_DISCHECK group by ""Discount Name""
        
        UNION
        SELECT  17  ,''Total'', sum(""Discount Amount"") from TEMP_DISCHECK

        UNION
        SELECT  18  ,""Discount Name"", sum(""Discount Amount"") from TEMP_DISITEM group by ""Discount Name""
        
        UNION
        SELECT  19  ,''Total'', sum(""Discount Amount"") from TEMP_DISITEM
        
        -- --- CC PAYMENTS
        UNION
        SELECT 20 ,''   ''   , NULL 
        
        UNION
        SELECT  21  ,""Card Brand"", sum(""Amount"")::DECIMAL(18,2) from TEMP_pay where PAYMENTMETHODNAME = ''EPX''  group by ""Card Brand""
        
        UNION
        SELECT  22  ,''Total With AMEX'', sum(""Amount"")::DECIMAL(18,2) from TEMP_pay where PAYMENTMETHODNAME = ''EPX''
        
        UNION
        SELECT  23  ,''Total Without AMEX'', sum(""Amount"")::DECIMAL(18,2) from TEMP_pay where PAYMENTMETHODNAME = ''EPX'' and ""Card Brand"" <> ''American Express''

        UNION
        SELECT 24 ,''   ''   , NULL 
        
        UNION
        SELECT  25  ,''Cash Total'', sum(""Amount"") from TEMP_pay where PAYMENTMETHODNAME = ''Cash''
        
        ) order by ""Order""
      );

RETURN TABLE(reportSet); 
END;
-- ';"
PROCEDURE,DATAADMIN,SP_STAGELOADDAYPART_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADDAYPART_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.DAYPART_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.DAYPART_DIM(   
          DAYPART_DIM_NK, 
          DAYPART, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          ORGANIZATION_DIM_FK, 
          DELETED_AT, 
          CREATED_AT, 
          UPDATED_AT 
) 
 SELECT   DAYPART_DIM_NK  as   DAYPART_DIM_NK,  
   DAYPART  as   DAYPART,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   ORGANIZATION_DIM_FK  as   ORGANIZATION_DIM_FK,  
   DELETED_AT  as   DELETED_AT,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT 
  FROM DATAADMIN.DAYPART_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''DAYPART_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''DAYPART_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADDISCOUNTREASON_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADDISCOUNTREASON_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.DISCOUNTREASON_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.DISCOUNTREASON_DIM(   
          DISCOUNTREASON_DIM_NK, 
          DISCOUNTREASON, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          IS_ENABLED, 
          CREATED_AT, 
          UPDATED_AT, 
          DESCRIPTION 
) 
 SELECT   DISCOUNTREASON_DIM_NK  as   DISCOUNTREASON_DIM_NK,  
   DISCOUNTREASON  as   DISCOUNTREASON,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   IS_ENABLED  as   IS_ENABLED,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   DESCRIPTION  as   DESCRIPTION 
  FROM DATAADMIN.DISCOUNTREASON_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''DISCOUNTREASON_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''DISCOUNTREASON_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADTAX_FACT(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADTAX_FACT""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.TAX_FACT),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.TAX_FACT(   
          TAX_FACT_NK, 
          TAXRATENAME, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          CHEQUE_FACT_FK, 
          DAYPART_DIM_FK, 
          EMPLOYEE_DIM_FK, 
          ITEM_FACT_FK, 
          LOCATION_DIM_FK, 
          MENUITEM_DIM_FK, 
          MENUITEMNAME_DIM_FK, 
          ORDERTYPE_DIM_FK, 
          TAX_RATE_ID, 
          IS_TRAINING, 
          IS_TAX_INCLUDED, 
          CLOSED_AT, 
          CREATED_AT, 
          FISCAL_DATE, 
          OPENED_AT, 
          UPDATED_AT, 
          CHECKSTATUS, 
          ITEMSTATUS, 
          REVENUECENTERNAME, 
          ROUNDINGMETHOD, 
          CHEQUENUMBER, 
          ITEM_ID, 
          CHECKTOTALINCLUSIVETAX, 
          CHECKTOTALTAX, 
          AMOUNT, 
          PERCENT 
) 
 SELECT   TAX_FACT_NK  as   TAX_FACT_NK,  
   TAXRATENAME  as   TAXRATENAME,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   CHEQUE_FACT_FK  as   CHEQUE_FACT_FK,  
   DAYPART_DIM_FK  as   DAYPART_DIM_FK,  
   EMPLOYEE_DIM_FK  as   EMPLOYEE_DIM_FK,  
   ITEM_FACT_FK  as   ITEM_FACT_FK,  
   LOCATION_DIM_FK  as   LOCATION_DIM_FK,  
   MENUITEM_DIM_FK  as   MENUITEM_DIM_FK,  
   MENUITEMNAME_DIM_FK  as   MENUITEMNAME_DIM_FK,  
   ORDERTYPE_DIM_FK  as   ORDERTYPE_DIM_FK,  
   TAX_RATE_ID  as   TAX_RATE_ID,  
   IS_TRAINING  as   IS_TRAINING,  
   IS_TAX_INCLUDED  as   IS_TAX_INCLUDED,  
   CLOSED_AT  as   CLOSED_AT,  
   CREATED_AT  as   CREATED_AT,  
   FISCAL_DATE  as   FISCAL_DATE,  
   OPENED_AT  as   OPENED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   CHECKSTATUS  as   CHECKSTATUS,  
   ITEMSTATUS  as   ITEMSTATUS,  
   REVENUECENTERNAME  as   REVENUECENTERNAME,  
   ROUNDINGMETHOD  as   ROUNDINGMETHOD,  
   CHEQUENUMBER  as   CHEQUENUMBER,  
   ITEM_ID  as   ITEM_ID,  
   CHECKTOTALINCLUSIVETAX  as   CHECKTOTALINCLUSIVETAX,  
   CHECKTOTALTAX  as   CHECKTOTALTAX,  
   AMOUNT  as   AMOUNT,  
   PERCENT  as   PERCENT 
  FROM DATAADMIN.TAX_FACT
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''TAX_FACT'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''TAX_FACT'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,"SP_LOAD_AVERO_CHECKHEADER(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_AVERO_CHECKHEADER""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2020-08-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2029-08-20T14:48:37.661Z''; 
  -- locationid string      := ''[2,3,4,351,352]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--=================================================================================================================================
BEGIN
--=================================================================================================================================
reportSet := (  
----------------------------------------------------------------------------------------------------------------------------------
SELECT CHF.FISCAL_DATE    AS BUSDATE --Business Day Date as YYYYMMDD 8 digits(99991231)fiscal day of check20110101
,CHF.REVENUECENTER_DIM_FK AS RVCNUM -- Revenue Center Number Number 12 digits(999999999999)Unique identifier for the revenuecenter 
,CHF.REVENUECENTERNAME    AS RVCDESC --Revenue CenterDescriptionString 40 characters Description of the revenue center
,CHF.CHEQUE_FACT_NK       AS CHKSEQ --Unique check sequence identifier String
,CHF.CHEQUENUMBER         AS CHKNUM --Check number Number
,CHF.EMPLOYEE_DIM_FK      AS EMPNUM -- Employee Number Number 12 digit(999999999999)Unique identifier for check owner
,EMD.EMPLOYEE_NAME        AS EMPDESC --Employee Description String 40 characters First and Last Name of check owning employee
,SHD.JOBPOSITION_DIM_FK   AS EMPCLASS --NUM Employee Class Number Number 12 digit (999999999999)Employee class number
,JPD.JOB_POSITION         AS EMPCLASSDESC   --Employee ClassDescription string 40 characters Class Description of employee
,TO_CHAR(TO_DATE(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHF.OPENED_AT::timestamp_ntz )),''YYYYMMDD'')
                          AS CHKOPENDAY --Check Open Day YYYYMMDD 8 digits(99991231)Actual calendar date check opened 20110101
,TO_CHAR(TO_TIMESTAMP(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHF.OPENED_AT::timestamp_ntz )),''HH24:MI:SS'')
                          AS CHKOPENTIME --Check Open Time Time as HH24:MM 23:59 Time the check was opened, inlocal time11:10
,TO_CHAR(TO_DATE(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHF.CLOSED_AT::timestamp_ntz )),''YYYYMMDD'')
                          AS CHKCLOSEDAY  --Check Close Day Date as YYYYMMDD 8 digits(99991231)calendar date check closed20110101
,TO_CHAR(TO_TIMESTAMP(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHF.CLOSED_AT::timestamp_ntz )),''HH24:MI:SS'')
                          AS CHKCLOSETIME --Check Close Time Time as HH24:MM 23:59 Time the check was closed. inlocal time13:40
,CHF.PARTY_COUNT::NUMBER(12,0) AS COVERS  --Count Number 12 digits(999999999999)Number of covers, or guests, onthe check.4
FROM DATAWAREHOUSE.CHEQUE_FACT          CHF
  INNER JOIN DATAWAREHOUSE.EMPLOYEE_DIM EMD
    ON EMD.EMPLOYEE_DIM_NK = CHF.EMPLOYEE_DIM_FK
      AND CHF.DW_ISCURRENTROW
      AND EMD.DW_ISCURRENTROW
      AND CHF.LOCATION_DIM_FK IN (--351,352
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)
      AND NOT CHF.IS_TRAINING
      AND CHF.DW_ISCURRENTROW
      AND CHF.STATUS in (''Closed'')
          AND (CHF.FISCAL_DATE::date >= :startdate::date 
                AND CHF.FISCAL_DATE::date  <= :enddate::date)
  INNER JOIN DATAWAREHOUSE.LOCATION_DIM                 LOC
    ON LOC.LOCATION_DIM_NK = CHF.LOCATION_DIM_fK
      AND CHF.DW_ISCURRENTROW
      AND LOC.DW_ISCURRENTROW
  INNER JOIN DATAWAREHOUSE.SHIFT_DIM                    SHD
    ON SHD.SHIFT_DIM_NK = CHF.SHIFT_DIM_FK
      AND SHD.DW_ISCURRENTROW
  INNER JOIN DATAWAREHOUSE.JOBPOSITION_DIM              JPD
    ON JPD.JOBPOSITION_DIM_NK = SHD.JOBPOSITION_DIM_FK
      AND JPD.DW_ISCURRENTROW
--=================================================================================================================================
);
RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,"SP_REPORT_ACCOUNTSUMMARY_PAYMENTS_FEES(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_ACCOUNTSUMMARY_PAYMENTS_FEES""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet           resultset;
  -- startdate string    := ''2020-07-10'';  
  -- enddate string      := ''2029-07-10''; 
  -- locationid string   := ''[351]'';
  locationidS string  :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--=========================================================================================
BEGIN
  DROP TABLE IF EXISTS TEMP_TABLE1;

------------------------------------------------------------------------------------------------  
 CREATE TEMP TABLE TEMP_TABLE1 AS
 SELECT suf.LOCATION_DIM_FK                                             as ""Location ID"" 
    ,IfNULL(replace(replace(sud.type,''Fixed'',''Fixed ''),''Open'',''Open '')
      || case when sud.type ilike(''%Amount'') then  '' $'' else '' ''  end
      || to_char((sud.fixed_value/1000000)::decimal(15,2)),''None'') 
      || CASE WHEN sud.type ilike(''%Percent'') then ''%'' else '' '' end
                                                                        as ""Rate""
    ,sud.SURCHARGE                                                      as ""Surcharge""
    ,SUM(1)::NUMBER(18,0)                                               as ""Count""
    ,SUM(SUF.APPLIEDAMOUNT)::NUMBER(18,2)                               as ""Total""  
FROM DATAWAREHOUSE.CHEQUE_FACT                                          CHK
      INNER JOIN DATAWAREHOUSE.SURCHARGE_FACT                           SUF
          ON SUF.CHEQUE_FACT_FK = CHK.CHEQUE_FACT_NK
             AND CHK.DW_ISCURRENTROW
             AND SUF.DW_ISCURRENTROW
             AND NOT CHK.DW_ISDELETED
             AND NOT CHK.IS_TRAINING
             AND CHK.STATUS = ''Closed''
             AND NOT SUF.STATUS = ''Disabled''
             -- AND NOT SUF.IS_GRATUITY
             AND CHK.FISCAL_DATE::date
                >= :startdate::date 
            AND CHK.FISCAL_DATE::date  
                <= :enddate::date 
            AND CHK.LOCATION_DIM_FK IN ( 
               SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)
      INNER JOIN DATAWAREHOUSE.SURCHARGE_DIM           SUD
        ON SUF.SURCHARGE_DIM_NK = SUD.SURCHARGE_DIM_NK
          AND SUD.DW_ISCURRENTROW
GROUP BY  
  ""Rate""
  ,""Surcharge""
  ,""Location ID"" 
;

--=========================================================================================
 reportSet:= (
 SELECT  ROW_NUMBER() OVER (ORDER BY ""Location ID"")  AS  ""Support ID"" 
   ,*   
 FROM TEMP_TABLE1
);

--===========================================================================================
RETURN TABLE(reportSet); 

END';"
PROCEDURE,DATAADMIN,"SP_REPORT_BATCH(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_BATCH""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2000-11-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2029-11-20T14:48:37.661Z''; 
  -- locationid string      := ''[351,3,2]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--===============================================================================================================
BEGIN
 reportSet := (
        SELECT cct.CCTRANSACTION_fact_nk                 as ""Support ID"" 
         , to_char(cct.CCTRANSACTION_fact_nk)            as ""Support ID STR"" 
         , ''BAT-'' ||row_number() over (order by cct.CCTRANSACTION_fact_nk) 
                                                         as ""Detail ID""        
--status, category, level-------------------------------------------------------------------
          ,IFNULL(cct.status,''None'')                      as ""Status""       
-- --geography--------------------------------------------------------------------------------      
          ,IFNULL(loc.locationname,''None'')                as ""Location""
          ,CCT.LOCATION_DIM_FK::decimal(36,0)             as ""Location ID""          
 --dates-------------------------------------------------------------------------------------
     ,LOC.TZ_NAME                                         as ""Time Zone""
    ,to_char(LEFT(cct.FISCAL_DAY,4))                      as ""Year""
    ,to_char(YEAR(cct.FISCAL_DAY::DATE)) || ''|'' || TO_CHAR(RIGHT(''0'' || MONTH(cct.FISCAL_DAY::DATE),2))
                                                          as ""Year and Month""
    ,to_char(cct.FISCAL_DAY)                              as ""Fiscal Day""
    ,IFNULL(DAYNAME(cct.FISCAL_DAY),''None'')               as ""Day of Week""
    ,CASE WHEN DAYNAME(cct.FISCAL_DAY) IN (''Sat'',''Sun'')  
          THEN TRUE ELSE FALSE END                        as ""Is Weekend""       
     ,left(to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CCT.AUTH_TRAN_GMT::timestamp_ntz )::timestamp ),16)
                                                          as ""Transaction Date""
-- --people-------------------------------------------------------------------------------------
    ,IFNULL(emd.EMPLOYEE_NAME,''None'')                     as ""Employee""
    ,CASE WHEN to_char(cct.COMMAND) = ''Capture''
      AND cct.status = ''Success''
     THEN TRUE ELSE FALSE END                             as ""Valid Transaction""
-- --Descriptors--------------------------------------------------------------------------------    
          ,IFNULL(to_char(cct.BATCH_DIM_FK),''None'')       as ""Batch""
          ,IFNULL(to_char(cct.COMMAND),''None'')            as ""Type""
          ,IFNULL(to_char(cct.TRANSACTION_NUMBER),''None'') as ""Transaction NO""
          ,IFNULL(to_char(cct.APPROVAL),''None'')           as ""Approval""
          ,IFNULL(to_char(cct.AUTH_BRIC),''None'')          as ""BRIC""
          ,IFNULL(to_char(cct.CARD_ENTRY_METHOD),''None'')  as ""Card Entry""
          ,IFNULL(to_char(cct.POS_TERMINAL_ID),''None'')    as ""Terminal ID""
          ,IFNULL(to_char(cct.REFERENCE_NUMBER),''None'')   as ""Reference Number""
          ,IFNULL(to_char(cct.AUTHORIZATION_CODE),''None'') as ""Auth Code""
          ,IFNULL(TO_CHAR(cct.CARDHOLDER_LOCATION),''None'')as ""Cardholder Location""
          ,IFNULL( cct.CARD_TYPE ,''None'')                 as ""Card Brand""            
          ,IFNULL(cct.CARDHOLDER_NAME,''None'')             as ""Cardholder Name""
          ,IFNULL(cct.MASKED_CC_NUMBER,''None'')            as ""Card Last 4 Digits""
                                                      
--  --Facts--------------------------------------------------------------------------------------  
         ,1::NUMBER(18,0)                                 as ""Count""
         ----------------------------------------------------------------------------------------
         ,case when cct.COMMAND = ''Capture''
           THEN cct.TOTAL END::DECIMAL(18,2)              as ""Credit Card Total""
          ,case when cct.STATUS = ''Declined''
           THEN cct.TOTAL END::DECIMAL(18,2)              as ""Declined Total""
          ,case when cct.COMMAND = ''Refund'' AND cct.STATUS = ''Success''
           THEN cct.TOTAL END::DECIMAL(18,2)              as ""Refund Total""
         ,case when cct.COMMAND = ''Void''   AND cct.STATUS = ''Success''
           THEN cct.TOTAL END::DECIMAL(18,2)              as ""Void Total""           
         ----------------------------------------------------------------------------------------
         ,case when cct.CARD_TYPE = ''Visa'' and cct.COMMAND = ''Capture''
               then cct.TOTAL end::DECIMAL(18,2)          as ""Visa Total""           --Gross sales of al Visa trans
          ,case when cct.CARD_TYPE = ''American Express'' and cct.COMMAND = ''Capture''
               then cct.TOTAL end::DECIMAL(18,2)          as ""Amex Total""           --Gross sales of all Amex transactions
          ,case when cct.CARD_TYPE = ''Mastercard'' and cct.COMMAND = ''Capture''
              then cct.TOTAL end::DECIMAL(18,2)           as ""Mastercard Total""     --Gross sales of all Mastercard transactions
          ,case when cct.CARD_TYPE = ''Discover'' and cct.COMMAND = ''Capture''
            then cct.TOTAL end::DECIMAL(18,2)             as ""Discover Total""       --Gross sales of all Discover transactions
          ,case when cct.CARD_TYPE= ''Citi'' and cct.COMMAND = ''Capture''
               then cct.TOTAL end::DECIMAL(18,2)          as ""Citi Total""   
         ----------------------------------------------------------------------------------------               
          ,cct.TIP::DECIMAL(18,2)                         as ""Tip""   
          ,cct.TOTAL::DECIMAL(18,2)                       as ""Total""     
        FROM DATAWAREHOUSE.CCTRANSACTION_FACT                 cct
          INNER JOIN DATAWAREHOUSE.location_DIM               loc
            ON cct.location_DIM_FK = loc.location_DIM_NK
              AND cct.FISCAL_DAY::date >= :startdate::date 
              AND cct.FISCAL_DAY::date <= :enddate::date  
              AND (cct.COMMAND in (''Capture'',''Refund'',''Void'',''GoodFaith'',''StoreAndForward'')
                AND cct.STATUS in (''Success'', ''Declined'')
                )
              AND cct.LOCATION_DIM_FK in (
                SELECT table1.value 
                   FROM table(split_to_table(:locationidS, '',''))  table1) 
              AND cct.dw_iscurrentrow
              AND loc.dw_iscurrentrow
              AND NOT cct.dw_isdeleted
          LEFT JOIN DATAWAREHOUSE.employee_DIM                     emd
            ON emd.employee_DIM_NK = cct.EMPLOYEE_DIM_FK
              AND emd.dw_iscurrentrow                          
--===============================================================================================================
); 
 RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,SP_SEND_HARD_FAILS_OVER_SLACK(),"CREATE OR REPLACE PROCEDURE ""SP_SEND_HARD_FAILS_OVER_SLACK""()
RETURNS VARCHAR
LANGUAGE PYTHON
RUNTIME_VERSION = '3.11'
PACKAGES = ('snowflake-snowpark-python')
HANDLER = 'send_hard_fail_alert'
EXTERNAL_ACCESS_INTEGRATIONS = (SLACK_EXTERNAL_ACCESS_INTEGRATION)
SECRETS = ('webhook_secret'=DATAADMIN.SLACK_WEBHOOK_PROD_DATAWAREHOUSE_ALERTS)
EXECUTE AS CALLER
AS '
""""""
-- Description:
--   Monitors for and reports ""hard fails"" of Snowflake Tasks. A hard fail is a critical
--   error that prevents a task from completing, such as a SQL compilation error, permission
--   issue, or warehouse problem, resulting in a ''FAILED'' state.
--
--   The procedure operates statefully:
--   1. It determines the last time it ran by checking for the most recent hard fail logged in
--      the `dataadmin.error_logs` table, creating an efficient, overlapping time window.
--   2. It queries `information_schema.task_history` to find any new task failures.
--   3. It cross-references these failures against its own log to ensure alerts are not duplicated.
--   4. New failures are formatted into a detailed critical alert and sent to a Slack channel.
--   5. Only AFTER a successful Slack notification, it records the failures in the
--      `dataadmin.error_logs` table to prevent re-alerting in the future.
--
--   This procedure is designed to be run on a simple schedule (e.g., every 15 minutes) by a
--   master monitoring task to provide near real-time alerts on pipeline infrastructure failures.
--
-- Parameters:
--   This procedure does not accept any parameters.
--
-- Returns:
--   VARCHAR: A status message indicating the outcome of the operation.
--     - ''No new hard fails to report.'' -> No new task failures were found.
--     - ''Successfully reported and logged {failure_count} hard fail(s).'' -> On success.
--     - A descriptive error message if the API call to Slack fails. The procedure will halt
--       without logging the errors to ensure they are picked up on the next run.
""""""
import _snowflake
import json
import urllib.request
from snowflake.snowpark.functions import col, lit, max as sp_max, coalesce, dateadd, current_timestamp, concat, call_function
from collections import defaultdict

def trim_message(message, max_len=800, front_len=200, back_len=300):
    message = message.replace(''`'', ""''"")
    if len(message) > max_len:
        return message[:front_len] + ""... (trimmed) ..."" + message[-back_len:]
    return message

def send_hard_fail_alert(session):
    # 1. Determine the start time for the search.
    # This query finds the last hard fail''s timestamp, subtracts 1 hour as a safety margin,
    # and defaults to a 24-hour lookback if no previous hard fails have been logged.
    ts_query = """"""
        SELECT DATEADD(''hour'', -1, COALESCE(
            (SELECT MAX(event_timestamp) FROM dataadmin.error_logs WHERE error_type_id = 1),
            DATEADD(''hour'', -24, CURRENT_TIMESTAMP())
        ))
    """"""
    last_check_ts = session.sql(ts_query).collect()[0][0]

    # 2. Query information_schema.task_history for new failed tasks.
    task_history_df = session.sql(f""""""
        SELECT
            GRAPH_RUN_GROUP_ID,
            ATTEMPT_NUMBER,
            NAME,
            STATE,
            ERROR_CODE,
            ERROR_MESSAGE,
            QUERY_ID,
            COMPLETED_TIME
        FROM TABLE(information_schema.task_history(
            SCHEDULED_TIME_RANGE_START => TO_TIMESTAMP_LTZ(''{last_check_ts}''),
            ERROR_ONLY => TRUE
        ))
    """""")

    # 3. Exclude records that have already been reported in error_logs.
    # We create a unique run key to identify distinct task runs.
    existing_logs_df = session.table(''dataadmin.error_logs'').filter(col(''ERROR_TYPE_ID'') == 1).select(
        concat(col(''TASK_RUN_GROUP_ID''), lit(''|''), col(''ATTEMPT_NUMBER'')).alias(''RUN_KEY'')
    )

    new_failures_df = task_history_df.withColumn(
        ''RUN_KEY'', concat(col(''GRAPH_RUN_GROUP_ID''), lit(''|''), col(''ATTEMPT_NUMBER''))
    ).join(
        existing_logs_df,
        [''RUN_KEY''],
        ''left_anti''
    )

    # Cache the result to materialize the list of new failures.
    new_failures_df.cache_result()
    
    failures_to_report = new_failures_df.collect()
    failure_count = len(failures_to_report)
    if failure_count == 0:
        return ''No new hard fails to report.''
    
    # This ID will be used to mark these errors as part of this notification batch.
    get_graph_run_id_query = """"""
    BEGIN
        -- Attempt to get the real ID
        RETURN SYSTEM$TASK_RUNTIME_INFO(''CURRENT_TASK_GRAPH_RUN_GROUP_ID'');
    EXCEPTION
        -- If any error occurs (like not being in a task), run this block instead
        WHEN OTHER THEN
            RETURN UUID_STRING();
    END;
    """"""
    notification_query_id = session.sql(get_graph_run_id_query).collect()[0][0]

    # 4. Build and send the Slack message.
    grouped_failures = defaultdict(list)
    for row in failures_to_report:
        grouped_failures[row[''NAME'']].append(row)

    blocks = [
        {
            ""type"": ""header"",
            ""text"": {
                ""type"": ""plain_text"",
                ""text"": f"":x: Critical Alert: {failure_count} Snowflake Task Failure(s) Detected""
            }
        },
        {""type"": ""divider""}
    ]

    for task_name, failures in grouped_failures.items():
        task_error_count = len(failures)
        
        # Add a header for the task group
        task_header_block = {
            ""type"": ""section"",
            ""text"": {
                ""type"": ""mrkdwn"",
                ""text"": f""*{task_name}:* {task_error_count} failure(s)""
            }
        }
        blocks.append(task_header_block)

        # Show up to 5 errors to avoid huge messages
        for failure in failures[:5]:
            error_message = trim_message(failure[''ERROR_MESSAGE''])
            query_id = failure[''QUERY_ID'']
            completed_time = failure[''COMPLETED_TIME''].strftime(''%Y-%m-%d %H:%M:%S %Z'')

            # Each failure gets its own block to avoid the 3000 char limit
            failure_block = {
                ""type"": ""section"",
                ""text"": {
                    ""type"": ""mrkdwn"",
                    ""text"": f""   *Failed At:* {completed_time}\\n""
                            f""    *Error:* `{error_message}`\\n""
                            f""    *Query ID:* `{query_id}`""
                }
            }
            blocks.append(failure_block)
        
        if len(failures) > 5:
            more_failures_block = {
                ""type"": ""context"",
                ""elements"": [
                    {
                        ""type"": ""mrkdwn"",
                        ""text"": f""...and {len(failures) - 5} more.""
                    }
                ]
            }
            blocks.append(more_failures_block)

        blocks.append({""type"": ""divider""})

    slack_payload = {""blocks"": blocks}
    webhook_secret = _snowflake.get_generic_secret_string(''webhook_secret'')
    webhook_url = f""https://hooks.slack.com/services/{webhook_secret}""
    payload_json = json.dumps(slack_payload).encode(''utf-8'')
    
    req = urllib.request.Request(
        webhook_url,
        data=payload_json,
        headers={''Content-Type'': ''application/json''}
    )
    
    try:
        with urllib.request.urlopen(req) as response:
            if response.status != 200:
                # Abort if Slack notification fails to avoid incorrectly logging the errors.
                return f""Failed to send Slack message. Status: {response.status}, Body: {response.read().decode()}""
    except Exception as e:
        return f""Error sending Slack message: {e}""

    # 5. After sending the alert, write the failure information to `dataadmin.error_logs`.
    df_to_insert = new_failures_df.select(
        call_function(""uuid_string"").alias(""ID""),
        col(''COMPLETED_TIME'').alias(''EVENT_TIMESTAMP''),
        col(''QUERY_ID'').alias(''PARENT_QUERY_ID''),
        col(''GRAPH_RUN_GROUP_ID'').alias(''TASK_RUN_GROUP_ID''),
        col(''ATTEMPT_NUMBER''),
        lit(None).astype(''string'').alias(''SESSION_ID''), # Not available in task_history
        col(''NAME'').alias(''TASK_NAME''),
        col(''QUERY_ID'').alias(''FAILED_QUERY_ID''),
        lit(1).alias(''ERROR_TYPE_ID''), # 1 = hard fail
        lit(''CRITICAL'').alias(''SEVERITY''),
        col(''ERROR_CODE'').alias(''SQL_ERROR_CODE''),
        col(''ERROR_MESSAGE'').alias(''SQL_ERROR_MESSAGE''),
        col(''STATE'').alias(''SQL_STATE''),
        lit(None).astype(''variant'').alias(''DETAILS''),
        lit(notification_query_id).alias(''ERROR_NOTIFICATION_ID''),
        current_timestamp().alias(''ERROR_NOTIFICATION_TS'')
    )

    df_to_insert.write.mode(""append"").save_as_table(""dataadmin.error_logs"")

    return f""Successfully reported and logged {failure_count} hard fail(s).""
';"
PROCEDURE,DATAADMIN,SP_STAGELOADDISCOUNTCHEQUEBYITEM_FACT(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADDISCOUNTCHEQUEBYITEM_FACT""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.DISCOUNTCHEQUEBYITEM_FACT),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.DISCOUNTCHEQUEBYITEM_FACT(   
          DISCOUNTCHEQUEBYITEM_FACT_NK, 
          DISCOUNTNAME, 
          DW_STARTDATE, 
          FISCAL_DATE, 
          DW_ENDDATE, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISDELETED, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          CHEQUE_FACT_FK, 
          DAYPART_DIM_FK, 
          DISCOUNTCHECK_FACT_FK, 
          EMPLOYEE_DIM_FK_AS_ADDED_BY, 
          EMPLOYEE_DIM_FK_AS_APPROVED_BY, 
          EMPLOYEE_DIM_FK, 
          ITEM_FACT_FK, 
          LOCATION_DIM_FK, 
          STANDARDDISCOUNT_DIM_FK, 
          DO_AUTOAPPLY, 
          IS_TRAINING, 
          ADDED_AT, 
          CREATED_AT, 
          OPENED_AT, 
          UPDATED_AT, 
          APPLICATION, 
          STATUS, 
          CHEQUESTATUS, 
          DISCOUNTREASON, 
          DISCOUNTLEVEL, 
          RECEIPTNAME, 
          PROMOCODE, 
          PROMODESCRIPTION, 
          REVENUECENTERNAME, 
          ROUNDINGMETHOD, 
          CHEQUENUMBER, 
          DISCOUNT_ID, 
          ITEM_ID, 
          PROMOCODE_ID, 
          DISCOUNT_TYPE, 
          DISCOUNT_PERCENT, 
          APPLIED_AMOUNT, 
          DISCOUNT_AMOUNT, 
          VALUE, 
          DISCOUNT, 
          DISCOUNTCHECK, 
          DISCOUNTITEM, 
          GROSS, 
          NET, 
          ITEM_QUANTITY, 
          TOTAL_ITEMS_ON_CHECK, 
          ITEM_ROW_NUMBER, 
          SINGLE_ITEM_BASE_ALLOCATION, 
          CHECK_REMAINDER, 
          ALLOCATED_ITEM_DISCOUNT 
) 
 SELECT   DISCOUNTCHEQUEBYITEM_FACT_NK  as   DISCOUNTCHEQUEBYITEM_FACT_NK,  
   DISCOUNTNAME  as   DISCOUNTNAME,  
   DW_STARTDATE  as   DW_STARTDATE,  
   FISCAL_DATE  as   FISCAL_DATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISDELETED  as   DW_ISDELETED,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   CHEQUE_FACT_FK  as   CHEQUE_FACT_FK,  
   DAYPART_DIM_FK  as   DAYPART_DIM_FK,  
   DISCOUNTCHECK_FACT_FK  as   DISCOUNTCHECK_FACT_FK,  
   EMPLOYEE_DIM_FK_AS_ADDED_BY  as   EMPLOYEE_DIM_FK_AS_ADDED_BY,  
   EMPLOYEE_DIM_FK_AS_APPROVED_BY  as   EMPLOYEE_DIM_FK_AS_APPROVED_BY,  
   EMPLOYEE_DIM_FK  as   EMPLOYEE_DIM_FK,  
   ITEM_FACT_FK  as   ITEM_FACT_FK,  
   LOCATION_DIM_FK  as   LOCATION_DIM_FK,  
   STANDARDDISCOUNT_DIM_FK  as   STANDARDDISCOUNT_DIM_FK,  
   DO_AUTOAPPLY  as   DO_AUTOAPPLY,  
   IS_TRAINING  as   IS_TRAINING,  
   ADDED_AT  as   ADDED_AT,  
   CREATED_AT  as   CREATED_AT,  
   OPENED_AT  as   OPENED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   APPLICATION  as   APPLICATION,  
   STATUS  as   STATUS,  
   CHEQUESTATUS  as   CHEQUESTATUS,  
   DISCOUNTREASON  as   DISCOUNTREASON,  
   DISCOUNTLEVEL  as   DISCOUNTLEVEL,  
   RECEIPTNAME  as   RECEIPTNAME,  
   PROMOCODE  as   PROMOCODE,  
   PROMODESCRIPTION  as   PROMODESCRIPTION,  
   REVENUECENTERNAME  as   REVENUECENTERNAME,  
   ROUNDINGMETHOD  as   ROUNDINGMETHOD,  
   CHEQUENUMBER  as   CHEQUENUMBER,  
   DISCOUNT_ID  as   DISCOUNT_ID,  
   ITEM_ID  as   ITEM_ID,  
   PROMOCODE_ID  as   PROMOCODE_ID,  
   DISCOUNT_TYPE  as   DISCOUNT_TYPE,  
   DISCOUNT_PERCENT  as   DISCOUNT_PERCENT,  
   APPLIED_AMOUNT  as   APPLIED_AMOUNT,  
   DISCOUNT_AMOUNT  as   DISCOUNT_AMOUNT,  
   VALUE  as   VALUE,  
   DISCOUNT  as   DISCOUNT,  
   DISCOUNTCHECK  as   DISCOUNTCHECK,  
   DISCOUNTITEM  as   DISCOUNTITEM,  
   GROSS  as   GROSS,  
   NET  as   NET,  
   ITEM_QUANTITY  as   ITEM_QUANTITY,  
   TOTAL_ITEMS_ON_CHECK  as   TOTAL_ITEMS_ON_CHECK,  
   ITEM_ROW_NUMBER  as   ITEM_ROW_NUMBER,  
   SINGLE_ITEM_BASE_ALLOCATION  as   SINGLE_ITEM_BASE_ALLOCATION,  
   CHECK_REMAINDER  as   CHECK_REMAINDER,  
   ALLOCATED_ITEM_DISCOUNT  as   ALLOCATED_ITEM_DISCOUNT 
  FROM DATAADMIN.DISCOUNTCHEQUEBYITEM_FACT
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''DISCOUNTCHEQUEBYITEM_FACT'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''DISCOUNTCHEQUEBYITEM_FACT'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADMENUITEM_MENUGROUP_XREF(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADMENUITEM_MENUGROUP_XREF""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.MENUITEM_MENUGROUP_XREF),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.MENUITEM_MENUGROUP_XREF(   
          MENUITEM_MENUGROUP_XREF_NK, 
          MENUITEM_MENUGROUP, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          MENUGROUP_DIM_FK, 
          MENUITEM_DIM_FK 
) 
 SELECT   MENUITEM_MENUGROUP_XREF_NK  as   MENUITEM_MENUGROUP_XREF_NK,  
   MENUITEM_MENUGROUP  as   MENUITEM_MENUGROUP,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   MENUGROUP_DIM_FK  as   MENUGROUP_DIM_FK,  
   MENUITEM_DIM_FK  as   MENUITEM_DIM_FK 
  FROM DATAADMIN.MENUITEM_MENUGROUP_XREF
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''MENUITEM_MENUGROUP_XREF'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''MENUITEM_MENUGROUP_XREF'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,"SP_UPDATEDWTABLE(VARCHAR, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_UPDATEDWTABLE""(""SCHEMANAME"" VARCHAR(50), ""TABLENAME"" VARCHAR(50))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
        -- DBNAME VARCHAR(45)    := ''DEV_HOSPENG_REPORTING'';--''CHEQUE_FACT'';--
        -- SCHEMANAME VARCHAR(45):= ''DATAWAREHOUSE'';--''CHEQUE_FACT'';--
        -- TABLENAME VARCHAR(50) := ''ITEM_FACT'';

        IsTableName            INT;
        col_list               RESULTSET;
        res                    RESULTSET;
       
        ErrorMessage resultset:= (SELECT ''Invalid Table name.'' AS MESSAGE);
        SuccessMessage resultset:= (SELECT ''Successful Table load.'' AS MESSAGE);        
        -- db_name varchar       := UPPER(DBNAME);
        schema_name varchar   := UPPER(SCHEMANAME);
        table_name varchar    := UPPER(TABLENAME);
        sqltext1 := 
  $$
  UPDATE DATAWAREHOUSE_TEMP.<TABLE NAME> tab
  SET tab.DW_ISCURRENTROW = FALSE
     ,tab.DW_ENDDATE = inlt.DW_ENDDATE_UPDATE
     ,tab.DW_UPDATETIME = CURRENT_TIMESTAMP()
  FROM(
    SELECT <TABLE NAME>_PK
      ,<TABLE NAME>_NK
      ,DW_ISCURRENTROW
      ,DW_STARTDATE
      ,SUM(CASE WHEN DW_ISCURRENTROW THEN 1 ELSE 0 END) 
          OVER (PARTITION BY <TABLE NAME>_NK)                                  AS DW_ISCURRENTROW_COUNT
      ,TIMESTAMPADD(NANOSECOND,-1,LEAD(DW_STARTDATE) OVER (PARTITION 
        BY  <TABLE NAME>_NK ORDER BY DW_STARTDATE))                            AS DW_ENDDATE_UPDATE
      ,RANK()OVER(PARTITION BY DW_ISCURRENTROW,<TABLE NAME>_NK 
         ORDER BY DW_STARTDATE desc)
                                                                               AS IS_UPDATEROW  
    FROM DATAWAREHOUSE_TEMP.<TABLE NAME>
  )  INLT
WHERE TAB.<TABLE NAME>_PK = INLT.<TABLE NAME>_PK
  AND INLT.IS_UPDATEROW > 1
  AND INLT.DW_ISCURRENTROW_COUNT > 1
  AND INLT.DW_ISCURRENTROW
  ;
$$;

----------------------------------------------------------------------------------------------------------
BEGIN
----------------------------------------------------------------------------------------------------------
--If the table is not found in the catalouge - retern an error message
IsTableName := (SELECT count(*)  FROM information_schema.tables t 
                   WHERE t.table_type = ''BASE TABLE''
                     AND t.table_schema = ''DATAWAREHOUSE_TEMP''  AND t.table_name = :table_name); 
  
--========================================================================================================  
--ONLY RETURN RESULTS IF INPUT IS VALID TABLE NAME
IF (:IsTableName = 0) 
  THEN
      RETURN TABLE(ErrorMessage);
  ELSE 
     EXECUTE IMMEDIATE(REPLACE(sqltext1,''<TABLE NAME>'',:table_name));
     RETURN TABLE(SuccessMessage);
END IF;

----------------------------------------------------------------------------------------------------------
END';"
PROCEDURE,DATAADMIN,"SP_VALIDATEDWDATES_CREATEALL(VARCHAR, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_VALIDATEDWDATES_CREATEALL""(""REPORTTYPE"" VARCHAR(1), ""ERRORREPORT"" VARCHAR(5))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
    -- REPORTTYPE VARCHAR(1)          := ''P'';  --valid values {L,P,S}
    -- ERRORREPORT VARCHAR(5)         := ''COUNT''; --VALID VALUES {COUNT,ERROR,ALL}
    
    SQLStmt resultset;
    ScriptInsM varchar;
    ScriptInsC varchar;
    SQLTextOut varchar;
    SQLIns varchar;
    SCRIPT resultset;
    BIGSCRIPTS resultset;
  
    TableType_VAR  VARCHAR(075)  := CASE UPPER(REPORTTYPE)
                                        WHEN ''L''THEN ''VIEW'' 
                                        WHEN ''P'' THEN ''BASE TABLE''
                                        WHEN ''S'' THEN ''BASE TABLE''
                                        ELSE ''WRONG'' END; 
    SchemaName_VAR VARCHAR(075)  := CASE UPPER(REPORTTYPE) 
                                        WHEN ''L'' THEN ''DATAADMIN'' 
                                        WHEN ''P'' THEN ''DATAWAREHOUSE''
                                        WHEN ''S'' THEN ''DATAWAREHOUSE_TEMP''
                                        ELSE ''WRONG'' END;
                                        
    RunSQLText     VARCHAR(100)  := ''CALL DATAADMIN.SP_VALIDATEDWDATES('' 
                                      || ''\\'''' || REPORTTYPE || ''\\'',''
                                      || ''\\'''' || ''<TABLENAME>'' || ''\\'',''
                                      || ''\\'''' || ERRORREPORT || ''\\'''' || '');'';
                                        
-----------------------------------------------------------------------------------------------------------
BEGIN
   --drop temp tables if they exist
   drop table if exists dwtable_lists; 
   drop table if exists dwtable_scripts; 

   create table dwtable_scripts (
     MESSAGE varchar
     ,""COUNT""  int
  );

   --create a table containing rows with the call statements to create the load stored procedures
   SELECT 
     REPLACE(:RunSQLText,''<TABLENAME>'',TABLE_NAME) AS sqltext
     FROM information_schema.tables t
   WHERE  TABLE_SCHEMA = :SchemaName_VAR
     AND TABLE_TYPE    = :TableType_VAR
     AND TABLE_NAME not in ( ''ORDER_SUMMARY'',''DATASHARE_VIEW'',''DATASHARE_SECURE_VIEW'',''DATE_DIM'',''VW_REPORT_TENDER'',''ERRORDWDATE_DIM'',''ITEM_SALES'')
     AND TABLE_NAME NOT ILIKE ''DW_%''
     AND NOT TABLE_NAME ILIKE (''%REPORT%'')
     ;
   
   CREATE TABLE dwtable_lists AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

   SQLStmt := (select * from dwtable_lists);

  --loop through all rows that create the load stored proceedure 1 per table
      BEGIN
          FOR record IN SQLStmt DO
            SQLTextOut := record.sqltext;
                BEGIN  
                   SCRIPT := (EXECUTE IMMEDIATE record.sqltext);         
                END;

                INSERT INTO dwtable_scripts(MESSAGE,COUNT) 
                    SELECT MESSAGE,COUNT FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

          END FOR;
     END;

  BIGSCRIPTS := (SELECT * from dwtable_scripts);   
  RETURN TABLE(BIGSCRIPTS);
  
END';"
PROCEDURE,DATAADMIN,SP_CHECKVARIANTDATATYPES_ALL(VARCHAR),"CREATE OR REPLACE PROCEDURE ""SP_CHECKVARIANTDATATYPES_ALL""(""REPORTTYPE"" VARCHAR(1))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
        -- REPORTTYPE VARCHAR(1)  := ''L'';

        SCHEMANAME VARCHAR(075)  := CASE UPPER(REPORTTYPE) 
                                        WHEN ''L'' THEN ''DATAADMIN'' 
                                        WHEN ''P'' THEN ''DATAWAREHOUSE''
                                        WHEN ''S'' THEN ''DATAWAREHOUSE_TEMP''
                                        ELSE ''WRONG'' END;

        TableType_VAR  VARCHAR(75) := CASE UPPER(REPORTTYPE) WHEN ''L''THEN ''VIEW'' ELSE ''BASE TABLE'' END;                                         
        HAS_RESULTS    int;
        VAR_RESULTS    resultset;
        VAR_NORESULTS  resultset;

BEGIN

   DROP TABLE IF EXISTS dwtable_lists; 
   DROP TABLE IF EXISTS REPORT_OUTPUT;  
    
   CREATE TABLE REPORT_OUTPUT (
     ""TABLE"" varchar
     ,""COLUMN"" varchar
     ,""COUNT""  int
    );

    SELECT c.table_name                 as ""Table""
        ,c.column_name                  as ""Column""
        ,c.data_type                    as ""Count""
    FROM information_schema.columns c
         WHERE c.table_name    = c.table_name
            AND c.table_schema = :SCHEMANAME
            AND c.data_type    = ''VARIANT''
            AND c.table_name   <> ''ERRORDWDATE_DIM''
        ;
        
    CREATE TABLE dwtable_lists AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));
     
    VAR_NORESULTS := (
      SELECT :SCHEMANAME                                            as ""Table""
        ,''This Schema has NO Variant Columns.''                      as ""Column""
        ,0                                                          as ""Count""
      );
   
   HAS_RESULTS:=(SELECT COUNT(*) FROM dwtable_lists);        
   VAR_RESULTS := (SELECT * from dwtable_lists);   

IF (:HAS_RESULTS > 0)  --Has VARiant COLUMNS.
    THEN
      RETURN TABLE(VAR_RESULTS); 
    ELSE
      RETURN TABLE(VAR_NORESULTS);
  END IF;
                    
END';"
PROCEDURE,DATAADMIN,SP_DATAWAREHOUSECLONE(),"CREATE OR REPLACE PROCEDURE ""SP_DATAWAREHOUSECLONE""()
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
    SQLTEXT resultset:=(CREATE OR REPLACE SCHEMA DATAWAREHOUSE_TEMP CLONE DATAWAREHOUSE);
BEGIN
   RETURN TABLE(SQLTEXT);
END';"
PROCEDURE,DATAADMIN,SP_DATAWAREHOUSERENAME(),"CREATE OR REPLACE PROCEDURE ""SP_DATAWAREHOUSERENAME""()
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
    SQLTEXT1 resultset:= (DROP SCHEMA IF EXISTS DATAWAREHOUSE_HOLD);
    SQLTEXT2 resultset:= (ALTER SCHEMA DATAWAREHOUSE RENAME TO DATAWAREHOUSE_HOLD);
    SQLTEXT3 resultset:= (ALTER SCHEMA DATAWAREHOUSE_TEMP RENAME TO DATAWAREHOUSE);
BEGIN
   RETURN TABLE(SQLTEXT1);
   RETURN TABLE(SQLTEXT2);
   RETURN TABLE(SQLTEXT3);
END';"
PROCEDURE,DATAADMIN,SP_GETPERSPECTIVESCHEMA(VARCHAR),"CREATE OR REPLACE PROCEDURE ""SP_GETPERSPECTIVESCHEMA""(""SPROCNAME"" VARCHAR(500))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS '
--=================================================================================================================
--This sproc creates the schema for a Perspective Report from the Source Data Stored Proceedure
-- call SP_GetPerspectiveSchema;
--=================================================================================================================
DECLARE 
--sprocName VARCHAR(500):= ''DATAADMIN.SP_REPORT_PMIX'';
  startdate timestamp_tz :=      ''2000-11-20T14:48:37.661Z'';  
  enddate timestamp_tz :=        ''2023-11-20T14:48:37.661Z''; 
  locationid number :=            351;
  dataout resultset;  

BEGIN
  drop table if exists schema_data; 
  CALL DATAADMIN.SP_REPORT_PMIX(''2000-11-20T14:48:37.661Z'',''2023-11-20T14:48:37.661Z'',351) ;
 
  CREATE TABLE schema_data AS
    SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

  ALTER TABLE schema_data ADD COLUMN MAXROW NUMBER;

  dataout := (

  SELECT   ''""schema"": {\\n''
    || LISTAGG (''  '' || ''""'' 
     || COLUMN_NAME 
     || ''"" : '' 
     || CASE DATA_TYPE 
       WHEN ''TEXT'' THEN ''""str""'' 
       WHEN ''NUMBER'' THEN ''""float""''
       WHEN ''TIMESTAMP_TZ'' THEN ''""datetime""'' 
       WHEN ''BOOLEAN'' THEN ''""bool""''
      ELSE DATA_TYPE END 
      || '','' 
      || ''\\n''
      ) || ''}''
      AS DATA_TYPE 
    FROM information_schema.columns 
    WHERE table_name=''SCHEMA_DATA'' 
    ORDER BY ORDINAL_POSITION
    );
    

  return table(dataout);
END
';"
PROCEDURE,DATAADMIN,SP_GET_ENVVARS(ARRAY),"CREATE OR REPLACE PROCEDURE ""SP_GET_ENVVARS""(""SECRET_NAMES"" ARRAY)
RETURNS VARIANT
LANGUAGE SQL
EXECUTE AS CALLER
AS '
/*
How to use in python:
```
    # 1. Define the environment variables you need for this procedure
    required_vars = [''S3_STAGE_NAME'', ''SFTP_BASE_DIR'']
    
    fetched_vars : dict = json.loads(session.call(''DATAADMIN.SP_GET_ENVVARS'', required_vars))

    # 2. Unpack the dictionary values into variables in a specific order.
    s3_stage, sftp_base_dir = [fetched_vars.get(key) for key in required_vars]
```

How to use in sql procedure:
```
DECLARE
    config_obj VARIANT;
    s3_stage VARCHAR;
    sftp_base_dir VARCHAR;
BEGIN
    CALL DATAADMIN.SP_GET_ENVVARS(ARRAY_CONSTRUCT(''S3_STAGE_NAME'', ''SFTP_BASE_DIR''));

    SELECT ""SP_GET_ENVVARS"" INTO :config_obj FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

    s3_stage := :config_obj:S3_STAGE_NAME::STRING;
    sftp_base_dir := :config_obj:SFTP_BASE_DIR::STRING;
```
 */
DECLARE
    secrets_obj VARIANT;
BEGIN
    -- Aggregate the key-value pairs into a single JSON object
    -- CORRECTED: Use PARAM_NAME and PARAM_VALUE to match the table columns
    SELECT OBJECT_AGG(PARAM_NAME, PARAM_VALUE::VARIANT)
    INTO :secrets_obj
    FROM DATAADMIN.ENV_VARS
    -- Filter the table to only include the names passed in the input array
    WHERE PARAM_NAME IN (SELECT VALUE::STRING FROM TABLE(FLATTEN(INPUT => :secret_names)));

    RETURN secrets_obj;
END;
';"
PROCEDURE,DATAADMIN,SP_STAGELOADCONFIG_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADCONFIG_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.CONFIG_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.CONFIG_DIM(   
          CONFIG_DIM_NK, 
          CONFIG_ID, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          INTEGRATIONTYPE_DIM_FK, 
          CREATED_AT, 
          UPDATED_AT, 
          CONFIG 
) 
 SELECT   CONFIG_DIM_NK  as   CONFIG_DIM_NK,  
   CONFIG_ID  as   CONFIG_ID,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   INTEGRATIONTYPE_DIM_FK  as   INTEGRATIONTYPE_DIM_FK,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   CONFIG  as   CONFIG 
  FROM DATAADMIN.CONFIG_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''CONFIG_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''CONFIG_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,"SP_DATASHARE_CRAFTABLE_LABOR(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_DATASHARE_CRAFTABLE_LABOR""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
--   startdate timestamp_tz      := ''2020-08-20T14:48:37.661Z'';  
--   enddate timestamp_tz        := ''2029-08-20T14:48:37.661Z''; 
--   locationid string           := ''[35]'';
  locationidS string          :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
  
-----------------------------------------------------------------------------------------------------------------------
  BEGIN
    --drop temp tables
    DROP TABLE IF EXISTS REPORT_DATA;

-----------------------------------------------------------------------------------------------------------------------
    CALL DATAADMIN.SP_REPORT_LABOR(:startdate,:enddate,:locationid);
    
    CREATE TEMP TABLE REPORT_DATA AS
       SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))
    ;

-----------------------------------------------------------------------------------------------------------------------    
    --return values from the sproc with validated columns only  
     reportSet := (
        SELECT 
             ORG.ORGANIZATION                                            AS ""Organization Name""
            ,ORG.ORGANIZATION_DIM_NK                                     AS ""Organization ID""
            ,REPD.""Location""                                             AS ""Location Name""
            ,REPD.""Location ID""                                          AS ""Location ID""
            ,REPD.""Fiscal Day""                                           AS ""Business Day""
            ,REPD.""Shift ID""                                             AS ""Shift ID""
            ,REPD.""Clocked In At""                                        AS ""Time In""
            ,REPD.""Clocked Out At""                                       AS ""Time Out""
            ,REPD.""Job Category""                                         AS ""Department""
            ,REPD.""Job Position""                                         AS ""Job Title""
            ,REPD.""Employee ID""                                          AS ""Employee No""
            ,REPD.""Employee""                                             AS ""Employee Name""
            ,(IFNULL(REPD.""Regular Seconds"",0)/(60*60))::DECIMAL(36,4)   AS ""Regular Hours""
            ,(IFNULL(REPD.""Overtime Seconds"",0)/(60*60))::DECIMAL(36,4)  AS ""Overtime Hours""            
            ,REPD.""Regular Rate"" ::DECIMAL(36,2)                         AS ""Hourly wage""   
            ,IFNULL(REPD.""Break Seconds"",0)::DECIMAL(36,2)               AS ""Break Seconds""
        FROM REPORT_DATA                                                 REPD
        LEFT JOIN DATAWAREHOUSE.ORGANIZATION_DIM                         ORG
            ON REPD.""Location ID""  = ORG.ORGANIZATION_DIM_NK
            AND ORG.DW_ISCURRENTROW
        WHERE NOT ""Detail ID"" LIKE (''TGR%'')
     );

--=====================================================================================================================
RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,"SP_DATAWAREHOUSE_DASHBOARD_CHECK(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_DATAWAREHOUSE_DASHBOARD_CHECK""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet      resultset;
  -- startdate      date     := ''2025-06-27'';  
  -- enddate        date     := ''2025-06-27''; 
  -- locationid     string   := ''[32]'';
  locationidS string      :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
  today          char(11) := CURRENT_DATE()::DATE::VARCHAR(10);
  yesterdaydate  date     := dateadd(day,-1,:today);
  weekOffset     int      := (  
                              SELECT TOP 1 ORG.START_OF_BIZ_WEEK_INT  
                                FROM DATAWAREHOUSE.ORGANIZATION_DIM          ORG
                                  INNER JOIN DATAWAREHOUSE.LOCATION_DIM      LOC 
                                     ON LOC.ORGANIZATION_DIM_FK = ORG.ORGANIZATION_DIM_NK
                                        AND LOC.DW_ISCURRENTROW
                                        AND ORG.DW_ISCURRENTROW
                                        AND LOC.LOCATION_DIM_NK in (
                                             SELECT table1.value 
                                          FROM table(split_to_table(:locationidS, '',''))  table1) 
                             );
  lastWeekStart  date     := (DATEADD(DAY,
                                ((DAYOFWEEK(:today::date) - (:weekOffset )  ) * -1)  -7
                                + case when DAYOFWEEK(:today::date)< :weekOffset then -0 else 0 end
                                 , :today)) ::date;
  lastWeekEnd    date     := dateadd(day,6,:lastWeekStart);
  lastMonthStart date     := left(dateadd(month,-1,:today)::date::string,7) || ''-01'';
  lastMonthEnd   date     := dateadd(day,-1,dateadd(month,1,lastMonthStart))::date;
  lastYearStart  date     := date_part(year,(dateadd(year,-1,:today))) || ''-01-01'';                  
  lastYearEnd    date     := dateadd(day,-1,dateadd(year,1,:lastYearStart));

---====================================================================================================================
BEGIN
  DROP TABLE if exists CHK_DATA_TEMP;
  DROP TABLE if exists ITEM_DATA_TEMP;  

-----------------------------------------------------------------------------------------------------------------------
--Get history data from the Warehouse. Faster than streaming data-the warehouse has already processed JSON, etc
SELECT TO_CHAR(CHK.CHEQUE_FACT_NK)                                            AS ""Support ID""
  ,''DataWarehouse''                                                            AS ""Origin""
  ,CHK.STATUS                                                                 AS ""Check Status""
  ,''Check''                                                                    AS ""Level""
  ,CHK.CHEQUE_FACT_NK                                                         AS ""Check ID""
  ,CHK.SHIFT_DIM_FK                                                           AS ""Shift ID""
  ,CHK.LOCATION_DIM_FK                                                        AS ""Location ID""  
  ,CHK.REVENUECENTERNAME                                                      AS ""Revenue Center""
  ,CHK.EMPLOYEE_DIM_FK                                                        AS ""Employee ID""
  ,CHK.DAYPART_DIM_FK                                                         AS ""Daypart ID""
  ,CHK.ORDERTYPE_DIM_FK                                                       AS ""Order Type ID""   
  ,DPD.DAYPART                                                                AS ""Daypart""
  ,ORD.ORDER_TYPE                                                             AS ""Order Type""
  ,LOC.LOCATIONNAME                                                           AS ""Location""
  ,null                                                                       AS ""Menu Item""
  ,null                                                                       AS ""Gets Paid Break""  
  ---------------------------------------------------------------------------------------
  ,CHK.FISCAL_DATE::DATE                                                      AS ""Fiscal Date"" 
  ,TO_CHAR(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME
      ,chk.OPENED_AT::timestamp_ntz)::timestamp ) ::DATE                                                                                                                                                  AS ""Opened At""  
  ,TO_CHAR(TO_CHAR(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME
       ,chk.OPENED_AT::timestamp_ntz)::timestamp ) ::timestamp 
  , ''HH24'') ::NUMBER(18,0)                                                    AS ""Hour""  
  ,NULL/*(SHD.PAY_RATE/1000000)::DECIMAL(18,2)*/                              AS ""Rate""
  ,CASE WHEN TO_CHAR(CHK.FISCAL_DATE)::DATE  
    BETWEEN :startdate::DATE AND :enddate::DATE THEN TRUE ELSE FALSE END  
                                                                              AS ""Is Current""
  ,CASE WHEN TO_CHAR(CHK.FISCAL_DATE)::DATE  
    = :today::DATE THEN TRUE ELSE FALSE END                                   AS ""Is Today""                                                                              
  ,CASE WHEN TO_CHAR(CHK.FISCAL_DATE)::DATE  
    = :yesterdaydate::DATE THEN TRUE ELSE FALSE END                           AS ""Is Yesterday""
    
  ,CASE WHEN TO_CHAR(CHK.FISCAL_DATE)::DATE  
    BETWEEN :lastWeekStart::DATE AND :lastWeekEnd::DATE 
      THEN TRUE ELSE FALSE END                                                AS ""Is Last Week""
      
  ,CASE WHEN TO_CHAR(CHK.FISCAL_DATE)::DATE  
    BETWEEN :lastMonthStart::DATE AND :lastMonthEnd::DATE 
       THEN TRUE ELSE FALSE END                                               AS ""Is Last Month""
       
  ,CASE WHEN TO_CHAR(CHK.FISCAL_DATE)::DATE  
    BETWEEN :lastYearStart::DATE AND :lastYearEnd::DATE 
        THEN TRUE ELSE FALSE END                                              AS ""Is Last Year""
-----------------------------------------------------------------------------------------------------------------
--Facts CHECK LEVEL
 ,(CASE WHEN CHK.IS_VOID THEN 0 ELSE CHK.PARTY_COUNT END)::DECIMAL(36,2)::DECIMAL(36,0)                                                                                                                    AS ""Guest Count""
 ,(CASE WHEN CHK.IS_VOID THEN 0 ELSE CHK.FEES END)::DECIMAL(36,2)              AS ""Fee Amount""
 ,(CASE WHEN CHK.IS_VOID THEN 0 ELSE CHK.GRATUITIES END) ::DECIMAL(36,2)       AS ""Gratuity Amount""
 ,DATEDIFF(MINUTE
  ,IFNULL(CHK.OPENED_AT,IFNULL(CHK.CLOSED_AT,CURRENT_TIMESTAMP))
  ,IFNULL(CHK.CLOSED_AT,CURRENT_TIMESTAMP))::NUMBER(36,0)                   
                                                                               AS ""Table Time""  
  -----------------------------------------------------------------------------------------------------------------
 --Facts  ITEM LEVEL (all item level amounts should be filtered for voids)
  ,0::NUMBER(36,0)                                                             AS ""Shift Seconds"" 
  ,0::NUMBER(36,0)                                                             AS ""Shift Count""
  ,0::NUMBER(36,0)                                                             AS ""Item Count"" 
  ,(CASE WHEN CHK.STATUS = ''Voided'' THEN 0 ELSE 1 END)::NUMBER(36,0)           AS ""Check Count"" 
  ,(CASE WHEN CHK.STATUS = ''Voided'' THEN 1 ELSE 0 END)::NUMBER(36,0)           AS ""Void Count""
  ,(CASE WHEN CHK.STATUS = ''Voided'' THEN CHK.GROSS ELSE 0 END)::NUMBER(36,2)   AS ""Void Amount"" 
  ,0::DECIMAL(36,2)                                                            AS ""Net Amount""
  ,(CASE WHEN NOT CHK.STATUS = ''Voided'' THEN CHK.DISCOUNTCHECK ELSE 0 END)::DECIMAL(36,2)                                             
                                                                               AS ""Discount Amount""
  ,0::DECIMAL(36,2)                                                            AS ""Gross Amount""  

----------------------------------------------------------------------------------------------------------------- 
FROM DATAWAREHOUSE.CHEQUE_FACT                                                 CHK
  INNER JOIN DATAWAREHOUSE.LOCATION_DIM                                        LOC
    ON CHK.LOCATION_DIM_FK = LOC.LOCATION_DIM_NK
      AND LOC.DW_ISCURRENTROW
      AND CHK.DW_ISCURRENTROW
      AND NOT CHK.IS_TRAINING
      AND NOT CHK.DW_ISDELETED
      AND CHK.STATUS IN (''Closed'',''Opened'',''Voided'') 
      AND NOT (CHK.STATUS = ''Opened'' AND CHK.FISCAL_DATE::date <= :today::date )
      AND CHK.FISCAL_DATE::date >= :startdate::date --:lastYearEnd::date 
              AND CHK.FISCAL_DATE::date <= :enddate::date--:today::date  
              AND CHK.LOCATION_DIM_FK in (
                SELECT table1.value 
                   FROM table(split_to_table(:locationidS, '',''))  table1) 
  INNER JOIN DATAWAREHOUSE.DAYPART_DIM                                         DPD
    ON CHK.DAYPART_DIM_FK = DPD.DAYPART_DIM_NK
      AND DPD.DW_ISCURRENTROW
  INNER JOIN DATAWAREHOUSE.ORDERTYPE_DIM                                       ORD
    ON CHK.ORDERTYPE_DIM_FK = ORD.ORDERTYPE_DIM_NK
      AND ORD.DW_ISCURRENTROW      
;
-- SELEcT * FROM CHK_DATA_TEMP WHERE ""Check ID"" = ''17854'';

CREATE TEMP TABLE CHK_DATA_TEMP AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))
;

-- ====================================================================================================================
SELECT  TO_CHAR(ITM.ITEM_FACT_NK)                                            AS ""Support ID""
  ,''DataWarehouse''                                                           AS ""Origin""
  ,ITM.ITEMSTATUS                                                            AS ""Check Status""
  ,''Item''                                                                    AS ""Level""
  ,CHK.""Check ID""                                                            AS ""Check ID""
  ,CHK.""Shift ID""                                                            AS ""Shift ID""
  ,CHK.""Location ID""                                                         AS ""Location ID""  
  ,CHK.""Revenue Center""                                                      AS ""Revenue Center""
  ,CHK.""Employee ID""                                                         AS ""Employee ID""
  ,CHK.""Daypart ID""                                                          AS ""Daypart ID""
  ,CHK.""Order Type ID""                                                       AS ""Order Type ID""   
  ,CHK.""Daypart""                                                             AS ""Daypart""
  ,CHK.""Order Type""                                                          AS ""Order Type""
  ,CHK.""Location""                                                            AS ""Location""
  ,ITM.NAME                                                                  AS ""Menu Item""
  ,null                                                                      AS ""Gets Paid Break"" 
  ---------------------------------------------------------------------------------------
  ,CHK.""Fiscal Date""                                                         AS ""Fiscal Date"" 
  ,CHK.""Opened At""                                                           AS ""Opened At""  
  ,CHK.""Hour""                                                                AS ""Hour""  
  ,NULL/*(SHD.PAY_RATE/1000000)::DECIMAL(18,2)*/                             AS ""Rate""
  ,CHK.""Is Current""                                                          AS ""Is Current""
  ,CHK.""Is Today""                                                            AS ""Is Today""                            
  ,CHK.""Is Yesterday""                                                        AS ""Is Yesterday""
  ,CHK.""Is Last Week""                                                        AS ""Is Last Week""
  ,CHK.""Is Last Month""                                                       AS ""Is Last Month""
  ,CHK.""Is Last Year""                                                        AS ""Is Last Year""
-----------------------------------------------------------------------------------------------------------------
--Facts CHECK LEVEL
  ,0::DECIMAL(36,0)                                                           AS ""Guest Count""
  ,0::DECIMAL(36,0)                                                           AS ""Fee Amount""
  ,0::DECIMAL(36,0)                                                           AS ""Gratuity Amount""
  ,0::DECIMAL(36,0)                                                           AS ""Table Time""   
  -----------------------------------------------------------------------------------------------------------------
   --Facts ITEM LEVEL (all item level amounts should be filtered for voids)
  ,0::NUMBER(36,0)                                                            AS ""Shift Seconds"" 
  ,0::NUMBER(36,0)                                                            AS ""Shift Count""
  ,CAST(CASE WHEN NOT ITM.ITEMSTATUS = ''Voided'' AND NOT CHK.""Check Status"" = ''Voided''
    THEN ITM.QUANTITY ELSE 0 END AS DECIMAL(36,0))                            AS ""Item Count""  
  ,0::DECIMAL(36,0)                                                           AS ""Check Count"" 
  ,CAST(CASE WHEN  ITM.ITEMSTATUS = ''Voided'' 
    THEN ITM.QUANTITY ELSE 0 END AS DECIMAL(36,0))                            AS ""Void Count""
  -- ,CAST(CASE WHEN  ITM.ITEMSTATUS = ''Voided'' AND NOT CHK.""Check Status"" = ''Voided''
  --   THEN ITM.PRICE ELSE 0 END AS DECIMAL(36,2))                            AS ""Void Amount"" 
  ,(CASE WHEN  ITM.ITEMSTATUS = ''Voided'' 
    THEN
    CASE WHEN ITM.PRICE > 0.0000 THEN ITM.PRICE * ITM.QUANTITY ELSE ITM.baseprice END
      + ((ifnull(IMF.PRICE,0)) * (ITM.QUANTITY))
      ELSE 0 END )::  DECIMAL(38,2)                            
                                                                              AS ""Void Amount"" 
  ,CAST(CASE WHEN NOT ITM.ITEMSTATUS = ''Voided'' AND NOT CHK.""Check Status"" = ''Voided''
    THEN ITM.APPLIEDAMOUNT ELSE 0 END AS DECIMAL(38,2))                       AS ""Net Amount""
  ,CAST(CASE WHEN NOT ITM.ITEMSTATUS = ''Voided'' AND NOT CHK.""Check Status"" = ''Voided''
    THEN ITM.DISCOUNTITEM ELSE 0 END AS DECIMAL(36,2))                        AS ""Discount Amount""
  ,CAST(CASE WHEN NOT ITM.ITEMSTATUS = ''Voided'' AND NOT CHK.""Check Status"" = ''Voided'' 
    THEN ITM.GROSS ELSE 0 END AS DECIMAL(36,2))                               AS ""Gross Amount""  
----------------------------------------------------------------------------------------------------------------- 
FROM CHK_DATA_TEMP                                                            CHK 
  INNER JOIN DATAWAREHOUSE.ITEM_FACT                                          ITM
    ON CHK.""Check ID"" = ITM.CHEQUE_FACT_FK
      AND ITM.DW_ISCURRENTROW
      AND ITM.ITEMSTATUS IN (''Added'',''Sent'',''Voided'')
  LEFT JOIN (SELECT ITEM_FACT_FK,SUM(PRICE) AS PRICE 
               FROM DATAWAREHOUSE.ITEMMODIFIER_DIM  
             WHERE DW_ISCURRENTROW
             GROUP BY ITEM_FACT_FK
                                                                        )    IMF
              ON ITM.ITEM_FACT_NK = IMF.ITEM_FACT_FK 
  WHERE ITM.DW_ISCURRENTROW
      AND ITM.ITEMSTATUS IN (''Added'',''Sent'',''Voided'')            
;

CREATE TEMP TABLE ITEM_DATA_TEMP AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))
;


-- ====================================================================================================================

 reportSet   := (
 
  SELECT /*top 150*/ ROW_NUMBER() OVER (ORDER BY ""Check ID"")                        AS ""Support ID""
  ,''DataWarehouse''                                                       AS ""Origin""
  ,''None''                                                                AS ""Check Status""
  ,NULL                                                                  AS ""Level""
  ,NULL                                                                  AS ""Check ID""
  ,NULL                                                                  AS ""Shift ID""
  ,""Location ID""                                                         AS ""Location ID""  
  ,""Revenue Center""                                                      AS ""Revenue Center""
  ,NULL                                                                  AS ""Employee ID""
  ,""Daypart ID""                                                          AS ""Daypart ID""
  ,""Order Type ID""                                                       AS ""Order Type ID""   
  ,""Daypart""                                                             AS ""Daypart""
  ,""Order Type""                                                          AS ""Order Type""
  ,""Location""                                                            AS ""Location""
  ,""Menu Item""                                                           AS ""Menu Item""
  ,NULL                                                                  AS ""Gets Paid Break"" 
  -----------------------------------------------------------------------------------------------------------------
  ,""Fiscal Date""                                                         AS ""Fiscal Date"" 
  ,""Opened At""                                                           AS ""Opened At""  
  ,""Hour""                                                                AS ""Hour""  
  ,NULL/*(SHD.PAY_RATE/1000000)::DECIMAL(18,2)*/                         AS ""Rate""
  ,""Is Current""                                                          AS ""Is Current""
  ,""Is Today""                                                            AS ""Is Today""                            
  ,""Is Yesterday""                                                        AS ""Is Yesterday""
  ,""Is Last Week""                                                        AS ""Is Last Week""
  ,""Is Last Month""                                                       AS ""Is Last Month""
  ,""Is Last Year""                                                        AS ""Is Last Year""
-----------------------------------------------------------------------------------------------------------------
--Facts CHECK LEVEL
  ,SUM(""Guest Count"")::DECIMAL(36,0)                                     AS ""Guest Count""
  ,SUM(""Fee Amount"")::DECIMAL(36,2)                                      AS ""Fee Amount""
  ,SUM(""Gratuity Amount"")::DECIMAL(36,2)                                 AS ""Gratuity Amount""
  ,SUM(""Table Time"")::DECIMAL(36,0)                                      AS ""Table Time""   
  -----------------------------------------------------------------------------------------------------------------
   --Facts ITEM LEVEL (all item level amounts should be filtered for voids)
  ,SUM(0)::NUMBER(36,0)                                                  AS ""Shift Seconds"" 
  ,SUM(0)::NUMBER(36,0)                                                  AS ""Shift Count""
  ,SUM(""Item Count"")::DECIMAL(36,0)                                      AS ""Item Count""  
  ,SUM(""Check Count"")::DECIMAL(36,0)                                     AS ""Check Count"" 
  ,SUM(""Void Count"")::DECIMAL(36,0)                                      AS ""Void Count""
  ,SUM(""Void Amount"")::DECIMAL(36,2)                                     AS ""Void Amount"" 
  ,SUM(""Net Amount"")::DECIMAL(36,2)                                      AS ""Net Amount""
  ,SUM(""Discount Amount"")::DECIMAL(36,2)                                 AS ""Discount Amount""
  ,SUM(""Gross Amount"")::DECIMAL(36,2)                                    AS ""Gross Amount"" 
FROM (
 SELECT * FROM ITEM_DATA_TEMP  --74
 UNION ALL
 SELECT * FROM CHK_DATA_TEMP 
 )  
-- where ""Is Current"" 
 GROUP BY ""Origin""
  ,""Check Status""
  ,""Level""
  ,""Check ID""
  ,""Shift ID""
  ,""Location ID""  
  ,""Revenue Center""
  ,""Employee ID""
  ,""Daypart ID""
  ,""Order Type ID""   
  ,""Daypart""
  ,""Order Type""
  ,""Location""
  ,""Menu Item""
  ,""Gets Paid Break"" 
  ,""Fiscal Date"" 
  ,""Opened At""  
  ,""Hour""  
  ,""Rate""
  ,""Is Current""
  ,""Is Today""                            
  ,""Is Yesterday""
  ,""Is Last Week""
  ,""Is Last Month""
  ,""Is Last Year""

  --  SELECT :weekOffset as ""weekoffset""
  --  ,:today as ""today""
  -- ,:yesterdaydate as ""yesterdaydate""
  -- ,:lastWeekStart as ""lastWeekStart""
  -- ,:lastWeekEnd as ""lastWeekEnd"" 
  -- ,:lastMonthStart as ""lastMonthStart""
  -- ,:lastMonthEnd as ""lastMonthEnd""
  -- ,:lastYearStart as ""lastYearStart""
  -- ,:lastYearEnd as ""lastYearEnd""
   
--===================================================================================================
); 
 RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,SP_DQ_IS_YESTERDAY_LOADED_IN_CSF(),"CREATE OR REPLACE PROCEDURE ""SP_DQ_IS_YESTERDAY_LOADED_IN_CSF""()
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS OWNER
AS '
DECLARE
    -- Runtime metadata
    run_metadata VARIANT;
    parent_query_id VARCHAR;
    task_run_group_id VARCHAR;
    attempt_number NUMBER;
    session_id VARCHAR;
    task_name VARCHAR;

    -- Procedure specific variables
    max_fiscal_date DATE;
    yesterday_date DATE;
    select_query_id VARCHAR;
BEGIN
    -- Get runtime metadata for logging and traceability
    -- This part is boilerplate from our orchestration framework
    CALL dataadmin.sp_get_dag_run_metadata(COALESCE(last_query_id(), ''NOT_FOUND'')) INTO :run_metadata;
    parent_query_id := :run_metadata:parent_query_id::VARCHAR;
    task_run_group_id := :run_metadata:graph_run_group_id::VARCHAR;
    attempt_number := :run_metadata:run_attempt_number::NUMBER;
    session_id := :run_metadata:session_id::VARCHAR;
    task_name := COALESCE(:run_metadata:task_name::VARCHAR, ''sp_dq_is_yesterday_loaded_in_csf''); -- Task name might be null on manual run

    -- The actual data quality check logic
    yesterday_date := DATEADD(day, -1, CURRENT_DATE());

    SELECT max(fiscal_date) INTO :max_fiscal_date
    FROM DATAWAREHOUSE.CLOSEOUTSUMMARY_FACT
    WHERE dw_iscurrentrow;

    select_query_id := last_query_id();

    IF (:max_fiscal_date IS NULL OR :max_fiscal_date <> :yesterday_date) THEN
        -- If the max date is null (empty table) or less than yesterday, log a data quality issue.
        INSERT INTO DATAADMIN.error_logs (
            parent_query_id,
            task_run_group_id,
            attempt_number,
            session_id,
            task_name,
            failed_query_id,
            error_type_id,
            severity,
            sql_error_code,
            sql_error_message,
            sql_state,
            details
        )
        SELECT
            :parent_query_id,
            :task_run_group_id,
            :attempt_number,
            :session_id,
            :task_name,
            :select_query_id,
            3, -- 1=Hard Fail, 2=Soft Fail, 3=Data Quality
            ''WARNING'',
            NULL, -- No SQL error code for DQ check
            ''Data quality check failed: CLOSEOUTSUMMARY_FACT is not updated with yesterday data.'',
            NULL, -- No SQL state for DQ check
            OBJECT_CONSTRUCT(
                ''check_name'', ''sp_dq_is_yesterday_loaded_in_csf'',
                ''yesterday_date'', :yesterday_date,
                ''max_fiscal_date_in_table'', :max_fiscal_date
            );
        RETURN ''Data quality check failed. CLOSEOUTSUMMARY_FACT max(fiscal_date) is '' || COALESCE(TO_VARCHAR(:max_fiscal_date), ''NULL'') || '', expected at least '' || :yesterday_date;
    ELSE
        RETURN ''Data quality check passed.'';
    END IF;

END;
';"
PROCEDURE,DATAADMIN,"SP_LOAD_365_JOBS(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_365_JOBS""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2025-02-19T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2025-02-19T14:48:37.661Z''; 
  -- locationid string      := ''[15]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
  -- GRANT usage ON procedure dataadmin.SP_LOAD_365_JOBS(timestamp_tz,timestamp_tz,string) TO ROLE matillion;
--==================================================================================================================================
BEGIN
--==================================================================================================================================
DROP TABLE IF EXISTS TEMP_EMPS;

SELECT JOBPOSITION_DIM_FK
    FROM DATAWAREHOUSE.SHIFT_DIM SHD
    WHERE shd.fiscal_day::date
        >= dateadd(DAY,-10,:startdate)::date     --calculate data 10 days around selected dates so that  
      AND  shd.fiscal_day::date  
            <= dateadd(DAY,10,:enddate)::date    --the data in the selected range calcs overtime for full fiscal week
      AND SHD.LOCATION_DIM_FK IN ( SELECT table1.value 
            FROM table(split_to_table(:locationidS, '',''))  table1)
      AND SHD.DW_ISCURRENTROW
      AND NOT SHD.DW_ISDELETED
    GROUP BY JOBPOSITION_DIM_FK;

CREATE TEMP TABLE TEMP_EMPS AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

--================================================================================================================================= 
reportSet := (  
------------------------------------------------------------------------------------------------------------------------------------
SELECT  IFNULL(REPLACE(JPD.JOBPOSITION_DIM_NK,'','',''''),''None'')  AS JobCode  --* string Number used to identify the job in R365.
 , IFNULL(REPLACE(JPD.JOB_POSITION,'','',''''),''None'')             AS JobName  --* string Name of the job.
 FROM DATAWAREHOUSE.JOBPOSITION_DIM                            JPD
   INNER JOIN TEMP_EMPS                                        EMPS
     ON  JPD.JOBPOSITION_DIM_NK = EMPS.JOBPOSITION_DIM_FK
       AND JPD.DW_ISCURRENTROW
      AND NOT JPD.IS_TRAINING
--==================================================================================================================================
);
RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,"SP_LOAD_365_SURCHARGES(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_365_SURCHARGES""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2020-08-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2029-08-20T14:48:37.661Z''; 
  -- locationid string      := ''[2,3,4,351,352]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');

--=================================================================================================================================
BEGIN
--=================================================================================================================================
reportSet := (  
------------------------------------------------------------------------------------------------------------------------------------
SELECT to_char(SUF.chequenumber) || ''.'' || to_char(SUF.cheque_fact_fk)          
                                   AS Surcharge_CheckNumber  --* string
    ,IFNULL(SUF.APPLIEDAMOUNT,0)   AS Surcharge_Amount       --* decimal
    ,SUD.SURCHARGE                 AS Surcharge_Name         --* string 
  FROM DATAWAREHOUSE.SURCHARGE_FACT          SUF
    INNER JOIN DATAWAREHOUSE.SURCHARGE_DIM   SUD
      ON SUF.SURCHARGE_DIM_NK = SUD.SURCHARGE_DIM_NK
        AND SUF.DW_ISCURRENTROW
        AND SUD.DW_ISCURRENTROW
      AND (SUF.FISCAL_DATE::date >= :startdate::date 
                AND SUF.FISCAL_DATE::date  <= :enddate::date)
      AND SUF.LOCATION_DIM_FK IN (
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)       
--=================================================================================================================================
);
RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,SP_LOAD_AVERO_GETLOCATIONS(),"CREATE OR REPLACE PROCEDURE ""SP_LOAD_AVERO_GETLOCATIONS""()
RETURNS TABLE (""LOCATIONID"" NUMBER(38,0), ""AVEROLOCATIONID"" NUMBER(38,0))
LANGUAGE SQL
EXECUTE AS OWNER
AS '
DECLARE
  res RESULTSET;
BEGIN
  res := (SELECT DISTINCT
        f.VALUE:locationId::INT AS locationId,
        f.VALUE:averoLocationId::INT AS averoLocationId
    FROM
        DATAWAREHOUSE.INTEGRATIONTYPE_DIM IND
    INNER JOIN
        DATAWAREHOUSE.CONFIG_DIM CFD
        ON IND.INTEGRATIONTYPE_DIM_NK = CFD.INTEGRATIONTYPE_DIM_FK
        AND CFD.DW_ISCURRENTROW
        AND IND.DW_ISCURRENTROW
        AND NOT IND.DW_ISDELETED
        AND IND.INTEGRATIONTYPE = ''averoSFTP'',
    LATERAL FLATTEN(input => PARSE_JSON(CFD.config):locations) f);
  RETURN TABLE(res);
END;
';"
PROCEDURE,DATAADMIN,"SP_LOAD_COMPEAT_MENUITEMS(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_COMPEAT_MENUITEMS""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2020-08-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2029-08-20T14:48:37.661Z''; 
  -- locationid string      := ''[2,3,4,351,352]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--==================================================================================================================================
BEGIN
  DROP TABLE IF EXISTS TEMP_item; 
  DROP TABLE IF EXISTS TEMP_header; 

----------------------------------------------------------------------------------------------------------------------------------  
  SELECT ''ItemNumber''
  ,''ItemName''     
  ,''CategoryName''  
;  

 CREATE TEMP TABLE TEMP_header AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID())); 
     
------------------------------------------------------------------------------------------------------------------------------------
SELECT  IFNULL(REPLACE(MEN.MENUITEMNAME_DIM_NK,'','',''''),''None'')  AS ItemNumber     --*  Menu Item ID
  ,IFNULL(REPLACE(MEN.MENUITEMNAME,'','',''''),''None'')              AS ItemName       --* string Name of the Menu Item.
  ,IFNULL(REPLACE(MEG.REPORTCATEGORY,'','',''''),''None'')            AS CategoryName   --* string Cogs category
 FROM DATAWAREHOUSE.MENUITEM_DIM                                MED
   INNER JOIN DATAWAREHOUSE.MENUITEMNAME_DIM                    MEN
     ON MED.MENUITEMNAME_DIM_FK = MEN.MENUITEMNAME_DIM_NK
       AND MED.DW_ISCURRENTROW
       AND MEN.DW_ISCURRENTROW
   INNER JOIN DATAWAREHOUSE.ORGANIZATION_DIM                    ORG
     ON MED.ORGANIZATION_DIM_FK = ORG.ORGANIZATION_DIM_NK
       AND ORG.DW_ISCURRENTROW
   INNER JOIN DATAWAREHOUSE.LOCATION_DIM                        LOC
     ON LOC.ORGANIZATION_DIM_FK = ORG.ORGANIZATION_DIM_NK
       AND LOC.DW_ISCURRENTROW
       AND LOC.LOCATION_DIM_NK in (SELECT table1.value 
        FROM table(split_to_table(:locationidS, '',''))  table1) 
    INNER JOIN DATAWAREHOUSE.REPORTCATEGORY_DIM                 MEG
        ON MEN.REPORTCATEGORY_DIM_FK = MEG.REPORTCATEGORY_DIM_NK
          AND MEG.DW_ISCURRENTROW = TRUE
      -- INNER JOIN DATAWAREHOUSE.COGSCATEGORY_DIM                 CCD
      --   ON CCD.COGSCATEGORY_DIM_NK = MEG.COGSCATEGORY_DIM_FK    
      --     AND CCD.DW_ISCURRENTROW        
GROUP BY IFNULL(REPLACE(MEN.MENUITEMNAME_DIM_NK,'','',''''),''None'') 
  ,IFNULL(REPLACE(MEN.MENUITEMNAME,'','',''''),''None'')       
  ,IFNULL(REPLACE(MEG.REPORTCATEGORY,'','',''''),''None'') 
ORDER BY  IFNULL(REPLACE(MEN.MENUITEMNAME_DIM_NK,'','',''''),''None'') 
  ,IFNULL(REPLACE(MEN.MENUITEMNAME,'','',''''),''None'')       
  ,IFNULL(REPLACE(MEG.REPORTCATEGORY,'','',''''),''None'') 
  ;

  CREATE TEMP TABLE TEMP_item AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID())); 
  
--==================================================================================================================================
 
reportSet := ( 
  SELECT * FROM TEMP_header
    UNION ALL
  SELECT * FROM TEMP_item
--==================================================================================================================================
);
RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,"SP_LOAD_DATASHARE_CRAFTABLE_DISCOUNT(VARCHAR, VARCHAR, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_DATASHARE_CRAFTABLE_DISCOUNT""(""START_DATE"" VARCHAR, ""END_DATE"" VARCHAR, ""LOCATION_IDS"" VARCHAR)
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS CALLER
AS 'BEGIN
    -- Execute the source procedure that returns the data
    CALL DATAADMIN.SP_DATASHARE_CRAFTABLE_DISCOUNT(:START_DATE, :END_DATE, :LOCATION_IDS);

    -- Insert the results into the target table
    INSERT INTO DATASHARE_DEV.CRAFTABLE_DISCOUNT (
        ""Organization Name"",
        ""Organization ID"",
        ""Location Name"",
        ""Location ID"",
        ""Business Day"",
        ""Discount ID"",
        ""Discount Level"",
        ""Discount Name"",
        ""Check Number"",
        ""Check ID"",
        ""Item Name"",
        ""Item ID"",
        ""Employee for Discount (approver)"",
        ""Discount Amount"",
        ""Cash Discount Amount"",
        ""Disc Amount No Cash""
    )
    SELECT
        ""Organization Name"",
        ""Organization ID"",
        ""Location Name"",
        ""Location ID"",
        ""Business Day"",
        ""Discount ID"",
        ""Discount Level"",
        ""Discount Name"",
        ""Check Number"",
        ""Check ID"",
        ""Item Name"",
        ""Item ID"",
        ""Employee for Discount (approver)"",
        ""Discount Amount"",
        ""Cash Discount Amount"",
        ""Disc Amount No Cash""
    FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

    RETURN ''Success: Data loaded into DATASHARE_DEV.CRAFTABLE_DISCOUNT.'';
END';"
PROCEDURE,DATAADMIN,"SP_LOAD_DATASHARE_ITEMS_DIANESESION(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_DATASHARE_ITEMS_DIANESESION""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS '
-- -- =====================================================================================
-- Example Call Statement
-- CALL DATAWAREHOUSE.SP_LOAD_DATASHARE_ITEMS(''2000-11-20T14:48:37.661Z'',''2026-11-20T14:48:37.661Z'',''[351]'');
-- GRANT usage ON procedure DATAWAREHOUSE.SP_LOAD_DATASHARE_ITEMS(timestamp_tz,timestamp_tz,string) TO ROLE DATA_REPLICATION_HOSPENG;
-- --=========================================================================================
DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2020-08-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2029-08-20T14:48:37.661Z''; 
  -- locationid string      := ''[351,352]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--=========================================================================================
BEGIN
 reportSet:= (
SELECT itf.ITEM_FACT_NK                                   as ""Support ID"" 
--status, category, level-------------------------------------------------------------------
    ,IFNULL(ccd.COGSCATEGORY,''None'')                      as ""Category Name""
    ,IFNULL(ccd.cogscategory_dim_nk,0)                    as ""Category ID""
-- --geography--------------------------------------------------------------------------------
    ,IFNULL(loc.LOCATIONNAME,''None'')                      as ""Location Name""
    ,IFNULL(loc.LOCATION_DIM_NK,''None'')                   as ""Location ID""
    ,IFNULL(itf.REVENUECENTERNAME,''None'')                 as ""Revenue Center Name""
-- --dates-------------------------------------------------------------------------------------
    ,LOC.TZ_NAME                                          as ""Time Zone""
    ,to_char(LEFT(chk.FISCAL_DATE,4))                     as ""Year""
    ,to_char(YEAR(chk.FISCAL_DATE)) || ''|'' || TO_CHAR(LEFT(''0'' || MONTH(chk.FISCAL_DATE),2))                                       
                                                          as ""Year and Month""
    ,IFNULL(dad.DAYPART,''None'')                           as ""Daypart""
    ,to_char(chk.FISCAL_DATE)                             as ""Fiscal Date""
    ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,chk.OPENED_AT::timestamp_ntz )::timestamp )                                                                           
                                                          as ""Opened At""                                                           
    ,IFNULL(DAYNAME(chk.FISCAL_DATE),''None'')              as ""Day of Week""
    ,CASE WHEN DAYNAME(chk.FISCAL_DATE) IN (''Sat'',''Sun'')  
             THEN TRUE ELSE FALSE END                     as ""Is Weekend""
-- --flags--------------------------------------------------------------------------------------
    ,IFNULL(itf.HASMODIFIERS,FALSE)                       as ""Has Modifiers""
-- --Descriptors-------------------------------------------------------------------------------- 
    ,IFNULL(itf.chequenumber ,''None'')                     as ""Check""
    ,IFNULL(itf.CHEQUE_FACT_FK ,''None'')                   as ""Check ID""    
    ,IFNULL(med.MENUITEMNAME,'' None'')                     as ""Item Name""
    ,IFNULL(med.MENUITEMNAME,'' None'')                     as ""Item Code""
    ,IFNULL(itf.COMBINEDNAME,''Regular'')                   as ""Variant Name""     
-- --Facts-----------------------------------------------------------------------------------------
    ,IFNULL(itf.QUANTITY::NUMBER(10,0),0)                 as ""Count""   
    ,IFNULL(itf.APPLIEDAMOUNT::NUMBER(18,2),0)            as ""Net Amount""
    ,IFNULL(itf.GROSS::NUMBER(18,2),0)                    as ""Gross Amount"" 
    ,IFNULL(itf.BASEPRICE::NUMBER(18,2),0)                as ""Base Price""
    ,IFNULL(itf.PRICE::NUMBER(18,2),0)                    as ""Price""
    
    -- ,IFNULL(dis.""Item Discount Amount""::NUMBER(18,2),0)   as ""Item Discount Amount""
    --,IFNULL(chk.DiscountItem ::NUMBER(18,2),0)   as ""Item Discount Amount"" -- this is giving the item discoutns at the check level
    ,IFNULL(itf.DiscountItem ::NUMBER(18,2),0)   as ""Item Discount Amount"" -- and this will give us the sum of disccounts at item level
    
    ,IFNULL(itf.INCLUSIVETAX::NUMBER(18,2),0)             as ""Inclusive Tax Amount""    
    ,IFNULL(itf.TAX::NUMBER(18,2),0)                      as ""Tax Amount""
--------------------------------------------------------------------------------------------   
FROM DATAWAREHOUSE.ITEM_FACT                              itf
     INNER JOIN DATAWAREHOUSE.MENUITEMNAME_DIM            med
       ON med.MENUITEMNAME_DIM_NK = itf.MENUITEMNAME_DIM_FK
          AND itf.ITEMSTATUS IN (''Added'',''Sent'')
          AND itf.CHECKSTATUS = ''Closed''
          AND itf.DW_ISCURRENTROW  
          AND med.DW_ISCURRENTROW  
          AND NOT itf.DW_ISDELETED
          AND NOT itf.IS_TRAINING
          AND itf.LOCATION_DIM_FK IN (--351,352
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)
      INNER JOIN DATAWAREHOUSE.CHEQUE_FACT                                chk
        ON chk.CHEQUE_FACT_NK = itf.CHEQUE_FACT_FK
          AND chk.DW_ISCURRENTROW
          AND chk.STATUS = ''Closed''
          AND itf.ITEMSTATUS IN (''Added'',''Sent'')
          AND (chk.FISCAL_DATE::date >= :startdate::date 
                AND chk.FISCAL_DATE::date  <= :enddate::date)
      INNER JOIN DATAWAREHOUSE.LOCATION_DIM                     loc
        ON itf.LOCATION_DIM_FK = loc.LOCATION_DIM_NK
          AND loc.DW_ISCURRENTROW
      INNER JOIN DATAWAREHOUSE.DAYPART_DIM                      dad
        ON itf.daypart_dim_fk = dad.daypart_dim_nk
          AND dad.DW_ISCURRENTROW = TRUE         
      INNER JOIN DATAWAREHOUSE.REPORTCATEGORY_DIM               meg
        ON med.REPORTCATEGORY_DIM_FK = meg.REPORTCATEGORY_DIM_NK
          AND meg.DW_ISCURRENTROW = TRUE
      INNER JOIN DATAWAREHOUSE.COGSCATEGORY_DIM                  ccd
        ON ccd.COGSCATEGORY_DIM_NK = meg.COGSCATEGORY_DIM_FK    
          AND ccd.DW_ISCURRENTROW
      -- LEFT JOIN (
      --     SELECT daf.ITEM_FACT_FK, SUM(daf.APPLIED_AMOUNT) AS ""Item Discount Amount""
      --         FROM DATAWAREHOUSE.DISCOUNTITEM_FACT daf
      --           WHERE daf.DW_ISCURRENTROW 
      --             AND (daf.FISCAL_DATE::date >= :startdate::date 
      --             AND daf.FISCAL_DATE::date  <= :enddate::date)
      --             AND daf.LOCATION_DIM_FK IN (--351,352
      --                SELECT table1.value 
      --                   FROM table(split_to_table(:locationidS, '',''))  table1)
      --             AND NOT daf.IS_TRAINING
      --           GROUP BY daf.ITEM_FACT_FK
      --                                                     )dis 
      --       ON dis.ITEM_FACT_FK = itf.ITEM_FACT_NK
          
--==========================================================================================
);
RETURN TABLE(reportSet); 
END;
-- ';"
PROCEDURE,DATAADMIN,"SP_LOAD_DATASHARE_ITEMS_REMOVE_LEFTJOIN(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_DATASHARE_ITEMS_REMOVE_LEFTJOIN""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS '
DECLARE
    reportSet resultset;
    locationidS string := REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
BEGIN
reportSet:= (
SELECT
    itf.ITEM_FACT_NK as ""Support ID""
    --status, category, level-------------------------------------------------------------------
    ,IFNULL(ccd.COGSCATEGORY,''None'') as ""Category Name""
    ,IFNULL(ccd.cogscategory_dim_nk,0) as ""Category ID""
    -- --geography--------------------------------------------------------------------------------
    ,IFNULL(loc.LOCATIONNAME,''None'') as ""Location Name""
    ,IFNULL(loc.LOCATION_DIM_NK,''None'') as ""Location ID""
    ,IFNULL(itf.REVENUECENTERNAME,''None'') as ""Revenue Center Name""
    -- --dates-------------------------------------------------------------------------------------
    ,LOC.TZ_NAME as ""Time Zone""
    ,to_char(LEFT(chk.FISCAL_DATE,4)) as ""Year""
    ,to_char(YEAR(chk.FISCAL_DATE)) || ''|'' || TO_CHAR(LEFT(''0'' || MONTH(chk.FISCAL_DATE),2)) as ""Year and Month""
    ,IFNULL(dad.DAYPART,''None'') as ""Daypart""
    ,to_char(chk.FISCAL_DATE) as ""Fiscal Date""
    ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,chk.OPENED_AT::timestamp_ntz )::timestamp ) as ""Opened At""
    ,IFNULL(DAYNAME(chk.FISCAL_DATE),''None'') as ""Day of Week""
    ,CASE WHEN DAYNAME(chk.FISCAL_DATE) IN (''Sat'',''Sun'') THEN TRUE ELSE FALSE END as ""Is Weekend""
    -- --flags--------------------------------------------------------------------------------------
    ,IFNULL(itf.HASMODIFIERS,FALSE) as ""Has Modifiers""
    -- --Descriptors--------------------------------------------------------------------------------
    ,IFNULL(itf.chequenumber ,''None'') as ""Check""
    ,IFNULL(itf.CHEQUE_FACT_FK ,''None'') as ""Check ID""
    ,IFNULL(med.MENUITEMNAME,'' None'') as ""Item Name""
    ,IFNULL(med.MENUITEMNAME,'' None'') as ""Item Code""
    ,IFNULL(itf.COMBINEDNAME,''Regular'') as ""Variant Name""
    -- --Facts-----------------------------------------------------------------------------------------
    ,IFNULL(itf.QUANTITY::NUMBER(10,0),0) as ""Count""
    ,IFNULL(itf.APPLIEDAMOUNT::NUMBER(18,2),0) as ""Net Amount""
    ,IFNULL(itf.GROSS::NUMBER(18,2),0) as ""Gross Amount""
    ,IFNULL(itf.BASEPRICE::NUMBER(18,2),0) as ""Base Price""
    ,IFNULL(itf.PRICE::NUMBER(18,2),0) as ""Price""

    -- ============================ MODIFICATION START ============================
    -- 1. The old, incorrect ""Item Discount Amount"" is removed.
    -- 2. A new column is added to show the total discount for the entire check.
    --    This value comes directly from the CHEQUE_FACT table (aliased as chk).
    ,IFNULL(chk.DISCOUNT::NUMBER(18,2), 0) AS ""Total Check Discount""
    -- ============================= MODIFICATION END =============================

    ,IFNULL(itf.INCLUSIVETAX::NUMBER(18,2),0) as ""Inclusive Tax Amount""
    ,IFNULL(itf.TAX::NUMBER(18,2),0) as ""Tax Amount""
FROM
    DATAWAREHOUSE.ITEM_FACT itf
INNER JOIN
    DATAWAREHOUSE.MENUITEMNAME_DIM med ON med.MENUITEMNAME_DIM_NK = itf.MENUITEMNAME_DIM_FK
    AND itf.ITEMSTATUS IN (''Added'',''Sent'')
    AND itf.CHECKSTATUS = ''Closed''
    AND itf.DW_ISCURRENTROW
    AND med.DW_ISCURRENTROW
    AND NOT itf.DW_ISDELETED
    AND NOT itf.IS_TRAINING
    AND itf.LOCATION_DIM_FK IN (SELECT table1.value FROM table(split_to_table(:locationidS, '','')) table1)
INNER JOIN
    DATAWAREHOUSE.CHEQUE_FACT chk ON chk.CHEQUE_FACT_NK = itf.CHEQUE_FACT_FK
    AND chk.DW_ISCURRENTROW
    AND chk.STATUS = ''Closed''
    AND (chk.FISCAL_DATE::date >= :startdate::date AND chk.FISCAL_DATE::date <= :enddate::date)
INNER JOIN
    DATAWAREHOUSE.LOCATION_DIM loc ON itf.LOCATION_DIM_FK = loc.LOCATION_DIM_NK AND loc.DW_ISCURRENTROW
INNER JOIN
    DATAWAREHOUSE.DAYPART_DIM dad ON itf.daypart_dim_fk = dad.daypart_dim_nk AND dad.DW_ISCURRENTROW = TRUE
INNER JOIN
    DATAWAREHOUSE.REPORTCATEGORY_DIM meg ON med.REPORTCATEGORY_DIM_FK = meg.REPORTCATEGORY_DIM_NK AND meg.DW_ISCURRENTROW = TRUE
INNER JOIN
    DATAWAREHOUSE.COGSCATEGORY_DIM ccd ON ccd.COGSCATEGORY_DIM_NK = meg.COGSCATEGORY_DIM_FK AND ccd.DW_ISCURRENTROW

-- ============================ MODIFICATION START ============================
-- 3. The entire LEFT JOIN subquery to calculate partial discounts is no longer needed and has been removed.
--    This simplifies the query and makes it more performant.
--
--  (REMOVED THE FOLLOWING BLOCK)
--
--  LEFT JOIN (
--      SELECT daf.ITEM_FACT_FK, SUM(daf.APPLIED_AMOUNT) AS ""Item Discount Amount""
--      FROM DATAWAREHOUSE.DISCOUNTITEM_FACT daf
--      WHERE daf.DW_ISCURRENTROW
--          AND (daf.FISCAL_DATE::date >= :startdate::date AND daf.FISCAL_DATE::date <= :enddate::date)
--          AND daf.LOCATION_DIM_FK IN (SELECT table1.value FROM table(split_to_table(:locationidS, '','')) table1)
--          AND NOT daf.IS_TRAINING
--      GROUP BY daf.ITEM_FACT_FK
--  ) dis
--  ON dis.ITEM_FACT_FK = itf.ITEM_FACT_NK
-- ============================= MODIFICATION END =============================

);
RETURN TABLE(reportSet);
END;
';"
PROCEDURE,DATAADMIN,"SP_REPORT_ACCOUNTSUMMARY_PAYMENTS_TAXDETAIL(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_ACCOUNTSUMMARY_PAYMENTS_TAXDETAIL""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet           resultset;
  -- startdate string    := ''2025-11-05'';  
  -- enddate string      := ''2025-11-05''; 
  -- locationid string   := ''[27]'';
  locationidS string  :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');

  -- CALL DATAADMIN.SP_REPORT_ACCOUNTSUMMARY_PAYMENTS_TAXDETAIL(''2000-11-20T14:48:37.661Z'',''2026-11-20T14:48:37.661Z'',''[351,27]'');
-- =======================================================================================
-- CALL DATAWAREHOUSE.SP_REPORTDATAGROOM(''SP_REPORT_ACCOUNTSUMMARY_PAYMENTS_TAXDETAIL'',2,3);
-- CALL dataadmin.SP_REPORT_ACCOUNTSUMMARY_PAYMENTS_TAXDETAIL(''2001-01-20T14:48:37.661Z'',''2026-11-20T14:48:37.661Z'',''[361, 352, 353, 351, 574, 480, 433, 421, 408, 399, 390, 389, 379, 382, 385, 387, 388]'');
-- GRANT usage ON procedure DATAADMIN.SP_REPORT_ACCOUNTSUMMARY_PAYMENTS_TAXDETAIL(timestamp_tz,timestamp_tz,string) TO ROLE DATA_REPLICATION_HOSPENG;
  
--=========================================================================================

BEGIN
  DROP TABLE IF EXISTS TEMP_TABLE1;
  DROP TABLE IF EXISTS TEMP_TABLE2;

 SELECT 
    tax.LOCATION_DIM_FK                                       as ""Location ID""
    ,IFNULL(tax.TAXRATENAME,'' None'')                          as ""Rate Name""
    ,tax.PERCENT::NUMBER(18,2)                                as ""Rate""
    ,CASE WHEN is_tax_included THEN tax.AMOUNT ELSE 0 END     as ""Inclusive""
    ,CASE WHEN noT is_tax_included THEN tax.AMOUNT ELSE 0 END as ""Exclusive""
    ,0.00                                                     as ""Fee Tax""    
    ,tax.AMOUNT::NUMBER(18,2)                                 as ""Tax Total""

FROM DATAWAREHOUSE.TAX_FACT                                   tax
    INNER JOIN DATAWAREHOUSE.CHEQUE_FACT                      chk
        ON chk.CHEQUE_FACT_NK = tax.CHEQUE_FACT_FK
          AND chk.DW_ISCURRENTROW
          AND NOT chk.IS_VOID
          AND NOT chk.DW_ISDELETED
          AND CHK.UNPAID = 0
     INNER JOIN DATAWAREHOUSE.ITEM_FACT                       itf
        ON itf.ITEM_FACT_NK = tax.ITEM_FACT_FK
          AND itf.DW_ISCURRENTROW
          AND tax.ITEMSTATUS IN (''Added'',''Sent'')
          AND tax.CHECKSTATUS = ''Closed''
          AND tax.OPENED_AT is not null
          AND tax.DW_ISCURRENTROW  
          AND NOT tax.DW_ISDELETED
          AND NOT tax.IS_TRAINING
          AND tax.FISCAL_DATE::date
              >= :startdate::date 
          AND tax.FISCAL_DATE::date  
              <= :enddate::date 
          AND tax.LOCATION_DIM_FK IN ( 
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1);
  CREATE TEMP TABLE TEMP_TABLE1 AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

--=========================================================================================     
--get taxes for fees
   SELECT 
     tax.LOCATION_DIM_FK                                     as ""Location ID""
    ,IFNULL(tax.TAXRATENAME,'' None'')                         as ""Rate Name""
    ,tax.PERCENT::NUMBER(18,2)                               as ""Rate""
    ,0::NUMBER(18,2)                                         as ""Inclusive""
    ,0::NUMBER(18,2)                                         as ""Exclusive""
    ,tax.TAX::NUMBER(18,2)                                   as ""Fee Tax""
    ,0::NUMBER(18,2)                                         as ""Tax Total""
   FROM DATAWAREHOUSE.FEETAX_FACT                            tax
     INNER JOIN DATAWAREHOUSE.CHEQUE_FACT                    chk
        ON chk.CHEQUE_FACT_NK = tax.CHEQUE_FACT_FK
          AND chk.STATUS = ''Closed''
          AND chk.OPENED_AT is not null
          AND chk.DW_ISCURRENTROW          
          AND tax.DW_ISCURRENTROW  
          AND NOT tax.DW_ISDELETED
          AND NOT tax.IS_TRAINING
          AND tax.FISCAL_DATE::date
              >= :startdate::date 
          AND tax.FISCAL_DATE::date  
              <= :enddate::date 
          AND tax.LOCATION_DIM_FK IN ( 
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1);
                  
  CREATE TEMP TABLE TEMP_TABLE2 AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));                  
;                       

--=========================================================================================
 reportSet:= (
   SELECT 
     TO_CHAR(ROW_NUMBER() OVER (ORDER BY INLT.""Location ID""))   AS  ""Support ID"" 
       ,INLT.""Location ID""                                      AS ""Location ID""
       ,INLT.""Rate Name""                                        AS ""Rate Name""
       ,INLT.""Rate""                                             AS ""Rate""
       ,SUM(INLT.""Inclusive"")::NUMBER(18,2)                     AS ""Inclusive""
       ,SUM(INLT.""Exclusive"")::NUMBER(18,2)                     AS ""Exclusive""
       ,SUM(INLT.""Fee Tax"")::NUMBER(18,2)                       AS ""Fee Tax""
       ,SUM(IFNULL(INLT.""Tax Total"",0) + IFNULL(INLT.""Fee Tax"",0) )::NUMBER(18,2)   AS ""Tax Total"" 

     FROM (
     SELECT * from TEMP_TABLE1
       UNION ALL
     SELECT * from TEMP_TABLE2
     ) INLT
  GROUP BY ""Location ID""
     ,""Rate Name""
     ,""Rate""
);

--===========================================================================================
RETURN TABLE(reportSet); 

END';"
PROCEDURE,DATAADMIN,"SP_REPORT_PAYINOUT(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_PAYINOUT""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2020-01-02T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2029-08-02T14:48:37.661Z''; 
  -- locationid string      := ''[2,3,4,351,352]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--======================================================================================================
BEGIN
reportSet   := (
SELECT TO_CHAR(PIF.PAYINOUT_FACT_NK)                    AS ""Support ID"" 
        , ''PAY-'' ||row_number() over (order by PIF.PAYINOUT_FACT_NK) 
                                                        AS ""Detail ID"" 
--status, category, level-------------------------------------------------------------------------------
   ,PIF.STATUS                                          AS ""Status""
   ,PIR.TYPE                                            AS ""Pay Type""  --PAY IN or PAY OUT
--geography---------------------------------------------------------------------------------------------
   ,loc.LOCATIONNAME                                    AS ""Location""   
   ,loc.LOCATION_DIM_NK                                 AS ""Location ID""     
--dates-------------------------------------------------------------------------------------------------
  ,LOC.TZ_NAME                                          AS ""Time Zone""
  ,to_char(LEFT(SHD.FISCAL_DAY,4))                      AS ""Year""
  ,to_char(YEAR(SHD.FISCAL_DAY)) || ''|'' || TO_CHAR(RIGHT(''0'' || MONTH(SHD.FISCAL_DAY),2))                                       
                                                        AS ""Year and Month""

   ,to_char(SHD.FISCAL_DAY)                             AS ""Fiscal Date""      

    
          -- ,PIF.CREATED_AT::timestamp_ntz  
    ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,PIF.CREATED_AT::timestamp_ntz )::timestamp)             
                                                        AS ""Applied At""

    ,DATE_PART(epoch_second,PIF.CREATED_AT)::DECIMAL(18,0)  
                                                        AS ""Applied At UTC""
                                                           
    ,IFNULL(DAYNAME(SHD.FISCAL_DAY),''None'')             AS""Day of Week""
    ,CASE WHEN DAYNAME(SHD.FISCAL_DAY) IN (''Sat'',''Sun'')  
             THEN TRUE ELSE FALSE END                   AS ""Is Weekend""
 --flags-------------------------------------------------------------------------------------------------
  ,PIF.IS_VOID                                          AS ""Is Voided""           --Was it Voided 
 --people------------------------------------------------------------------------------------------------
 ,EMD.EMPLOYEE_NAME                                     AS ""Employee""
 --Descriptors------------------------------------------------------------------------------------------- 
  ,PIR.PAYINPAYOUTREASON                                AS ""Reason""              --Paid In or Out Reason
  ,PIF.NOTES                                            AS ""Note""                --Associated Note
  ,PAD.PAYMENTMETHODNAME                                AS ""Payment Method""      --Which Payment Method was used 
  ,CCT.CARD_TYPE                                        AS ""Card Brand""
  ,REPLACE(PAD.PAYMENTMETHODTYPE,''EPX'',''Credit Card'')   AS ""Type""
  ,TO_CHAR(PIF.SHIFT_ID)                                AS ""Shift""
--Facts-------------------------------------------------------------------------------------------------  
  ,1::NUMBER(18,0)                                      AS ""Count""
  ,PIF.AMOUNT::DECIMAL(18,2)                            AS ""Amount""
  ,CASE WHEN PIF.IS_VOID 
    THEN PIF.AMOUNT ELSE 0 END ::DECIMAL(18,2)          AS ""Void Amount""         --If applicable  
 --------------------------------------------------------------------------------------------------------  
FROM DATAADMIN.PAYINOUT_FACT                                                PIF
 INNER JOIN SHIFT_DIM                                                       SHD
     ON SHD.SHIFT_DIM_NK = PIF.SHIFT_DIM_FK
      AND SHD.DW_ISCURRENTROW
      AND PIF.STATUS = ''Success''      
      AND PIF.DW_ISCURRENTROW
      AND NOT PIF.IS_VOID
      AND NOT PIF.DW_ISDELETED
      AND SHD.FISCAL_DAY::DATE >= :startdate::DATE
      AND SHD.FISCAL_DAY::DATE <= :enddate::DATE
      AND SHD.LOCATION_DIM_FK in (
          SELECT table1.value 
            FROM table(split_to_table(:locationidS, '',''))  table1)
  INNER JOIN DATAADMIN.LOCATION_DIM                                         LOC
    ON LOC.LOCATION_DIM_NK = SHD.LOCATION_DIM_FK
      AND LOC.DW_ISCURRENTROW
  INNER JOIN DATAADMIN.PAYMENTMETHOD_DIM                                    PAD
    ON PIF.PAYMENTMETHOD_DIM_FK = PAD.PAYMENTMETHOD_DIM_NK 
      AND PAD.DW_ISCURRENTROW
   INNER JOIN PAYINPAYOUTREASON_DIM                                         PIR
     ON PIF.PAYINPAYOUTREASON_DIM_FK = PIR.PAYINPAYOUTREASON_DIM_PK
      AND PIR.DW_ISCURRENTROW 
   INNER JOIN EMPLOYEE_DIM                                                  EMD
     ON SHD.EMPLOYEE_DIM_FK = EMD.EMPLOYEE_DIM_NK
      AND EMD.DW_ISCURRENTROW
   LEFT JOIN CCTRANSACTION_FACT                                             CCT
     ON CCT.CCTRANSACTION_FACT_NK = PIF.CCTRANSATION_FACT_FK
       AND CCT.DW_ISCURRENTROW
--==========================================================================================
); 
 RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,"SP_REPORT_TAX(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_TAX""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2025-06-24'';  
  -- enddate timestamp_tz   := ''2025-06-24''; 
  -- locationid string      := ''[41]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--========================================================================================================
BEGIN
  DROP TABLE IF EXISTS temp_itemtax;
  DROP TABLE IF EXISTS temp_feetax;  

SELECT 
    TAX_FACT_NK                                           as ""Support ID"" 
    , ''TAX-'' ||row_number() over (order by TAX_FACT_NK) 
                                                          as ""Detail ID""  
--Status, category, level------------------------------------------------------------------------------------
    ,IFNULL(tax.CHECKSTATUS,''None'')                       as ""Check Status""
    ,IFNULL(tax.ITEMSTATUS,''None'')                        as ""Item Status""
    ,IFNULL(ccd.COGSCATEGORY,''None'')                      as ""Category""
-- --Geography----------------------------------------------------------------------------------------------
    ,IFNULL(org.ORGANIZATION,''None'')                      as ""Organization""    
    ,IFNULL(loc.LOCATIONNAME,''None'')                      as ""Location""
    ,loc.LOCATION_DIM_NK                                  as ""Location ID""    
    ,IFNULL(tax.REVENUECENTERNAME,''None'')                 as ""Revenue Center""
-- --Dates---------------------------------------------------------------------------------------------------
   ,LOC.TZ_NAME                                           as ""Time Zone""
    ,to_char(LEFT(tax.FISCAL_DATE,4))                     as ""Year""
    ,to_char(YEAR(tax.FISCAL_DATE)) || ''|'' 
        || TO_CHAR(RIGHT(''0'' || MONTH(tax.FISCAL_DATE),2))
                                                          as ""Year and Month""
    ,IFNULL(dad.DAYPART,''None'')                           as ""Daypart""
    
    -- ,tax.CLOSED_AT::timestamp_ntz 
    ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,
       tax.CLOSED_AT::timestamp_ntz )::timestamp) 
                                                          as ""Closed At""
    ,to_char(tax.FISCAL_DATE)                             as ""Fiscal Date""

    ,IFNULL(DAYNAME(tax.FISCAL_DATE),''None'')              as ""Day of Week""
    ,CASE WHEN DAYNAME(tax.FISCAL_DATE) IN (''Sat'',''Sun'')  
       THEN TRUE ELSE FALSE END                           as ""Is Weekend"" 
-- --Flags---------------------------------------------------------------------------------------------------
    ,tax.IS_TAX_INCLUDED::BOOLEAN                         as ""Is Tax Included""
-- --People--------------------------------------------------------------------------------------------------
-- --Descriptors---------------------------------------------------------------------------------------------- 
    ,IFNULL(tax.CHEQUENUMBER ,''None'')                     as ""Check""
    ,IFNULL(med.MENUITEMNAME,'' None'')                     as ""Menu Item""
    ,IFNULL(ord.ORDER_TYPE,'' None'')                       as ""Order Type""
    ,IFNULL(tax.TAXRATENAME,'' None'')                      as ""Rate Name""
-- --Facts-----------------------------------------------------------------------------------------------------
    ,1::NUMBER(18,0)                                      as ""Count""
    ,CASE WHEN split_part(tax.tax_fact_nk, ''.'',  3)  = 0
      THEN itf.GROSS::NUMBER(18,2)  
      ELSE NULL::NUMBER(18,2) 
      END                              
                                                          as ""Gross""                      
    ,CASE WHEN split_part(tax.tax_fact_nk, ''.'',  3)  = 0
      THEN itf.APPLIEDAMOUNT::NUMBER(18,2)  
      ELSE NULL::NUMBER(18,2) 
      END
                                                          as ""Applied Amount""
    
    ,(CASE WHEN ABS(tax.AMOUNT - (itf.GROSS * (tax.PERCENT/100))) < 0.009
      THEN itf.GROSS 
      ELSE itf.APPLIEDAMOUNT END) ::NUMBER(18,2)          as ""Tax Basis Amount""
    ,tax.AMOUNT::NUMBER(18,2)                             as ""Tax Amount""
    ,tax.AMOUNT::NUMBER(18,2)                             as ""Tax Total""   
    ,tax.PERCENT::NUMBER(18,2)                            as ""Tax Percent""
----------------------------------------------------------------------------------------------------------------   
FROM DATAWAREHOUSE.TAX_FACT                               tax
     INNER JOIN DATAWAREHOUSE.ITEM_FACT                   itf
        ON itf.ITEM_FACT_NK = tax.ITEM_FACT_FK
          AND itf.DW_ISCURRENTROW
          AND itf.MTLN_CDC_SEQUENCE_NUMBER = tax.MTLN_CDC_SEQUENCE_NUMBER
          AND tax.ITEMSTATUS IN (''Added'',''Sent'')
          AND tax.CHECKSTATUS = ''Closed''
          AND tax.OPENED_AT is not null
          AND tax.DW_ISCURRENTROW  
          AND NOT tax.DW_ISDELETED
          AND NOT tax.IS_TRAINING
          AND tax.FISCAL_DATE::date
              >= :startdate::date 
          AND tax.FISCAL_DATE::date  
              <= :enddate::date 
          AND tax.LOCATION_DIM_FK IN ( 
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)
      INNER JOIN DATAWAREHOUSE.LOCATION_DIM                 loc
        ON tax.LOCATION_DIM_FK = loc.LOCATION_DIM_NK
          AND loc.DW_ISCURRENTROW
      INNER JOIN DATAWAREHOUSE.MENUITEMNAME_DIM             med
       ON med.MENUITEMNAME_DIM_NK = tax.MENUITEMNAME_DIM_FK
         AND med.DW_ISCURRENTROW
      INNER JOIN DATAWAREHOUSE.ORDERTYPE_DIM                ord
        ON ord.ORDERTYPE_DIM_NK = tax.ORDERTYPE_DIM_FK
          AND ord.DW_ISCURRENTROW
      INNER JOIN DATAWAREHOUSE.ORGANIZATION_DIM             org
        ON org.ORGANIZATION_DIM_NK = loc.ORGANIZATION_DIM_FK
          AND org.DW_ISCURRENTROW
      INNER JOIN DATAWAREHOUSE.DAYPART_DIM                  dad
        ON tax.DAYPART_DIM_FK = dad.DAYPART_DIM_NK
          AND dad.DW_ISCURRENTROW         
      INNER JOIN DATAWAREHOUSE.REPORTCATEGORY_DIM           meg
        ON med.REPORTCATEGORY_DIM_FK = meg.REPORTCATEGORY_DIM_NK
          AND meg.DW_ISCURRENTROW 
    INNER JOIN DATAWAREHOUSE.COGSCATEGORY_DIM               ccd
        ON ccd.COGSCATEGORY_DIM_NK = meg.COGSCATEGORY_DIM_FK    
          AND ccd.DW_ISCURRENTROW
order by itf.ITEM_FACT_NK, tax.tax_fact_nk
;

CREATE TEMP TABLE temp_itemtax AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID())); 
-------------------------------------------------------------------------------------------------------------
SELECT 
     FEETAX_FACT_NK                                          as ""Support ID"" 
     , ''FEE-'' ||row_number() over (order by FEETAX_FACT_NK) 
                                                             as ""Detail ID""  
--Status, category, level------------------------------------------------------------------------------------
    ,IFNULL(chk.STATUS,''None'')                               as ""Check Status""
    ,''None''                                                  as ""Item Status""
    ,''None''                                                  as ""Category""
-- -- --Geography----------------------------------------------------------------------------------------------
    ,IFNULL(org.ORGANIZATION,''None'')                         as ""Organization""    
    ,IFNULL(loc.LOCATIONNAME,''None'')                         as ""Location""
    ,loc.LOCATION_DIM_NK                                     as ""Location ID""   
    ,IFNULL(chk.REVENUECENTERNAME,''None'')                    as ""Revenue Center""
-- -- --Dates---------------------------------------------------------------------------------------------------
   ,LOC.TZ_NAME                                              as ""Time Zone""
    ,to_char(LEFT(tax.FISCAL_DATE,4))                        as ""Year""
    ,to_char(YEAR(tax.FISCAL_DATE)) || ''|'' 
        || TO_CHAR(RIGHT(''0'' || MONTH(tax.FISCAL_DATE),2))
                                                             as ""Year and Month""
    ,IFNULL(dad.DAYPART,''None'')                              as ""Daypart""
    
    ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,
       chk.CLOSED_AT::timestamp_ntz )::timestamp) 
                                                             as ""Closed At""
    ,to_char(chk.FISCAL_DATE)                                as ""Fiscal Date""

    ,IFNULL(DAYNAME(chk.FISCAL_DATE),''None'')                 as ""Day of Week""
    ,CASE WHEN DAYNAME(chk.FISCAL_DATE) IN (''Sat'',''Sun'')  
       THEN TRUE ELSE FALSE END                              as ""Is Weekend"" 
-- -- --Flags---------------------------------------------------------------------------------------------------
    ,tax.IS_TAXINCLUDED::BOOLEAN                             as ""Is Tax Included""
-- -- --People--------------------------------------------------------------------------------------------------
-- -- --Descriptors---------------------------------------------------------------------------------------------- 
    ,IFNULL(tax.CHEQUENUMBER ,''None'')                        as ""Check""
    ,''None''                                                  as ""Menu Item""
    ,IFNULL(ord.ORDER_TYPE,'' None'')                          as ""Order Type""
    ,IFNULL(tax.TAXRATENAME,'' None'')                         as ""Rate Name""
-- -- --Facts-----------------------------------------------------------------------------------------------------
    ,1::NUMBER(18,0)                                         as ""Count""
    ,0::NUMBER(18,0)                                         as ""Gross""                                                                     
    ,tax.APPLIEDAMOUNT::NUMBER(18,2)                         as ""Applied Amount""
    ,tax.TAXBASIS ::NUMBER(18,2)                             as ""Tax Basis Amount""
    ,tax.TAX::NUMBER(18,2)                                   as ""Tax Amount""
    ,tax.TAX::NUMBER(18,2)                                   as ""Tax Total""   
    ,tax.PERCENT::NUMBER(18,2)                               as ""Tax Percent""
----------------------------------------------------------------------------------------------------------------   
FROM DATAWAREHOUSE.FEETAX_FACT                               tax
     INNER JOIN DATAWAREHOUSE.CHEQUE_FACT                    chk
        ON chk.CHEQUE_FACT_NK = tax.CHEQUE_FACT_FK
          AND chk.TAX > 0.000
          AND chk.STATUS = ''Closed''
          AND chk.OPENED_AT is not null
          AND chk.DW_ISCURRENTROW          
          AND tax.DW_ISCURRENTROW  
          AND NOT tax.DW_ISDELETED
          AND NOT tax.IS_TRAINING
          AND tax.FISCAL_DATE::date
              >= :startdate::date 
          AND tax.FISCAL_DATE::date  
              <= :enddate::date 
          AND tax.LOCATION_DIM_FK IN ( 
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)
      INNER JOIN DATAWAREHOUSE.LOCATION_DIM                 loc
        ON tax.LOCATION_DIM_FK = loc.LOCATION_DIM_NK
          AND loc.DW_ISCURRENTROW
      INNER JOIN DATAWAREHOUSE.ORDERTYPE_DIM                ord
        ON ord.ORDERTYPE_DIM_NK = chk.ORDERTYPE_DIM_FK
          AND ord.DW_ISCURRENTROW
      INNER JOIN DATAWAREHOUSE.ORGANIZATION_DIM             org
        ON org.ORGANIZATION_DIM_NK = loc.ORGANIZATION_DIM_FK
          AND org.DW_ISCURRENTROW
      INNER JOIN DATAWAREHOUSE.DAYPART_DIM                  dad
        ON tax.DAYPART_DIM_FK = dad.DAYPART_DIM_NK
          AND dad.DW_ISCURRENTROW         ;

    CREATE TEMP TABLE temp_feetax AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID())); 
-------------------------------------------------------------------------------------------------------------
 reportSet:= (
 select * from (
select * from temp_itemtax
  union
select * from temp_feetax  
)
--==============================================================================================================
);
RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,SP_STAGELOADGIFTCARDACTIVITY_FACT(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADGIFTCARDACTIVITY_FACT""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.GIFTCARDACTIVITY_FACT),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.GIFTCARDACTIVITY_FACT(   
          GIFTCARDACTIVITY_FACT_NK, 
          GIFTCARD, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          ACCOUNT_DIM_FK, 
          CHEQUE_FACT_FK, 
          DAYPART_DIM_FK, 
          EMPLOYEE_DIM_FK_AS_CREATOR, 
          LOCATION_DIM_FK, 
          MERCHANT_DIM_FK, 
          ORDERTYPE_DIM_FK, 
          REVENUECENTER_DIM_FK, 
          STATUSREASON_DIM_FK, 
          IS_RELOAD, 
          IS_TRAINING, 
          CREATED_AT, 
          UPDATED_AT, 
          OPENED_AT, 
          FISCALDATE, 
          AUTHGUIDID, 
          CHEQUENUMBER, 
          CURRENCY_ID, 
          FLOORPLAN_ID, 
          REVENUECENTERNAME, 
          STATUS, 
          STATUSREASON, 
          TABLENAME, 
          PARTYSIZE, 
          AMOUNT 
) 
 SELECT   GIFTCARDACTIVITY_FACT_NK  as   GIFTCARDACTIVITY_FACT_NK,  
   GIFTCARD  as   GIFTCARD,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   ACCOUNT_DIM_FK  as   ACCOUNT_DIM_FK,  
   CHEQUE_FACT_FK  as   CHEQUE_FACT_FK,  
   DAYPART_DIM_FK  as   DAYPART_DIM_FK,  
   EMPLOYEE_DIM_FK_AS_CREATOR  as   EMPLOYEE_DIM_FK_AS_CREATOR,  
   LOCATION_DIM_FK  as   LOCATION_DIM_FK,  
   MERCHANT_DIM_FK  as   MERCHANT_DIM_FK,  
   ORDERTYPE_DIM_FK  as   ORDERTYPE_DIM_FK,  
   REVENUECENTER_DIM_FK  as   REVENUECENTER_DIM_FK,  
   STATUSREASON_DIM_FK  as   STATUSREASON_DIM_FK,  
   IS_RELOAD  as   IS_RELOAD,  
   IS_TRAINING  as   IS_TRAINING,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   OPENED_AT  as   OPENED_AT,  
   FISCALDATE  as   FISCALDATE,  
   AUTHGUIDID  as   AUTHGUIDID,  
   CHEQUENUMBER  as   CHEQUENUMBER,  
   CURRENCY_ID  as   CURRENCY_ID,  
   FLOORPLAN_ID  as   FLOORPLAN_ID,  
   REVENUECENTERNAME  as   REVENUECENTERNAME,  
   STATUS  as   STATUS,  
   STATUSREASON  as   STATUSREASON,  
   TABLENAME  as   TABLENAME,  
   PARTYSIZE  as   PARTYSIZE,  
   AMOUNT  as   AMOUNT 
  FROM DATAADMIN.GIFTCARDACTIVITY_FACT
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''GIFTCARDACTIVITY_FACT'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''GIFTCARDACTIVITY_FACT'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADOVERTIMELABORRULE_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADOVERTIMELABORRULE_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.OVERTIMELABORRULE_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.OVERTIMELABORRULE_DIM(   
          OVERTIMELABORRULE_DIM_NK, 
          OVERTIMERULE, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          LOCATION_DIM_FK, 
          SHOULD_NOTIFY_MANAGER, 
          IS_ACTIVE, 
          CREATED_AT, 
          UPDATED_AT, 
          HOURS_PER_DAY, 
          HOURS_PER_WEEK 
) 
 SELECT   OVERTIMELABORRULE_DIM_NK  as   OVERTIMELABORRULE_DIM_NK,  
   OVERTIMERULE  as   OVERTIMERULE,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   LOCATION_DIM_FK  as   LOCATION_DIM_FK,  
   SHOULD_NOTIFY_MANAGER  as   SHOULD_NOTIFY_MANAGER,  
   IS_ACTIVE  as   IS_ACTIVE,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   HOURS_PER_DAY  as   HOURS_PER_DAY,  
   HOURS_PER_WEEK  as   HOURS_PER_WEEK 
  FROM DATAADMIN.OVERTIMELABORRULE_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''OVERTIMELABORRULE_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''OVERTIMELABORRULE_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADPAYINPAYOUTREASON_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADPAYINPAYOUTREASON_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.PAYINPAYOUTREASON_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.PAYINPAYOUTREASON_DIM(   
          PAYINPAYOUTREASON_DIM_NK, 
          PAYINPAYOUTREASON, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          ORGANIZATION_DIM_FK, 
          IS_ENABLED, 
          IS_PAY_IN, 
          CREATED_AT, 
          UPDATED_AT, 
          TYPE, 
          DESCRIPTION 
) 
 SELECT   PAYINPAYOUTREASON_DIM_NK  as   PAYINPAYOUTREASON_DIM_NK,  
   PAYINPAYOUTREASON  as   PAYINPAYOUTREASON,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   ORGANIZATION_DIM_FK  as   ORGANIZATION_DIM_FK,  
   IS_ENABLED  as   IS_ENABLED,  
   IS_PAY_IN  as   IS_PAY_IN,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   TYPE  as   TYPE,  
   DESCRIPTION  as   DESCRIPTION 
  FROM DATAADMIN.PAYINPAYOUTREASON_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''PAYINPAYOUTREASON_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''PAYINPAYOUTREASON_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,"SP_STREAM_DASHBOARD_SHIFT(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_STREAM_DASHBOARD_SHIFT""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet      resultset;
  -- startdate      date     := ''2020-03-26'';  
  -- enddate        date     := ''2029-04-10''; 
  -- locationid     string   := ''[351]'';
  locationidS string      :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
  today          char(11) := CURRENT_DATE()::DATE::VARCHAR(10);
  yesterdaydate  date     := dateadd(day,-1,:today);
  weekOffset     int      := (  
                              SELECT TOP 1 ORG.START_OF_BIZ_WEEK_INT  
                                FROM DATAWAREHOUSE.ORGANIZATION_DIM          ORG
                                  INNER JOIN DATAWAREHOUSE.LOCATION_DIM      LOC 
                                     ON LOC.ORGANIZATION_DIM_FK = ORG.ORGANIZATION_DIM_NK
                                        AND LOC.DW_ISCURRENTROW
                                        AND LOC.DW_ISCURRENTROW
                                        AND LOC.LOCATION_DIM_NK in (
                                             SELECT table1.value 
                                          FROM table(split_to_table(:locationidS, '',''))  table1) 
                             );
  lastWeekStart  date     := (DATEADD(DAY,
                                ((DAYOFWEEK(:today::date) - (:weekOffset )  ) * -1)  -7
                                + case when DAYOFWEEK(:today::date)< :weekOffset then -0 else 0 end
                                 , :today)) ::date;
  lastWeekEnd    date     := dateadd(day,6,:lastWeekStart);
  lastMonthStart date     := left(dateadd(month,-1,:today)::date::string,7) || ''-01'';
  lastMonthEnd   date     := dateadd(day,-1,dateadd(month,1,lastMonthStart))::date;
  lastYearStart  date     := date_part(year,(dateadd(year,-1,:today))) || ''-01-01'';                  
  lastYearEnd    date     := dateadd(day,-1,dateadd(year,1,:lastYearStart));

---====================================================================================================================
BEGIN
  DROP TABLE if exists SHIFT_DATA_TEMP; 
  DROP TABLE if exists BREAK_DATA_TEMP; 

-----------------------------------------------------------------------------------------------------------------------
SELECT TO_CHAR(SHD.""id"")                                                         AS ""Support ID""
  ,''Stream''                                                                      AS ""Origin""
  ,''None''                                                                        AS ""Check Status""
  ,''Shift''                                                                       AS ""Level""
  ,NULL                                                                          AS ""Check ID""
  ,SHD.""id""                                                                      AS ""Shift ID""
  ,SHD.""location_id""                                                             AS ""Location ID""  
  ,NULL                                                                          AS ""Revenue Center""
  ,SHD.""employee_id""                                                             AS ""Employee ID""
  ,NULL                                                                          AS ""Daypart ID""
  ,NULL                                                                          AS ""Order Type ID""   
  ,NULL                                                                          AS ""Daypart""
  ,NULL                                                                          AS ""Order Type""
  ,LOC.LOCATIONNAME                                                              AS ""Location""
  ,NULL                                                                          AS ""Menu Item""
  ,FALSE                                                                         AS ""Gets Paid Break""
--   ---------------------------------------------------------------------------------------
  ,SHD.""fiscal_date""::DATE                                                       AS ""Fiscal Date"" 
  ,NULL                                                                          AS ""Opened At""  
  ,TO_CHAR(TO_CHAR(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME
       ,SHD.""clock_in""::timestamp_ntz)::timestamp ) ::timestamp 
  , ''HH24'')::NUMBER(18,0)                                                                           
                                                                                 AS ""Hour""  
  ,(SHD.""pay_rate""/1000000)::DECIMAL(36,2)                                       AS ""Rate""
  ,TRUE                                                                          AS ""Is Current""
  ,TRUE                                                                          AS ""Is Today""                         
  ,FALSE                                                                         AS ""Is Yesterday""
  ,FALSE                                                                         AS ""Is Last Week"" 
  ,FALSE                                                                         AS ""Is Last Month"" 
  ,FALSE                                                                         AS ""Is Last Year""
-- -----------------------------------------------------------------------------------------------------------------
-- --Facts CHECK LEVEL
 ,0::NUMBER(36,0)                                                                AS ""Guest Count""
 ,0 ::NUMBER(36,0)                                                               AS ""Fee Amount""
 ,0 ::NUMBER(36,0)                                                               AS ""Gratuity Amount""
 ,0 ::NUMBER(36,0)                                                               AS ""Table Time""   
--   -----------------------------------------------------------------------------------------------------------------
--  --Facts  ITEM LEVEL (all item level amounts should be filtered for voids)
 ,ROUND(TIMEDIFF(second
               ,SHD.""clock_in""::timestamp_ntz 
               ,COALESCE(SHD.""clock_out""::timestamp_ntz,CONVERT_TIMEZONE(''UTC'', CURRENT_TIMESTAMP())::timestamp_ntz)
              )::Number(36,0),0)
                                                                               AS ""Shift Seconds""  
  ,1::NUMBER(36,0)                                                             AS ""Shift Count""
  ,0::NUMBER(36,0)                                                             AS ""Item Count""  
  ,0::NUMBER(36,0)                                                             AS ""Check Count"" 
  ,0::NUMBER(36,0)                                                             AS ""Void Count""
  ,0::DECIMAL(36,2)                                                            AS ""Void Amount"" 
  ,0::DECIMAL(36,2)                                                            AS ""Net Amount""
  ,0::DECIMAL(36,2)                                                            AS ""Discount Amount""
  ,0::DECIMAL(36,2)                                                            AS ""Gross Amount""  
----------------------------------------------------------------------------------------------------------------- 
  FROM DATASTREAMING.POSAPI_PUBLIC_EMPLOYEE_SHIFT                                 SHD
          INNER JOIN DATAWAREHOUSE.LOCATION_DIM                                   LOC
             ON SHD.""location_id"" = LOC.LOCATION_DIM_NK
                AND LOC.DW_ISCURRENTROW
                AND  SHD.""fiscal_date""::date = :today::date  
                -- AND   SHD.""location_id"" = 999999
                AND SHD.""location_id"" in (
                  SELECT table1.value 
                     FROM table(split_to_table(:locationidS, '',''))  table1)
          INNER JOIN DATAWAREHOUSE.JOBPOSITION_DIM                 JBP
            ON JBP.JOBPOSITION_DIM_NK = SHD.""job_position_id"" 
              AND JBP.DW_ISCURRENTROW
;

CREATE TEMP TABLE SHIFT_DATA_TEMP AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))
;

-----------------------------------------------------------------------------------------------------------------------
SELECT SHD_1.""Shift ID""                                         AS ""Shift ID""
 ,SHD_1.""Gets Paid Break""                                       AS ""Gets Paid Break""
 ,SUM(IFF( BRK.IS_BREAKCOMPLETE ,BRK.BREAK_SECONDS , 
          ROUND(TIMEDIFF(SECOND
            ,BRK.START_AT::timestamp_ntz 
            ,CURRENT_TIMESTAMP::timestamp_ntz 
                )::Number(38,0),0)) )                                                  
                                                                AS ""Break Seconds""

          FROM SHIFT_DATA_TEMP                                  SHD_1
            INNER JOIN DATAWAREHOUSE.SHIFTBREAK_FACT            BRK
              ON SHD_1.""Shift ID"" = BRK.SHIFT_DIM_FK
                 AND BRK.DW_ISCURRENTROW
                 AND NOT BRK.DW_ISDELETED
         GROUP BY SHD_1.""Shift ID""
            ,SHD_1.""Gets Paid Break""
;


CREATE TEMP TABLE BREAK_DATA_TEMP AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))
;

-- ----------------------------------------------------------------------------------------------------------------------
UPDATE SHIFT_DATA_TEMP  shd_2
  SET shd_2.""Shift Seconds"" = shd_2.""Shift Seconds""
    - (IFNULL((CASE WHEN brk_1.""Gets Paid Break"" THEN 0 ELSE brk_1.""Break Seconds"" END),0))
  FROM BREAK_DATA_TEMP  brk_1
  WHERE shd_2.""Shift ID"" = brk_1.""Shift ID""
    AND NOT brk_1.""Gets Paid Break""
;

-- ====================================================================================================================
 reportSet   := (
     SELECT * FROM SHIFT_DATA_TEMP  
   
--===================================================================================================
); 
 RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,"SP_UPDATEDWTABLE(VARCHAR, VARCHAR, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_UPDATEDWTABLE""(""DBNAME"" VARCHAR(50), ""SCHEMANAME"" VARCHAR(50), ""TABLENAME"" VARCHAR(50))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
        -- DBNAME VARCHAR(45)    := ''DEV_HOSPENG_REPORTING'';--''CHEQUE_FACT'';--
        -- SCHEMANAME VARCHAR(45):= ''DATAWAREHOUSE'';--''CHEQUE_FACT'';--
        -- TABLENAME VARCHAR(50) := ''SHIFT_DIM'';

        IsTableName            INT;
        col_list               RESULTSET;
        res                    RESULTSET;
       
        ErrorMessage resultset:= (SELECT ''Invalid Table name.'' AS MESSAGE);
        SuccessMessage resultset:= (SELECT ''Successful Table load.'' AS MESSAGE);        
        db_name varchar       := UPPER(DBNAME);
        schema_name varchar   := UPPER(SCHEMANAME);
        table_name varchar    := UPPER(TABLENAME);
        sqltext1 := 
  $$
 UPDATE DATAWAREHOUSE_TEMP.<TABLE NAME> tab
   SET tab.DW_ISCURRENTROW = FALSE
     ,tab.DW_ENDDATE = inlt.DW_ENDDATE_UPDATE
     ,tab.DW_UPDATETIME = CURRENT_TIMESTAMP()
FROM (
    SELECT <TABLE NAME>_PK
      ,<TABLE NAME>_NK
      ,DW_ISCURRENTROW
      ,DW_STARTDATE
      ,DW_ENDDATE 
      ,MTLN_CDC_SEQUENCE_NUMBER
      ,SUM(CASE WHEN DW_ISCURRENTROW THEN 1 ELSE 0 END) 
          OVER (PARTITION BY <TABLE NAME>_NK)                            AS DW_ISCURRENTROW_COUNT
      ,TIMESTAMPADD(NANOSECOND,-1,LEAD(DW_STARTDATE) OVER (PARTITION 
        BY <TABLE NAME>_NK ORDER BY DW_STARTDATE))                       AS DW_ENDDATE_UPDATE
      ,RANK()OVER(PARTITION BY DW_ISCURRENTROW, <TABLE NAME>_NK 
         ORDER BY DW_STARTDATE desc)
                                                                          AS IS_UPDATEROW  
    FROM DATAWAREHOUSE_TEMP.<TABLE NAME> ITM
       
)  inlt
WHERE inlt.IS_UPDATEROW > 1
  AND inlt.DW_ISCURRENTROW_COUNT > 1
  AND inlt.DW_ISCURRENTROW
  AND tab.<TABLE NAME>_NK = inlt.<TABLE NAME>_NK
  AND tab.MTLN_CDC_SEQUENCE_NUMBER = inlt.MTLN_CDC_SEQUENCE_NUMBER
  AND tab.DW_STARTDATE = inlt.DW_STARTDATE
  ;
$$;

----------------------------------------------------------------------------------------------------------
BEGIN
----------------------------------------------------------------------------------------------------------
--If the table is not found in the catalouge - retern an error message
IsTableName := (SELECT count(*)  FROM information_schema.tables t 
                   WHERE t.table_type = ''BASE TABLE''
                     AND t.table_schema = :schema_name AND t.table_name = :table_name); 
  
--========================================================================================================  
--ONLY RETURN RESULTS IF INPUT IS VALID TABLE NAME
IF (:IsTableName = 0) 
  THEN
      RETURN TABLE(ErrorMessage);
  ELSE 
     EXECUTE IMMEDIATE(REPLACE(sqltext1,''<TABLE NAME>'',:table_name));
     RETURN TABLE(SuccessMessage);
END IF;

----------------------------------------------------------------------------------------------------------
END';"
PROCEDURE,DATAADMIN,"SP_LOAD_AVERO_EXTRACTALLFILES(VARCHAR, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_AVERO_EXTRACTALLFILES""(""FISCALDATE"" VARCHAR(16777216), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet         resultset;
  -- locationid string := ''[709]'';
  -- fiscaldate string := ''2024-12-17'';
  
--=================================================================================================================================
BEGIN
 CALL dataadmin.SP_LOAD_AVERO_EXTRACTONEFILE(:fiscaldate,:locationid,''CheckHeader'');
 CALL dataadmin.SP_LOAD_AVERO_EXTRACTONEFILE(:fiscaldate,:locationid,''CheckDetail'');
 CALL dataadmin.SP_LOAD_AVERO_EXTRACTONEFILE(:fiscaldate,:locationid,''CheckTransfer'');
 CALL dataadmin.SP_LOAD_AVERO_EXTRACTONEFILE(:fiscaldate,:locationid,''MenuItemDetail'');
 CALL dataadmin.SP_LOAD_AVERO_EXTRACTONEFILE(:fiscaldate,:locationid,''Daypart'');

 -- ----------------------------------------------------------------------------------------------------------------------------------
 -- DROP TABLE if exists TEMP_FILES;
 --  LIST @DATAADMIN.STAGE-AVEROFTP;
  
 --  CREATE TEMP TABLE TEMP_FILES AS
 --     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

 --  SELECT ""name"",* FROM TEMP_FILES TEF WHERE ""name"" ILIKE (''s3://test-mqa-metl/AVEROFTP/Location351/20241218/%.csv'') order by TEF.""name"";
  
  
--=================================================================================================================================
reportSet := (  
  select ''Complete'' as STATUS
);
RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,"SP_REPORT_TENDER(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_TENDER""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2000-11-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2029-11-20T14:48:37.661Z''; 
  -- locationid string      := ''[3,2,351]'';
  locationidS string        :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
-- -- --==========================================================================================
-- --ISSUE 1:  HOW DO WE DETERMINE IF SOMETHING IS AN NFC PAYMENT???
-- --ISSUE 2:  Location groups look like there may be many groups per location.  That could throw off totals..how to pick one?
-- --ISSUE 3:  What status to use?  Success only?   
-- --QUEST 1:  DO WE FILTER OUT SOME STATUSES?  SHOW SUCCESS ONLY? compare check.payments to check.paid ---see cheque.id = 4320 and example below  ref-> WORKBOOK:  Payment sum to cheque paid
--LOOK HERE FOR ""card_entry_type""  CARD ENTRY TYPES  the cc_transaction table in the ""card_entry_type""
-- [''None''],
  -- [''Swiped Track 2''],
  -- [''Fallback Swipe''],
  -- [''EMV Contact''],
  -- [''EMV Contactless''],
  -- [''Manual Entry''],
  -- [''Fallback With No App''],
  -- [''Unknown''],
-- --==========================================================================================
BEGIN
 reportSet   := (
 
        SELECT pay.payments_fact_nk                    as ""Support ID"" 
         , ''TEN-'' ||row_number() over (order by pay.payments_fact_nk) 
                                                       as ""Detail ID""        
--status, category, level-------------------------------------------------------------------
          ,IFNULL(pay.paymentstatus,''None'')            as ""Status""
--geography--------------------------------------------------------------------------------      
          ,IFNULL(loc.locationname,''None'')             as ""Location""
          ,loc.location_dim_nk::decimal(36,0)          as ""Location ID""
          ,IFNULL(pay.revenuecentername ,''None'')       as ""Revenue Center""
 --dates-------------------------------------------------------------------------------------
     ,LOC.TZ_NAME                                      as ""Time Zone""
    ,to_char(LEFT(pay.FISCALDATE,4))                   as ""Year""
    ,to_char(YEAR(pay.FISCALDATE)) || ''|'' || TO_CHAR(RIGHT(''0'' || MONTH(pay.FISCALDATE),2))
                                                       as ""Year and Month""
    ,IFNULL(dpd.DAYPART,''None'')                        as ""Daypart"" 
           
    ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,pay.OPENED_AT::timestamp_ntz )::timestamp )         
                                                        as ""Paid At""
    ,to_char(pay.FISCALDATE)                            as ""Fiscal Day""
    ,IFNULL(DAYNAME(pay.FISCALDATE),''None'')             as ""Day of Week""
    ,CASE WHEN DAYNAME(pay.FISCALDATE) IN (''Sat'',''Sun'')  
          THEN TRUE ELSE FALSE END                      as ""Is Weekend""

--people-------------------------------------------------------------------------------------
          ,IFNULL(emd.EMPLOYEE_NAME,''None'')             as ""Employee""
--Descriptors--------------------------------------------------------------------------------    
          ,pay.CHEQUENUMBER                             as ""Check""
          ,IFNULL(ptd.paymentmethodname ,''None'')        as ""Payment Method""
          ,PAYMENTTYPE                                  as ""Payment Type""
          ,CASE WHEN  pay.PAYMENTTYPE in (''CC'',''EPX'') THEN pay.cardbrand ELSE ptd.paymentmethodname END                             
                                                        as ""Payment Name""   
          ,IFNULL(pay.cardholderName,''None'')            as ""Cardholder Name""
          ,IFNULL(pay.LASTFOURCCNUMBER,''None'')          as ""Card Last 4 Digits""
          ,IFNULL(case pay.cardbrand when '''' 
             THEN ''Not a Credit Card'' 
            else pay.cardbrand end,''None'')  
                                                        as ""Card Brand"" 
         ,otd.ORDER_TYPE                                as ""Order Type""                                                        
         ,to_char(pay.LOCATION_DIM_FK)                  as ""Location ID""
         ,pay.LOCATION_DIM_FK                           as ""Location ID INT""
 --Facts--------------------------------------------------------------------------------------  
         ,1::NUMBER(18,0)                               as ""Count""
          ,case pay.PAYMENTTYPE when ''Cash''  
              then pay.AMOUNTAPPLIEDTOCHECK::DECIMAL(18,2)  end     as ""Cash Sales"" 

          ,case pay.PAYMENTTYPE when ''Other'' 
              then pay.TOTAL end::DECIMAL(18,2)         as ""Other Sales""         --Gross of other trans
          ,case when pay.cardbrand = ''Visa'' and pay.PAYMENTTYPE in (''CC'',''EPX'')
               then pay.TOTAL end::DECIMAL(18,2)        as ""Visa Sales""           --Gross sales of al Visa trans
          ,case when pay.cardbrand = ''American Express'' and pay.PAYMENTTYPE in (''CC'',''EPX'')
               then pay.TOTAL end::DECIMAL(18,2)        as ""Amex Sales""           --Gross sales of all Amex transactions
          ,case when pay.cardbrand = ''Mastercard'' and pay.PAYMENTTYPE in (''CC'',''EPX'')
              then pay.TOTAL end::DECIMAL(18,2)         as ""Mastercard Sales""     --Gross sales of all Mastercard transactions
          ,case when pay.cardbrand = ''Discover''and pay.PAYMENTTYPE in (''CC'',''EPX'')
            then pay.TOTAL end::DECIMAL(18,2)           as ""Discover Sales""       --Gross sales of all Discover transactions
           ,case when pay.cardbrand= ''Citi'' and pay.PAYMENTTYPE in (''CC'',''EPX'')
               then pay.TOTAL end::DECIMAL(18,2)        as ""Citi Sales""                                   
          ,case when pay.PAYMENTTYPE in (''CC'',''EPX'')
              then pay.TOTAL end::DECIMAL(18,2)         as ""Credit Card Sales""   --Gross of credit card trans              
          ,IFF(cct.ISCARDPRESENT,pay.TOTAL 
            ,0.00 )::DECIMAL(18,2)                      as ""Card Present Sales""   
          --Gross sales of all transactions where the processor identified the card as present (swiped, dipped, tapped)
          ,IFF(NOT cct.ISCARDPRESENT,pay.TOTAL 
            ,0.00 )::DECIMAL(18,2)                      as ""Card Not Present Sales"" --Total Card Not Present Sales
          ,IFF( pay.PAYMENTTYPE = ''GiftCard'',pay.TOTAL 
            ,0.00 )::DECIMAL(18,2)                      as ""Gift Card""

          ,CASE WHEN pay.PAYMENTTYPE in (''EPX'',''CC'') then pay.Tip::DECIMAL(18,2) else 0 end 
                                                        as ""Credit Card Tips""
            
          ,pay.Tip::DECIMAL(18,2)                       as ""Tips""  

          ,to_numeric(CASE WHEN pay.PAYMENTTYPE = ''Cash'' THEN (pay.AMOUNTAPPLIEDTOCHECK)
                  else (pay.TOTAL ) end - ifnull(pay.TIP,0),16,2)as ""Pre Tip Total"" 

          
          ,CASE WHEN pay.PAYMENTTYPE = ''Cash'' THEN pay.AMOUNTAPPLIEDTOCHECK::DECIMAL(18,2) 
                  else pay.TOTAL ::DECIMAL(18,2) end     as ""Amount""  
          ,CASE WHEN pay.PAYMENTTYPE = ''Cash'' THEN pay.AMOUNTAPPLIEDTOCHECK::DECIMAL(18,2) 
                  else pay.TOTAL::DECIMAL(18,2) end     as ""Total""            
        FROM DATAWAREHOUSE.payments_FACT                                pay
          INNER JOIN DATAWAREHOUSE.location_DIM                         loc
            ON pay.location_DIM_FK = loc.location_DIM_NK
              AND pay.FISCALDATE::date >= :startdate::date 
              AND pay.FISCALDATE::date <= :enddate::date  
              AND pay.LOCATION_DIM_FK in (
                SELECT table1.value 
                   FROM table(split_to_table(:locationidS, '',''))  table1) 
              AND pay.dw_iscurrentrow
              AND loc.dw_iscurrentrow
              AND NOT pay.IS_TRAINING
              AND NOT pay.dw_isdeleted
              AND pay.PAYMENTSTATUS = ''Success''
          INNER JOIN DATAWAREHOUSE.PaymentMethod_DIM                     ptd      
            ON pay.PaymentMethod_DIM_FK = ptd.PaymentMethod_DIM_NK
              AND ptd.dw_iscurrentrow
              AND NOT ptd.dw_isdeleted
          INNER JOIN DATAWAREHOUSE.organization_dim                      org
            ON loc.organization_DIM_FK = org.organization_DIM_NK
              AND org.dw_iscurrentrow
              AND NOT org.dw_isdeleted
          INNER JOIN DATAWAREHOUSE.daypart_dim                           dpd
            ON pay.daypart_dim_fk = dpd.daypart_dim_nk
              AND dpd.dw_iscurrentrow
              AND NOT dpd.dw_isdeleted
          INNER JOIN DATAWAREHOUSE.ORDERTYPE_DIM                         otd
            ON otd.Ordertype_DIM_nK = pay.Ordertype_DIM_FK
              AND otd.dw_iscurrentrow
          LEFT JOIN DATAWAREHOUSE.employee_DIM                           emd
            ON emd.employee_DIM_NK = pay.EMPLOYEE_DIM_FK_AS_PAYEE
              AND emd.dw_iscurrentrow 
          LEFT JOIN DATAWAREHOUSE.CCTransaction_FACT                      cct   
            ON cct.cctransaction_fact_nk = pay.TRANSACTION_FACT_FK                     
              AND cct.dw_iscurrentrow                                                                
              AND cct.TRANSACTION_NUMBER = 1                             
    ORDER BY loc.locationname
--============================================================================
); 
 RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,"SP_REPORT_VOID_0001_DEV(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_VOID_0001_DEV""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2024-09-29T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2029-09-29T14:48:37.661Z''; 
  -- locationid string      := ''[26]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
-- --===================================================================================================================
BEGIN

-------------------------------------------------------------------------------------------------------------------------
DROP TABLE IF EXISTS TEMP_ITEM;

-------------------------------------------------------------------------------------------------------------------------
SELECT iaf.ITEM_FACT_NK                                             AS ITEM_FACT_NK
   ,iaf.CHEQUE_FACT_FK                                              AS CHEQUE_FACT_FK
   ,max(vdr_item.VOIDREASON)                                        AS VOIDREASON
   ,max(iaf.PRICE)                                                  AS ITEMPRICE
   ,sum(imf.PRICE)                                                  AS MODIFIERPRICE
   ,(max(case when iaf.PRICE > 0.0000 THEN iaf.PRICE ELSE iaf.baseprice END)
     + sum(ifnull(imf.PRICE,0))) * max(iaf.QUANTITY)                AS PRICE
        FROM (select * FROM DATAWAREHOUSE.ITEM_FACT where dw_iscurrentrow AND CHECKSTATUS <> ''MergeVoided'' AND IS_VOID AND NOT DW_ISDELETED AND NOT  IS_TRAINING  )                              iaf
           LEFT JOIN  DATAWAREHOUSE.ITEMMODIFIER_DIM                imf
              ON iaf.ITEM_FACT_NK = imf.ITEM_FACT_FK
                  -- AND iaf.LOCATION_DIM_fK = 2
                AND iaf.LOCATION_DIM_fK IN (
                    SELECT table1.value 
                      FROM table(split_to_table(:locationidS, '',''))  table1)
                -- AND iaf.FISCAL_DATE = ''2024-09-29''
                AND iaf.FISCAL_DATE::date
                    >= :startdate::date 
                AND iaf.FISCAL_DATE::date  
                   <= :enddate::date 
                AND iaf.IS_VOID
                AND iaf.CHECKSTATUS <> ''MergeVoided''
                AND iaf.DW_ISCURRENTROW 
                AND imf.DW_ISCURRENTROW 
                AND NOT iaf.DW_ISDELETED
                AND NOT iaf.IS_TRAINING
        LEFT JOIN DATAWAREHOUSE.VoidReason_DIM                        vdr_item
             ON vdr_item.VOIDREASON_DIM_NK = iaf.VoidReason_DIM_FK
               AND vdr_item.DW_ISCURRENTROW        
GROUP BY iaf.item_fact_nk,iaf.cheque_fact_fk 
;
-- select * from TEMP_ITEM where CHEQUE_FACT_FK = 243922; and item_fact_nk in (''243922.ac8be0dd-dbf7-475d-a6c5-30615561e208 = 29.95'',''243922.b8526d5c-d26c-422b-83e2-d50ea4fab464 = 59.80'');

     --item = 243922.ac8be0dd-dbf7-475d-a6c5-30615561e208 = 29.95
     --item = 243922.b8526d5c-d26c-422b-83e2-d50ea4fab464 = 59.80
-------------------------------------------------------------------------------------------------------------------------
 CREATE TEMP TABLE TEMP_ITEM AS
     SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));
  
-------------------------------------------------------------------------------------------------------------------------
 reportSet   := (
        SELECT to_char(act.activity_fact_nk)        AS ""Support ID"" 
          ,''VOID-'' ||row_number() over (order by act.activity_fact_nk) 
                                                    AS ""Detail ID""        
        --status, category, level-----------------------------------------------------------------------------------------
        ,CASE act.TYPE 
          WHEN ''ItemVoided'' 
            THEN ''Item'' 
          WHEN ''Voided'' 
            THEN ''Check''
            ELSE ''None'' 
          END 
                                                 AS ""Level""          --Values of Check or Item.
        --geography--------------------------------------------------------------------------------------------------------
        ,IFNULL(LOC.LOCATIONNAME ,''None'')        AS ""Location""
        ,LOC.LOCATION_DIM_NK                     AS ""Location ID""        
        ,IFNULL(CHK.revenueCenterName ,''None'')   AS ""Revenue Center""
        --dates------------------------------------------------------------------------------------------------------------- 
        ,LOC.TZ_NAME                                                               AS ""Time Zone""
        ,to_char(LEFT(chk.FISCAL_DATE,4))                                          AS ""Year""
        ,to_char(YEAR(chk.FISCAL_DATE)) || ''|'' || TO_CHAR(RIGHT(''0'' || MONTH(chk.FISCAL_DATE),2))                                       
                                                                                   AS ""Year and Month""
        ,IFNULL(dad.DAYPART,''None'')                                                AS ""Daypart""
        ,to_char(chk.FISCAL_DATE)                                                  AS ""Fiscal Date""
        
        --,chk.OPENED_AT::timestamp_ntz 
         ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHK.OPENED_AT::timestamp_ntz )::timestamp )
                                                                                   AS ""Check Opened At""     
        --,chk.CREATED_AT::timestamp_ntz 
        ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,CHK.CREATED_AT::timestamp_ntz )::timestamp) 
                                                                                   AS ""Item Ordered At""    
        -- ,act.PERFORMED_AT::timestamp_ntz 
        ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,act.PERFORMED_AT::timestamp_ntz )::timestamp) 
                                                                                   AS ""Voided At""
        
        ,dad.DAYPART                                                               AS ""Day Part""              
        ,IFNULL(DAYNAME(chk.FISCAL_DATE),''None'')                                   AS ""Day of Week""
        ,CASE WHEN DAYNAME(chk.FISCAL_DATE) IN (''Sat'',''Sun'')  
           THEN TRUE ELSE FALSE END                                                AS ""Is Weekend""
        
        ,TIMESTAMPDIFF(second ,chk.OPENED_AT,act.PERFORMED_AT)::NUMBER(18,0) 
                                                                                   AS ""Seconds to Void""
        ,TIMESTAMPDIFF(minute ,chk.OPENED_AT,act.PERFORMED_AT) ::NUMBER(18,0)
                                                                                   AS ""Minutes to Void""                                                 
        --Flags---------------------------------------------------------------------------------------------------------
        --People--------------------------------------------------------------------------------------------------------
        ,IFNULL(amd_asperf.EMPLOYEE_NAME,''None'') AS ""Voider""
        ,IFNULL(amd_asapp.EMPLOYEE_NAME,''None'')  AS ""Approver""   
        --Descriptors----------------------------------------------------------------------------------------------------
        ,chk.CHEQUENUMBER                        AS ""Check""
        ,chk.CHEQUE_FACT_NK                      AS ""Check ID""
        ,IFNULL(COALESCE(itf.VOIDREASON,
         vdr_check.VOIDREASON),''None'')           AS ""Reason""
        
          
        ,IFNULL(act.MENUITEMNAME,''None'')         AS ""Item""
        ,itf.ITEM_FACT_NK                        AS ""Item ID""    

        --Facts-----------------------------------------------------------------------------------------------------------
        ,1::NUMBER(18,0)                         AS ""Count""  
        ,CASE WHEN act.TYPE = ''ItemVoided'' 
            THEN itf.PRICE 
         -- ELSE chk.NET END::NUMBER(18,2)
          ELSE chk.GROSS END::NUMBER(18,2)
                                                 AS ""Amount""                   
        FROM DATAWAREHOUSE.ACTIVITY_FACT                                  act
           INNER JOIN  DATAWAREHOUSE.LOCATION_DIM                         loc
              ON act.LOCATION_DIM_FK = loc.LOCATION_DIM_NK
                AND act.LOCATION_DIM_fK IN (
                    SELECT table1.value 
                      FROM table(split_to_table(:locationidS, '',''))  table1)
                AND loc.DW_ISCURRENTROW 
                AND NOT loc.DW_ISDELETED
            INNER JOIN DATAWAREHOUSE.CHEQUE_FACT                          chk
              ON act.CHEQUE_FACT_FK = chk.CHEQUE_FACT_NK
                AND act.IS_VOID
                AND act.DW_ISCURRENTROW 
                AND chk.FISCAL_DATE::date >= :startdate::date 
                AND chk.FISCAL_DATE::date <= :enddate::date  
                AND NOT act.DW_ISDELETED
                AND chK.DW_ISCURRENTROW 
                AND NOT chk.DW_ISDELETED
                AND NOT chk.IS_TRAINING
            INNER JOIN DATAWAREHOUSE.DAYPART_DIM                          dad
              ON chk.DAYPART_DIM_FK = dad.daypart_dim_Nk
                AND dad.DW_ISCURRENTROW 
                AND NOT dad.DW_ISDELETED
           
            LEFT JOIN DATAWAREHOUSE.EMPLOYEE_DIM                          amd_asperf
              ON act.EMPLOYEE_DIM_FK_AS_PERFORMING_EMPLOYEE 
                  = amd_asperf.EMPLOYEE_DIM_NK
                AND amd_asperf.DW_ISCURRENTROW 
                AND NOT amd_asperf.DW_ISDELETED 
            LEFT JOIN DATAWAREHOUSE.EMPLOYEE_DIM                          amd_asapp
              ON act.EMPLOYEE_DIM_FK_AS_APPROVING_EMPLOYEE 
                  = amd_asapp.EMPLOYEE_DIM_NK
                AND amd_asapp.DW_ISCURRENTROW 
                AND NOT amd_asapp.DW_ISDELETED   
            LEFT JOIN DATAWAREHOUSE.VoidReason_DIM                        vdr_check
             ON vdr_check.VOIDREASON_DIM_NK = CHK.VoidReason_DIM_FK
               AND vdr_check.DW_ISCURRENTROW 
               AND NOT vdr_check.DW_ISDELETED
            LEFT JOIN TEMP_ITEM                                              itf
              ON itf.Item_fact_NK = act.Item_fact_fk 
            -- LEFT JOIN DATAWAREHOUSE.ITEM_FACT                             itf
            --  ON itf.Item_fact_NK = act.Item_fact_fk
            --    AND itf.DW_ISCURRENTROW 
            --    AND NOT itf.DW_ISDELETED        
            -- LEFT JOIN DATAWAREHOUSE.VoidReason_DIM                        vdr_item
            --  ON vdr_item.VOIDREASON_DIM_NK = itf.VoidReason_DIM_FK
            --    AND vdr_item.DW_ISCURRENTROW 
            --    AND NOT vdr_item.DW_ISDELETED     
--=================================================================================================================
); 
 RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,SP_STAGELOADSTANDARDDISCOUNT_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADSTANDARDDISCOUNT_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.STANDARDDISCOUNT_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.STANDARDDISCOUNT_DIM(   
          STANDARDDISCOUNT_DIM_NK, 
          STANDARDDISCOUNTNAME, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          ORGANIZATION_DIM_FK, 
          IS_ENABLED, 
          IS_TAXABLE, 
          DO_AUTO_APPLY, 
          REQUIRE_APPROVAL, 
          CREATED_AT, 
          UPDATED_AT, 
          STANDARDDISCOUNTSHORTNAME, 
          RECEIPT_NAME, 
          OPEN_LIMIT, 
          DISCOUNTTYPE, 
          DISCOUNTAPPLICATION, 
          FIXED_VALUE, 
          MIN_CHECK_AMOUNT, 
          MAX_CHECK_AMOUNT 
) 
 SELECT   STANDARDDISCOUNT_DIM_NK  as   STANDARDDISCOUNT_DIM_NK,  
   STANDARDDISCOUNTNAME  as   STANDARDDISCOUNTNAME,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   ORGANIZATION_DIM_FK  as   ORGANIZATION_DIM_FK,  
   IS_ENABLED  as   IS_ENABLED,  
   IS_TAXABLE  as   IS_TAXABLE,  
   DO_AUTO_APPLY  as   DO_AUTO_APPLY,  
   REQUIRE_APPROVAL  as   REQUIRE_APPROVAL,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   STANDARDDISCOUNTSHORTNAME  as   STANDARDDISCOUNTSHORTNAME,  
   RECEIPT_NAME  as   RECEIPT_NAME,  
   OPEN_LIMIT  as   OPEN_LIMIT,  
   DISCOUNTTYPE  as   DISCOUNTTYPE,  
   DISCOUNTAPPLICATION  as   DISCOUNTAPPLICATION,  
   FIXED_VALUE  as   FIXED_VALUE,  
   MIN_CHECK_AMOUNT  as   MIN_CHECK_AMOUNT,  
   MAX_CHECK_AMOUNT  as   MAX_CHECK_AMOUNT 
  FROM DATAADMIN.STANDARDDISCOUNT_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''STANDARDDISCOUNT_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''STANDARDDISCOUNT_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADTERMINAL_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADTERMINAL_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.TERMINAL_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.TERMINAL_DIM(   
          TERMINAL_DIM_NK, 
          TERMINALNAME, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          LOCATION_DIM_FK, 
          IS_CALL_CENTER, 
          CREATED_AT, 
          UPDATED_AT, 
          DELETED_AT, 
          TERMINAL_ROLE, 
          PROVISION_TOKEN 
) 
 SELECT   TERMINAL_DIM_NK  as   TERMINAL_DIM_NK,  
   TERMINALNAME  as   TERMINALNAME,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   LOCATION_DIM_FK  as   LOCATION_DIM_FK,  
   IS_CALL_CENTER  as   IS_CALL_CENTER,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   DELETED_AT  as   DELETED_AT,  
   TERMINAL_ROLE  as   TERMINAL_ROLE,  
   PROVISION_TOKEN  as   PROVISION_TOKEN 
  FROM DATAADMIN.TERMINAL_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''TERMINAL_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''TERMINAL_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADVOIDCHECKBYITEM_FACT(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADVOIDCHECKBYITEM_FACT""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.VOIDCHECKBYITEM_FACT),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.VOIDCHECKBYITEM_FACT(   
          VOIDCHECKBYITEM_FACT_NK, 
          CHEQUENUMBER, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          CHEQUE_FACT_FK, 
          DAYPART_DIM_FK, 
          EMPLOYEE_DIM_FK, 
          ITEM_FACT_FK, 
          LOCATION_DIM_FK, 
          MENUITEM_DIM_FK, 
          MENUITEMNAME_DIM_FK, 
          ORDERTYPE_DIM_FK, 
          ORGANIZATION_DIM_FK, 
          REVENUECENTER_DIM_FK, 
          SHIFT_DIM_FK, 
          TAXSETTINGS_DIM_FK, 
          VARIANT_DIM_FK, 
          VOIDREASON_DIM_FK, 
          HAS_DISCOUNT, 
          IS_TRAINING, 
          IS_VOID, 
          HAS_TRACKTAXESONCOMP, 
          FISCAL_DATE_INT, 
          FISCAL_DATE, 
          OPENED_AT, 
          BEGIN_PREP_AT, 
          CLOSED_AT, 
          SCHEDULED_AT, 
          CREATED_AT, 
          UPDATED_AT, 
          UUID, 
          AUDIT, 
          ROUNDINGMETHOD, 
          COMBINEDRECEIPTNAME, 
          RECEIPTOPTION, 
          TAXTRACKING, 
          REVENUECENTERNAME, 
          REVENUECENTERID, 
          STATUS_REASON_ID, 
          CHECK_ID, 
          TABLE_NAME, 
          STATUS, 
          ITEM_ID, 
          ITEMSTATUS, 
          CHECKGROSS, 
          CHECKTOTAL, 
          PRICE, 
          QUANTITY, 
          GROSS, 
          VOID_LEVEL, 
          TOTAL_NON_VOIDED_QUANTITY_ON_CHECK, 
          NON_VOIDED_ITEM_ROW_NUMBER, 
          ALLOCATED_ITEM_VOID 
) 
 SELECT   VOIDCHECKBYITEM_FACT_NK  as   VOIDCHECKBYITEM_FACT_NK,  
   CHEQUENUMBER  as   CHEQUENUMBER,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   CHEQUE_FACT_FK  as   CHEQUE_FACT_FK,  
   DAYPART_DIM_FK  as   DAYPART_DIM_FK,  
   EMPLOYEE_DIM_FK  as   EMPLOYEE_DIM_FK,  
   ITEM_FACT_FK  as   ITEM_FACT_FK,  
   LOCATION_DIM_FK  as   LOCATION_DIM_FK,  
   MENUITEM_DIM_FK  as   MENUITEM_DIM_FK,  
   MENUITEMNAME_DIM_FK  as   MENUITEMNAME_DIM_FK,  
   ORDERTYPE_DIM_FK  as   ORDERTYPE_DIM_FK,  
   ORGANIZATION_DIM_FK  as   ORGANIZATION_DIM_FK,  
   REVENUECENTER_DIM_FK  as   REVENUECENTER_DIM_FK,  
   SHIFT_DIM_FK  as   SHIFT_DIM_FK,  
   TAXSETTINGS_DIM_FK  as   TAXSETTINGS_DIM_FK,  
   VARIANT_DIM_FK  as   VARIANT_DIM_FK,  
   VOIDREASON_DIM_FK  as   VOIDREASON_DIM_FK,  
   HAS_DISCOUNT  as   HAS_DISCOUNT,  
   IS_TRAINING  as   IS_TRAINING,  
   IS_VOID  as   IS_VOID,  
   HAS_TRACKTAXESONCOMP  as   HAS_TRACKTAXESONCOMP,  
   FISCAL_DATE_INT  as   FISCAL_DATE_INT,  
   FISCAL_DATE  as   FISCAL_DATE,  
   OPENED_AT  as   OPENED_AT,  
   BEGIN_PREP_AT  as   BEGIN_PREP_AT,  
   CLOSED_AT  as   CLOSED_AT,  
   SCHEDULED_AT  as   SCHEDULED_AT,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   UUID  as   UUID,  
   AUDIT  as   AUDIT,  
   ROUNDINGMETHOD  as   ROUNDINGMETHOD,  
   COMBINEDRECEIPTNAME  as   COMBINEDRECEIPTNAME,  
   RECEIPTOPTION  as   RECEIPTOPTION,  
   TAXTRACKING  as   TAXTRACKING,  
   REVENUECENTERNAME  as   REVENUECENTERNAME,  
   REVENUECENTERID  as   REVENUECENTERID,  
   STATUS_REASON_ID  as   STATUS_REASON_ID,  
   CHECK_ID  as   CHECK_ID,  
   TABLE_NAME  as   TABLE_NAME,  
   STATUS  as   STATUS,  
   ITEM_ID  as   ITEM_ID,  
   ITEMSTATUS  as   ITEMSTATUS,  
   CHECKGROSS  as   CHECKGROSS,  
   CHECKTOTAL  as   CHECKTOTAL,  
   PRICE  as   PRICE,  
   QUANTITY  as   QUANTITY,  
   GROSS  as   GROSS,  
   VOID_LEVEL  as   VOID_LEVEL,  
   TOTAL_NON_VOIDED_QUANTITY_ON_CHECK  as   TOTAL_NON_VOIDED_QUANTITY_ON_CHECK,  
   NON_VOIDED_ITEM_ROW_NUMBER  as   NON_VOIDED_ITEM_ROW_NUMBER,  
   ALLOCATED_ITEM_VOID  as   ALLOCATED_ITEM_VOID 
  FROM DATAADMIN.VOIDCHECKBYITEM_FACT
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''VOIDCHECKBYITEM_FACT'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''VOIDCHECKBYITEM_FACT'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,SP_STAGELOADVOIDREASON_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADVOIDREASON_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.VOIDREASON_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.VOIDREASON_DIM(   
          VOIDREASON_DIM_NK, 
          VOIDREASON, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          IS_ENABLED, 
          CREATED_AT, 
          UPDATED_AT, 
          DESCRIPTION 
) 
 SELECT   VOIDREASON_DIM_NK  as   VOIDREASON_DIM_NK,  
   VOIDREASON  as   VOIDREASON,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   IS_ENABLED  as   IS_ENABLED,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   DESCRIPTION  as   DESCRIPTION 
  FROM DATAADMIN.VOIDREASON_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''VOIDREASON_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''VOIDREASON_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN,"SP_VALIDATEDWDATES(VARCHAR, VARCHAR, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_VALIDATEDWDATES""(""REPORTTYPE"" VARCHAR(1), ""TABLENAME"" VARCHAR(45), ""ERRORREPORT"" VARCHAR(5))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
--CALL SP_VALIDATEDWDATES(''l'',''CHEQUE_FACT'',''ALL'');
--ALTER SESSION SET TIMESTAMP_NTZ_OUTPUT_FORMAT = ''YYYY-MM-DD HH24:MI:SS.FF'';
-- SchemaName_VAR
-- REPORTTYPE VARCHAR(1)          := ''L'';  --valid values {L,P,S}
-- TABLENAME VARCHAR(45)          := ''CHEQUE_FACT'';--''WRONG_FACT'';--''ERRORDWDATE_DIM''--''CHEQUE_FACT''--''WRONG_FACT''
-- ERRORREPORT VARCHAR(5)         := ''COUNT'';--ERROR, ALL, COUNT
----------------------------------------------------------------------------------------------------------------------
  DBName_VAR VARCHAR(075)        := ''PRD_HOSPENG_REPORTING'';
  SchemaName_VAR VARCHAR(075)    := CASE UPPER(REPORTTYPE) 
                                        WHEN ''L'' THEN ''DATAADMIN'' 
                                        WHEN ''P'' THEN ''DATAWAREHOUSE''
                                        WHEN ''S'' THEN ''DATAWAREHOUSE_TEMP''
                                        ELSE ''DATAWAREHOUSE'' END;
  TableName_VAR VARCHAR(050)     := UPPER(TABLENAME);
  ErrorReport_VAR VARCHAR(500)   := UPPER(ERRORREPORT);
  FullTableName_VAR VARCHAR(500) := DBName_VAR || ''.'' || SchemaName_VAR ||  ''.'' || TableName_VAR;
  TableType_VAR  VARCHAR(75)     := CASE UPPER(REPORTTYPE) WHEN ''L''THEN ''VIEW'' ELSE ''BASE TABLE'' END; 

  NaturalKey_VAR varchar(250);
  ErrorCount int;
  ErrorSet resultset;
  CountError resultset   := (SELECT ''No Errors'' as ""MESSAGE"", 0 as ""COUNT"");
  NK_ErrorMessage resultset := (SELECT :TableName_VAR || '' ERROR:  Missing Natural Key.'' AS ""MESSAGE"", 1 as ""COUNT"");
  TB_ErrorMessage resultset := (SELECT :TableName_VAR || '' ERROR:  Invalid view or table name.'' AS ""MESSAGE"", 1 as ""COUNT"");
----------------------------------------------------------------------------------------------------------------------
BEGIN
----------------------------------------------------------------------------------------------------------------------
--Get the Primary Key for the dw table or landing view.  Validate that the value passed in is acutally a conforming vies
--  by looking for the table or view passed in.  
NaturalKey_VAR := 
  ( 
   SELECT c.column_name
    FROM information_schema.tables t
      INNER JOIN information_schema.columns c
          ON t.table_schema     = c.table_schema
            AND t.table_name    = c.table_name
            AND t.table_schema  = :SchemaName_VAR
            AND t.table_type    = :TableType_VAR
            AND t.table_name    = :TableName_VAR
            AND :TableName_VAR  = left(c.column_name,length(:TableName_VAR))
            AND c.column_name ilike ''%_NK''
    );

TableName_VAR := 
  ( 
   SELECT t.table_name
    FROM information_schema.tables t
      WHERE t.table_schema  = :SchemaName_VAR
            AND t.table_type    = :TableType_VAR
            AND t.table_name    = :TableName_VAR

    );

----------------------------------------------------------------------------------------------------------------------
--Drop temp table if exists - used for dev as temp tables would be dropped when sproc session ends
DROP TABLE IF EXISTS ErrorSet CASCADE;  

----------------------------------------------------------------------------------------------------------------------  
--Query Errors and return the result set either the errors or all data for review.
IF (:NaturalKey_VAR IS NOT NULL)
  THEN
   CREATE TEMP TABLE ErrorSet AS
    SELECT *
     FROM(
 
    SELECT INLT1.PK                                                   AS PK
        ,INLT1.MTLN_CDC_SEQUENCE_NUMBER                               AS MTLN_CDC_SEQUENCE_NUMBER
        ,INLT1.MTLN_CDC_LAST_COMMIT_TIMESTAMP                         AS MTLN_CDC_LAST_COMMIT_TIMESTAMP
        ,INLT1.RANKORDER                                              AS RANKORDER
        ,INLT1.DW_ISCURRENTROW                                        AS DW_ISCURRENTROW
        ,INLT1.DW_STARTDATE                                           AS DW_STARTDATE
        ,TO_TIMESTAMP(INLT1.DW_ENDDATE)                               AS DW_ENDDATE
        ,TO_TIMESTAMP(INLT1.DW_STARTDATE_PREVROW)                     AS DW_STARTDATE_PREVROW
        ,INLT1.LAST_COLUMN                                            AS lAST_COLUMN

        ,COUNT(DISTINCT INLT1.DW_ENDDATE) 
           OVER (PARTITION BY INLT1.PK)                               AS COUNT_ENDDATE

        ,CASE WHEN (TO_TIMESTAMP(INLT1.DW_STARTDATE_PREVROW) = TO_TIMESTAMP(INLT1.DW_ENDDATE) 
              AND INLT1.DW_ENDDATE <> ''9999-09-09 09:09:08.999999999'')
            OR (INLT1.DW_ISCURRENTROW )
            THEN FALSE ELSE TRUE END                                  AS ERROR_DW_DATES_NONCONTIGUOUS
        ,CASE WHEN (INLT1.DW_ISCURRENTROW 
            AND ABS(DATEDIFF(MILLISECOND,INLT1.DW_ENDDATE,''9999-09-09 09:09:08.999999999'' )) = 0) 
               OR (NOT INLT1.DW_ISCURRENTROW
                    AND  ABS(DATEDIFF(MILLISECOND,INLT1.DW_ENDDATE,''9999-09-09 09:09:08.999999999'' )) > 0)
            THEN FALSE ELSE TRUE END                                  AS ERROR_CURRENTROW_DATES
        ,CASE WHEN DW_CURRENTROW_COUNT > 1 THEN TRUE ELSE FALSE END   AS ERROR_MULTIPLE_CURENT_ROWS
        ,CASE WHEN INLT1.LAST_COLUMN = ''9999-09-09 09:09:08.999999999''
            THEN FALSE ELSE TRUE END                                  AS ERROR_NO_CURRENT_ROW 

        ,
        CASE WHEN COUNT_HIGHENDDATE > 1 THEN TRUE ELSE FALSE END

                                                                      AS ERROR_MULTIPLE_MAX_DATE    
        ,CASE WHEN (INLT1.HIGH_STARTDATE = INLT1.DW_STARTDATE
            AND INLT1.DW_ISCURRENTROW = TRUE)
            OR (INLT1.HIGH_STARTDATE <> INLT1.DW_STARTDATE
                AND INLT1.DW_ISCURRENTROW = FALSE)
            THEN FALSE ELSE TRUE END                                   AS ERROR_LOW_STARTDATE
       ,CASE WHEN NOT HIGH_CURRENTROW 
            THEN TRUE ELSE FALSE END                                   AS ERROR_NO_TRUE_CURENTROW
            --------------------------------------------------------------------------------------
        ,CASE WHEN MAX( INLT1.MTLN_CDC_SEQUENCE_NUMBER)  OVER (PARTITION BY INLT1.PK) 
          =
          MIN( INLT1.MTLN_CDC_SEQUENCE_NUMBER) OVER (PARTITION BY INLT1.PK)
          AND
          MAX( INLT1.MTLN_CDC_FILENAME)  OVER (PARTITION BY INLT1.PK) 
          =
          MIN( INLT1.MTLN_CDC_FILENAME) OVER (PARTITION BY INLT1.PK)
          AND
          MAX( INLT1.MTLN_CDC_SRC_VERSION)  OVER (PARTITION BY INLT1.PK) 
          =
          MIN( INLT1.MTLN_CDC_SRC_VERSION) OVER (PARTITION BY INLT1.PK)
           THEN TRUE ELSE FALSE END                                    AS ERROR_DUPLICATE_CDCSQUENCE
           --------------------------------------------------------------------------------------
        FROM (
            SELECT IDENTIFIER(:NaturalKey_VAR)                         AS PK
                ,row_number() OVER(PARTITION BY IDENTIFIER(:NaturalKey_VAR)
                    ORDER BY PF.DW_ENDDATE)                            AS RANKORDER
                ,PF.DW_STARTDATE                                       AS DW_STARTDATE
                ,PF.DW_ENDDATE                                         AS DW_ENDDATE
                ,PF.DW_ISCURRENTROW                                    AS DW_ISCURRENTROW
                ,PF.MTLN_CDC_SEQUENCE_NUMBER                           AS MTLN_CDC_SEQUENCE_NUMBER
                ,PF.MTLN_CDC_LAST_COMMIT_TIMESTAMP                     AS MTLN_CDC_LAST_COMMIT_TIMESTAMP
                ,PF.MTLN_CDC_FILENAME                                  AS MTLN_CDC_FILENAME
                ,PF.MTLN_CDC_SRC_VERSION                               AS MTLN_CDC_SRC_VERSION
                ,SUM(CASE WHEN PF.DW_ISCURRENTROW = TRUE THEN 1 
                  ELSE 0 END) 
                    OVER (PARTITION BY IDENTIFIER(:NaturalKey_VAR))    AS DW_CURRENTROW_COUNT

                ,DATEADD(NS,-1,lEAD(PF.DW_STARTDATE) 
                    OVER (PARTITION BY IDENTIFIER(:NaturalKey_VAR) 
                        ORDER BY PF.DW_STARTDATE))         
                                                                      AS DW_STARTDATE_PREVROW
                ,LAST_VALUE(PF.DW_ENDDATE) OVER (PARTITION BY 
                      IDENTIFIER(:NaturalKey_VAR) 
                    ORDER BY PF.DW_ENDDATE NULLS LAST)                 AS LAST_COLUMN
                ,MAX(PF.DW_STARTDATE) OVER (PARTITION 
                    BY IDENTIFIER(:NaturalKey_VAR))                    AS HIGH_STARTDATE

                ,MAX(PF.DW_ISCURRENTROW) OVER (PARTITION 
                    BY IDENTIFIER(:NaturalKey_VAR))                    AS HIGH_CURRENTROW
                
                ,SUM(CASE WHEN PF.DW_ENDDATE
                  = ''9999-09-09 09:09:08.999999999'' 
                    THEN 1 ELSE 0 END)                                 
                  OVER (PARTITION  BY IDENTIFIER(:NaturalKey_VAR))     AS COUNT_HIGHENDDATE
            FROM TABLE(:FullTableName_VAR) PF
            ORDER BY IDENTIFIER(:NaturalKey_VAR),PF.DW_ENDDATE
                                                                                         ) INLT1
                                                                                             ) INLT2
    WHERE (INLT2.ERROR_DW_DATES_NONCONTIGUOUS  --RETURN ALL DATA OR ERRORS ONLY
        OR INLT2.ERROR_CURRENTROW_DATES
        OR INLT2.ERROR_MULTIPLE_CURENT_ROWS 
        OR INLT2.ERROR_LOW_STARTDATE
        or INLT2.ERROR_NO_TRUE_CURENTROW)
        OR INLT2.ERROR_MULTIPLE_MAX_DATE
         OR (:ErrorReport_VAR = ''ALL'')

    ORDER BY INLT2.PK  
        ,INLT2.MTLN_CDC_SEQUENCE_NUMBER   
        ,INLT2.MTLN_CDC_LAST_COMMIT_TIMESTAMP                                                                                   
    ;

   ErrorSet   := (SELECT * from ErrorSet);  
   ErrorCount := (SELECT COUNT(*) from ErrorSet);
   CountError := (SELECT :TableName_VAR as MESSAGE,:ErrorCount as ""COUNT"" );
   
END IF;

--------------------------------------------------------------------------------------------------------
--RETURN RESULTS 
 IF (:TableName_VAR IS NULL)  --ONLY RETURN RESULTS IF INPUT IS VALID TABLE NAME
    THEN
      RETURN TABLE(TB_ErrorMessage);
  ELSEIF (:NaturalKey_VAR IS NULL)  --ONLY RETURN RESULTS IF INPUT IS VALID TABLE NAME
    THEN
      RETURN TABLE(NK_ErrorMessage);
 ELSEIF (:ERRORREPORT = ''COUNT'')
      THEN
       RETURN TABLE(CountError);
    ELSE
      RETURN TABLE(ErrorSet);
  END IF;
 
--------------------------------------------------------------------------------------------------------  
END';"
PROCEDURE,DATAADMIN,"SP_REPORT_PMIX_NEW(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_PMIX_NEW""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2020-08-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2029-08-20T14:48:37.661Z''; 
  -- locationid string      := ''[351,2,3,4]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
BEGIN  

DROP TABLE IF EXISTS TEMP_TAXBASIS;

--=========================================================================================
--get tax basis - can be multiple taxes per item - select the max tax basis for that item 
CREATE TABLE TEMP_TAXBASIS AS
SELECT tax.ITEM_FACT_FK
   ,MAX(CASE WHEN ABS(tax.AMOUNT - (itf.GROSS * (tax.PERCENT/100))) < 0.009
      THEN itf.GROSS 
      ELSE itf.APPLIEDAMOUNT END) ::NUMBER(18,2)          as ""Tax Basis Amount""
FROM DATAWAREHOUSE.TAX_FACT                               tax
     INNER JOIN DATAWAREHOUSE.ITEM_FACT                   itf
        ON itf.ITEM_FACT_NK = tax.ITEM_FACT_FK
          AND itf.TAX > 0.000
          AND itf.DW_ISCURRENTROW
    WHERE tax.ITEMSTATUS IN (''Added'',''Sent'')
          AND tax.CHECKSTATUS = ''Closed''
          AND tax.OPENED_AT is not null
          AND tax.DW_ISCURRENTROW  
          AND NOT tax.DW_ISDELETED
          AND NOT tax.IS_TRAINING
          AND tax.FISCAL_DATE::date
              >= :startdate::date 
          AND tax.FISCAL_DATE::date  
              <= :enddate::date 
          AND tax.LOCATION_DIM_FK IN ( 
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)
  GROUP BY tax.ITEM_FACT_FK
;

--=========================================================================================
 reportSet:= (
SELECT itf.ITEM_FACT_NK                                   as ""Support ID"" 
    , ''PMIX-'' ||row_number() over (order by itf.ITEM_FACT_NK) 
                                                          as ""Detail ID""
--status, category, level-------------------------------------------------------------------
    ,IFNULL(itf.CHECKSTATUS,''None'')                       as ""Check Status""
    ,IFNULL(itf.ITEMSTATUS,''None'')                        as ""Item Status""
    ,IFNULL(itf.STATUSREASON,''None'')                      as ""Status Reason""
    ,IFNULL(ccd.COGSCATEGORY,''None'')                      as ""Category""
    -- ,IFNULL(ccd.COGSCATEGORY,''None'')                   as ""COGS Category""
-- --geography
    ,IFNULL(loc.LOCATIONNAME,''None'')                      as ""Location""
    ,itf.LOCATION_DIM_FK::DECIMAL(36,0)                   as ""Location ID""
    ,IFNULL(itf.REVENUECENTERNAME,''None'')                 as ""Revenue Center""
-- --dates-------------------------------------------------------------------------------------
    ,LOC.TZ_NAME                                          as ""Time Zone""
    ,to_char(LEFT(chk.FISCAL_DATE,4))                     as ""Year""
    ,to_char(YEAR(chk.FISCAL_DATE)) || ''|'' || TO_CHAR(RIGHT(''0'' || MONTH(chk.FISCAL_DATE),2))                                       
                                                          as ""Year and Month""
    ,IFNULL(dad.DAYPART,''None'')                           as ""Daypart""
    ,to_char(chk.FISCAL_DATE)                             as ""Fiscal Date""
    ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,chk.OPENED_AT::timestamp_ntz )::timestamp )                                                                           
                                                          as ""Opened At""                                                           
    ,IFNULL(DAYNAME(chk.FISCAL_DATE),''None'')              as ""Day of Week""
    ,CASE WHEN DAYNAME(chk.FISCAL_DATE) IN (''Sat'',''Sun'')  
             THEN TRUE ELSE FALSE END                     as ""Is Weekend""
-- --flags--------------------------------------------------------------------------------------
    ,IFNULL(itf.HASMODIFIERS,FALSE)                       as ""Has Modifiers""
-- --people-------------------------------------------------------------------------------------
    ,IFNULL(emd.EMPLOYEE_NAME,''None'')                     as ""Employee""
-- --Descriptors-------------------------------------------------------------------------------- 
    ,IFNULL(itf.chequenumber ,''None'')                     as ""Check""
    ,IFNULL(itf.cheque_fact_fk::decimal(10,0)::string ,''None'')                   as ""Check ID""    
    ,IFNULL(med.MENUITEMNAME,'' None'')                     as ""Menu Item""
    ,IFNULL(itf.NOTE,''None'')                              as ""Note""
    ,IFNULL(itf.DESCRIPTION,''None'')                       as ""Description""
    ,IFNULL(itf.COMBINEDNAME,''Regular'')                   as ""Variant""     
    ,itf.SPLITBY::NUMBER(18,0)                            as ""Split By""
-- --Facts-----------------------------------------------------------------------------------------
    ,itf.QUANTITY::NUMBER(10,0)                           as ""Count""
    ,itf.REPORTQUANTITY::NUMBER(18,2)                     as ""Report Quantity""   
    ,itf.APPLIEDAMOUNT::NUMBER(18,2)                      as ""Applied Amount""
    ,itf.BASEPRICE::NUMBER(18,2)                          as ""Base Price""
    ,itf.PRICE::NUMBER(18,2)                              as ""Price""
    ,itf.GROSS::NUMBER(18,2)                              as ""Gross"" 
    ,dis.""Item Discount Amount""::NUMBER(18,2)             as ""Item Discount Amount""
    ,(IFNULL(itf.GROSS,0) - IFNULL(dis.""Item Discount Amount"",0))::NUMBER(18,2)                      
                                                          as ""Net""  
    ,itf.INCLUSIVETAX::NUMBER(18,2)                       as ""Inclusive Tax""    
    ,itf.TAX::NUMBER(18,2)                                as ""Tax""
    ,ttb.""Tax Basis Amount""                               as ""Tax Basis Amount""
    ,itf.TOTAL::NUMBER(18,2)                              as ""Total"" 
--------------------------------------------------------------------------------------------   
FROM DATAWAREHOUSE.ITEM_FACT                                  itf
     INNER JOIN DATAWAREHOUSE.MENUITEMNAME_DIM                med
       ON med.MENUITEMNAME_DIM_NK = itf.MENUITEMNAME_DIM_FK
          AND itf.ITEMSTATUS IN (''Added'',''Sent'')
          AND itf.CHECKSTATUS = ''Closed''
          AND itf.DW_ISCURRENTROW  
          AND med.DW_ISCURRENTROW  
          AND NOT itf.DW_ISDELETED
          AND NOT itf.IS_TRAINING
          AND itf.LOCATION_DIM_FK IN (--351,352
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)
      INNER JOIN DATAWAREHOUSE.CHEQUE_FACT                                chk
        ON chk.CHEQUE_FACT_NK = itf.CHEQUE_FACT_FK
          AND chk.DW_ISCURRENTROW
          AND chk.STATUS = ''Closed''
          AND itf.ITEMSTATUS IN (''Added'',''Sent'')
          AND (chk.FISCAL_DATE::date >= :startdate::date 
                AND chk.FISCAL_DATE::date  <= :enddate::date)
      INNER JOIN DATAWAREHOUSE.LOCATION_DIM                     loc
        ON itf.LOCATION_DIM_FK = loc.LOCATION_DIM_NK
          AND loc.DW_ISCURRENTROW
      INNER JOIN DATAWAREHOUSE.EMPLOYEE_DIM                     emd
        ON itf.employee_dim_fk = emd.employee_dim_Nk
          AND emd.DW_ISCURRENTROW 
      INNER JOIN DATAWAREHOUSE.DAYPART_DIM                      dad
        ON itf.daypart_dim_fk = dad.daypart_dim_nk
          AND dad.DW_ISCURRENTROW = TRUE         
      INNER JOIN DATAWAREHOUSE.REPORTCATEGORY_DIM               meg
        ON med.REPORTCATEGORY_DIM_FK = meg.REPORTCATEGORY_DIM_NK
          AND meg.DW_ISCURRENTROW = TRUE
      INNER JOIN DATAWAREHOUSE.COGSCATEGORY_DIM                  ccd
        ON ccd.COGSCATEGORY_DIM_NK = meg.COGSCATEGORY_DIM_FK    
          AND ccd.DW_ISCURRENTROW
      LEFT JOIN (
          SELECT daf.ITEM_FACT_FK, SUM(daf.APPLIED_AMOUNT) AS ""Item Discount Amount""
              FROM DATAWAREHOUSE.DISCOUNTITEM_FACT daf
                WHERE daf.DW_ISCURRENTROW 
                  AND (daf.FISCAL_DATE::date >= :startdate::date 
                  AND daf.FISCAL_DATE::date  <= :enddate::date)
                  AND daf.LOCATION_DIM_FK IN (--351,352
                     SELECT table1.value 
                        FROM table(split_to_table(:locationidS, '',''))  table1)
                  AND NOT daf.IS_TRAINING
                GROUP BY daf.ITEM_FACT_FK
                                                          )dis 
            ON dis.ITEM_FACT_FK = itf.ITEM_FACT_NK
      LEFT JOIN TEMP_TAXBASIS                              ttb
            ON  ttb.item_fact_fk = itf.item_fact_nk
          
--==========================================================================================
);
RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAADMIN,SP_STAGELOADCOGSCATEGORY_DIM(BOOLEAN),"CREATE OR REPLACE PROCEDURE ""SP_STAGELOADCOGSCATEGORY_DIM""(""VALIDATE_DATE"" BOOLEAN)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE res resultset;
      --validate_date boolean := TRUE;
      errorCount_res resultset;
      highwater int := IFNULL((SELECT MAX(MTLN_CDC_SEQUENCE_NUMBER) FROM DATAWAREHOUSE_TEMP.COGSCATEGORY_DIM),0);
  BEGIN
    res := (
       INSERT INTO DATAWAREHOUSE_TEMP.COGSCATEGORY_DIM(   
          COGSCATEGORY_DIM_NK, 
          COGSCATEGORY, 
          DW_STARTDATE, 
          DW_ENDDATE, 
          DW_ISDELETED, 
          DW_RANGESTART, 
          DW_RANGEEND, 
          DW_ISCURRENTROW, 
          MTLN_CDC_LAST_CHANGE_TYPE, 
          MTLN_CDC_LAST_COMMIT_TIMESTAMP, 
          MTLN_CDC_SEQUENCE_NUMBER, 
          MTLN_CDC_LOAD_BATCH_ID, 
          MTLN_CDC_LOAD_TIMESTAMP, 
          MTLN_CDC_PROCESSED_DATE_HOUR, 
          MTLN_CDC_SRC_VERSION, 
          MTLN_CDC_FILENAME, 
          MTLN_CDC_FILEPATH, 
          MTLN_CDC_SRC_DATABASE, 
          MTLN_CDC_SRC_SCHEMA, 
          MTLN_CDC_SRC_TABLE, 
          ORGANIZATION_DIM_FK, 
          CREATED_AT, 
          UPDATED_AT, 
          DESCRIPTION 
) 
 SELECT   COGSCATEGORY_DIM_NK  as   COGSCATEGORY_DIM_NK,  
   COGSCATEGORY  as   COGSCATEGORY,  
   DW_STARTDATE  as   DW_STARTDATE,  
   DW_ENDDATE  as   DW_ENDDATE,  
   DW_ISDELETED  as   DW_ISDELETED,  
   :highwater  as   DW_RANGESTART,  
   MAX(MTLN_CDC_SEQUENCE_NUMBER) OVER(PARTITION BY 1)  as   DW_RANGEEND,  
   DW_ISCURRENTROW  as   DW_ISCURRENTROW,  
   MTLN_CDC_LAST_CHANGE_TYPE  as   MTLN_CDC_LAST_CHANGE_TYPE,  
   MTLN_CDC_LAST_COMMIT_TIMESTAMP  as   MTLN_CDC_LAST_COMMIT_TIMESTAMP,  
   MTLN_CDC_SEQUENCE_NUMBER  as   MTLN_CDC_SEQUENCE_NUMBER,  
   MTLN_CDC_LOAD_BATCH_ID  as   MTLN_CDC_LOAD_BATCH_ID,  
   MTLN_CDC_LOAD_TIMESTAMP  as   MTLN_CDC_LOAD_TIMESTAMP,  
   MTLN_CDC_PROCESSED_DATE_HOUR  as   MTLN_CDC_PROCESSED_DATE_HOUR,  
   MTLN_CDC_SRC_VERSION  as   MTLN_CDC_SRC_VERSION,  
   MTLN_CDC_FILENAME  as   MTLN_CDC_FILENAME,  
   MTLN_CDC_FILEPATH  as   MTLN_CDC_FILEPATH,  
   MTLN_CDC_SRC_DATABASE  as   MTLN_CDC_SRC_DATABASE,  
   MTLN_CDC_SRC_SCHEMA  as   MTLN_CDC_SRC_SCHEMA,  
   MTLN_CDC_SRC_TABLE  as   MTLN_CDC_SRC_TABLE,  
   ORGANIZATION_DIM_FK  as   ORGANIZATION_DIM_FK,  
   CREATED_AT  as   CREATED_AT,  
   UPDATED_AT  as   UPDATED_AT,  
   DESCRIPTION  as   DESCRIPTION 
  FROM DATAADMIN.COGSCATEGORY_DIM
     WHERE MTLN_CDC_SEQUENCE_NUMBER > :highwater);

 
 --======================================================================================================================== 

 
--========================================================================================================================
CALL SP_UpdateDWTable( ''DATASTAGE'', ''COGSCATEGORY_DIM'');
IF (validate_date = TRUE)  THEN  errorCount_res := (CALL DATAADMIN.SP_ValidateDWDates(''p'',''COGSCATEGORY_DIM'',''COUNT''));
END IF;
return table(errorCount_res); END';"
PROCEDURE,DATAADMIN_DEBUG,"SP_REPORT_PMIX(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_PMIX""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2020-08-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2029-08-20T14:48:37.661Z''; 
  -- locationid string      := ''[351,2,3,4]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
BEGIN  

DROP TABLE IF EXISTS TEMP_TAXBASIS;

--=========================================================================================
--get tax basis - can be multiple taxes per item - select the max tax basis for that item 
CREATE TABLE TEMP_TAXBASIS AS
SELECT tax.ITEM_FACT_FK
   ,MAX(CASE WHEN ABS(tax.AMOUNT - (itf.GROSS * (tax.PERCENT/100))) < 0.009
      THEN itf.GROSS 
      ELSE itf.APPLIEDAMOUNT END) ::NUMBER(18,2)          as ""Tax Basis Amount""
FROM DATAADMIN_DEBUG.TAX_FACT                               tax
     INNER JOIN DATAADMIN_DEBUG.ITEM_FACT                   itf
        ON itf.ITEM_FACT_NK = tax.ITEM_FACT_FK
          AND itf.TAX > 0.000
          AND itf.DW_ISCURRENTROW
    WHERE tax.ITEMSTATUS IN (''Added'',''Sent'')
          AND tax.CHECKSTATUS = ''Closed''
          AND tax.OPENED_AT is not null
          AND tax.DW_ISCURRENTROW  
          AND NOT tax.DW_ISDELETED
          AND NOT tax.IS_TRAINING
          AND tax.FISCAL_DATE::date
              >= :startdate::date 
          AND tax.FISCAL_DATE::date  
              <= :enddate::date 
          AND tax.LOCATION_DIM_FK IN ( 
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)
  GROUP BY tax.ITEM_FACT_FK
;

--=========================================================================================
 reportSet:= (
SELECT itf.ITEM_FACT_NK                                   as ""Support ID"" 
    , ''PMIX-'' ||row_number() over (order by itf.ITEM_FACT_NK) 
                                                          as ""Detail ID""
--status, category, level-------------------------------------------------------------------
    ,IFNULL(itf.CHECKSTATUS,''None'')                       as ""Check Status""
    ,IFNULL(itf.ITEMSTATUS,''None'')                        as ""Item Status""
    ,IFNULL(itf.STATUSREASON,''None'')                      as ""Status Reason""
    ,IFNULL(ccd.COGSCATEGORY,''None'')                      as ""Category""
    -- ,IFNULL(ccd.COGSCATEGORY,''None'')                   as ""COGS Category""
-- --geography
    ,IFNULL(loc.LOCATIONNAME,''None'')                      as ""Location""
    ,itf.LOCATION_DIM_FK::DECIMAL(36,0)                   as ""Location ID""
    ,IFNULL(itf.REVENUECENTERNAME,''None'')                 as ""Revenue Center""
-- --dates-------------------------------------------------------------------------------------
    ,LOC.TZ_NAME                                          as ""Time Zone""
    ,to_char(LEFT(chk.FISCAL_DATE,4))                     as ""Year""
    ,to_char(YEAR(chk.FISCAL_DATE)) || ''|'' || TO_CHAR(RIGHT(''0'' || MONTH(chk.FISCAL_DATE),2))                                       
                                                          as ""Year and Month""
    ,IFNULL(dad.DAYPART,''None'')                           as ""Daypart""
    ,to_char(chk.FISCAL_DATE)                             as ""Fiscal Date""
    ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,chk.OPENED_AT::timestamp_ntz )::timestamp )                                                                           
                                                          as ""Opened At""                                                           
    ,IFNULL(DAYNAME(chk.FISCAL_DATE),''None'')              as ""Day of Week""
    ,CASE WHEN DAYNAME(chk.FISCAL_DATE) IN (''Sat'',''Sun'')  
             THEN TRUE ELSE FALSE END                     as ""Is Weekend""
-- --flags--------------------------------------------------------------------------------------
    ,IFNULL(itf.HASMODIFIERS,FALSE)                       as ""Has Modifiers""
-- --people-------------------------------------------------------------------------------------
    ,IFNULL(emd.EMPLOYEE_NAME,''None'')                     as ""Employee""
-- --Descriptors-------------------------------------------------------------------------------- 
    ,IFNULL(itf.chequenumber ,''None'')                     as ""Check""
    ,IFNULL(itf.cheque_fact_fk::decimal(10,0)::string ,''None'')                   as ""Check ID""    
    ,IFNULL(med.MENUITEMNAME,'' None'')                     as ""Menu Item""
    ,IFNULL(itf.NOTE,''None'')                              as ""Note""
    ,IFNULL(itf.DESCRIPTION,''None'')                       as ""Description""
    ,IFNULL(itf.COMBINEDNAME,''Regular'')                   as ""Variant""     
    ,itf.SPLITBY::NUMBER(18,0)                            as ""Split By""
-- --Facts-----------------------------------------------------------------------------------------
    ,itf.QUANTITY::NUMBER(10,0)                           as ""Count""
    ,itf.REPORTQUANTITY::NUMBER(18,2)                     as ""Report Quantity""   
    ,itf.APPLIEDAMOUNT::NUMBER(18,2)                      as ""Applied Amount""
    ,itf.BASEPRICE::NUMBER(18,2)                          as ""Base Price""
    ,itf.PRICE::NUMBER(18,2)                              as ""Price""
    ,itf.GROSS::NUMBER(18,2)                              as ""Gross"" 
    ,dis.""Item Discount Amount""::NUMBER(18,2)             as ""Item Discount Amount""
    ,(IFNULL(itf.GROSS,0) - IFNULL(dis.""Item Discount Amount"",0))::NUMBER(18,2)                      
                                                          as ""Net""  
    ,itf.INCLUSIVETAX::NUMBER(18,2)                       as ""Inclusive Tax""    
    ,itf.TAX::NUMBER(18,2)                                as ""Tax""
    ,ttb.""Tax Basis Amount""                               as ""Tax Basis Amount""
    ,itf.TOTAL::NUMBER(18,2)                              as ""Total"" 
--------------------------------------------------------------------------------------------   
FROM DATAADMIN_DEBUG.ITEM_FACT                                  itf
     INNER JOIN DATAWAREHOUSE.MENUITEMNAME_DIM                med
       ON med.MENUITEMNAME_DIM_NK = itf.MENUITEMNAME_DIM_FK
          AND itf.ITEMSTATUS IN (''Added'',''Sent'')
          AND itf.CHECKSTATUS = ''Closed''
          AND itf.DW_ISCURRENTROW  
          AND med.DW_ISCURRENTROW  
          AND NOT itf.DW_ISDELETED
          AND NOT itf.IS_TRAINING
          AND itf.LOCATION_DIM_FK IN (--351,352
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)
      INNER JOIN DATAADMIN_DEBUG.CHEQUE_FACT                                chk
        ON chk.CHEQUE_FACT_NK = itf.CHEQUE_FACT_FK
          AND chk.DW_ISCURRENTROW
          AND chk.STATUS = ''Closed''
          AND itf.ITEMSTATUS IN (''Added'',''Sent'')
          AND (chk.FISCAL_DATE::date >= :startdate::date 
                AND chk.FISCAL_DATE::date  <= :enddate::date)
      INNER JOIN DATAWAREHOUSE.LOCATION_DIM                     loc
        ON itf.LOCATION_DIM_FK = loc.LOCATION_DIM_NK
          AND loc.DW_ISCURRENTROW
      INNER JOIN DATAWAREHOUSE.EMPLOYEE_DIM                     emd
        ON itf.employee_dim_fk = emd.employee_dim_Nk
          AND emd.DW_ISCURRENTROW 
      INNER JOIN DATAWAREHOUSE.DAYPART_DIM                      dad
        ON itf.daypart_dim_fk = dad.daypart_dim_nk
          AND dad.DW_ISCURRENTROW = TRUE         
      INNER JOIN DATAWAREHOUSE.REPORTCATEGORY_DIM               meg
        ON med.REPORTCATEGORY_DIM_FK = meg.REPORTCATEGORY_DIM_NK
          AND meg.DW_ISCURRENTROW = TRUE
      INNER JOIN DATAWAREHOUSE.COGSCATEGORY_DIM                  ccd
        ON ccd.COGSCATEGORY_DIM_NK = meg.COGSCATEGORY_DIM_FK    
          AND ccd.DW_ISCURRENTROW
      LEFT JOIN (
          SELECT daf.ITEM_FACT_FK, SUM(daf.APPLIED_AMOUNT) AS ""Item Discount Amount""
              FROM DATAADMIN_DEBUG.DISCOUNTITEM_FACT daf
                WHERE daf.DW_ISCURRENTROW 
                  AND (daf.FISCAL_DATE::date >= :startdate::date 
                  AND daf.FISCAL_DATE::date  <= :enddate::date)
                  AND daf.LOCATION_DIM_FK IN (--351,352
                     SELECT table1.value 
                        FROM table(split_to_table(:locationidS, '',''))  table1)
                  AND NOT daf.IS_TRAINING
                GROUP BY daf.ITEM_FACT_FK
                                                          )dis 
            ON dis.ITEM_FACT_FK = itf.ITEM_FACT_NK
      LEFT JOIN TEMP_TAXBASIS                              ttb
            ON  ttb.item_fact_fk = itf.item_fact_nk
          
--==========================================================================================
);
RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATASHARE_DEV,TEST_DELETE_THIS(),"CREATE OR REPLACE PROCEDURE ""TEST_DELETE_THIS""()
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE
    -- 1. Constants & Setup (Mimicking your SP)
    LOOKBACK_DAYS INT DEFAULT 30;
    DATE_FORMAT VARCHAR DEFAULT ''YYYY-MM-DD'';
    
    -- Date Variables
    yesterday_date DATE;
    retention_boundary_date DATE;
    
    -- Watermark Variables
    target_table_max_date DATE;
    calculated_start_date DATE;
    start_date_str VARCHAR;
    
    -- Dynamic SQL Variable
    sql_command VARCHAR;

    -- Test Variables (Used to simulate database states)
    LOGS VARCHAR DEFAULT ''Validation Results:\\\\n-------------------\\\\n'';
    TEST_SCENARIOS ARRAY DEFAULT ARRAY_CONSTRUCT(
        NULL,                                         -- Scenario 1: Table is empty (Returns NULL)
        ''2020-01-01'',                                 -- Scenario 2: Data is very old (Older than 30 days)
        TO_VARCHAR(DATEADD(day, -2, CURRENT_DATE()))  -- Scenario 3: Data is fresh (2 days ago)
    );
    current_simulated_max_date VARCHAR;

    -- Variables for fetching from dynamic SQL
    res RESULTSET;
    c1 CURSOR FOR SELECT NULL; -- Initialized with a dummy query

BEGIN
    -- Calculate Baseline Dates
    yesterday_date := DATEADD(day, -1, CURRENT_DATE());
    retention_boundary_date := DATEADD(day, -LOOKBACK_DAYS, yesterday_date);

    LOGS := LOGS || ''Retention Boundary (30 days ago): '' || retention_boundary_date || ''\\\\n\\\\n'';

    -- Loop through Scenarios to prove logic works
    FOR i IN 0 TO ARRAY_SIZE(TEST_SCENARIOS) - 1 DO
        
        -- SIMULATION: 
        -- In your real SP, you will derive the table name here.
        -- We simulate the SQL result here by grabbing a value from our test array.
        current_simulated_max_date := TEST_SCENARIOS[i];
        
        -- Construct a dummy query to validate EXECUTE IMMEDIATE ... INTO syntax works
        IF (current_simulated_max_date IS NULL) THEN
            sql_command := ''SELECT NULL''; 
        ELSE
            sql_command := ''SELECT '''''' || current_simulated_max_date || ''''''::DATE'';
        END IF;

        -- =======================================================
        -- START: WATERMARK CALCULATION LOGIC
        -- =======================================================
        
        -- Step A: Run the Dynamic SQL and fetch the result into a variable
        res := (EXECUTE IMMEDIATE sql_command);
        OPEN c1 FOR res; -- Open the cursor FOR the dynamic result set
        FETCH c1 INTO target_table_max_date;
        CLOSE c1;

        -- Step B: Handle NULL (First Load)
        IF (target_table_max_date IS NULL) THEN
            target_table_max_date := ''1900-01-01''::DATE;
        END IF;

        -- Step C: Compare Max Date vs Retention Boundary
        -- We use IF/ELSE here as it is cleaner than CASE in procedural blocks
        IF (target_table_max_date > retention_boundary_date) THEN
            calculated_start_date := target_table_max_date;
        ELSE
            calculated_start_date := retention_boundary_date;
        END IF;

        -- Step D: Convert to String for SPROC call
        start_date_str := TO_VARCHAR(calculated_start_date, DATE_FORMAT);

        -- =======================================================
        -- END: WATERMARK CALCULATION LOGIC
        -- =======================================================

        -- Logging results for review
        LOGS := LOGS || ''Scenario '' || (i+1) || '': '' ||
                ''Table Max Date ['' || COALESCE(current_simulated_max_date, ''NULL'') || ''] '' ||
                ''-> Calculated Start Date: '' || start_date_str || ''\\\\n'';

    END FOR;

    RETURN LOGS;
END';"
PROCEDURE,DATAWAREHOUSE,"SP_REPORT_PMIX(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_PMIX""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS '
-- -- =====================================================================================
-- Example Call Statement
-- CALL DATAWAREHOUSE.SP_REPORT_PMIX(''2000-11-20T14:48:37.661Z'',''2026-11-20T14:48:37.661Z'',''[2]'');
-- =======================================================================================
-- CALL DATAWAREHOUSE.SP_REPORTDATAGROOM(''SP_REPORT_PMIX'',2,3);
-- CALL DATAWAREHOUSE.SP_REPORT_PMIX(''2001-01-20T14:48:37.661Z'',''2026-11-20T14:48:37.661Z'',''[361, 352, 353, 351, 574, 480, 433, 421, 408, 399, 390, 389, 379, 382, 385, 387, 388]'');
-- GRANT usage ON procedure DATAWAREHOUSE.SP_REPORT_PMIX(timestamp_tz,timestamp_tz,string) TO ROLE DATA_REPLICATION_HOSPENG;
-- --=========================================================================================
DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2020-08-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2029-08-20T14:48:37.661Z''; 
  -- locationid string      := ''[2,3,4]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--=========================================================================================
BEGIN
 reportSet:= (
SELECT itf.ITEM_FACT_NK                                   as ""Support ID"" 
    , ''PMIX-'' ||row_number() over (order by itf.ITEM_FACT_NK) 
                                                          as ""Detail ID""
--status, category, level-------------------------------------------------------------------
    ,IFNULL(itf.CHECKSTATUS,''None'')                       as ""Check Status""
    ,IFNULL(itf.ITEMSTATUS,''None'')                        as ""Item Status""
    ,IFNULL(itf.STATUSREASON,''None'')                      as ""Status Reason""
    ,IFNULL(ccd.COGSCATEGORY,''None'')                      as ""Category""
    -- ,IFNULL(ccd.COGSCATEGORY,''None'')                   as ""COGS Category""
-- --geography--------------------------------------------------------------------------------
    ,IFNULL(loc.LOCATIONNAME,''None'')                      as ""Location""
    ,IFNULL(itf.REVENUECENTERNAME,''None'')                 as ""Revenue Center""
-- --dates-------------------------------------------------------------------------------------
    ,LOC.TZ_NAME                                          as ""Time Zone""
    ,to_char(LEFT(chk.FISCAL_DATE,4))                     as ""Year""
    ,to_char(YEAR(chk.FISCAL_DATE)) || ''|'' || TO_CHAR(LEFT(''0'' || MONTH(chk.FISCAL_DATE),2))                                       
                                                          as ""Year and Month""
    ,IFNULL(dad.DAYPART,''None'')                           as ""Daypart""
    ,to_char(chk.FISCAL_DATE)                             as ""Fiscal Date""
    ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,chk.OPENED_AT::timestamp_ntz )::timestamp )                                                                           
                                                          as ""Opened At""                                                           
    ,IFNULL(DAYNAME(chk.FISCAL_DATE),''None'')              as ""Day of Week""
    ,CASE WHEN DAYNAME(chk.FISCAL_DATE) IN (''Sat'',''Sun'')  
             THEN TRUE ELSE FALSE END                     as ""Is Weekend""
-- --flags--------------------------------------------------------------------------------------
    ,IFNULL(itf.HASMODIFIERS,FALSE)                       as ""Has Modifiers""
-- --people-------------------------------------------------------------------------------------
    ,IFNULL(emd.EMPLOYEE_NAME,''None'')                     as ""Employee""
-- --Descriptors-------------------------------------------------------------------------------- 
    ,IFNULL(itf.chequenumber ,''None'')                     as ""Check""
    ,IFNULL(med.MENUITEMNAME,'' None'')                     as ""Menu Item""
    ,IFNULL(itf.NOTE,''None'')                              as ""Note""
    ,IFNULL(itf.DESCRIPTION,''None'')                       as ""Description""
    ,IFNULL(itf.COMBINEDNAME,''Regular'')                   as ""Variant""     
    ,itf.SPLITBY::NUMBER(18,0)                            as ""Split By""
-- --Facts-----------------------------------------------------------------------------------------
    ,itf.QUANTITY::NUMBER(10,0)                           as ""Count""
    ,itf.REPORTQUANTITY::NUMBER(18,2)                     as ""Report Quantity""   
    ,itf.APPLIEDAMOUNT::NUMBER(18,2)                      as ""Applied Amount""
    ,itf.BASEPRICE::NUMBER(18,2)                          as ""Base Price""
    ,itf.PRICE::NUMBER(18,2)                              as ""Price""
    ,itf.GROSS::NUMBER(18,2)                              as ""Gross"" 
    ,dis.""Item Discount Amount""::NUMBER(18,2)             as ""Item Discount Amount""
    ,(IFNULL(itf.GROSS,0) - IFNULL(dis.""Item Discount Amount"",0))::NUMBER(18,2)                      
                                                          as ""Net""  
    ,itf.INCLUSIVETAX::NUMBER(18,2)                       as ""Inclusive Tax""    
    ,itf.TAX::NUMBER(18,2)                                as ""Tax""
    ,itf.TOTAL::NUMBER(18,2)                              as ""Total"" 
--------------------------------------------------------------------------------------------   
FROM DATAWAREHOUSE.ITEM_FACT                                  itf
     INNER JOIN DATAWAREHOUSE.MENUITEMNAME_DIM                med
       ON med.MENUITEMNAME_DIM_NK = itf.MENUITEMNAME_DIM_FK
          AND itf.ITEMSTATUS IN (''Added'',''Sent'')
          AND itf.CHECKSTATUS = ''Closed''
          AND itf.DW_ISCURRENTROW  
          AND med.DW_ISCURRENTROW  
          AND NOT itf.DW_ISDELETED
          AND NOT itf.IS_TRAINING
          AND itf.LOCATION_DIM_FK IN (--351,352
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)
      INNER JOIN DATAWAREHOUSE.CHEQUE_FACT                                chk
        ON chk.CHEQUE_FACT_NK = itf.CHEQUE_FACT_FK
          AND chk.DW_ISCURRENTROW
          AND chk.STATUS = ''Closed''
          AND itf.ITEMSTATUS IN (''Added'',''Sent'')
          AND (chk.FISCAL_DATE::date >= :startdate::date 
                AND chk.FISCAL_DATE::date  <= :enddate::date)
      INNER JOIN DATAWAREHOUSE.LOCATION_DIM                     loc
        ON itf.LOCATION_DIM_FK = loc.LOCATION_DIM_NK
          AND loc.DW_ISCURRENTROW
      INNER JOIN DATAWAREHOUSE.EMPLOYEE_DIM                     emd
        ON itf.employee_dim_fk = emd.employee_dim_Nk
          AND emd.DW_ISCURRENTROW 
      INNER JOIN DATAWAREHOUSE.DAYPART_DIM                      dad
        ON itf.daypart_dim_fk = dad.daypart_dim_nk
          AND dad.DW_ISCURRENTROW = TRUE         
      INNER JOIN DATAWAREHOUSE.REPORTCATEGORY_DIM               meg
        ON med.REPORTCATEGORY_DIM_FK = meg.REPORTCATEGORY_DIM_NK
          AND meg.DW_ISCURRENTROW = TRUE
      INNER JOIN DATAWAREHOUSE.COGSCATEGORY_DIM                  ccd
        ON ccd.COGSCATEGORY_DIM_NK = meg.COGSCATEGORY_DIM_FK    
          AND ccd.DW_ISCURRENTROW
      LEFT JOIN (
          SELECT daf.ITEM_FACT_FK, SUM(daf.APPLIED_AMOUNT) AS ""Item Discount Amount""
              FROM DATAWAREHOUSE.DISCOUNTITEM_FACT daf
                WHERE daf.DW_ISCURRENTROW 
                  AND (daf.FISCAL_DATE::date >= :startdate::date 
                  AND daf.FISCAL_DATE::date  <= :enddate::date)
                  AND daf.LOCATION_DIM_FK IN (--351,352
                     SELECT table1.value 
                        FROM table(split_to_table(:locationidS, '',''))  table1)
                  AND NOT daf.IS_TRAINING
                GROUP BY daf.ITEM_FACT_FK
                                                          )dis 
            ON dis.ITEM_FACT_FK = itf.ITEM_FACT_NK
          
--==========================================================================================
);
RETURN TABLE(reportSet); 
END;
-- ';"
PROCEDURE,DATAWAREHOUSE,CREATE_DW_UPDATE(VARCHAR),"CREATE OR REPLACE PROCEDURE ""CREATE_DW_UPDATE""(""TABLE_NAME_INPUT"" VARCHAR(16777216))
RETURNS TABLE (""SQLTEXT"" VARCHAR(16777216))
LANGUAGE SQL
EXECUTE AS OWNER
AS '
DECLARE res_list    resultset;
        --table_name_input varchar := ''PAYMENT_FACT''; --uncomment for development
        table_name  varchar := table_name_input; 
        
-----------------------------------------------------------------------------------------
BEGIN
  res_list := (        
   SELECT LISTAGG(REPLACE(txt.SQLTEXTVALUE,''<Table Name>'',:table_name) || '' \\n '') 
        WITHIN GROUP(ORDER BY txt.SQLTEXTORDINAL)
    FROM DEV_HOSPENG_REPORTING.DATAWAREHOUSE.DW_SQLTEXT  txt
    WHERE txt.SQLTEXTGROUP = ''DWUpdateText''
      AND NOT txt.ISDELETED
      AND txt.ISCURRENTVERSION        
   )  --end of select stmt for sql_text variable
   
   ;
--======================================================================================    
    return table(res_list);
--======================================================================================
END;
--======================================================================================
';"
PROCEDURE,DATAWAREHOUSE,"SP_LOAD_DATASHARE_ITEMS(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_DATASHARE_ITEMS""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS '
-- -- =====================================================================================
-- Example Call Statement
-- CALL DATAWAREHOUSE.SP_LOAD_DATASHARE_ITEMS(''2000-11-20T14:48:37.661Z'',''2026-11-20T14:48:37.661Z'',''[351]'');
-- GRANT usage ON procedure DATAWAREHOUSE.SP_LOAD_DATASHARE_ITEMS(timestamp_tz,timestamp_tz,string) TO ROLE DATA_REPLICATION_HOSPENG;
-- --=========================================================================================
DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2020-08-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2029-08-20T14:48:37.661Z''; 
  -- locationid string      := ''[351,352]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--=========================================================================================
BEGIN
 reportSet:= (
SELECT itf.ITEM_FACT_NK                                   as ""Support ID"" 
--status, category, level-------------------------------------------------------------------
    ,IFNULL(ccd.COGSCATEGORY,''None'')                      as ""Category Name""
    ,IFNULL(ccd.cogscategory_dim_nk,0)                    as ""Category ID""
-- --geography--------------------------------------------------------------------------------
    ,IFNULL(loc.LOCATIONNAME,''None'')                      as ""Location Name""
    ,IFNULL(loc.LOCATION_DIM_NK,''None'')                   as ""Location ID""
    ,IFNULL(itf.REVENUECENTERNAME,''None'')                 as ""Revenue Center Name""
-- --dates-------------------------------------------------------------------------------------
    ,LOC.TZ_NAME                                          as ""Time Zone""
    ,to_char(LEFT(chk.FISCAL_DATE,4))                     as ""Year""
    ,to_char(YEAR(chk.FISCAL_DATE)) || ''|'' || TO_CHAR(LEFT(''0'' || MONTH(chk.FISCAL_DATE),2))                                       
                                                          as ""Year and Month""
    ,IFNULL(dad.DAYPART,''None'')                           as ""Daypart""
    ,to_char(chk.FISCAL_DATE)                             as ""Fiscal Date""
    ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,chk.OPENED_AT::timestamp_ntz )::timestamp )                                                                           
                                                          as ""Opened At""                                                           
    ,IFNULL(DAYNAME(chk.FISCAL_DATE),''None'')              as ""Day of Week""
    ,CASE WHEN DAYNAME(chk.FISCAL_DATE) IN (''Sat'',''Sun'')  
             THEN TRUE ELSE FALSE END                     as ""Is Weekend""
-- --flags--------------------------------------------------------------------------------------
    ,IFNULL(itf.HASMODIFIERS,FALSE)                       as ""Has Modifiers""
-- --Descriptors-------------------------------------------------------------------------------- 
    ,IFNULL(itf.chequenumber ,''None'')                     as ""Check""
    ,IFNULL(itf.CHEQUE_FACT_FK ,''None'')                   as ""Check ID""    
    ,IFNULL(med.MENUITEMNAME,'' None'')                     as ""Item Name""
    ,IFNULL(med.MENUITEMNAME,'' None'')                     as ""Item Code""
    ,IFNULL(itf.COMBINEDNAME,''Regular'')                   as ""Variant Name""     
-- --Facts-----------------------------------------------------------------------------------------
    ,IFNULL(itf.QUANTITY::NUMBER(10,0),0)                 as ""Count""   
    ,IFNULL(itf.APPLIEDAMOUNT::NUMBER(18,2),0)            as ""Net Amount""
    ,IFNULL(itf.GROSS::NUMBER(18,2),0)                    as ""Gross Amount"" 
    ,IFNULL(itf.BASEPRICE::NUMBER(18,2),0)                as ""Base Price""
    ,IFNULL(itf.PRICE::NUMBER(18,2),0)                    as ""Price""
    ,IFNULL(dis.""Item Discount Amount""::NUMBER(18,2),0)   as ""Item Discount Amount""
    ,IFNULL(itf.INCLUSIVETAX::NUMBER(18,2),0)             as ""Inclusive Tax Amount""    
    ,IFNULL(itf.TAX::NUMBER(18,2),0)                      as ""Tax Amount""
--------------------------------------------------------------------------------------------   
FROM DATAWAREHOUSE.ITEM_FACT                              itf
     INNER JOIN DATAWAREHOUSE.MENUITEMNAME_DIM            med
       ON med.MENUITEMNAME_DIM_NK = itf.MENUITEMNAME_DIM_FK
          AND itf.ITEMSTATUS IN (''Added'',''Sent'')
          AND itf.CHECKSTATUS = ''Closed''
          AND itf.DW_ISCURRENTROW  
          AND med.DW_ISCURRENTROW  
          AND NOT itf.DW_ISDELETED
          AND NOT itf.IS_TRAINING
          AND itf.LOCATION_DIM_FK IN (--351,352
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)
      INNER JOIN DATAWAREHOUSE.CHEQUE_FACT                                chk
        ON chk.CHEQUE_FACT_NK = itf.CHEQUE_FACT_FK
          AND chk.DW_ISCURRENTROW
          AND chk.STATUS = ''Closed''
          AND itf.ITEMSTATUS IN (''Added'',''Sent'')
          AND (chk.FISCAL_DATE::date >= :startdate::date 
                AND chk.FISCAL_DATE::date  <= :enddate::date)
      INNER JOIN DATAWAREHOUSE.LOCATION_DIM                     loc
        ON itf.LOCATION_DIM_FK = loc.LOCATION_DIM_NK
          AND loc.DW_ISCURRENTROW
      INNER JOIN DATAWAREHOUSE.DAYPART_DIM                      dad
        ON itf.daypart_dim_fk = dad.daypart_dim_nk
          AND dad.DW_ISCURRENTROW = TRUE         
      INNER JOIN DATAWAREHOUSE.REPORTCATEGORY_DIM               meg
        ON med.REPORTCATEGORY_DIM_FK = meg.REPORTCATEGORY_DIM_NK
          AND meg.DW_ISCURRENTROW = TRUE
      INNER JOIN DATAWAREHOUSE.COGSCATEGORY_DIM                  ccd
        ON ccd.COGSCATEGORY_DIM_NK = meg.COGSCATEGORY_DIM_FK    
          AND ccd.DW_ISCURRENTROW
      LEFT JOIN (
          SELECT daf.ITEM_FACT_FK, SUM(daf.APPLIED_AMOUNT) AS ""Item Discount Amount""
              FROM DATAWAREHOUSE.DISCOUNTITEM_FACT daf
                WHERE daf.DW_ISCURRENTROW 
                  AND (daf.FISCAL_DATE::date >= :startdate::date 
                  AND daf.FISCAL_DATE::date  <= :enddate::date)
                  AND daf.LOCATION_DIM_FK IN (--351,352
                     SELECT table1.value 
                        FROM table(split_to_table(:locationidS, '',''))  table1)
                  AND NOT daf.IS_TRAINING
                GROUP BY daf.ITEM_FACT_FK
                                                          )dis 
            ON dis.ITEM_FACT_FK = itf.ITEM_FACT_NK
          
--==========================================================================================
);
RETURN TABLE(reportSet); 
END;
-- ';"
PROCEDURE,DATAWAREHOUSE,CREATE_TABLE_DW(VARCHAR),"CREATE OR REPLACE PROCEDURE ""CREATE_TABLE_DW""(""TABLE_NAME_INPUT"" VARCHAR(16777216))
RETURNS TABLE (""SQLTEXT"" VARCHAR(16777216))
LANGUAGE SQL
EXECUTE AS OWNER
AS '
DECLARE res_list            resultset;
        --table_name_input    varchar := ''PAYMENTS_FACT''; --uncomment for dev
        table_name          varchar := table_name_input; 
-----------------------------------------------------------------------------------------
BEGIN
  res_list := (
    SELECT LISTAGG(INLT2.SQLTextValue  || '' \\n '') WITHIN GROUP (ORDER BY INLT2.SQLTextOrdinal) AS sqlText
      FROM(
      --additional columns added to the view for the dw table
      SELECT INLT1.SQLTextOrdinal
          ,REPLACE(INLT1.SQLTextValue,''<TableName>'', MAX(INLT1.TableName)OVER(PARTITION BY 1)) as SQLTextValue
        FROM (
           SELECT SQT.SQLTextOrdinal     AS SQLTextOrdinal
             ,NULL                       AS TableName
             ,SQT.SQLTextValue           AS SQLTextValue
             FROM dev_hospeng_reporting.datawarehouse.DW_SQLText  SQT
            WHERE SQT.SQLTextGroup = ''DWAdditionalColumns''
              AND SQT.IsCurrentVersion 
              AND NOT SQT.ISDELETED
        
           UNION
          
--grab all of the columns from the conforming view to include in the dw table
        SELECT
             c.Ordinal_position, t.table_name
             ,'' '' || c.column_name || '''' || '' '' 
                || CASE WHEN c.column_name LIKE ''%_PK''
                    THEN ''int identity(1,1),''
                  ELSE 
                     CASE WHEN c.column_name LIKE ''%_FK''
                        THEN '' int,''
                      ELSE 
                  c.DATA_TYPE || CASE WHEN DATA_TYPE NOT IN (''BOOLEAN'',''VARIANT'') 
                    THEN '' (''  || COALESCE(CAST(c.CHARACTER_MAXIMUM_LENGTH as STRING)
                               ,CAST(c.DATETIME_PRECISION as STRING)
                               ,CAST(c.CHARACTER_OCTET_LENGTH as STRING)
                               ,CAST(c.NUMERIC_PRECISION as STRING),'' '')
                 ELSE '' ''
                     END
              
               || CASE WHEN DATA_TYPE  = ''NUMBER'' THEN '','' || CAST(NUMERIC_SCALE AS STRING)  ELSE '' '' END
               || CASE WHEN DATA_TYPE NOT IN (''BOOLEAN'',''VARIANT'') THEN '')'' ELSE '' '' END
              

               || CASE WHEN c.ordinal_position = MAX(c.ordinal_position) OVER (PARTITION BY 1) THEN '');'' ELSE '', '' END
              END 
            END
                        AS sqlText
      from information_schema.tables t
      inner join information_schema.columns c
          on t.table_schema     = c.table_schema
            and t.table_name    = c.table_name
            and t.table_type    = ''VIEW''
            and t.table_schema  = ''POSTGRES_PUBLIC''
            and t.table_name    = :table_name
            
        UNION
     --add natural key for all foreign keys      
     select c.Ordinal_position + 0.5                  as ordinal_position 
      , :table_name                                   as table_name
      --,replace(c.column_name,''FK'',''NK'') || '',''        as column_name
            ,'' '' || replace(c.column_name,''FK'',''NK'') || '''' || '' '' || c.DATA_TYPE
                || CASE WHEN DATA_TYPE NOT IN (''BOOLEAN'',''VARIANT'')
                  THEN '' (''  || COALESCE(CAST(c.CHARACTER_MAXIMUM_LENGTH as STRING)
                               ,CAST(c.DATETIME_PRECISION as STRING)
                               ,CAST(c.CHARACTER_OCTET_LENGTH as STRING)
                               ,CAST(c.NUMERIC_PRECISION as STRING),'' '')
                              
               ELSE '' '' END
       
               || CASE WHEN DATA_TYPE  = ''NUMBER'' THEN '','' || CAST(NUMERIC_SCALE AS STRING)  ELSE '' '' END
               || CASE WHEN DATA_TYPE NOT IN (''BOOLEAN'',''VARIANT'') THEN ''),'' ELSE '','' END
    
              
                        AS sqlText
     from information_schema.tables t
      inner join information_schema.columns c
          on t.table_schema     = c.table_schema
            and t.table_name    = c.table_name
            and t.table_type    = ''VIEW''
            and t.table_schema  = ''POSTGRES_PUBLIC''
            and t.table_name    = :table_name
            and c.column_name   like ''%_FK''
                                                    ) INLT1
      --order by SQLTextOrdinal
                                                            ) INLT2
                                                                    )
    ;
--======================================================================================    
return table(res_list);
--======================================================================================
END;
';"
PROCEDURE,DATAWAREHOUSE,CREATE_DW_LOAD(VARCHAR),"CREATE OR REPLACE PROCEDURE ""CREATE_DW_LOAD""(""TABLE_NAME_INPUT"" VARCHAR(16777216))
RETURNS TABLE (""SQLTEXT"" VARCHAR(16777216))
LANGUAGE SQL
EXECUTE AS OWNER
AS '
declare select_statement varchar;
        col_list    resultset;
        --select_list resultset;
        res         resultset;
        sqlText2    varchar := '')'';
        sqlTextA    varchar := ''select '';
        --table_name_input varchar := ''ADDRESS_DIM'';
        table_name  varchar := table_name_input; 
        sqlText1    varchar := ''insert into DEV_HOSPENG_REPORTING.DATAWAREHOUSE.'' 
                    || :table_name ||'' (''; 
        sqlTextB    varchar := '' from DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.'' || :table_name || '';''; 
        all_sqltext varchar;
-----------------------------------------------------------------------------------------
begin
  drop table if exists DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_cols; 
  drop table if exists DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_sql;
  
  create temp table DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_sql (
    ordinal int
    ,sqlText varchar
  );

------------------------------------------------------------------------------------
  create temp table DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_cols as
      select c.column_name 
              || case when c.ordinal_position = max(ordinal_position) over (partition by 1)
                     then '' ''
                   else '', ''
                   end as column_name
              ,c.ordinal_position
              ,min(c.ordinal_position) over(partition by 1) as minOrdinal
              ,max(c.ordinal_position) over(partition by 1) as maxOrdinal
      from information_schema.tables t
         inner join information_schema.columns c
            on t.table_schema      = c.table_schema
                and t.table_name   = c.table_name
                and t.table_type   = ''BASE TABLE''
                and t.table_schema = ''DATAWAREHOUSE''
                and t.table_name   = :table_name
                and c.column_name Not like ''DW_%''
            order by c.ordinal_position;
            
-----------------------------------------------------------------------------------------           
  insert into DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_sql (ordinal,sqlText)
     select  1 as ordinal
       ,:sqlText1 || listagg(column_name) within group (order by ordinal_position) 
         || :sqlText2 as sqlText
        from DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_cols;

------------------------------------------------------------------------------------
col_list := (
  SELECT LISTAGG(sqlText) WITHIN GROUP (ORDER BY inlt1.ORDINAL)
    FROM (
      SELECT sqlText || '' \\n '' as sqlText, 1 AS ORDINAL 
      FROM DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_sql   
        UNION
      SELECT LISTAGG(case when ordinal_position = minordinal 
         then :sqlTextA
         else '' '' 
         end
        || replace(column_name,'','') 
        || case when column_name like ''%_FK%'' then '' || ''''.'''' ||  DW_BATCHID '' else '' '' end
        || '' as '' 
        || case when ordinal_position = maxordinal 
             then replace(column_name,'','') || :sqlTextB
            else column_name
            end  || '' \\n'') WITHIN GROUP (ORDER BY ordinal_position) 
        as output_text
      , 2 AS ORDINAL 
        --,ordinal_position + 100 as ordinal
      from DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_cols 
    ) inlt1
);

res := (
     select ''skssksk sksk'' as output_text
   );
   
  
--======================================================================================         
return table(col_list);

end;
';"
PROCEDURE,DATAWAREHOUSE,CREATE_LOAD_STAGE(VARCHAR),"CREATE OR REPLACE PROCEDURE ""CREATE_LOAD_STAGE""(""TABLE_NAME_INPUT"" VARCHAR(16777216))
RETURNS TABLE (""SQLTEXT"" VARCHAR(16777216))
LANGUAGE SQL
EXECUTE AS OWNER
AS '
declare select_statement varchar;
        col_list    resultset;
        --select_list resultset;
        res         resultset;
        sqlText2    varchar := '')'';
        sqlTextA    varchar := ''SELECT '';
        --table_name_input varchar := ''ADDRESS_DIM'';
        table_name  varchar := table_name_input; 
        sqlText1    varchar := ''INSERT OVERWRITE INTO DEV_HOSPENG_REPORTING.DATASTAGE.'' 
                    || :table_name ||'' (  \\n''; 
        sqlTextB    varchar := '' from DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.'' || :table_name || '';''; 
        all_sqltext varchar;
-----------------------------------------------------------------------------------------
begin
  drop table if exists DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_cols; 
  drop table if exists DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_sql;
  
  create temp table DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_sql (
    ordinal int
    ,sqlText varchar
  );

------------------------------------------------------------------------------------
  create temp table DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_cols as
      select  c.column_name 
              || case when c.ordinal_position = max(ordinal_position) over (partition by 1)
                     then '' ''
                   else '', ''
                   end as column_name
              ,c.ordinal_position
              ,min(c.ordinal_position) over(partition by 1) as minOrdinal
              ,max(c.ordinal_position) over(partition by 1) as maxOrdinal
      from information_schema.tables t
         inner join information_schema.columns c
            on t.table_schema      = c.table_schema
                and t.table_name   = c.table_name
                and t.table_type   = ''BASE TABLE''
                and t.table_schema = ''DATASTAGE''
                and t.table_name   = :table_name
                --and c.column_name Not like ''DW_%               
            order by c.ordinal_position;
            
-----------------------------------------------------------------------------------------           
  insert into DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_sql (ordinal,sqlText)
     select  1 as ordinal
       ,:sqlText1 || listagg(column_name) within group (order by ordinal_position) 
         || :sqlText2 as sqlText
        from DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_cols;

------------------------------------------------------------------------------------
col_list := (
  SELECT LISTAGG(sqlText) WITHIN GROUP (ORDER BY inlt1.ORDINAL)
    FROM (
      SELECT sqlText || '' \\n '' as sqlText, 1 AS ORDINAL 
      FROM DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_sql   
        UNION
      SELECT LISTAGG(case when ordinal_position = minordinal 
         then :sqlTextA
         else '' '' 
         end
        || replace(column_name,'','') 
        --|| case when column_name like ''%_FK%'' then '' || ''''.'''' ||  DW_BATCHID '' else '' '' end
        || '' as '' 
        || case when ordinal_position = maxordinal 
             then replace(column_name,'','') || :sqlTextB
            else column_name
            end  || '' \\n'') WITHIN GROUP (ORDER BY ordinal_position) 
        as output_text
      , 2 AS ORDINAL 
        --,ordinal_position + 100 as ordinal
      from DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_cols 
    ) inlt1
);

res := (
     select ''skssksk sksk'' as output_text
   );
   
  
--======================================================================================         
return table(col_list);

end;
';"
PROCEDURE,DATAWAREHOUSE,"SP_REPORT_LABOR(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_LABOR""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS '
-- --=============================================================================================
-- CALL DATAWAREHOUSE.SP_REPORTDATAGROOM(''SP_REPORT_LABOR'',365,351);
-- CALL DATAWAREHOUSE.SP_REPORT_LABOR(''2000-11-20T14:48:37.661Z'',''2026-11-20T14:48:37.661Z'',''[2,3,4]'');
-- GRANT usage ON procedure DATAWAREHOUSE.SP_REPORT_LABOR(timestamp_tz,timestamp_tz,string) TO ROLE DATA_REPLICATION_HOSPENG;
--=============================================================================================
DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2024-08-23T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2024-08-23T14:48:37.661Z''; 
  -- locationid string      := ''[2]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
-- =============================================================================================
BEGIN
  DROP TABLE IF EXISTS TEMP_LABOR;
  DROP TABLE IF EXISTS TEMP_TIPGRAT;

  WITH SHIFT_CTE AS (
    SELECT SHD.SHIFT_DIM_PK --|| overtime_fact_nk || fiscal day and week or date                                 
                                                               AS ""Support ID"" 
        ,SHD.SHIFT_DIM_NK                                      AS ""SHIFT_DIM_NK""
    --status, category, level------------------------------------------------------------------
        ,''Shift''                                               AS ""Level""
    --geography--------------------------------------------------------------------------------
        ,IFNULL(loc.LOCATIONNAME,''None'')                       AS ""Location""
        ,IFNULL(org.organization,''None'')                       AS ""Organization""
    --dates-------------------------------------------------------------------------------------
        ,LOC.TZ_NAME                                            AS ""Time Zone""
        ,TO_CHAR(DATE_PART(YEAR,SHD.CLOCKEDIN_AT::timestamp_ntz ))   
                                                               AS ""Year""
        ,to_char(LEFT(SHD.CLOCKEDIN_AT::timestamp_ntz,7))                     
                                                               AS ""Year and Month""
        ,SHD.CLOCKEDIN_AT::timestamp_ntz                             
                                                               AS ""Clocked In At""
        ,SHD.CLOCKEDOUT_AT::timestamp_ntz                                    
                                                               AS ""Clocked Out At""    
        ,IFNULL(DAYNAME(SHD.CLOCKEDIN_AT::timestamp_ntz),''None'')              
                                                               AS ""Day of Week""
        ,CASE WHEN DAYNAME(SHD.CLOCKEDIN_AT::timestamp_ntz) IN (''Sat'',''Sun'')  
            THEN TRUE ELSE FALSE END                           
                                                               AS ""Is Weekend""
        ,ORG.START_OF_PAYROLL_WEEK_INT                         AS ""Week Offset""
                ,YEAR(TIMESTAMPADD(DAY,ORG.START_OF_PAYROLL_WEEK_INT,SHD.FISCAL_DAY::timestamp_ntz)) || ''-'' ||
         WEEKOFYEAR(TIMESTAMPADD(DAY,ORG.START_OF_PAYROLL_WEEK_INT,SHD.FISCAL_DAY::timestamp_ntz))                                                 
                                                               AS ""Fiscal Week""                                                
        ,SHD.FISCAL_DAY                                        AS ""Fiscal Day""  
    --flags--------------------------------------------------------------------------------------
        ,SHD.IS_SHIFTCOMPLETE                                  AS ""Is Clocked Out""
        ,SHD.WAS_SYSTEM_CLOCKOUT                               AS ""Was System Clock Out""
        ,SHD.GETS_PAID_BREAK                                   AS ""Gets Paid Break""
    --people------------------------------------------------------------------------------------- 
        ,EMD.EMPLOYEE_NAME                                     AS ""Employee""
        ,EMD.EMPLOYEE_DIM_NK                                   AS ""Employee ID""
        ,SHD.JOBPOSITION_DIM_FK                                AS ""JOBPOSITION_DIM_FK""
        ,SHD.LOCATION_DIM_FK                                   AS ""LOCATION_DIM_FK""        
     --Descriptors-------------------------------------------------------------------------------- 
       ,JBP.JOB_POSITION                                       AS ""Job Position""  --(i.e. Bartender, Cook, Server)    
       ,SHD.SHIFT                                              AS ""Shift ID""  
       ,SHD.PAY_RATE_BASIS                                     AS ""Pay Basis""
     --Facts-----------------------------------------------------------------------------------------
        ,NULL                                                  AS ""Overtime Rule""
        ,NULL                                                  AS ""Hours Per Day""
        ,NULL                                                  AS ""Seconds Per Day""
        ,NULL                                                  AS ""Hours Per Week""
        ,NULL                                                  AS ""Seconds Per Week""
        ,to_number(1)                                          AS ""Shift Count""
        ,NULL                                                  AS ""Break Count""  
        ,COUNT(SHD.SHIFT) OVER (PARTITION BY SHD.LOCATION_DIM_FK,EMD.EMPLOYEE_DIM_NK,SHD.FISCAL_DAY)  
                                                               AS ""Shift Per Day Count""
        -- ,IFF( SHD.IS_SHIFTCOMPLETE,SHD.SHIFT_SECONDS, 
        --   ROUND(TIMEDIFF(second
        --        ,CONVERT_TIMEZONE(''UTC'',loc.TZ_NAME,shd.CLOCKEDIN_AT::timestamp_ntz )::timestamp
        --     -- ,SHD.CLOCKEDIN_AT::timestamp_ntz 
        --        ,CONVERT_TIMEZONE(''UTC'',loc.TZ_NAME,CURRENT_TIMESTAMP::timestamp_ntz )::timestamp
        --     -- ,CURRENT_TIMESTAMP::timestamp_ntz 
        --       )::Number(38,0),0))
        --                                                        AS ""Shift Seconds""


        ,IFF( SHD.IS_SHIFTCOMPLETE,SHD.SHIFT_SECONDS, 
          ROUND(TIMEDIFF(second
               ,SHD.CLOCKEDIN_AT::timestamp_ntz 
               ,CONVERT_TIMEZONE(''UTC'', CURRENT_TIMESTAMP())::timestamp_ntz
              )::Number(38,0),0))
                                                               AS ""Shift Seconds""

                                                               
        ,NULL                                                  AS ""Break Seconds""


        ,shd.REGULAR_RATE * 1.5::Number(18,2)             
                                                               AS ""Overtime Rate""
        ,shd.REGULAR_RATE::Number(18,2)                        AS ""Regular Rate""
 
        FROM DATAWAREHOUSE.SHIFT_DIM                               SHD
          INNER JOIN DATAWAREHOUSE.LOCATION_DIM                    LOC
             ON SHD.LOCATION_DIM_FK = LOC.LOCATION_DIM_NK
                AND LOC.DW_ISCURRENTROW
                AND SHD.DW_ISCURRENTROW
             
                AND NOT SHD.DW_ISDELETED
                AND NOT SHD.IS_ARCHIVED
                AND shd.fiscal_day::date
                   >= dateadd(DAY,-10,:startdate)::date --calculate data 10 days around selected dates so that  
                AND  shd.fiscal_day::date  
                  <= dateadd(DAY,10,:enddate)::date    --the data in the selected range calcs overtime for full fiscal week
                AND SHD.LOCATION_DIM_FK IN ( SELECT table1.value 
                           FROM table(split_to_table(:locationidS, '',''))  table1)
          INNER JOIN DATAWAREHOUSE.ORGANIZATION_DIM                ORG
            ON LOC.ORGANIZATION_DIM_FK = ORG.ORGANIZATION_DIM_NK
              AND ORG.DW_ISCURRENTROW
          INNER JOIN DATAWAREHOUSE.EMPLOYEE_DIM                    EMD
            ON SHD.EMPLOYEE_DIM_FK = EMD.EMPLOYEE_DIM_NK
              AND EMD.DW_ISCURRENTROW
          INNER JOIN DATAWAREHOUSE.JOBPOSITION_DIM                 JBP
            ON JBP.JOBPOSITION_DIM_NK = SHD.JOBPOSITION_DIM_FK 
              AND JBP.DW_ISCURRENTROW
          -- INNER JOIN DATAWAREHOUSE.EMPLOYMENTPERIOD_DIM          EPD
          --   ON EPD.JOBPOSITION_DIM_FK = SHD.JOBPOSITION_DIM_FK
          --     AND EPD.LOCATION_DIM_FK = SHD.LOCATION_DIM_FK
          --     AND EPD.EMPLOYEE_DIM_FK = SHD.EMPLOYEE_DIM_FK
          --     AND EPD.DW_ISCURRENTROW
         ORDER BY SHD.CLOCKEDIN_AT DESC          )
    ,BREAK_CTE AS (
        SELECT SHD_1.""Support ID""                               AS ""Support ID"" 
        ,MAX(SHD_1.SHIFT_DIM_NK)                                AS ""SHIFT_DIM_NK""
    --status, category, level------------------------------------------------------------------
        ,''Break''                                                AS ""Level""
    --geography--------------------------------------------------------------------------------
        ,NULL                                                   AS ""Location""
        ,NULL                                                   AS ""Organization""
    -- --dates-------------------------------------------------------------------------------------
        ,MAX(SHD_1.""Time Zone"")                                 AS ""Time Zone""
        ,NULL                                                   AS ""Year""
        ,NULL                                                   AS ""Year and Month""
        ,NULL                                                   AS ""Clocked In At""
        ,NULL                                                   AS ""Clocked Out At""    
        ,NULL                                                   AS ""Day of Week""
        ,NULL                                                   AS ""Is Weekend""
        ,NULL                                                   AS ""Week Offset""
        ,MAX(SHD_1.""Fiscal Week"")                               AS ""Fiscal Week""                      
        ,NULL                                                   AS ""Fiscal Day""  
    -- --flags--------------------------------------------------------------------------------------
        ,NULL                                                   AS ""Is Clocked Out""
        ,NULL                                                   AS ""Was System Clock Out""
        ,NULL                                                   AS ""Gets Paid Break""
    -- --people------------------------------------------------------------------------------------- 
        ,NULL                                                   AS ""Employee""
        ,NULL                                                   AS ""Employee ID""
        ,NULL                                                   AS JOBPOSITION_DIM_FK
        ,NULL                                                   AS LOCATION_DIM_FK       
    --  --Descriptors-------------------------------------------------------------------------------- 
       ,NULL                                                    AS ""Job Position""  --(i.e. Bartender, Cook, Server)  
       ,NULL                                                    AS ""Pay Basis""
       ,NULL                                                    AS ""Shift ID""  
    -- Facts-----------------------------------------------------------------------------------------
        ,NULL                                                   AS ""Overtime Rule""
        ,NULL                                                   AS ""Hours Per Day""
        ,NULL                                                   AS ""Seconds Per Day""
        ,NULL                                                   AS ""Hours Per Week""
        ,NULL                                                   AS ""Seconds Per Week""
        ,NULL                                                   AS ""Shift Count""
        ,1                                                      AS ""Break Count""   
        ,NULL                                                   AS ""Shift Per Day Count""
        ,0                                                      AS ""Shift Seconds""
        ,SUM(IFF( BRK_1.IS_BREAKCOMPLETE ,BRK_1.BREAK_SECONDS , 
          ROUND(TIMEDIFF(SECOND
            ,BRK_1.START_AT::timestamp_ntz 
            ,CURRENT_TIMESTAMP::timestamp_ntz 
                )::Number(38,0),0)) )                                                  
                                                                AS ""Break Seconds""
     
        ,NULL                                                   AS ""Overtime Rate""
        ,NULL                                                   AS ""Regular Rate""
          FROM SHIFT_CTE                                        SHD_1
            INNER JOIN DATAWAREHOUSE.SHIFTBREAK_FACT                BRK_1
              ON SHD_1.SHIFT_DIM_NK = BRK_1.SHIFT_DIM_FK
                 AND BRK_1.DW_ISCURRENTROW
                 AND NOT BRK_1.DW_ISDELETED
            GROUP BY SHD_1.""Support ID""  
    )
    ,RULE_CTE AS (  ---NOTE:  THIS JOIN SHOULD NOT BE CURRENT ROW...IT SHOULD BE ROW WHERE TIME = SHIFT START
         SELECT SHD_2.""Support ID""                              AS ""Support ID"" 
        ,SHD_2.SHIFT_DIM_NK                                     AS ""SHIFT_DIM_NK""
    --status, category, level------------------------------------------------------------------
        ,''Rule''                                                 AS ""Level""
    --geography--------------------------------------------------------------------------------
        ,NULL                                                   AS ""Location""
        ,NULL                                                   AS ""Organization""
    -- --dates-------------------------------------------------------------------------------------
        ,NULL                                                   AS ""Time Zone""    
        ,NULL                                                   AS ""Year""
        ,NULL                                                   AS ""Year and Month""
        ,NULL                                                   AS ""Clocked In At""
        ,NULL                                                   AS ""Clocked Out At""    
        ,NULL                                                   AS ""Day of Week""
        ,NULL                                                   AS ""Is Weekend""
        ,NULL                                                   AS ""Week Offset""
        ,SHD_2.""Fiscal Week""                                    AS ""Fiscal Week""                      
        ,NULL                                                   AS ""Fiscal Day""    
    -- --flags--------------------------------------------------------------------------------------
        ,NULL                                                   AS ""Is Clocked Out""
        ,NULL                                                   AS ""Was System Clock Out""
        ,NULL                                                   AS ""Gets Paid Break""
    -- --people------------------------------------------------------------------------------------- 
        ,NULL                                                   AS ""Employee""
        ,NULL                                                   AS ""Employee ID""        
        ,NULL                                                   AS JOBPOSITION_DIM_FK
        ,NULL                                                   AS LOCATION_DIM_FK       
    --  --Descriptors-------------------------------------------------------------------------------- 
       ,NULL                                                    AS ""Job Position""  --(i.e. Bartender, Cook, Server) 
       ,NULL                                                    AS ""Pay Basis""
       ,NULL                                                    AS ""Shift ID""  
    -- Facts-----------------------------------------------------------------------------------------
        ,OLT.OVERTIMERULE                                       AS ""Overtime Rule""
        ,CASE WHEN OLT.HOURS_PER_DAY = 0 or :locationidS in (''[3]'',''[4]'',''[5]'')
            THEN 99999 ELSE  OLT.HOURS_PER_DAY END                                      
                                                                AS ""Hours Per Day""
        ,CASE WHEN OLT.HOURS_PER_DAY = 0 or :locationidS in (''[3]'',''[4]'',''[5]'')
            THEN 99999 ELSE  OLT.HOURS_PER_DAY END * 60 * 60                                 
                                                                AS ""Seconds Per Day""
                                                                
        ,CASE WHEN OLT.HOURS_PER_DAY = 0 or :locationidS in (''[3]'',''[4]'',''[5]'')
           THEN 99999 ELSE OLT.HOURS_PER_WEEK  END                                   
                                                                AS ""Hours Per Week""
        ,CASE WHEN OLT.HOURS_PER_DAY = 0 or :locationidS in (''[3]'',''[4]'',''[5]'') 
          THEN 99999 ELSE OLT.HOURS_PER_WEEK * 60 *60 END                         
                                                                AS ""Seconds Per Week""
        
        ,NULL                                                   AS ""Shift Count""
        ,0                                                      AS ""Break Count""   
        ,NULL                                                   AS ""Shift Per Day Count""
        ,0                                                      AS ""Shift Seconds""
        ,NULL                                                   AS ""Break Seconds""
     
        ,NULL                                                   AS ""Overtime Rate""
        ,NULL                                                   AS ""Regular Rate""
          FROM SHIFT_CTE                                        SHD_2
            INNER JOIN OVERTIMELABORRULE_JOBPOSITION_XREF       OJX
           ON OJX.JOBPOSITION_DIM_FK = SHD_2.JOBPOSITION_DIM_FK
             AND OJX.DW_ISCURRENTROW
         INNER JOIN DATAWAREHOUSE.OVERTIMELABORRULE_DIM             OLT
            ON SHD_2.LOCATION_DIM_FK = OLT.LOCATION_DIM_FK
              AND OLT.OVERTIMELABORRULE_DIM_PK = OJX.OVERTIMELABORRULE_DIM_FK
              AND OLT.DW_ISCURRENTROW  
              AND NOT OLT.DW_ISDELETED
              AND OLT.IS_ACTIVE
    )  --end of cte tables
    --=========================================================================================
    SELECT to_char(UNI_2.""Support ID"")           as ""Support ID""
    , ''LAB-'' ||row_number() over (order by UNI_2.""Shift ID"") 
                                                 as ""Detail ID""  
    ,UNI_2.""Location""
    ,UNI_2.""Time Zone""
    ,UNI_2.""Year""
    ,UNI_2.""Year and Month""
    ,CONVERT_TIMEZONE(''UTC'',UNI_2.""Time Zone"",UNI_2.""Clocked In At""::timestamp_ntz )::timestamp 
    --,UNI_2.""Clocked In At""
                                                     as ""Clocked In At""
    ,CONVERT_TIMEZONE(''UTC'',UNI_2.""Time Zone"",UNI_2.""Clocked Out At""::timestamp_ntz )::timestamp                                                      
    --,UNI_2.""Clocked Out At""
                                                     as ""Clocked Out At""

---------------------------------
    ,to_varchar(CONVERT_TIMEZONE(''UTC'',UNI_2.""Time Zone"",UNI_2.""Clocked In At""::timestamp_ntz )::timestamp,''HH12:MI:SS'')
                                                      as ""Clock In Time""
    ,to_varchar(CONVERT_TIMEZONE(''UTC'',UNI_2.""Time Zone"",UNI_2.""Clocked Out At""::timestamp_ntz )::timestamp,''HH12:MI:SS'')
                                                      as ""Clock Out Time""                                                      
---------------------------------
    ,UNI_2.""Day of Week""
    ,UNI_2.""Is Weekend""
    ,UNI_2.""Fiscal Week""
    ,to_char(UNI_2.""Fiscal Day"")                      as ""Fiscal Day""
    ,UNI_2.""Is Clocked Out""
    ,UNI_2.""Was System Clock Out""
    ,UNI_2.""Employee""
    -- ,TO_VARCHAR(UNI_2.""Employee ID"")               as ""Employee ID""
    ,UNI_2.""Job Position""
    ,UNI_2.""Pay Basis""
    ,''Shift '' ||UNI_2.""Shift ID""                      as ""Shift ID""
    ,UNI_2.""Overtime Rule""
    ,UNI_2.""Overtime Rate""::NUMBER(18,2)              as ""Overtime Rate""
    ,UNI_2.""Regular Rate"" ::NUMBER(18,2)              as ""Regular Rate""
    --=======================================================================  
    ,UNI_2.""Shift Seconds""::NUMBER(18,0)              as ""Shift Seconds""
    ,UNI_2.""Break Seconds""::NUMBER(18,0)              as ""Break Seconds""
    ,UNI_2.""Seconds Per Week""::NUMBER(18,0)           as ""Weekly Overtime Rule Seconds""
    ,UNI_2.""Seconds Per Day"" ::NUMBER(18,0)           as ""Daily Overtime Rule Seconds""
--===================== ====================================================================================
   -- ,UNI_2.""Shift Regular Seconds""::NUMBER(18,0)    as ""Regular Seconds""

   --    ,IFF(UNI_2.""Day Regular Seconds Running Total"" > UNI_2.""Seconds Per Week"" 
   --      AND UNI_2.""Seconds Per Week"" IS NOT NULL
   --          ,IFF(UNI_2.""Seconds Per Week"" <
   --               LAG(UNI_2.""Day Regular Seconds Running Total"") 
   --                 OVER (PARTITION BY  UNI_2.""Employee"", UNI_2.""Fiscal Week""  ORDER BY UNI_2.""Clocked In At"")
   --              ,UNI_2.""Shift Regular Seconds""
   --              ,UNI_2.""Day Regular Seconds Running Total"" - UNI_2.""Seconds Per Week""
   --              )   
   --          ,UNI_2.""Shift Day Overtime Seconds"") ::NUMBER(18,0)                                                      
   --                                                    as ""Overtime Seconds"" 

   ,UNI_2.""Shift Regular Seconds""::NUMBER(18,0)       
     -
    IFF(UNI_2.""Day Regular Seconds Running Total"" > UNI_2.""Seconds Per Week"" 
        AND UNI_2.""Seconds Per Week"" IS NOT NULL
            ,IFF(UNI_2.""Seconds Per Week"" <
                 LAG(UNI_2.""Day Regular Seconds Running Total"") 
                   OVER (PARTITION BY  UNI_2.""Employee"", UNI_2.""Fiscal Week""  ORDER BY UNI_2.""Clocked In At"")
                ,UNI_2.""Shift Regular Seconds""
                ,UNI_2.""Day Regular Seconds Running Total"" - UNI_2.""Seconds Per Week""
                )   
            ,UNI_2.""Shift Day Overtime Seconds"") ::NUMBER(18,0) 

     
       as ""Regular Seconds""
--=====================  ===================================================================================
   -- ,UNI_2.""Day Regular Seconds Running Total""
   -- -- -- ,UNI_2.""Shift Day Overtime Seconds""
   -- -- -- ,UNI_2.""Seconds Per Week""
   -- ,LAG(UNI_2.""Day Regular Seconds Running Total"") 
   --                 OVER (PARTITION BY  UNI_2.""Employee"", UNI_2.""Fiscal Week""  ORDER BY UNI_2.""Clocked In At"")           
   --                                                 as ""Last Running Total""
                                                   
   ,IFF(UNI_2.""Day Regular Seconds Running Total"" > UNI_2.""Seconds Per Week"" 
        AND UNI_2.""Seconds Per Week"" IS NOT NULL
            ,IFF(UNI_2.""Seconds Per Week"" <
                 LAG(UNI_2.""Day Regular Seconds Running Total"") 
                   OVER (PARTITION BY  UNI_2.""Employee"", UNI_2.""Fiscal Week""  ORDER BY UNI_2.""Clocked In At"")
                ,UNI_2.""Shift Regular Seconds""
                ,UNI_2.""Day Regular Seconds Running Total"" - UNI_2.""Seconds Per Week""
                )   
            ,UNI_2.""Shift Day Overtime Seconds"") ::NUMBER(18,0)                                                      
                                                      as ""Overtime Seconds"" 

--======================================================================================
 ,floor(UNI_2.""Shift Regular Seconds""/60/60/24) || '' D '' ||
       floor(UNI_2.""Shift Regular Seconds""/60/60%24) || '':'' ||
       floor(UNI_2.""Shift Regular Seconds""/60%60) || '':'' ||
       floor(UNI_2.""Shift Regular Seconds""%60)         as ""Regular D H:M:S""


 ,floor(IFF(UNI_2.""Day Regular Seconds Running Total"" > UNI_2.""Seconds Per Week"" 
                       AND UNI_2.""Seconds Per Week"" IS NOT NULL
                        ,UNI_2.""Day Regular Seconds Running Total"" - UNI_2.""Seconds Per Week""
                        ,UNI_2.""Shift Day Overtime Seconds"") ::NUMBER(18,0)/60/60/24) || '' D '' ||
       floor(IFF(UNI_2.""Day Regular Seconds Running Total"" > UNI_2.""Seconds Per Week"" 
                       AND UNI_2.""Seconds Per Week"" IS NOT NULL
                        ,UNI_2.""Day Regular Seconds Running Total"" - UNI_2.""Seconds Per Week""
                        ,UNI_2.""Shift Day Overtime Seconds"") ::NUMBER(18,0)/60/60%24) || '':'' ||
       floor(IFF(UNI_2.""Day Regular Seconds Running Total"" > UNI_2.""Seconds Per Week"" 
                       AND UNI_2.""Seconds Per Week"" IS NOT NULL
                        ,UNI_2.""Day Regular Seconds Running Total"" - UNI_2.""Seconds Per Week""
                        ,UNI_2.""Shift Day Overtime Seconds"") ::NUMBER(18,0)/60%60) || '':'' ||
       floor(IFF(UNI_2.""Day Regular Seconds Running Total"" > UNI_2.""Seconds Per Week"" 
                       AND UNI_2.""Seconds Per Week"" IS NOT NULL
                        ,UNI_2.""Day Regular Seconds Running Total"" - UNI_2.""Seconds Per Week""
                        ,UNI_2.""Shift Day Overtime Seconds"") ::NUMBER(18,0)%60)         as ""Overtime D H:M:S""  
  ,null ::NUMBER(18,2)                                                                  as ""Tips""           
  ,null ::NUMBER(18,2)                                                                  as ""Gratuities""        
--======================================================================================
      FROM(
            SELECT UNI_1.* 
                   ,SUM(IFF(UNI_1.""Shift Seconds"" < UNI_1.""Seconds Per Day""
                       OR UNI_1.""Seconds Per Day"" IS NULL
                        ,UNI_1.""Shift Seconds"" 
                        ,UNI_1.""Seconds Per Day"" )) 
                            OVER (PARTITION BY UNI_1.LOCATION_DIM_FK,UNI_1.""Employee ID"" ,UNI_1.""Fiscal Week"" ORDER BY UNI_1.""Shift ID"" 
                    )                                                             AS ""Day Regular Seconds Running Total"" 
                
                    ,IFF(UNI_1.""Seconds Per Day"" < UNI_1.""Shift Seconds""  
                         AND UNI_1.""Seconds Per Day"" IS NOT NULL
                        ,UNI_1.""Seconds Per Day""
                        ,UNI_1.""Shift Seconds"" 
                         )                                 AS ""Shift Regular Seconds"" 
                        
                    ,IFF(UNI_1.""Shift Seconds"" > UNI_1.""Seconds Per Day"" 
                       AND UNI_1.""Seconds Per Day"" IS NOT NULL
                        ,UNI_1.""Shift Seconds"" - UNI_1.""Seconds Per Day"" 
                        ,0)                                                        AS ""Shift Day Overtime Seconds"" 
                                                                                
              FROM (
              SELECT UNI_0.* 
               -- ,CASE WHEN UNI_0.""Shift Per Day Count"" > 1 
               --    THEN SUM(UNI_0.""Shift - Break Seconds"") 
               --       OVER (PARTITION BY LOCATION_DIM_FK,""Employee ID"" ,""Fiscal Day""   --see ""Running Total Each Fiscal Day Seconds""below
               --          ORDER BY ""Shift ID"") 
               --       ELSE UNI_0.""Shift - Break Seconds""   END                        AS ""Shift Seconds""

                      ,UNI_0.""Shift - Break Seconds""                                    AS ""Shift Seconds""    --mod 2024/09/09 yyy

                  ,SUM(UNI_0.""Shift - Break Seconds"") OVER (PARTITION BY LOCATION_DIM_FK,""Employee ID"" ,""Fiscal Day"" 
                        ORDER BY ""Shift ID"")                                                                                                                                                                                            AS ""Running Total Each Fiscal Day Seconds""
                 FROM (
                      SELECT  UNI.""Support ID""                                       AS ""Support ID"" 
                    --status, category, level------------------------------------------------------------------
                    --geography--------------------------------------------------------------------------------
                        ,MAX(UNI.""Location"")                                         AS ""Location""
                        ,MAX(UNI.""Organization"")                                     AS ""Organization""
                    -- --dates-----------------------------------------------------------------------------------
                        ,MAX(UNI.""Time Zone"")                                        AS ""Time Zone""
                        ,MAX(UNI.""Year"")                                             AS ""Year""
                        ,MAX(UNI.""Year and Month"")                                   AS ""Year and Month""
                        ,MAX(UNI.""Clocked In At"")                                    AS ""Clocked In At""
                        ,MAX(UNI.""Clocked Out At"")                                   AS ""Clocked Out At""    
                        ,MAX(UNI.""Day of Week"")                                      AS ""Day of Week""
                        ,MAX(UNI.""Is Weekend"")                                       AS ""Is Weekend""
                        ,MAX(UNI.""Week Offset"")                                      AS ""Week Offset""
                        ,MAX(UNI.""Fiscal Week"")                                      AS ""Fiscal Week""                 
                        ,MAX(UNI.""Fiscal Day"")                                       AS ""Fiscal Day""    
                    -- --flags--------------------------------------------------------------------------------------
                        ,MAX(UNI.""Is Clocked Out"")                                   AS ""Is Clocked Out""
                        ,MAX(UNI.""Was System Clock Out"")                             AS ""Was System Clock Out""
                        ,MAX(UNI.""Gets Paid Break"")                                  AS ""Gets Paid Break""
                        ,CASE WHEN MAX(UNI.""Overtime Rule"") IS NULL THEN FALSE ELSE TRUE END                     
                                                                                     AS ""Gets Overtime""        
                    -- --people------------------------------------------------------------------------------------- 
                        ,MAX(UNI.""Employee"")                                         AS ""Employee""
                        ,MAX(UNI.""Employee ID"")                                      AS ""Employee ID""
                        ,MAX(UNI.JOBPOSITION_DIM_FK)                                 AS JOBPOSITION_DIM_FK
                        ,MAX(UNI.LOCATION_DIM_FK)                                    AS LOCATION_DIM_FK       
                    --  --Descriptors-------------------------------------------------------------------------------- 
                        ,MAX(UNI.""Job Position"")                                     AS ""Job Position""  --(i.e. Bartender, Cook, Server)   
                        ,MAX(UNI.""Pay Basis"")                                        AS ""Pay Basis""
                        ,MAX(UNI.""Shift ID"")                                         AS ""Shift ID""  
                    -- Facts-----------------------------------------------------------------------------------------
                        ,IFNULL(MAX(UNI.""Overtime Rule""),''None'')                     AS ""Overtime Rule""
                        ,MAX(UNI.""Hours Per Day"")                                    AS ""Hours Per Day""
                        ,MAX(UNI.""Hours Per Week"")                                   AS ""Hours Per Week""
                        ,MAX(UNI.""Shift Count"")                                      AS ""Shift Count""
                        ,MAX(UNI.""Break Count"")                                      AS ""Break Count"" 

                        ,MAX(UNI.""Shift Per Day Count"")                              AS ""Shift Per Day Count""
          
                        ,IFNULL(MAX(UNI.""Break Seconds""),0)                          AS ""Break Seconds""
                        ,MAX(UNI.""Overtime Rate"")                                    AS ""Overtime Rate""
                        ,MAX(UNI.""Regular Rate"")                                     AS ""Regular Rate""
                        ,MAX(UNI.""Seconds Per Week"")                                 AS ""Seconds Per Week""
                        ,MAX(UNI.""Seconds Per Day"")                                  AS ""Seconds Per Day""                    
                        ,MAX(UNI.""Shift Seconds"")                                    AS ""Shift Total Seconds""
                        ,MAX(UNI.""Shift Seconds"") 
                           - IFF(MAX(UNI.""Gets Paid Break""),IFNULL(MAX(UNI.""Break Seconds""),0),0)                                    
                                                                                     AS ""Shift - Break Seconds""
                        FROM (
                            SELECT * FROM SHIFT_CTE 
                              UNION
                            SELECT * FROM BREAK_CTE  
                              UNION
                            SELECT * FROM RULE_CTE
                
                        )                                                   UNI
                        GROUP BY ""Support ID""
                                                                             ) UNI_0
                   
                                                                                )  UNI_1
                                                                                    
                                                                                        )UNI_2

  -- WHERE UNI_2.""Fiscal Day""::date
  --     >= :startdate::date --return only selected dates with ot calculated for a full fiscal week
  --   AND UNI_2.""Fiscal Day""::date
  --     <= :enddate::date 

;

--====================================================================================================================
CREATE TEMP TABLE TEMP_LABOR AS
             SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));  
             
--====================================================================================================================  
--get tip and gratuity data
SELECT 
    TO_CHAR(INLT1.""Support ID"")                                    AS ""Support ID""
    ,''TGR-'' ||row_number() over (order by INLT1.""Support ID"")      AS ""Detail ID""
    ,IFNULL(INLT1.LOCATIONNAME,''None'')                             AS ""Location""
    ,INLT1.TZ_NAME                                                 AS ""Time Zone""
    ,TO_CHAR(DATE_PART(YEAR,INLT1.FISCAL_DATE))                    AS ""Year""
    ,LEFT(TO_CHAR(INLT1.FISCAL_DATE),7)                            AS ""Year and Month""
    ,NULL                                                          AS ""Clocked In At""
    ,NULL                                                          AS ""Clocked Out At""
    ,NULL                                                          AS ""Clock In Time""
    ,NULL                                                          AS ""Clock Out Time""
    ,IFNULL(DAYNAME(INLT1.FISCAL_DATE::DATE),''None'')               AS ""Day of Week""
    ,CASE WHEN DAYNAME(INLT1.FISCAL_DATE::DATE) IN (''Sat'',''Sun'')  
                THEN TRUE ELSE FALSE END                           AS ""Is Weekend"" 
    ,YEAR(TIMESTAMPADD(DAY,INLT1.START_OF_PAYROLL_WEEK_INT,INLT1.FISCAL_DATE::DATE)) || ''-'' ||
     WEEKOFYEAR(TIMESTAMPADD(DAY,INLT1.START_OF_PAYROLL_WEEK_INT,INLT1.FISCAL_DATE::DATE))    
                                                                   AS ""Fiscal Week""
    ,INLT1.FISCAL_DATE                                             AS ""Fiscal Day""
    ,NULL                                                          AS ""Is Clocked Out""
    ,NULL                                                          AS ""Was System Clock Out""
    ,INLT1.EMPLOYEE_NAME                                           AS ""Employee""
    ,NULL                                                          AS ""Job Position""
    ,NULL                                                          AS ""Pay Basis""
    ,''Shift '' || to_char(INLT1.SHIFT)                              AS ""Shift ID""
    ,NULL                                                          AS ""Overtime Rule""
    ,NULL::NUMBER(18,2)                                            AS ""Overtime Rate""
    ,NULL::NUMBER(18,2)                                            AS ""Regular Rate""
    ,NULL::NUMBER(18,0)                                            AS ""Shift Seconds""
    ,NULL::NUMBER(18,0)                                            AS ""Break Seconds""
    ,NULL::NUMBER(18,0)                                            AS aily
    ,NULL::NUMBER(18,0)                                            AS ""Daily Overtime Rule Seconds""
    ,NULL::NUMBER(18,0)                                            AS ""Regular Seconds""
    ,NULL::NUMBER(18,0)                                            AS ""Overtime Seconds""
    ,NULL                                                          AS ""Regular D H:M:S""
    ,NULL                                                          AS ""Overtime D H:M:S""
    ,INLT1.TIP::NUMBER(18,2)                                       AS ""Tips""
    ,INLT1.GRATUITIES::NUMBER(18,2)                                AS ""Gratuities""
    -------------------------------------------------------------------------------------------- 
    FROM (
    SELECT  TO_CHAR(MAX(chk.CHEQUE_FACT_NK))                      AS ""Support ID""
           ,CHK.FISCAL_DATE                                       AS FISCAL_DATE
           ,EMD.EMPLOYEE_NAME                                     AS EMPLOYEE_NAME
           ,LOC.TZ_NAME                                           AS TZ_NAME
           ,LOC.LOCATIONNAME                                      AS LOCATIONNAME
           ,SHD.SHIFT                                             AS SHIFT
           ,MAX(ORG.START_OF_PAYROLL_WEEK_INT)                    AS START_OF_PAYROLL_WEEK_INT
           ,SUM(CHK.TIP)::NUMBER(18,2)                            AS TIP
           ,SUM(CHK.GRATUITIES)::NUMBER(18,2)                     AS GRATUITIES

        FROM DATAWAREHOUSE.CHEQUE_FACT                                chk
             INNER JOIN DATAWAREHOUSE.LOCATION_DIM                    loc
                ON chk.LOCATION_DIM_FK = loc.LOCATION_DIM_NK
                    AND loc.DW_ISCURRENTROW
                    AND chk.STATUS = ''Closed''
                    AND NOT chk.IS_TRAINING
                    AND chk.DW_ISCURRENTROW  
                    AND NOT chk.DW_ISDELETED
                    AND NOT chk.IS_TRAINING
                    AND chk.FISCAL_DATE::date   >= :startdate::date
                    AND chk.FISCAL_DATE::date   <= :enddate::date
                    AND chk.LOCATION_DIM_FK IN ( SELECT table1.value 
                           FROM table(split_to_table(:locationidS, '',''))  table1)
              INNER JOIN DATAWAREHOUSE.ORGANIZATION_DIM                ORG
                    ON LOC.ORGANIZATION_DIM_FK = ORG.ORGANIZATION_DIM_NK
                      AND ORG.DW_ISCURRENTROW
              INNER JOIN DATAWAREHOUSE.EMPLOYEE_DIM                     emd
                    ON emd.EMPLOYEE_DIM_NK = chk.EMPLOYEE_DIM_FK
                       AND emd.DW_ISCURRENTROW  
              LEFT JOIN DATAWAREHOUSE.SHIFT_DIM                         shd
                    ON shd.SHIFT_DIM_NK = chk.shift_dim_fk
                        AND shd.dw_iscurrentrow
                        
             GROUP BY CHK.FISCAL_DATE
                   ,EMD.EMPLOYEE_NAME
                   ,LOC.TZ_NAME
                   ,LOC.LOCATIONNAME
                   ,SHD.SHIFT
    ) INLT1        
;
--====================================================================================================================
CREATE TEMP TABLE TEMP_TIPGRAT AS
             SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID())); 

--====================================================================================================================
reportSet := (    
  SELECT MIN(""Support ID"")                    AS ""Support ID""
        ,MIN(""Detail ID"")                     AS ""Detail ID""
        ,""Location""                           AS ""Location""
        ,MAX(""Time Zone"")                     AS ""Time Zone""
        ,MAX(""Year"")                          AS ""Year""
        ,MAX(""Year and Month"")                AS ""Year and Month""
        ,to_char(MAX(""Clocked In At""))        AS ""Clocked In At""
        ,to_char(MAX(""Clocked Out At""))       AS ""Clocked Out At""
        ,to_char(MAX(""Clock In Time""))        AS ""Clock In Time""
        ,to_char(MAX(""Clock Out Time""))       AS ""Clock Out Time""
        ,MAX(""Day of Week"")                   AS ""Day of Week""
        ,MAX(""Is Weekend"")                    AS ""Is Weekend""
        ,MAX(""Fiscal Week"")                   AS ""Fiscal Week""
        ,to_char(MAX(""Fiscal Day""))           AS ""Fiscal Day""
        ,MAX(""Is Clocked Out"")                AS ""Is Clocked Out""
        ,MAX(""Was System Clock Out"")          AS ""Was System Clock Out""
        ,""Employee""                           AS ""Employee""
        ,MAX(""Job Position"")                  AS ""Job Position""
        ,MAX(""Pay Basis"")                     AS ""Pay Basis""
        ,""Shift ID""                           AS ""Shift ID""       
        ,MAX(""Overtime Rule"")                 AS ""Overtime Rule""
        ,MAX(""Overtime Rate"")                 AS ""Overtime Rate""
        ,MAX(""Regular Rate"")                  AS ""Regular Rate""
        ,SUM(""Shift Seconds"")::NUMBER(18,0)   AS ""Shift Seconds""
        ,SUM(""Break Seconds"")::NUMBER(18,0)   AS ""Break Seconds""
        ,MAX(""Weekly Overtime Rule Seconds"")  AS ""Weekly Overtime Rule Seconds""
        ,MAX(""Daily Overtime Rule Seconds"")   AS ""Daily Overtime Rule Seconds"" 
        ,SUM(""Regular Seconds"")::NUMBER(18,0) AS ""Regular Seconds""
        ,SUM(""Overtime Seconds"")::NUMBER(18,0)AS ""Overtime Seconds""
        ,MAX(""Regular D H:M:S"")               AS ""Regular D H:M:S""
        ,MAX(""Overtime D H:M:S"")              AS ""Overtime D H:M:S""
        ,SUM(""Tips"") ::NUMBER(18,2)           AS ""Tips""
        ,SUM(""Gratuities"")::NUMBER(18,2)      AS ""Gratuities"" 
    FROM (
  SELECT * FROM TEMP_LABOR
    UNION
  SELECT * FROM TEMP_TIPGRAT where ""Tips"" <> 0.0 or ""Gratuities"" <> 0.00
  )  
  WHERE ""Fiscal Day""::date
      >= :startdate::date --return only selected dates with ot calculated for a full fiscal week
    AND ""Fiscal Day""::date
      <= :enddate::date 
  GROUP BY ""Shift ID"",""Location"",""Employee""
  ORDER BY ""Employee"",""Fiscal Day""
); 
----------------------------------------------------------------------------------------------------------------------
RETURN TABLE(reportSet);
--====================================================================================================================
END;
';"
PROCEDURE,DATAWAREHOUSE,"SP_REPORT_CASH(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_CASH""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2000-11-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2026-11-20T14:48:37.661Z''; 
  -- locationid string      :=  ''[1,2,3,4,351]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
-- =============================================================================================================
--Expected Amount Totals Documented Here
--https://github.com/nabancard/pos-api/blob/master/db/migrations/20231120103333_enhance_cash_trackability.sql#L62
-- ============================================================================================================
BEGIN

DROP TABLE IF EXISTS TEMP_SHIFT;

--Temp Table to  FILTER both payments and Cashbank Events with the same Shift 
--  acts as a filter on location, time frame, and employee
  SELECT SHD_cte.SHIFT_DIM_NK                                         AS SHIFT_DIM_NK
    ,SHD_cte.fiscal_day                                               AS FISCAL_DAY
    ,SHD_cte.CLOCKEDIN_AT::timestamp_ntz                              AS CLOCKEDIN_AT
    ,SHD_cte.CLOCKEDOUT_AT::timestamp_ntz                             AS CLOCKEDOUT_AT
    ,SHD_cte.EMPLOYEE_DIM_FK                                          AS EMPLOYEE_DIM_FK
    ,SHD_cte.SHIFT_START_AT                                           AS SHIFT_START_AT
    ,SHD_cte.SHIFT_END_AT                                             AS SHIFT_END_AT
    ,EMD.EMPLOYEE_NAME                                                AS EMPLOYEE_NAME
    ,LOC.LOCATIONNAME                                                 AS LOCATIONNAME
    ,LOC.LOCATION_DIM_NK                                              AS ""Location ID""    
    ,LOC.TZ_NAME                                                      AS ""Time Zone""
    ,CBD.CASHBANK                                                     AS ""Cashbank ID""
    ,cbd.open_amount < cbd.close_amount                               AS IS_OPENHIGHERTHANCLOSE
    ,IFNULL(cbd.open_amount,0.0000) - IFNULL(cbd.close_amount,0.0000) AS OPENDELTA_AMOUNT
    ,IFNULL(cbd.EXPECTED_AMOUNT,0.0000)                               AS EXPECTED_AMOUNT
    ,IFNULL(cbd.open_amount,0.0000)                                   AS OPEN_AMOUNT
    ,IFNULL(cbd.close_amount,0.0000)                                  AS CLOSE_AMOUNT
    ,CBD.CASHBANK_DIM_NK                                              AS CASHBANK_DIM_NK
    ,cbd.status                                                       AS STATUS
    ,SHD_cte.FISCAL_DAY                                               AS ""Fiscal Day"" 
    FROM SHIFT_DIM                                        SHD_cte
      INNER JOIN DATAWAREHOUSE.LOCATION_DIM                   LOC
         ON SHD_cte.LOCATION_DIM_FK = LOC.LOCATION_DIM_NK
            AND LOC.DW_ISCURRENTROW
            AND SHD_cte.DW_ISCURRENTROW
            AND NOT SHD_cte.DW_ISDELETED
            ----------------------------------------------------------------------------------------------
            AND SHD_cte.fiscal_day
                   >= :startdate::date 
            AND  SHD_cte.fiscal_day  
                  <= :enddate::date    
            AND SHD_cte.LOCATION_DIM_FK IN (SELECT table1.value 
                   FROM table(split_to_table(:locationidS, '',''))  table1)
            ----------------------------------------------------------------------------------------------
      INNER JOIN DATAWAREHOUSE.CASHBANK_DIM                   CBD
        ON CBD.SHIFT_DIM_FK = SHD_cte.SHIFT_DIM_NK
          AND CBD.DW_ISCURRENTROW
          AND NOT CBD.DW_ISDELETED
          
      INNER JOIN DATAWAREHOUSE.EMPLOYEE_DIM                   EMD
        ON SHD_cte.EMPLOYEE_DIM_FK = EMD.EMPLOYEE_DIM_NK
          AND EMD.DW_ISCURRENTROW
;

CREATE TEMP TABLE TEMP_SHIFT AS
             SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));       
;


reportSet   := (
SELECT INLT.""Support ID""                            AS ""Support ID""
, ''CSH-'' ||row_number() over (order by INLT.""Support ID"") 
                                                    AS ""Detail ID""   
--status, category, level------------------------------------------------------------------------------
,INLT.""Status""                                      AS ""Status""
--geography--------------------------------------------------------------------------------------------
,INLT.""Location""                                    AS ""Location""
,INLT.""Location ID""                                 as ""Location ID""
--dates------------------------------------------------------------------------------------------------
,INLT.""Time Zone""                                   AS ""Time Zone""
,to_char(LEFT(INLT.""Fiscal Day"",4))                 AS ""Year""
,to_char(YEAR(INLT.""Fiscal Day"")) || ''|'' || TO_CHAR(LEFT(''0'' || MONTH(INLT.""Fiscal Day""),2))                                       
                                                    AS ""Year and Month""
,to_char(INLT.""Fiscal Day"")                         AS ""Fiscal Day""
,IFNULL(INLT.""Daypart"",''None'')                      AS ""Daypart""
-- ,INLT.""Transaction Date""::timestamp_ntz                        ------------------------ 
,to_char(CONVERT_TIMEZONE(''UTC'',INLT.""Time Zone"" ,INLT.""Transaction Date""::timestamp_ntz )::timestamp)        
                                                    AS ""Transacted At""
 ,IFNULL(DAYNAME(INLT.""Fiscal Day""),''None'')         AS""Day of Week""
    ,CASE WHEN DAYNAME(INLT.""Fiscal Day"") IN (''Sat'',''Sun'')  
             THEN TRUE ELSE FALSE END               AS ""Is Weekend""

,to_char(CONVERT_TIMEZONE(''UTC'',INLT.""Time Zone"" ,INLT.""Paid At""::timestamp_ntz )::timestamp )            
-- ,INLT.""Paid At""::timestamp_ntz                                      
                                                    AS ""Paid At""

,to_char(CONVERT_TIMEZONE(''UTC'',INLT.""Time Zone"" ,INLT.""Clocked In At""::timestamp_ntz )::timestamp )                                                    
-- ,INLT.""Clocked In At""::timestamp_ntz                               
                                                    AS ""Clocked In At""

,to_char(CONVERT_TIMEZONE(''UTC'',INLT.""Time Zone"" ,INLT.""Clocked Out At""::timestamp_ntz )::timestamp )                                                    
-- ,INLT.""Clocked Out At""::timestamp_ntz                              
                                                    AS ""Clocked Out At""
--flags------------------------------------------------------------------------------------------------
--people-----------------------------------------------------------------------------------------------
,INLT.""Employee Name""               AS ""Employee""
--Descriptors------------------------------------------------------------------------------------------ 
,INLT.""Cash Drawer ID""              AS ""Cash Drawer ID"" 
,to_char(INLT.""Cashbank ID"")        AS ""Cashbank ID""
,INLT.""Check ID""                    AS ""Check ID""
,INLT.""Check NO""                    AS ""Check NO""
,INLT.""Payment ID""                  AS ""Payment ID""        
,''Shift '' || to_varchar(INLT.""Shift ID"")  
                                    AS ""Shift ID""
,INLT.""Event Type""                  AS ""Event Type""
,INLT.""Notes""                       AS ""Notes""
,INLT.""Payment Method""              AS ""Payment Method""
,INLT.""Payment Type""                AS ""Payment Type""
,INLT.""Terminal""                    AS ""Terminal""
,INLT.""Reason""                      AS ""Reason""
--Facts------------------------------------------------------------------------------------------------
 ,1::NUMBER(18,0)                                 AS ""Count""
 ,INLT.""Adjusted Cash Open Amount""::NUMBER(18,2)  AS ""Adjusted Cash Open Amount""--The opening amount of cash  
 ,INLT.""Cash Close Amount""::NUMBER(18,2)          AS ""Cash Close Amount""--The closing amount of cash
 ,INLT.""Cash Open Amount""::NUMBER(18,2)           AS ""Cash Open Amount""--The opening amount of cash
 ,INLT.""Cash ReOpen Amount""::NUMBER(18,2)         AS ""Cash ReOpen Amount""
 ,INLT.""Deposit""::NUMBER(18,2)                    AS ""Deposit""--The opening amount of cash
 ,INLT.""Withdrawl""::NUMBER(18,2)                  AS ""Withdrawl""--The opening amount of cash   
 ,INLT.open_amount::NUMBER(18,2)                  AS ""Open Amount""
 ,INLT.close_amount::NUMBER(18,2)                 AS ""Close Amount""
 ,INLT.""Cash Due""::NUMBER(18,2)                   AS ""Cash Due""
 ,INLT.""Expected Amount""::NUMBER(18,2)            AS ""Expected Amount""
 ,INLT.""Cash Change Amount""::NUMBER(18,2)         AS ""Cash Change Amount""    
 ,INLT.""Cash Tendered Amount""::NUMBER(18,2)       AS ""Cash Tendered Amount"" 
 ,INLT.""Cash Payment Amount""::NUMBER(18,2)        AS ""Cash Payment Amount"" 
-- ,0.0000  AS ""Non Cash Payments""---This could be gift certificate or some other  per davis put on hold
-- ,0.0000  AS ""All Payments""--sum cash PLUS non cash  --Possibly removed from requirements?
 ,INLT.""Cash Tip Amount""::NUMBER(18,2)            AS ""Cash Tip Amount"" 
 ,INLT.""Pay In Amount""::NUMBER(18,2)              AS ""Pay In Amount""
 ,INLT.""Pay Out Amount""::NUMBER(18,2)             AS ""Pay Out Amount""
-------------------------------------------------------------------------------------------------------
  FROM (
        SELECT ''CBE:'' || TO_CHAR(CHF.CASHBANKEVENT_FACT_PK) AS ""Support ID""    --unique id not for displayeing id
        ,shd.""Cashbank ID""                        AS ""Cashbank ID""
        ,shd.EMPLOYEE_NAME                        AS ""Employee Name""
        ,shd.""Fiscal Day""                         AS ""Fiscal Day""
        ,chf.EVENT_TYPE                           AS ""Event Type""
        ,shd.SHIFT_DIM_NK                         AS ""Shift ID""
        ,''None''                                   AS ""Check ID""
        ,''None''                                   AS ""Check NO""
        ,shd.STATUS                               AS ""Status""
        ,''None''                                   AS ""Payment Method""
        ,''None''                                   AS ""Payment Type""
        ,''None''                                   AS ""Terminal""
        ,IFNULL(chf.notes,''None'')                 AS ""Notes""
        ,''None''                                   AS ""Reason""
        ,''None''                                   AS ""Payment ID""

        ,shd.""Time Zone""                          AS ""Time Zone""  
        ,CASE chf.EVENT_TYPE 
          WHEN ''BankOpened'' THEN shd.CLOCKEDIN_AT
          WHEN ''BankClosed'' THEN shd.CLOCKEDOUT_AT
          ELSE chf.dw_startdate END
                                                  AS ""Transaction Date""
        ,''None''                                   AS ""Daypart""
        ,''None''                                   AS ""Cash Drawer ID"" --OPTIONAL
        ,shd.LOCATIONNAME                         AS ""Location""
        ,shd.""Location ID""                        AS ""Location ID""
        ,chf.CREATED_AT                           AS ""Paid At""
        ,shd.CLOCKEDIN_AT                         AS ""Clocked In At""
        ,shd.CLOCKEDOUT_AT                        AS ""Clocked Out At""
        --===================================================================================
        ,CASE WHEN chf.EVENT_TYPE = ''AdjustedOpenAmount'' 
          THEN IFNULL(chf.AMOUNT,0.0000) 
          ELSE 0.0000 END                         AS ""Adjusted Cash Open Amount""--The opening amount of cash  
        ,CASE WHEN chf.EVENT_TYPE = ''BankClosed'' 
          THEN IFNULL(chf.AMOUNT,0.0000)
          ELSE 0.0000 END                         AS ""Cash Close Amount""--The closing amount of cash
        ,CASE WHEN chf.EVENT_TYPE = ''BankOpened'' 
          THEN IFNULL(chf.AMOUNT ,0.0000)
          ELSE 0.0000 END 
                                                  AS ""Cash Open Amount""--The opening amount of cash
        ,CASE WHEN chf.EVENT_TYPE = ''BankReopened''
          THEN IFNULL(chf.AMOUNT ,0.0000)
          ELSE 0.0000 END 
                                                  AS ""Cash ReOpen Amount""
        ,CASE WHEN chf.EVENT_TYPE = ''Deposit'' 
          THEN IFNULL(chf.AMOUNT ,0.0000)
          ELSE 0.0000 END                         AS ""Deposit""--The opening amount of cash
        ,CASE WHEN chf.EVENT_TYPE = ''Withdrawal'' 
          THEN IFNULL(chf.AMOUNT,0.0000) 
          ELSE 0.0000 END                         AS ""Withdrawl""--The opening amount of cash
        
          ,shd.open_amount, shd.close_amount
        ,CASE WHEN chf.EVENT_TYPE = ''BankClosed'' AND shd.IS_OPENHIGHERTHANCLOSE   
          THEN IFNULL(shd.OPENDELTA_AMOUNT,0.0000)
         ELSE 0.00 END                            AS ""Cash Due""--If the opening amount is less than closing amou            --NOTE:  1ST half of union is the open and close amounts so all 
         --=================
         --EXPECTED_AMOUNT
         ,CASE WHEN chf.EVENT_TYPE = ''BankOpened''    
          THEN IFNULL(shd.EXPECTED_AMOUNT,0.0000)
          ELSE 0.0000 END                         AS ""Expected Amount""
        --===================================================================================
        ,0.0000                                   AS ""Cash Change Amount""    
        ,0.0000                                   AS ""Cash Tendered Amount"" 
        ,0.0000                                   AS ""Cash Payment Amount""  --Total Payments in Cash Received
        -- ,0.0000  AS ""Non Cash Payments""---This could be gift certificate or some other  per davis put on hold
        -- ,0.0000  AS ""All Payments""--sum cash PLUS non cash  --Possibly removed from requirements?
        ,0.0000                                   AS ""Cash Tip Amount"" 
        ,0.0000                                   AS ""Pay In Amount""
        ,0.0000                                   AS ""Pay Out Amount""
         -----------------------------------------------------------------------------------------  
        FROM TEMP_SHIFT                                        SHD
            INNER JOIN DATAWAREHOUSE.CASHBANKEVENT_FACT            CHF
              ON SHD.CASHBANK_DIM_NK = CHF.CASHBANK_DIM_FK
                  AND CHF.DW_ISCURRENTROW
                  AND NOT CHF.DW_ISDELETED
                  --AND CBD.STATUS <> ''Open''
--         -----------------------------------------------------------------------------------------
         UNION ALL
--         -- -----------------------------------------------------------------------------------------
        SELECT ''PAY:'' || TO_CHAR(pay.PAYMENTS_FACT_PK)               AS ""Support ID""    --unique id 
        ,SHD.""Cashbank ID""                        AS ""Cashbank ID""
        ,shd.EMPLOYEE_NAME                        AS ""Employee Name""
        ,shd.""Fiscal Day""                         AS ""Fiscal Day""
        ,''Cash Payment''                           AS ""Event Type""
        ,shd.SHIFT_DIM_NK                         AS ""Shift ID""
        ,to_char(pay.cheque_fact_fk)              AS ""Check ID""
        ,to_char(pay.CHEQUENUMBER)                AS ""Check""
        ,shd.STATUS                               AS ""Status""
        ,pmd.PAYMENTMETHODNAME                    AS ""Payment Method""
        ,pmd.PAYMENTMETHODTYPE                    AS ""Payment Type""
        ,TED.TERMINALNAME                         AS ""Terminal""
        ,''None''                                   AS ""Notes""
        ,''None''                                   AS ""Reason""
        ,TO_CHAR(pay.PAYMENTS_FACT_NK)            AS ""Payment ID""
        ,shd.""Time Zone""                          AS ""Time Zone""          
        ,pay.PAID_AT::timestamp_ntz 
                                                  AS ""Transaction Date""
        ,dpd.DAYPART                              AS ""Daypart""
        ,null                                     AS ""Cash Drawer ID"" --OPTIONAL
        ,shd.LOCATIONNAME                         AS ""Location""
        ,shd.""Location ID""                        AS ""Location ID""
        ,pay.PAID_AT::timestamp_ntz                              
                                                  AS ""Paid At""
        ,shd.CLOCKEDIN_AT                         AS ""Clocked In At""
        ,shd.CLOCKEDOUT_AT                        AS ""Clocked Out At""
        --===================================================================================
        ,0.0000                                   AS ""Adjusted Cash Open Amount""
        ,0.0000   
        AS ""Cash Close Amount""--The closing amount of cash
        ,0.0000                                   AS ""Cash Open Amount""--The opening amount of cash
        ,0.0000                                   AS ""Cash ReOpen Amount""
        ,0.0000                                   AS ""Deposit""--The opening amount of cash
        ,0.0000                                   AS ""Withdrawl""--The opening amount of cash
        
        ,shd.open_amount
        , shd.close_amount
        ,0.0000                                   AS ""Cash Due""
        ,0.0000                                   AS ""Expected Amount""
        --===================================================================================
        ,IFNULL(CPL.AMOUNT_CHANGED,0.0000)         AS ""Cash Change Amount""    
        ,IFNULL(CPL.AMOUNT_TENDERED,0.0000)       AS ""Cash Tendered Amount""     
        ,IFNULL(PAY.TOTAL,0.0000)                 AS ""Cash Payment Amount""  --Total Payments in Cash Received
        -- ,NULL AS ""Non Cash Payments""---This could be gift certificate or some other per davis put on hold
        -- ,NULL AS ""All Payments""--sum cash PLUS non cash
        ,IFNULL(PAY.TIP,0.0000)                    AS ""Cash Tip Amount"" 
        ,0.0000                                    AS ""Pay In Amount""
        ,0.0000                                    AS ""Pay Out Amount""
         ----------------------------------------------------------------------------------------- 
           FROM TEMP_SHIFT                                       SHD
            INNER JOIN  CHECKCASHPAYMENTLEDGER_FACT              CPL
              ON SHD.SHIFT_DIM_NK = CPL.SHIFT_DIM_FK
                AND CPL.DW_ISCURRENTROW
                AND NOT CPL.DW_ISDELETED
                AND NOT CPL.IS_VOID
            INNER JOIN DATAWAREHOUSE.PAYMENTS_FACT                   PAY    --465
              ON PAY.PAYMENTS_FACT_NK = CPL.PAYMENTS_FACT_FK
                -- AND pay.PAYMENTSTATUS = ''Success''    --No need to check payment method for cash as all ledger rows are cash
                AND pay.DW_ISCURRENTROW
                AND NOT pay.IS_TRAINING
            INNER JOIN DATAWAREHOUSE.PAYMENTMETHOD_DIM                PMD
               ON PMD.PAYMENTMETHOD_DIM_NK = PAY.PAYMENTMETHOD_DIM_FK
                AND PAY.DW_ISCURRENTROW
            INNER JOIN DATAWAREHOUSE.DAYPART_DIM                       DPD
               ON dpd.DAYPART_DIM_NK = pay.DAYPART_DIM_FK
                 AND dpd.dw_iscurrentrow
            LEFT JOIN DATAWAREHOUSE.TERMINAL_DIM                       TED
                ON TED.TERMINAL_DIM_NK = PAY.TERMINAL_DIM_FK
                  AND TED.DW_ISCURRENTROW
        -- -----------------------------------------------------------------------------------------
        UNION ALL
        -- -----------------------------------------------------------------------------------------
        SELECT ''PIO:'' || TO_CHAR(PIO.PAYINOUT_FACT_PK)      AS ""Support ID""   
        ,shd.""Cashbank ID""                        AS ""Cashbank ID""
        ,shd.EMPLOYEE_NAME                        AS ""Employee Name""
        ,shd.""Fiscal Day""                         AS ""Fiscal Day""
        ,CASE WHEN PAR.IS_PAY_IN THEN ''Pay In''
          ELSE ''Pay Out'' END                      AS ""Event Type""
        ,shd.SHIFT_DIM_NK                         AS ""Shift ID""
        ,''None''                                   AS ""Check ID""
        ,''None''                                   AS ""Check NO""
        ,PIO.STATUS                               AS ""Status""
        ,pmd.PAYMENTMETHODNAME                    AS ""Payment Method""
        ,pmd.PAYMENTMETHODTYPE                    AS ""Payment Type""
        ,''None''                                   AS ""Terminal""
        ,IFNULL(pio.NOTES,''None'')                 AS ""Notes""
        ,IFNULL(par.PAYINPAYOUTREASON,''None'')     AS ""Reason"" 
        ,''None''                                   AS ""Payment ID""
         ,shd.""Time Zone""                         AS ""Time Zone""          
        ,pio.dw_startdate                         AS ""Transaction Date""
        ,''None''                                   AS ""Daypart""
        ,''None''                                   AS ""Cash Drawer ID"" 
        ,shd.LOCATIONNAME                         AS ""Location""
        ,shd.""Location ID""                        AS ""Location ID""
        ,pio.CREATED_AT::timestamp_ntz                           
                                                  AS ""Paid At""
        ,shd.CLOCKEDIN_AT                         AS ""Clocked In At""
        ,shd.CLOCKEDOUT_AT                        AS ""Clocked Out At""
        --===================================================================================
        ,0.0000                                   AS ""Adjusted Cash Open Amount""
        ,0.0000                                   AS ""Cash Close Amount""
        ,0.0000                                   AS ""Cash Open Amount""
        ,0.0000                                   AS ""Cash ReOpen Amount""
        ,0.0000                                   AS ""Deposit""
        ,0.0000                                   AS ""Withdrawl""
        ,NULL, NULL
        ,0.0000                                   AS ""Cash Due""--If the opening amount is less than closing amou  
        ,0.0000                                   AS ""Expected Amount""
        --===================================================================================
        ,0.0000                                   AS ""Cash Change Amount""    
        ,0.0000                                   AS ""Cash Tendered Amount"" 
        ,0.0000                                   AS ""Cash Payment Amount""
        ,0.0000                                   AS ""Cash Tip Amount""
        ,CASE WHEN PAR.IS_PAY_IN THEN PIO.AMOUNT 
          ELSE 0.0000 END                         AS ""Pay In Amount""  --Total Payments in Cash Received
        ,CASE WHEN NOT PAR.IS_PAY_IN THEN PIO.AMOUNT 
          ELSE 0.0000 END                         AS ""Pay Out Amount"" 
         -----------------------------------------------------------------------------------------  
        FROM TEMP_SHIFT                                        SHD
            INNER JOIN DATAWAREHOUSE.PAYINOUT_FACT                 PIO
              ON SHD.SHIFT_DIM_NK = PIO.SHIFT_DIM_FK
                  AND PIO.DW_ISCURRENTROW
                  AND NOT PIO.DW_ISDELETED
                  AND NOT PIO.IS_VOID
                  AND PIO.STATUS = ''Success''
            INNER JOIN DATAWAREHOUSE.PAYMENTMETHOD_DIM             PMD
              ON PMD.PAYMENTMETHOD_DIM_NK = PIO.PAYMENTMETHOD_DIM_FK
                  AND PMD.DW_ISCURRENTROW
                  AND PMD.PAYMENTMETHODTYPE = ''Cash''
                  -- AND PMD.PAYMENTMETHODNAME <> ''Error''
            INNER JOIN DATAWAREHOUSE.PAYINPAYOUTREASON_DIM         PAR
              ON PAR.PAYINPAYOUTREASON_DIM_NK = PIO.PAYINPAYOUTREASON_DIM_FK
                  AND PAR.DW_ISCURRENTROW
                  
           ) INLT
-- =================================================================================================================
); 
 RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAWAREHOUSE_HOLD,CREATE_DW_LOAD(VARCHAR),"CREATE OR REPLACE PROCEDURE ""CREATE_DW_LOAD""(""TABLE_NAME_INPUT"" VARCHAR(16777216))
RETURNS TABLE (""SQLTEXT"" VARCHAR(16777216))
LANGUAGE SQL
EXECUTE AS OWNER
AS '
declare select_statement varchar;
        col_list    resultset;
        --select_list resultset;
        res         resultset;
        sqlText2    varchar := '')'';
        sqlTextA    varchar := ''select '';
        --table_name_input varchar := ''ADDRESS_DIM'';
        table_name  varchar := table_name_input; 
        sqlText1    varchar := ''insert into DEV_HOSPENG_REPORTING.DATAWAREHOUSE.'' 
                    || :table_name ||'' (''; 
        sqlTextB    varchar := '' from DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.'' || :table_name || '';''; 
        all_sqltext varchar;
-----------------------------------------------------------------------------------------
begin
  drop table if exists DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_cols; 
  drop table if exists DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_sql;
  
  create temp table DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_sql (
    ordinal int
    ,sqlText varchar
  );

------------------------------------------------------------------------------------
  create temp table DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_cols as
      select c.column_name 
              || case when c.ordinal_position = max(ordinal_position) over (partition by 1)
                     then '' ''
                   else '', ''
                   end as column_name
              ,c.ordinal_position
              ,min(c.ordinal_position) over(partition by 1) as minOrdinal
              ,max(c.ordinal_position) over(partition by 1) as maxOrdinal
      from information_schema.tables t
         inner join information_schema.columns c
            on t.table_schema      = c.table_schema
                and t.table_name   = c.table_name
                and t.table_type   = ''BASE TABLE''
                and t.table_schema = ''DATAWAREHOUSE''
                and t.table_name   = :table_name
                and c.column_name Not like ''DW_%''
            order by c.ordinal_position;
            
-----------------------------------------------------------------------------------------           
  insert into DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_sql (ordinal,sqlText)
     select  1 as ordinal
       ,:sqlText1 || listagg(column_name) within group (order by ordinal_position) 
         || :sqlText2 as sqlText
        from DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_cols;

------------------------------------------------------------------------------------
col_list := (
  SELECT LISTAGG(sqlText) WITHIN GROUP (ORDER BY inlt1.ORDINAL)
    FROM (
      SELECT sqlText || '' \\n '' as sqlText, 1 AS ORDINAL 
      FROM DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_sql   
        UNION
      SELECT LISTAGG(case when ordinal_position = minordinal 
         then :sqlTextA
         else '' '' 
         end
        || replace(column_name,'','') 
        || case when column_name like ''%_FK%'' then '' || ''''.'''' ||  DW_BATCHID '' else '' '' end
        || '' as '' 
        || case when ordinal_position = maxordinal 
             then replace(column_name,'','') || :sqlTextB
            else column_name
            end  || '' \\n'') WITHIN GROUP (ORDER BY ordinal_position) 
        as output_text
      , 2 AS ORDINAL 
        --,ordinal_position + 100 as ordinal
      from DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_cols 
    ) inlt1
);

res := (
     select ''skssksk sksk'' as output_text
   );
   
  
--======================================================================================         
return table(col_list);

end;
';"
PROCEDURE,DATAWAREHOUSE_HOLD,"SP_REPORT_LABOR(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_LABOR""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS '
-- --=============================================================================================
-- CALL DATAWAREHOUSE.SP_REPORTDATAGROOM(''SP_REPORT_LABOR'',365,351);
-- CALL DATAWAREHOUSE.SP_REPORT_LABOR(''2000-11-20T14:48:37.661Z'',''2026-11-20T14:48:37.661Z'',''[2,3,4]'');
-- GRANT usage ON procedure DATAWAREHOUSE.SP_REPORT_LABOR(timestamp_tz,timestamp_tz,string) TO ROLE DATA_REPLICATION_HOSPENG;
--=============================================================================================
DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2024-08-23T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2024-08-23T14:48:37.661Z''; 
  -- locationid string      := ''[2]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
-- =============================================================================================
BEGIN
  DROP TABLE IF EXISTS TEMP_LABOR;
  DROP TABLE IF EXISTS TEMP_TIPGRAT;

  WITH SHIFT_CTE AS (
    SELECT SHD.SHIFT_DIM_PK --|| overtime_fact_nk || fiscal day and week or date                                 
                                                               AS ""Support ID"" 
        ,SHD.SHIFT_DIM_NK                                      AS ""SHIFT_DIM_NK""
    --status, category, level------------------------------------------------------------------
        ,''Shift''                                               AS ""Level""
    --geography--------------------------------------------------------------------------------
        ,IFNULL(loc.LOCATIONNAME,''None'')                       AS ""Location""
        ,IFNULL(org.organization,''None'')                       AS ""Organization""
    --dates-------------------------------------------------------------------------------------
        ,LOC.TZ_NAME                                            AS ""Time Zone""
        ,TO_CHAR(DATE_PART(YEAR,SHD.CLOCKEDIN_AT::timestamp_ntz ))   
                                                               AS ""Year""
        ,to_char(LEFT(SHD.CLOCKEDIN_AT::timestamp_ntz,7))                     
                                                               AS ""Year and Month""
        ,SHD.CLOCKEDIN_AT::timestamp_ntz                             
                                                               AS ""Clocked In At""
        ,SHD.CLOCKEDOUT_AT::timestamp_ntz                                    
                                                               AS ""Clocked Out At""    
        ,IFNULL(DAYNAME(SHD.CLOCKEDIN_AT::timestamp_ntz),''None'')              
                                                               AS ""Day of Week""
        ,CASE WHEN DAYNAME(SHD.CLOCKEDIN_AT::timestamp_ntz) IN (''Sat'',''Sun'')  
            THEN TRUE ELSE FALSE END                           
                                                               AS ""Is Weekend""
        ,ORG.START_OF_PAYROLL_WEEK_INT                         AS ""Week Offset""
                ,YEAR(TIMESTAMPADD(DAY,ORG.START_OF_PAYROLL_WEEK_INT,SHD.FISCAL_DAY::timestamp_ntz)) || ''-'' ||
         WEEKOFYEAR(TIMESTAMPADD(DAY,ORG.START_OF_PAYROLL_WEEK_INT,SHD.FISCAL_DAY::timestamp_ntz))                                                 
                                                               AS ""Fiscal Week""                                                
        ,SHD.FISCAL_DAY                                        AS ""Fiscal Day""  
    --flags--------------------------------------------------------------------------------------
        ,SHD.IS_SHIFTCOMPLETE                                  AS ""Is Clocked Out""
        ,SHD.WAS_SYSTEM_CLOCKOUT                               AS ""Was System Clock Out""
        ,SHD.GETS_PAID_BREAK                                   AS ""Gets Paid Break""
    --people------------------------------------------------------------------------------------- 
        ,EMD.EMPLOYEE_NAME                                     AS ""Employee""
        ,EMD.EMPLOYEE_DIM_NK                                   AS ""Employee ID""
        ,SHD.JOBPOSITION_DIM_FK                                AS ""JOBPOSITION_DIM_FK""
        ,SHD.LOCATION_DIM_FK                                   AS ""LOCATION_DIM_FK""        
     --Descriptors-------------------------------------------------------------------------------- 
       ,JBP.JOB_POSITION                                       AS ""Job Position""  --(i.e. Bartender, Cook, Server)    
       ,SHD.SHIFT                                              AS ""Shift ID""  
       ,SHD.PAY_RATE_BASIS                                     AS ""Pay Basis""
     --Facts-----------------------------------------------------------------------------------------
        ,NULL                                                  AS ""Overtime Rule""
        ,NULL                                                  AS ""Hours Per Day""
        ,NULL                                                  AS ""Seconds Per Day""
        ,NULL                                                  AS ""Hours Per Week""
        ,NULL                                                  AS ""Seconds Per Week""
        ,to_number(1)                                          AS ""Shift Count""
        ,NULL                                                  AS ""Break Count""  
        ,COUNT(SHD.SHIFT) OVER (PARTITION BY SHD.LOCATION_DIM_FK,EMD.EMPLOYEE_DIM_NK,SHD.FISCAL_DAY)  
                                                               AS ""Shift Per Day Count""
        -- ,IFF( SHD.IS_SHIFTCOMPLETE,SHD.SHIFT_SECONDS, 
        --   ROUND(TIMEDIFF(second
        --        ,CONVERT_TIMEZONE(''UTC'',loc.TZ_NAME,shd.CLOCKEDIN_AT::timestamp_ntz )::timestamp
        --     -- ,SHD.CLOCKEDIN_AT::timestamp_ntz 
        --        ,CONVERT_TIMEZONE(''UTC'',loc.TZ_NAME,CURRENT_TIMESTAMP::timestamp_ntz )::timestamp
        --     -- ,CURRENT_TIMESTAMP::timestamp_ntz 
        --       )::Number(38,0),0))
        --                                                        AS ""Shift Seconds""


        ,IFF( SHD.IS_SHIFTCOMPLETE,SHD.SHIFT_SECONDS, 
          ROUND(TIMEDIFF(second
               ,SHD.CLOCKEDIN_AT::timestamp_ntz 
               ,CONVERT_TIMEZONE(''UTC'', CURRENT_TIMESTAMP())::timestamp_ntz
              )::Number(38,0),0))
                                                               AS ""Shift Seconds""

                                                               
        ,NULL                                                  AS ""Break Seconds""


        ,shd.REGULAR_RATE * 1.5::Number(18,2)             
                                                               AS ""Overtime Rate""
        ,shd.REGULAR_RATE::Number(18,2)                        AS ""Regular Rate""
 
        FROM DATAWAREHOUSE.SHIFT_DIM                               SHD
          INNER JOIN DATAWAREHOUSE.LOCATION_DIM                    LOC
             ON SHD.LOCATION_DIM_FK = LOC.LOCATION_DIM_NK
                AND LOC.DW_ISCURRENTROW
                AND SHD.DW_ISCURRENTROW
             
                AND NOT SHD.DW_ISDELETED
                AND NOT SHD.IS_ARCHIVED
                AND shd.fiscal_day::date
                   >= dateadd(DAY,-10,:startdate)::date --calculate data 10 days around selected dates so that  
                AND  shd.fiscal_day::date  
                  <= dateadd(DAY,10,:enddate)::date    --the data in the selected range calcs overtime for full fiscal week
                AND SHD.LOCATION_DIM_FK IN ( SELECT table1.value 
                           FROM table(split_to_table(:locationidS, '',''))  table1)
          INNER JOIN DATAWAREHOUSE.ORGANIZATION_DIM                ORG
            ON LOC.ORGANIZATION_DIM_FK = ORG.ORGANIZATION_DIM_NK
              AND ORG.DW_ISCURRENTROW
          INNER JOIN DATAWAREHOUSE.EMPLOYEE_DIM                    EMD
            ON SHD.EMPLOYEE_DIM_FK = EMD.EMPLOYEE_DIM_NK
              AND EMD.DW_ISCURRENTROW
          INNER JOIN DATAWAREHOUSE.JOBPOSITION_DIM                 JBP
            ON JBP.JOBPOSITION_DIM_NK = SHD.JOBPOSITION_DIM_FK 
              AND JBP.DW_ISCURRENTROW
          -- INNER JOIN DATAWAREHOUSE.EMPLOYMENTPERIOD_DIM          EPD
          --   ON EPD.JOBPOSITION_DIM_FK = SHD.JOBPOSITION_DIM_FK
          --     AND EPD.LOCATION_DIM_FK = SHD.LOCATION_DIM_FK
          --     AND EPD.EMPLOYEE_DIM_FK = SHD.EMPLOYEE_DIM_FK
          --     AND EPD.DW_ISCURRENTROW
         ORDER BY SHD.CLOCKEDIN_AT DESC          )
    ,BREAK_CTE AS (
        SELECT SHD_1.""Support ID""                               AS ""Support ID"" 
        ,MAX(SHD_1.SHIFT_DIM_NK)                                AS ""SHIFT_DIM_NK""
    --status, category, level------------------------------------------------------------------
        ,''Break''                                                AS ""Level""
    --geography--------------------------------------------------------------------------------
        ,NULL                                                   AS ""Location""
        ,NULL                                                   AS ""Organization""
    -- --dates-------------------------------------------------------------------------------------
        ,MAX(SHD_1.""Time Zone"")                                 AS ""Time Zone""
        ,NULL                                                   AS ""Year""
        ,NULL                                                   AS ""Year and Month""
        ,NULL                                                   AS ""Clocked In At""
        ,NULL                                                   AS ""Clocked Out At""    
        ,NULL                                                   AS ""Day of Week""
        ,NULL                                                   AS ""Is Weekend""
        ,NULL                                                   AS ""Week Offset""
        ,MAX(SHD_1.""Fiscal Week"")                               AS ""Fiscal Week""                      
        ,NULL                                                   AS ""Fiscal Day""  
    -- --flags--------------------------------------------------------------------------------------
        ,NULL                                                   AS ""Is Clocked Out""
        ,NULL                                                   AS ""Was System Clock Out""
        ,NULL                                                   AS ""Gets Paid Break""
    -- --people------------------------------------------------------------------------------------- 
        ,NULL                                                   AS ""Employee""
        ,NULL                                                   AS ""Employee ID""
        ,NULL                                                   AS JOBPOSITION_DIM_FK
        ,NULL                                                   AS LOCATION_DIM_FK       
    --  --Descriptors-------------------------------------------------------------------------------- 
       ,NULL                                                    AS ""Job Position""  --(i.e. Bartender, Cook, Server)  
       ,NULL                                                    AS ""Pay Basis""
       ,NULL                                                    AS ""Shift ID""  
    -- Facts-----------------------------------------------------------------------------------------
        ,NULL                                                   AS ""Overtime Rule""
        ,NULL                                                   AS ""Hours Per Day""
        ,NULL                                                   AS ""Seconds Per Day""
        ,NULL                                                   AS ""Hours Per Week""
        ,NULL                                                   AS ""Seconds Per Week""
        ,NULL                                                   AS ""Shift Count""
        ,1                                                      AS ""Break Count""   
        ,NULL                                                   AS ""Shift Per Day Count""
        ,0                                                      AS ""Shift Seconds""
        ,SUM(IFF( BRK_1.IS_BREAKCOMPLETE ,BRK_1.BREAK_SECONDS , 
          ROUND(TIMEDIFF(SECOND
            ,BRK_1.START_AT::timestamp_ntz 
            ,CURRENT_TIMESTAMP::timestamp_ntz 
                )::Number(38,0),0)) )                                                  
                                                                AS ""Break Seconds""
     
        ,NULL                                                   AS ""Overtime Rate""
        ,NULL                                                   AS ""Regular Rate""
          FROM SHIFT_CTE                                        SHD_1
            INNER JOIN DATAWAREHOUSE.SHIFTBREAK_FACT                BRK_1
              ON SHD_1.SHIFT_DIM_NK = BRK_1.SHIFT_DIM_FK
                 AND BRK_1.DW_ISCURRENTROW
                 AND NOT BRK_1.DW_ISDELETED
            GROUP BY SHD_1.""Support ID""  
    )
    ,RULE_CTE AS (  ---NOTE:  THIS JOIN SHOULD NOT BE CURRENT ROW...IT SHOULD BE ROW WHERE TIME = SHIFT START
         SELECT SHD_2.""Support ID""                              AS ""Support ID"" 
        ,SHD_2.SHIFT_DIM_NK                                     AS ""SHIFT_DIM_NK""
    --status, category, level------------------------------------------------------------------
        ,''Rule''                                                 AS ""Level""
    --geography--------------------------------------------------------------------------------
        ,NULL                                                   AS ""Location""
        ,NULL                                                   AS ""Organization""
    -- --dates-------------------------------------------------------------------------------------
        ,NULL                                                   AS ""Time Zone""    
        ,NULL                                                   AS ""Year""
        ,NULL                                                   AS ""Year and Month""
        ,NULL                                                   AS ""Clocked In At""
        ,NULL                                                   AS ""Clocked Out At""    
        ,NULL                                                   AS ""Day of Week""
        ,NULL                                                   AS ""Is Weekend""
        ,NULL                                                   AS ""Week Offset""
        ,SHD_2.""Fiscal Week""                                    AS ""Fiscal Week""                      
        ,NULL                                                   AS ""Fiscal Day""    
    -- --flags--------------------------------------------------------------------------------------
        ,NULL                                                   AS ""Is Clocked Out""
        ,NULL                                                   AS ""Was System Clock Out""
        ,NULL                                                   AS ""Gets Paid Break""
    -- --people------------------------------------------------------------------------------------- 
        ,NULL                                                   AS ""Employee""
        ,NULL                                                   AS ""Employee ID""        
        ,NULL                                                   AS JOBPOSITION_DIM_FK
        ,NULL                                                   AS LOCATION_DIM_FK       
    --  --Descriptors-------------------------------------------------------------------------------- 
       ,NULL                                                    AS ""Job Position""  --(i.e. Bartender, Cook, Server) 
       ,NULL                                                    AS ""Pay Basis""
       ,NULL                                                    AS ""Shift ID""  
    -- Facts-----------------------------------------------------------------------------------------
        ,OLT.OVERTIMERULE                                       AS ""Overtime Rule""
        ,CASE WHEN OLT.HOURS_PER_DAY = 0 or :locationidS in (''[3]'',''[4]'',''[5]'')
            THEN 99999 ELSE  OLT.HOURS_PER_DAY END                                      
                                                                AS ""Hours Per Day""
        ,CASE WHEN OLT.HOURS_PER_DAY = 0 or :locationidS in (''[3]'',''[4]'',''[5]'')
            THEN 99999 ELSE  OLT.HOURS_PER_DAY END * 60 * 60                                 
                                                                AS ""Seconds Per Day""
                                                                
        ,CASE WHEN OLT.HOURS_PER_DAY = 0 or :locationidS in (''[3]'',''[4]'',''[5]'')
           THEN 99999 ELSE OLT.HOURS_PER_WEEK  END                                   
                                                                AS ""Hours Per Week""
        ,CASE WHEN OLT.HOURS_PER_DAY = 0 or :locationidS in (''[3]'',''[4]'',''[5]'') 
          THEN 99999 ELSE OLT.HOURS_PER_WEEK * 60 *60 END                         
                                                                AS ""Seconds Per Week""
        
        ,NULL                                                   AS ""Shift Count""
        ,0                                                      AS ""Break Count""   
        ,NULL                                                   AS ""Shift Per Day Count""
        ,0                                                      AS ""Shift Seconds""
        ,NULL                                                   AS ""Break Seconds""
     
        ,NULL                                                   AS ""Overtime Rate""
        ,NULL                                                   AS ""Regular Rate""
          FROM SHIFT_CTE                                        SHD_2
            INNER JOIN OVERTIMELABORRULE_JOBPOSITION_XREF       OJX
           ON OJX.JOBPOSITION_DIM_FK = SHD_2.JOBPOSITION_DIM_FK
             AND OJX.DW_ISCURRENTROW
         INNER JOIN DATAWAREHOUSE.OVERTIMELABORRULE_DIM             OLT
            ON SHD_2.LOCATION_DIM_FK = OLT.LOCATION_DIM_FK
              AND OLT.OVERTIMELABORRULE_DIM_PK = OJX.OVERTIMELABORRULE_DIM_FK
              AND OLT.DW_ISCURRENTROW  
              AND NOT OLT.DW_ISDELETED
              AND OLT.IS_ACTIVE
    )  --end of cte tables
    --=========================================================================================
    SELECT to_char(UNI_2.""Support ID"")           as ""Support ID""
    , ''LAB-'' ||row_number() over (order by UNI_2.""Shift ID"") 
                                                 as ""Detail ID""  
    ,UNI_2.""Location""
    ,UNI_2.""Time Zone""
    ,UNI_2.""Year""
    ,UNI_2.""Year and Month""
    ,CONVERT_TIMEZONE(''UTC'',UNI_2.""Time Zone"",UNI_2.""Clocked In At""::timestamp_ntz )::timestamp 
    --,UNI_2.""Clocked In At""
                                                     as ""Clocked In At""
    ,CONVERT_TIMEZONE(''UTC'',UNI_2.""Time Zone"",UNI_2.""Clocked Out At""::timestamp_ntz )::timestamp                                                      
    --,UNI_2.""Clocked Out At""
                                                     as ""Clocked Out At""

---------------------------------
    ,to_varchar(CONVERT_TIMEZONE(''UTC'',UNI_2.""Time Zone"",UNI_2.""Clocked In At""::timestamp_ntz )::timestamp,''HH12:MI:SS'')
                                                      as ""Clock In Time""
    ,to_varchar(CONVERT_TIMEZONE(''UTC'',UNI_2.""Time Zone"",UNI_2.""Clocked Out At""::timestamp_ntz )::timestamp,''HH12:MI:SS'')
                                                      as ""Clock Out Time""                                                      
---------------------------------
    ,UNI_2.""Day of Week""
    ,UNI_2.""Is Weekend""
    ,UNI_2.""Fiscal Week""
    ,to_char(UNI_2.""Fiscal Day"")                      as ""Fiscal Day""
    ,UNI_2.""Is Clocked Out""
    ,UNI_2.""Was System Clock Out""
    ,UNI_2.""Employee""
    -- ,TO_VARCHAR(UNI_2.""Employee ID"")               as ""Employee ID""
    ,UNI_2.""Job Position""
    ,UNI_2.""Pay Basis""
    ,''Shift '' ||UNI_2.""Shift ID""                      as ""Shift ID""
    ,UNI_2.""Overtime Rule""
    ,UNI_2.""Overtime Rate""::NUMBER(18,2)              as ""Overtime Rate""
    ,UNI_2.""Regular Rate"" ::NUMBER(18,2)              as ""Regular Rate""
    --=======================================================================  
    ,UNI_2.""Shift Seconds""::NUMBER(18,0)              as ""Shift Seconds""
    ,UNI_2.""Break Seconds""::NUMBER(18,0)              as ""Break Seconds""
    ,UNI_2.""Seconds Per Week""::NUMBER(18,0)           as ""Weekly Overtime Rule Seconds""
    ,UNI_2.""Seconds Per Day"" ::NUMBER(18,0)           as ""Daily Overtime Rule Seconds""
--===================== ====================================================================================
   -- ,UNI_2.""Shift Regular Seconds""::NUMBER(18,0)    as ""Regular Seconds""

   --    ,IFF(UNI_2.""Day Regular Seconds Running Total"" > UNI_2.""Seconds Per Week"" 
   --      AND UNI_2.""Seconds Per Week"" IS NOT NULL
   --          ,IFF(UNI_2.""Seconds Per Week"" <
   --               LAG(UNI_2.""Day Regular Seconds Running Total"") 
   --                 OVER (PARTITION BY  UNI_2.""Employee"", UNI_2.""Fiscal Week""  ORDER BY UNI_2.""Clocked In At"")
   --              ,UNI_2.""Shift Regular Seconds""
   --              ,UNI_2.""Day Regular Seconds Running Total"" - UNI_2.""Seconds Per Week""
   --              )   
   --          ,UNI_2.""Shift Day Overtime Seconds"") ::NUMBER(18,0)                                                      
   --                                                    as ""Overtime Seconds"" 

   ,UNI_2.""Shift Regular Seconds""::NUMBER(18,0)       
     -
    IFF(UNI_2.""Day Regular Seconds Running Total"" > UNI_2.""Seconds Per Week"" 
        AND UNI_2.""Seconds Per Week"" IS NOT NULL
            ,IFF(UNI_2.""Seconds Per Week"" <
                 LAG(UNI_2.""Day Regular Seconds Running Total"") 
                   OVER (PARTITION BY  UNI_2.""Employee"", UNI_2.""Fiscal Week""  ORDER BY UNI_2.""Clocked In At"")
                ,UNI_2.""Shift Regular Seconds""
                ,UNI_2.""Day Regular Seconds Running Total"" - UNI_2.""Seconds Per Week""
                )   
            ,UNI_2.""Shift Day Overtime Seconds"") ::NUMBER(18,0) 

     
       as ""Regular Seconds""
--=====================  ===================================================================================
   -- ,UNI_2.""Day Regular Seconds Running Total""
   -- -- -- ,UNI_2.""Shift Day Overtime Seconds""
   -- -- -- ,UNI_2.""Seconds Per Week""
   -- ,LAG(UNI_2.""Day Regular Seconds Running Total"") 
   --                 OVER (PARTITION BY  UNI_2.""Employee"", UNI_2.""Fiscal Week""  ORDER BY UNI_2.""Clocked In At"")           
   --                                                 as ""Last Running Total""
                                                   
   ,IFF(UNI_2.""Day Regular Seconds Running Total"" > UNI_2.""Seconds Per Week"" 
        AND UNI_2.""Seconds Per Week"" IS NOT NULL
            ,IFF(UNI_2.""Seconds Per Week"" <
                 LAG(UNI_2.""Day Regular Seconds Running Total"") 
                   OVER (PARTITION BY  UNI_2.""Employee"", UNI_2.""Fiscal Week""  ORDER BY UNI_2.""Clocked In At"")
                ,UNI_2.""Shift Regular Seconds""
                ,UNI_2.""Day Regular Seconds Running Total"" - UNI_2.""Seconds Per Week""
                )   
            ,UNI_2.""Shift Day Overtime Seconds"") ::NUMBER(18,0)                                                      
                                                      as ""Overtime Seconds"" 

--======================================================================================
 ,floor(UNI_2.""Shift Regular Seconds""/60/60/24) || '' D '' ||
       floor(UNI_2.""Shift Regular Seconds""/60/60%24) || '':'' ||
       floor(UNI_2.""Shift Regular Seconds""/60%60) || '':'' ||
       floor(UNI_2.""Shift Regular Seconds""%60)         as ""Regular D H:M:S""


 ,floor(IFF(UNI_2.""Day Regular Seconds Running Total"" > UNI_2.""Seconds Per Week"" 
                       AND UNI_2.""Seconds Per Week"" IS NOT NULL
                        ,UNI_2.""Day Regular Seconds Running Total"" - UNI_2.""Seconds Per Week""
                        ,UNI_2.""Shift Day Overtime Seconds"") ::NUMBER(18,0)/60/60/24) || '' D '' ||
       floor(IFF(UNI_2.""Day Regular Seconds Running Total"" > UNI_2.""Seconds Per Week"" 
                       AND UNI_2.""Seconds Per Week"" IS NOT NULL
                        ,UNI_2.""Day Regular Seconds Running Total"" - UNI_2.""Seconds Per Week""
                        ,UNI_2.""Shift Day Overtime Seconds"") ::NUMBER(18,0)/60/60%24) || '':'' ||
       floor(IFF(UNI_2.""Day Regular Seconds Running Total"" > UNI_2.""Seconds Per Week"" 
                       AND UNI_2.""Seconds Per Week"" IS NOT NULL
                        ,UNI_2.""Day Regular Seconds Running Total"" - UNI_2.""Seconds Per Week""
                        ,UNI_2.""Shift Day Overtime Seconds"") ::NUMBER(18,0)/60%60) || '':'' ||
       floor(IFF(UNI_2.""Day Regular Seconds Running Total"" > UNI_2.""Seconds Per Week"" 
                       AND UNI_2.""Seconds Per Week"" IS NOT NULL
                        ,UNI_2.""Day Regular Seconds Running Total"" - UNI_2.""Seconds Per Week""
                        ,UNI_2.""Shift Day Overtime Seconds"") ::NUMBER(18,0)%60)         as ""Overtime D H:M:S""  
  ,null ::NUMBER(18,2)                                                                  as ""Tips""           
  ,null ::NUMBER(18,2)                                                                  as ""Gratuities""        
--======================================================================================
      FROM(
            SELECT UNI_1.* 
                   ,SUM(IFF(UNI_1.""Shift Seconds"" < UNI_1.""Seconds Per Day""
                       OR UNI_1.""Seconds Per Day"" IS NULL
                        ,UNI_1.""Shift Seconds"" 
                        ,UNI_1.""Seconds Per Day"" )) 
                            OVER (PARTITION BY UNI_1.LOCATION_DIM_FK,UNI_1.""Employee ID"" ,UNI_1.""Fiscal Week"" ORDER BY UNI_1.""Shift ID"" 
                    )                                                             AS ""Day Regular Seconds Running Total"" 
                
                    ,IFF(UNI_1.""Seconds Per Day"" < UNI_1.""Shift Seconds""  
                         AND UNI_1.""Seconds Per Day"" IS NOT NULL
                        ,UNI_1.""Seconds Per Day""
                        ,UNI_1.""Shift Seconds"" 
                         )                                 AS ""Shift Regular Seconds"" 
                        
                    ,IFF(UNI_1.""Shift Seconds"" > UNI_1.""Seconds Per Day"" 
                       AND UNI_1.""Seconds Per Day"" IS NOT NULL
                        ,UNI_1.""Shift Seconds"" - UNI_1.""Seconds Per Day"" 
                        ,0)                                                        AS ""Shift Day Overtime Seconds"" 
                                                                                
              FROM (
              SELECT UNI_0.* 
               -- ,CASE WHEN UNI_0.""Shift Per Day Count"" > 1 
               --    THEN SUM(UNI_0.""Shift - Break Seconds"") 
               --       OVER (PARTITION BY LOCATION_DIM_FK,""Employee ID"" ,""Fiscal Day""   --see ""Running Total Each Fiscal Day Seconds""below
               --          ORDER BY ""Shift ID"") 
               --       ELSE UNI_0.""Shift - Break Seconds""   END                        AS ""Shift Seconds""

                      ,UNI_0.""Shift - Break Seconds""                                    AS ""Shift Seconds""    --mod 2024/09/09 yyy

                  ,SUM(UNI_0.""Shift - Break Seconds"") OVER (PARTITION BY LOCATION_DIM_FK,""Employee ID"" ,""Fiscal Day"" 
                        ORDER BY ""Shift ID"")                                                                                                                                                                                            AS ""Running Total Each Fiscal Day Seconds""
                 FROM (
                      SELECT  UNI.""Support ID""                                       AS ""Support ID"" 
                    --status, category, level------------------------------------------------------------------
                    --geography--------------------------------------------------------------------------------
                        ,MAX(UNI.""Location"")                                         AS ""Location""
                        ,MAX(UNI.""Organization"")                                     AS ""Organization""
                    -- --dates-----------------------------------------------------------------------------------
                        ,MAX(UNI.""Time Zone"")                                        AS ""Time Zone""
                        ,MAX(UNI.""Year"")                                             AS ""Year""
                        ,MAX(UNI.""Year and Month"")                                   AS ""Year and Month""
                        ,MAX(UNI.""Clocked In At"")                                    AS ""Clocked In At""
                        ,MAX(UNI.""Clocked Out At"")                                   AS ""Clocked Out At""    
                        ,MAX(UNI.""Day of Week"")                                      AS ""Day of Week""
                        ,MAX(UNI.""Is Weekend"")                                       AS ""Is Weekend""
                        ,MAX(UNI.""Week Offset"")                                      AS ""Week Offset""
                        ,MAX(UNI.""Fiscal Week"")                                      AS ""Fiscal Week""                 
                        ,MAX(UNI.""Fiscal Day"")                                       AS ""Fiscal Day""    
                    -- --flags--------------------------------------------------------------------------------------
                        ,MAX(UNI.""Is Clocked Out"")                                   AS ""Is Clocked Out""
                        ,MAX(UNI.""Was System Clock Out"")                             AS ""Was System Clock Out""
                        ,MAX(UNI.""Gets Paid Break"")                                  AS ""Gets Paid Break""
                        ,CASE WHEN MAX(UNI.""Overtime Rule"") IS NULL THEN FALSE ELSE TRUE END                     
                                                                                     AS ""Gets Overtime""        
                    -- --people------------------------------------------------------------------------------------- 
                        ,MAX(UNI.""Employee"")                                         AS ""Employee""
                        ,MAX(UNI.""Employee ID"")                                      AS ""Employee ID""
                        ,MAX(UNI.JOBPOSITION_DIM_FK)                                 AS JOBPOSITION_DIM_FK
                        ,MAX(UNI.LOCATION_DIM_FK)                                    AS LOCATION_DIM_FK       
                    --  --Descriptors-------------------------------------------------------------------------------- 
                        ,MAX(UNI.""Job Position"")                                     AS ""Job Position""  --(i.e. Bartender, Cook, Server)   
                        ,MAX(UNI.""Pay Basis"")                                        AS ""Pay Basis""
                        ,MAX(UNI.""Shift ID"")                                         AS ""Shift ID""  
                    -- Facts-----------------------------------------------------------------------------------------
                        ,IFNULL(MAX(UNI.""Overtime Rule""),''None'')                     AS ""Overtime Rule""
                        ,MAX(UNI.""Hours Per Day"")                                    AS ""Hours Per Day""
                        ,MAX(UNI.""Hours Per Week"")                                   AS ""Hours Per Week""
                        ,MAX(UNI.""Shift Count"")                                      AS ""Shift Count""
                        ,MAX(UNI.""Break Count"")                                      AS ""Break Count"" 

                        ,MAX(UNI.""Shift Per Day Count"")                              AS ""Shift Per Day Count""
          
                        ,IFNULL(MAX(UNI.""Break Seconds""),0)                          AS ""Break Seconds""
                        ,MAX(UNI.""Overtime Rate"")                                    AS ""Overtime Rate""
                        ,MAX(UNI.""Regular Rate"")                                     AS ""Regular Rate""
                        ,MAX(UNI.""Seconds Per Week"")                                 AS ""Seconds Per Week""
                        ,MAX(UNI.""Seconds Per Day"")                                  AS ""Seconds Per Day""                    
                        ,MAX(UNI.""Shift Seconds"")                                    AS ""Shift Total Seconds""
                        ,MAX(UNI.""Shift Seconds"") 
                           - IFF(MAX(UNI.""Gets Paid Break""),IFNULL(MAX(UNI.""Break Seconds""),0),0)                                    
                                                                                     AS ""Shift - Break Seconds""
                        FROM (
                            SELECT * FROM SHIFT_CTE 
                              UNION
                            SELECT * FROM BREAK_CTE  
                              UNION
                            SELECT * FROM RULE_CTE
                
                        )                                                   UNI
                        GROUP BY ""Support ID""
                                                                             ) UNI_0
                   
                                                                                )  UNI_1
                                                                                    
                                                                                        )UNI_2

  -- WHERE UNI_2.""Fiscal Day""::date
  --     >= :startdate::date --return only selected dates with ot calculated for a full fiscal week
  --   AND UNI_2.""Fiscal Day""::date
  --     <= :enddate::date 

;

--====================================================================================================================
CREATE TEMP TABLE TEMP_LABOR AS
             SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));  
             
--====================================================================================================================  
--get tip and gratuity data
SELECT 
    TO_CHAR(INLT1.""Support ID"")                                    AS ""Support ID""
    ,''TGR-'' ||row_number() over (order by INLT1.""Support ID"")      AS ""Detail ID""
    ,IFNULL(INLT1.LOCATIONNAME,''None'')                             AS ""Location""
    ,INLT1.TZ_NAME                                                 AS ""Time Zone""
    ,TO_CHAR(DATE_PART(YEAR,INLT1.FISCAL_DATE))                    AS ""Year""
    ,LEFT(TO_CHAR(INLT1.FISCAL_DATE),7)                            AS ""Year and Month""
    ,NULL                                                          AS ""Clocked In At""
    ,NULL                                                          AS ""Clocked Out At""
    ,NULL                                                          AS ""Clock In Time""
    ,NULL                                                          AS ""Clock Out Time""
    ,IFNULL(DAYNAME(INLT1.FISCAL_DATE::DATE),''None'')               AS ""Day of Week""
    ,CASE WHEN DAYNAME(INLT1.FISCAL_DATE::DATE) IN (''Sat'',''Sun'')  
                THEN TRUE ELSE FALSE END                           AS ""Is Weekend"" 
    ,YEAR(TIMESTAMPADD(DAY,INLT1.START_OF_PAYROLL_WEEK_INT,INLT1.FISCAL_DATE::DATE)) || ''-'' ||
     WEEKOFYEAR(TIMESTAMPADD(DAY,INLT1.START_OF_PAYROLL_WEEK_INT,INLT1.FISCAL_DATE::DATE))    
                                                                   AS ""Fiscal Week""
    ,INLT1.FISCAL_DATE                                             AS ""Fiscal Day""
    ,NULL                                                          AS ""Is Clocked Out""
    ,NULL                                                          AS ""Was System Clock Out""
    ,INLT1.EMPLOYEE_NAME                                           AS ""Employee""
    ,NULL                                                          AS ""Job Position""
    ,NULL                                                          AS ""Pay Basis""
    ,''Shift '' || to_char(INLT1.SHIFT)                              AS ""Shift ID""
    ,NULL                                                          AS ""Overtime Rule""
    ,NULL::NUMBER(18,2)                                            AS ""Overtime Rate""
    ,NULL::NUMBER(18,2)                                            AS ""Regular Rate""
    ,NULL::NUMBER(18,0)                                            AS ""Shift Seconds""
    ,NULL::NUMBER(18,0)                                            AS ""Break Seconds""
    ,NULL::NUMBER(18,0)                                            AS aily
    ,NULL::NUMBER(18,0)                                            AS ""Daily Overtime Rule Seconds""
    ,NULL::NUMBER(18,0)                                            AS ""Regular Seconds""
    ,NULL::NUMBER(18,0)                                            AS ""Overtime Seconds""
    ,NULL                                                          AS ""Regular D H:M:S""
    ,NULL                                                          AS ""Overtime D H:M:S""
    ,INLT1.TIP::NUMBER(18,2)                                       AS ""Tips""
    ,INLT1.GRATUITIES::NUMBER(18,2)                                AS ""Gratuities""
    -------------------------------------------------------------------------------------------- 
    FROM (
    SELECT  TO_CHAR(MAX(chk.CHEQUE_FACT_NK))                      AS ""Support ID""
           ,CHK.FISCAL_DATE                                       AS FISCAL_DATE
           ,EMD.EMPLOYEE_NAME                                     AS EMPLOYEE_NAME
           ,LOC.TZ_NAME                                           AS TZ_NAME
           ,LOC.LOCATIONNAME                                      AS LOCATIONNAME
           ,SHD.SHIFT                                             AS SHIFT
           ,MAX(ORG.START_OF_PAYROLL_WEEK_INT)                    AS START_OF_PAYROLL_WEEK_INT
           ,SUM(CHK.TIP)::NUMBER(18,2)                            AS TIP
           ,SUM(CHK.GRATUITIES)::NUMBER(18,2)                     AS GRATUITIES

        FROM DATAWAREHOUSE.CHEQUE_FACT                                chk
             INNER JOIN DATAWAREHOUSE.LOCATION_DIM                    loc
                ON chk.LOCATION_DIM_FK = loc.LOCATION_DIM_NK
                    AND loc.DW_ISCURRENTROW
                    AND chk.STATUS = ''Closed''
                    AND NOT chk.IS_TRAINING
                    AND chk.DW_ISCURRENTROW  
                    AND NOT chk.DW_ISDELETED
                    AND NOT chk.IS_TRAINING
                    AND chk.FISCAL_DATE::date   >= :startdate::date
                    AND chk.FISCAL_DATE::date   <= :enddate::date
                    AND chk.LOCATION_DIM_FK IN ( SELECT table1.value 
                           FROM table(split_to_table(:locationidS, '',''))  table1)
              INNER JOIN DATAWAREHOUSE.ORGANIZATION_DIM                ORG
                    ON LOC.ORGANIZATION_DIM_FK = ORG.ORGANIZATION_DIM_NK
                      AND ORG.DW_ISCURRENTROW
              INNER JOIN DATAWAREHOUSE.EMPLOYEE_DIM                     emd
                    ON emd.EMPLOYEE_DIM_NK = chk.EMPLOYEE_DIM_FK
                       AND emd.DW_ISCURRENTROW  
              LEFT JOIN DATAWAREHOUSE.SHIFT_DIM                         shd
                    ON shd.SHIFT_DIM_NK = chk.shift_dim_fk
                        AND shd.dw_iscurrentrow
                        
             GROUP BY CHK.FISCAL_DATE
                   ,EMD.EMPLOYEE_NAME
                   ,LOC.TZ_NAME
                   ,LOC.LOCATIONNAME
                   ,SHD.SHIFT
    ) INLT1        
;
--====================================================================================================================
CREATE TEMP TABLE TEMP_TIPGRAT AS
             SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID())); 

--====================================================================================================================
reportSet := (    
  SELECT MIN(""Support ID"")                    AS ""Support ID""
        ,MIN(""Detail ID"")                     AS ""Detail ID""
        ,""Location""                           AS ""Location""
        ,MAX(""Time Zone"")                     AS ""Time Zone""
        ,MAX(""Year"")                          AS ""Year""
        ,MAX(""Year and Month"")                AS ""Year and Month""
        ,to_char(MAX(""Clocked In At""))        AS ""Clocked In At""
        ,to_char(MAX(""Clocked Out At""))       AS ""Clocked Out At""
        ,to_char(MAX(""Clock In Time""))        AS ""Clock In Time""
        ,to_char(MAX(""Clock Out Time""))       AS ""Clock Out Time""
        ,MAX(""Day of Week"")                   AS ""Day of Week""
        ,MAX(""Is Weekend"")                    AS ""Is Weekend""
        ,MAX(""Fiscal Week"")                   AS ""Fiscal Week""
        ,to_char(MAX(""Fiscal Day""))           AS ""Fiscal Day""
        ,MAX(""Is Clocked Out"")                AS ""Is Clocked Out""
        ,MAX(""Was System Clock Out"")          AS ""Was System Clock Out""
        ,""Employee""                           AS ""Employee""
        ,MAX(""Job Position"")                  AS ""Job Position""
        ,MAX(""Pay Basis"")                     AS ""Pay Basis""
        ,""Shift ID""                           AS ""Shift ID""       
        ,MAX(""Overtime Rule"")                 AS ""Overtime Rule""
        ,MAX(""Overtime Rate"")                 AS ""Overtime Rate""
        ,MAX(""Regular Rate"")                  AS ""Regular Rate""
        ,SUM(""Shift Seconds"")::NUMBER(18,0)   AS ""Shift Seconds""
        ,SUM(""Break Seconds"")::NUMBER(18,0)   AS ""Break Seconds""
        ,MAX(""Weekly Overtime Rule Seconds"")  AS ""Weekly Overtime Rule Seconds""
        ,MAX(""Daily Overtime Rule Seconds"")   AS ""Daily Overtime Rule Seconds"" 
        ,SUM(""Regular Seconds"")::NUMBER(18,0) AS ""Regular Seconds""
        ,SUM(""Overtime Seconds"")::NUMBER(18,0)AS ""Overtime Seconds""
        ,MAX(""Regular D H:M:S"")               AS ""Regular D H:M:S""
        ,MAX(""Overtime D H:M:S"")              AS ""Overtime D H:M:S""
        ,SUM(""Tips"") ::NUMBER(18,2)           AS ""Tips""
        ,SUM(""Gratuities"")::NUMBER(18,2)      AS ""Gratuities"" 
    FROM (
  SELECT * FROM TEMP_LABOR
    UNION
  SELECT * FROM TEMP_TIPGRAT where ""Tips"" <> 0.0 or ""Gratuities"" <> 0.00
  )  
  WHERE ""Fiscal Day""::date
      >= :startdate::date --return only selected dates with ot calculated for a full fiscal week
    AND ""Fiscal Day""::date
      <= :enddate::date 
  GROUP BY ""Shift ID"",""Location"",""Employee""
  ORDER BY ""Employee"",""Fiscal Day""
); 
----------------------------------------------------------------------------------------------------------------------
RETURN TABLE(reportSet);
--====================================================================================================================
END;
';"
PROCEDURE,DATAWAREHOUSE_HOLD,CREATE_LOAD_STAGE(VARCHAR),"CREATE OR REPLACE PROCEDURE ""CREATE_LOAD_STAGE""(""TABLE_NAME_INPUT"" VARCHAR(16777216))
RETURNS TABLE (""SQLTEXT"" VARCHAR(16777216))
LANGUAGE SQL
EXECUTE AS OWNER
AS '
declare select_statement varchar;
        col_list    resultset;
        --select_list resultset;
        res         resultset;
        sqlText2    varchar := '')'';
        sqlTextA    varchar := ''SELECT '';
        --table_name_input varchar := ''ADDRESS_DIM'';
        table_name  varchar := table_name_input; 
        sqlText1    varchar := ''INSERT OVERWRITE INTO DEV_HOSPENG_REPORTING.DATASTAGE.'' 
                    || :table_name ||'' (  \\n''; 
        sqlTextB    varchar := '' from DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.'' || :table_name || '';''; 
        all_sqltext varchar;
-----------------------------------------------------------------------------------------
begin
  drop table if exists DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_cols; 
  drop table if exists DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_sql;
  
  create temp table DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_sql (
    ordinal int
    ,sqlText varchar
  );

------------------------------------------------------------------------------------
  create temp table DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_cols as
      select  c.column_name 
              || case when c.ordinal_position = max(ordinal_position) over (partition by 1)
                     then '' ''
                   else '', ''
                   end as column_name
              ,c.ordinal_position
              ,min(c.ordinal_position) over(partition by 1) as minOrdinal
              ,max(c.ordinal_position) over(partition by 1) as maxOrdinal
      from information_schema.tables t
         inner join information_schema.columns c
            on t.table_schema      = c.table_schema
                and t.table_name   = c.table_name
                and t.table_type   = ''BASE TABLE''
                and t.table_schema = ''DATASTAGE''
                and t.table_name   = :table_name
                --and c.column_name Not like ''DW_%               
            order by c.ordinal_position;
            
-----------------------------------------------------------------------------------------           
  insert into DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_sql (ordinal,sqlText)
     select  1 as ordinal
       ,:sqlText1 || listagg(column_name) within group (order by ordinal_position) 
         || :sqlText2 as sqlText
        from DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_cols;

------------------------------------------------------------------------------------
col_list := (
  SELECT LISTAGG(sqlText) WITHIN GROUP (ORDER BY inlt1.ORDINAL)
    FROM (
      SELECT sqlText || '' \\n '' as sqlText, 1 AS ORDINAL 
      FROM DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_sql   
        UNION
      SELECT LISTAGG(case when ordinal_position = minordinal 
         then :sqlTextA
         else '' '' 
         end
        || replace(column_name,'','') 
        --|| case when column_name like ''%_FK%'' then '' || ''''.'''' ||  DW_BATCHID '' else '' '' end
        || '' as '' 
        || case when ordinal_position = maxordinal 
             then replace(column_name,'','') || :sqlTextB
            else column_name
            end  || '' \\n'') WITHIN GROUP (ORDER BY ordinal_position) 
        as output_text
      , 2 AS ORDINAL 
        --,ordinal_position + 100 as ordinal
      from DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_cols 
    ) inlt1
);

res := (
     select ''skssksk sksk'' as output_text
   );
   
  
--======================================================================================         
return table(col_list);

end;
';"
PROCEDURE,DATAWAREHOUSE_HOLD,"SP_LOAD_DATASHARE_ITEMS(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_LOAD_DATASHARE_ITEMS""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS '
-- -- =====================================================================================
-- Example Call Statement
-- CALL DATAWAREHOUSE.SP_LOAD_DATASHARE_ITEMS(''2000-11-20T14:48:37.661Z'',''2026-11-20T14:48:37.661Z'',''[351]'');
-- GRANT usage ON procedure DATAWAREHOUSE.SP_LOAD_DATASHARE_ITEMS(timestamp_tz,timestamp_tz,string) TO ROLE DATA_REPLICATION_HOSPENG;
-- --=========================================================================================
DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2020-08-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2029-08-20T14:48:37.661Z''; 
  -- locationid string      := ''[351,352]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--=========================================================================================
BEGIN
 reportSet:= (
SELECT itf.ITEM_FACT_NK                                   as ""Support ID"" 
--status, category, level-------------------------------------------------------------------
    ,IFNULL(ccd.COGSCATEGORY,''None'')                      as ""Category Name""
    ,IFNULL(ccd.cogscategory_dim_nk,0)                    as ""Category ID""
-- --geography--------------------------------------------------------------------------------
    ,IFNULL(loc.LOCATIONNAME,''None'')                      as ""Location Name""
    ,IFNULL(loc.LOCATION_DIM_NK,''None'')                   as ""Location ID""
    ,IFNULL(itf.REVENUECENTERNAME,''None'')                 as ""Revenue Center Name""
-- --dates-------------------------------------------------------------------------------------
    ,LOC.TZ_NAME                                          as ""Time Zone""
    ,to_char(LEFT(chk.FISCAL_DATE,4))                     as ""Year""
    ,to_char(YEAR(chk.FISCAL_DATE)) || ''|'' || TO_CHAR(LEFT(''0'' || MONTH(chk.FISCAL_DATE),2))                                       
                                                          as ""Year and Month""
    ,IFNULL(dad.DAYPART,''None'')                           as ""Daypart""
    ,to_char(chk.FISCAL_DATE)                             as ""Fiscal Date""
    ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,chk.OPENED_AT::timestamp_ntz )::timestamp )                                                                           
                                                          as ""Opened At""                                                           
    ,IFNULL(DAYNAME(chk.FISCAL_DATE),''None'')              as ""Day of Week""
    ,CASE WHEN DAYNAME(chk.FISCAL_DATE) IN (''Sat'',''Sun'')  
             THEN TRUE ELSE FALSE END                     as ""Is Weekend""
-- --flags--------------------------------------------------------------------------------------
    ,IFNULL(itf.HASMODIFIERS,FALSE)                       as ""Has Modifiers""
-- --Descriptors-------------------------------------------------------------------------------- 
    ,IFNULL(itf.chequenumber ,''None'')                     as ""Check""
    ,IFNULL(itf.CHEQUE_FACT_FK ,''None'')                   as ""Check ID""    
    ,IFNULL(med.MENUITEMNAME,'' None'')                     as ""Item Name""
    ,IFNULL(med.MENUITEMNAME,'' None'')                     as ""Item Code""
    ,IFNULL(itf.COMBINEDNAME,''Regular'')                   as ""Variant Name""     
-- --Facts-----------------------------------------------------------------------------------------
    ,IFNULL(itf.QUANTITY::NUMBER(10,0),0)                 as ""Count""   
    ,IFNULL(itf.APPLIEDAMOUNT::NUMBER(18,2),0)            as ""Net Amount""
    ,IFNULL(itf.GROSS::NUMBER(18,2),0)                    as ""Gross Amount"" 
    ,IFNULL(itf.BASEPRICE::NUMBER(18,2),0)                as ""Base Price""
    ,IFNULL(itf.PRICE::NUMBER(18,2),0)                    as ""Price""
    ,IFNULL(dis.""Item Discount Amount""::NUMBER(18,2),0)   as ""Item Discount Amount""
    ,IFNULL(itf.INCLUSIVETAX::NUMBER(18,2),0)             as ""Inclusive Tax Amount""    
    ,IFNULL(itf.TAX::NUMBER(18,2),0)                      as ""Tax Amount""
--------------------------------------------------------------------------------------------   
FROM DATAWAREHOUSE.ITEM_FACT                              itf
     INNER JOIN DATAWAREHOUSE.MENUITEMNAME_DIM            med
       ON med.MENUITEMNAME_DIM_NK = itf.MENUITEMNAME_DIM_FK
          AND itf.ITEMSTATUS IN (''Added'',''Sent'')
          AND itf.CHECKSTATUS = ''Closed''
          AND itf.DW_ISCURRENTROW  
          AND med.DW_ISCURRENTROW  
          AND NOT itf.DW_ISDELETED
          AND NOT itf.IS_TRAINING
          AND itf.LOCATION_DIM_FK IN (--351,352
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)
      INNER JOIN DATAWAREHOUSE.CHEQUE_FACT                                chk
        ON chk.CHEQUE_FACT_NK = itf.CHEQUE_FACT_FK
          AND chk.DW_ISCURRENTROW
          AND chk.STATUS = ''Closed''
          AND itf.ITEMSTATUS IN (''Added'',''Sent'')
          AND (chk.FISCAL_DATE::date >= :startdate::date 
                AND chk.FISCAL_DATE::date  <= :enddate::date)
      INNER JOIN DATAWAREHOUSE.LOCATION_DIM                     loc
        ON itf.LOCATION_DIM_FK = loc.LOCATION_DIM_NK
          AND loc.DW_ISCURRENTROW
      INNER JOIN DATAWAREHOUSE.DAYPART_DIM                      dad
        ON itf.daypart_dim_fk = dad.daypart_dim_nk
          AND dad.DW_ISCURRENTROW = TRUE         
      INNER JOIN DATAWAREHOUSE.REPORTCATEGORY_DIM               meg
        ON med.REPORTCATEGORY_DIM_FK = meg.REPORTCATEGORY_DIM_NK
          AND meg.DW_ISCURRENTROW = TRUE
      INNER JOIN DATAWAREHOUSE.COGSCATEGORY_DIM                  ccd
        ON ccd.COGSCATEGORY_DIM_NK = meg.COGSCATEGORY_DIM_FK    
          AND ccd.DW_ISCURRENTROW
      LEFT JOIN (
          SELECT daf.ITEM_FACT_FK, SUM(daf.APPLIED_AMOUNT) AS ""Item Discount Amount""
              FROM DATAWAREHOUSE.DISCOUNTITEM_FACT daf
                WHERE daf.DW_ISCURRENTROW 
                  AND (daf.FISCAL_DATE::date >= :startdate::date 
                  AND daf.FISCAL_DATE::date  <= :enddate::date)
                  AND daf.LOCATION_DIM_FK IN (--351,352
                     SELECT table1.value 
                        FROM table(split_to_table(:locationidS, '',''))  table1)
                  AND NOT daf.IS_TRAINING
                GROUP BY daf.ITEM_FACT_FK
                                                          )dis 
            ON dis.ITEM_FACT_FK = itf.ITEM_FACT_NK
          
--==========================================================================================
);
RETURN TABLE(reportSet); 
END;
-- ';"
PROCEDURE,DATAWAREHOUSE_HOLD,CREATE_DW_UPDATE(VARCHAR),"CREATE OR REPLACE PROCEDURE ""CREATE_DW_UPDATE""(""TABLE_NAME_INPUT"" VARCHAR(16777216))
RETURNS TABLE (""SQLTEXT"" VARCHAR(16777216))
LANGUAGE SQL
EXECUTE AS OWNER
AS '
DECLARE res_list    resultset;
        --table_name_input varchar := ''PAYMENT_FACT''; --uncomment for development
        table_name  varchar := table_name_input; 
        
-----------------------------------------------------------------------------------------
BEGIN
  res_list := (        
   SELECT LISTAGG(REPLACE(txt.SQLTEXTVALUE,''<Table Name>'',:table_name) || '' \\n '') 
        WITHIN GROUP(ORDER BY txt.SQLTEXTORDINAL)
    FROM DEV_HOSPENG_REPORTING.DATAWAREHOUSE.DW_SQLTEXT  txt
    WHERE txt.SQLTEXTGROUP = ''DWUpdateText''
      AND NOT txt.ISDELETED
      AND txt.ISCURRENTVERSION        
   )  --end of select stmt for sql_text variable
   
   ;
--======================================================================================    
    return table(res_list);
--======================================================================================
END;
--======================================================================================
';"
PROCEDURE,DATAWAREHOUSE_HOLD,CREATE_TABLE_DW(VARCHAR),"CREATE OR REPLACE PROCEDURE ""CREATE_TABLE_DW""(""TABLE_NAME_INPUT"" VARCHAR(16777216))
RETURNS TABLE (""SQLTEXT"" VARCHAR(16777216))
LANGUAGE SQL
EXECUTE AS OWNER
AS '
DECLARE res_list            resultset;
        --table_name_input    varchar := ''PAYMENTS_FACT''; --uncomment for dev
        table_name          varchar := table_name_input; 
-----------------------------------------------------------------------------------------
BEGIN
  res_list := (
    SELECT LISTAGG(INLT2.SQLTextValue  || '' \\n '') WITHIN GROUP (ORDER BY INLT2.SQLTextOrdinal) AS sqlText
      FROM(
      --additional columns added to the view for the dw table
      SELECT INLT1.SQLTextOrdinal
          ,REPLACE(INLT1.SQLTextValue,''<TableName>'', MAX(INLT1.TableName)OVER(PARTITION BY 1)) as SQLTextValue
        FROM (
           SELECT SQT.SQLTextOrdinal     AS SQLTextOrdinal
             ,NULL                       AS TableName
             ,SQT.SQLTextValue           AS SQLTextValue
             FROM dev_hospeng_reporting.datawarehouse.DW_SQLText  SQT
            WHERE SQT.SQLTextGroup = ''DWAdditionalColumns''
              AND SQT.IsCurrentVersion 
              AND NOT SQT.ISDELETED
        
           UNION
          
--grab all of the columns from the conforming view to include in the dw table
        SELECT
             c.Ordinal_position, t.table_name
             ,'' '' || c.column_name || '''' || '' '' 
                || CASE WHEN c.column_name LIKE ''%_PK''
                    THEN ''int identity(1,1),''
                  ELSE 
                     CASE WHEN c.column_name LIKE ''%_FK''
                        THEN '' int,''
                      ELSE 
                  c.DATA_TYPE || CASE WHEN DATA_TYPE NOT IN (''BOOLEAN'',''VARIANT'') 
                    THEN '' (''  || COALESCE(CAST(c.CHARACTER_MAXIMUM_LENGTH as STRING)
                               ,CAST(c.DATETIME_PRECISION as STRING)
                               ,CAST(c.CHARACTER_OCTET_LENGTH as STRING)
                               ,CAST(c.NUMERIC_PRECISION as STRING),'' '')
                 ELSE '' ''
                     END
              
               || CASE WHEN DATA_TYPE  = ''NUMBER'' THEN '','' || CAST(NUMERIC_SCALE AS STRING)  ELSE '' '' END
               || CASE WHEN DATA_TYPE NOT IN (''BOOLEAN'',''VARIANT'') THEN '')'' ELSE '' '' END
              

               || CASE WHEN c.ordinal_position = MAX(c.ordinal_position) OVER (PARTITION BY 1) THEN '');'' ELSE '', '' END
              END 
            END
                        AS sqlText
      from information_schema.tables t
      inner join information_schema.columns c
          on t.table_schema     = c.table_schema
            and t.table_name    = c.table_name
            and t.table_type    = ''VIEW''
            and t.table_schema  = ''POSTGRES_PUBLIC''
            and t.table_name    = :table_name
            
        UNION
     --add natural key for all foreign keys      
     select c.Ordinal_position + 0.5                  as ordinal_position 
      , :table_name                                   as table_name
      --,replace(c.column_name,''FK'',''NK'') || '',''        as column_name
            ,'' '' || replace(c.column_name,''FK'',''NK'') || '''' || '' '' || c.DATA_TYPE
                || CASE WHEN DATA_TYPE NOT IN (''BOOLEAN'',''VARIANT'')
                  THEN '' (''  || COALESCE(CAST(c.CHARACTER_MAXIMUM_LENGTH as STRING)
                               ,CAST(c.DATETIME_PRECISION as STRING)
                               ,CAST(c.CHARACTER_OCTET_LENGTH as STRING)
                               ,CAST(c.NUMERIC_PRECISION as STRING),'' '')
                              
               ELSE '' '' END
       
               || CASE WHEN DATA_TYPE  = ''NUMBER'' THEN '','' || CAST(NUMERIC_SCALE AS STRING)  ELSE '' '' END
               || CASE WHEN DATA_TYPE NOT IN (''BOOLEAN'',''VARIANT'') THEN ''),'' ELSE '','' END
    
              
                        AS sqlText
     from information_schema.tables t
      inner join information_schema.columns c
          on t.table_schema     = c.table_schema
            and t.table_name    = c.table_name
            and t.table_type    = ''VIEW''
            and t.table_schema  = ''POSTGRES_PUBLIC''
            and t.table_name    = :table_name
            and c.column_name   like ''%_FK''
                                                    ) INLT1
      --order by SQLTextOrdinal
                                                            ) INLT2
                                                                    )
    ;
--======================================================================================    
return table(res_list);
--======================================================================================
END;
';"
PROCEDURE,DATAWAREHOUSE_HOLD,"SP_REPORT_CASH(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_CASH""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR)
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS 'DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2000-11-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2026-11-20T14:48:37.661Z''; 
  -- locationid string      :=  ''[1,2,3,4,351]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
-- =============================================================================================================
--Expected Amount Totals Documented Here
--https://github.com/nabancard/pos-api/blob/master/db/migrations/20231120103333_enhance_cash_trackability.sql#L62
-- ============================================================================================================
BEGIN

DROP TABLE IF EXISTS TEMP_SHIFT;

--Temp Table to  FILTER both payments and Cashbank Events with the same Shift 
--  acts as a filter on location, time frame, and employee
  SELECT SHD_cte.SHIFT_DIM_NK                                         AS SHIFT_DIM_NK
    ,SHD_cte.fiscal_day                                               AS FISCAL_DAY
    ,SHD_cte.CLOCKEDIN_AT::timestamp_ntz                              AS CLOCKEDIN_AT
    ,SHD_cte.CLOCKEDOUT_AT::timestamp_ntz                             AS CLOCKEDOUT_AT
    ,SHD_cte.EMPLOYEE_DIM_FK                                          AS EMPLOYEE_DIM_FK
    ,SHD_cte.SHIFT_START_AT                                           AS SHIFT_START_AT
    ,SHD_cte.SHIFT_END_AT                                             AS SHIFT_END_AT
    ,EMD.EMPLOYEE_NAME                                                AS EMPLOYEE_NAME
    ,LOC.LOCATIONNAME                                                 AS LOCATIONNAME
    ,LOC.LOCATION_DIM_NK                                              AS ""Location ID""    
    ,LOC.TZ_NAME                                                      AS ""Time Zone""
    ,CBD.CASHBANK                                                     AS ""Cashbank ID""
    ,cbd.open_amount < cbd.close_amount                               AS IS_OPENHIGHERTHANCLOSE
    ,IFNULL(cbd.open_amount,0.0000) - IFNULL(cbd.close_amount,0.0000) AS OPENDELTA_AMOUNT
    ,IFNULL(cbd.EXPECTED_AMOUNT,0.0000)                               AS EXPECTED_AMOUNT
    ,IFNULL(cbd.open_amount,0.0000)                                   AS OPEN_AMOUNT
    ,IFNULL(cbd.close_amount,0.0000)                                  AS CLOSE_AMOUNT
    ,CBD.CASHBANK_DIM_NK                                              AS CASHBANK_DIM_NK
    ,cbd.status                                                       AS STATUS
    ,SHD_cte.FISCAL_DAY                                               AS ""Fiscal Day"" 
    FROM SHIFT_DIM                                        SHD_cte
      INNER JOIN DATAWAREHOUSE.LOCATION_DIM                   LOC
         ON SHD_cte.LOCATION_DIM_FK = LOC.LOCATION_DIM_NK
            AND LOC.DW_ISCURRENTROW
            AND SHD_cte.DW_ISCURRENTROW
            AND NOT SHD_cte.DW_ISDELETED
            ----------------------------------------------------------------------------------------------
            AND SHD_cte.fiscal_day
                   >= :startdate::date 
            AND  SHD_cte.fiscal_day  
                  <= :enddate::date    
            AND SHD_cte.LOCATION_DIM_FK IN (SELECT table1.value 
                   FROM table(split_to_table(:locationidS, '',''))  table1)
            ----------------------------------------------------------------------------------------------
      INNER JOIN DATAWAREHOUSE.CASHBANK_DIM                   CBD
        ON CBD.SHIFT_DIM_FK = SHD_cte.SHIFT_DIM_NK
          AND CBD.DW_ISCURRENTROW
          AND NOT CBD.DW_ISDELETED
          
      INNER JOIN DATAWAREHOUSE.EMPLOYEE_DIM                   EMD
        ON SHD_cte.EMPLOYEE_DIM_FK = EMD.EMPLOYEE_DIM_NK
          AND EMD.DW_ISCURRENTROW
;

CREATE TEMP TABLE TEMP_SHIFT AS
             SELECT * FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));       
;


reportSet   := (
SELECT INLT.""Support ID""                            AS ""Support ID""
, ''CSH-'' ||row_number() over (order by INLT.""Support ID"") 
                                                    AS ""Detail ID""   
--status, category, level------------------------------------------------------------------------------
,INLT.""Status""                                      AS ""Status""
--geography--------------------------------------------------------------------------------------------
,INLT.""Location""                                    AS ""Location""
,INLT.""Location ID""                                 as ""Location ID""
--dates------------------------------------------------------------------------------------------------
,INLT.""Time Zone""                                   AS ""Time Zone""
,to_char(LEFT(INLT.""Fiscal Day"",4))                 AS ""Year""
,to_char(YEAR(INLT.""Fiscal Day"")) || ''|'' || TO_CHAR(LEFT(''0'' || MONTH(INLT.""Fiscal Day""),2))                                       
                                                    AS ""Year and Month""
,to_char(INLT.""Fiscal Day"")                         AS ""Fiscal Day""
,IFNULL(INLT.""Daypart"",''None'')                      AS ""Daypart""
-- ,INLT.""Transaction Date""::timestamp_ntz                        ------------------------ 
,to_char(CONVERT_TIMEZONE(''UTC'',INLT.""Time Zone"" ,INLT.""Transaction Date""::timestamp_ntz )::timestamp)        
                                                    AS ""Transacted At""
 ,IFNULL(DAYNAME(INLT.""Fiscal Day""),''None'')         AS""Day of Week""
    ,CASE WHEN DAYNAME(INLT.""Fiscal Day"") IN (''Sat'',''Sun'')  
             THEN TRUE ELSE FALSE END               AS ""Is Weekend""

,to_char(CONVERT_TIMEZONE(''UTC'',INLT.""Time Zone"" ,INLT.""Paid At""::timestamp_ntz )::timestamp )            
-- ,INLT.""Paid At""::timestamp_ntz                                      
                                                    AS ""Paid At""

,to_char(CONVERT_TIMEZONE(''UTC'',INLT.""Time Zone"" ,INLT.""Clocked In At""::timestamp_ntz )::timestamp )                                                    
-- ,INLT.""Clocked In At""::timestamp_ntz                               
                                                    AS ""Clocked In At""

,to_char(CONVERT_TIMEZONE(''UTC'',INLT.""Time Zone"" ,INLT.""Clocked Out At""::timestamp_ntz )::timestamp )                                                    
-- ,INLT.""Clocked Out At""::timestamp_ntz                              
                                                    AS ""Clocked Out At""
--flags------------------------------------------------------------------------------------------------
--people-----------------------------------------------------------------------------------------------
,INLT.""Employee Name""               AS ""Employee""
--Descriptors------------------------------------------------------------------------------------------ 
,INLT.""Cash Drawer ID""              AS ""Cash Drawer ID"" 
,to_char(INLT.""Cashbank ID"")        AS ""Cashbank ID""
,INLT.""Check ID""                    AS ""Check ID""
,INLT.""Check NO""                    AS ""Check NO""
,INLT.""Payment ID""                  AS ""Payment ID""        
,''Shift '' || to_varchar(INLT.""Shift ID"")  
                                    AS ""Shift ID""
,INLT.""Event Type""                  AS ""Event Type""
,INLT.""Notes""                       AS ""Notes""
,INLT.""Payment Method""              AS ""Payment Method""
,INLT.""Payment Type""                AS ""Payment Type""
,INLT.""Terminal""                    AS ""Terminal""
,INLT.""Reason""                      AS ""Reason""
--Facts------------------------------------------------------------------------------------------------
 ,1::NUMBER(18,0)                                 AS ""Count""
 ,INLT.""Adjusted Cash Open Amount""::NUMBER(18,2)  AS ""Adjusted Cash Open Amount""--The opening amount of cash  
 ,INLT.""Cash Close Amount""::NUMBER(18,2)          AS ""Cash Close Amount""--The closing amount of cash
 ,INLT.""Cash Open Amount""::NUMBER(18,2)           AS ""Cash Open Amount""--The opening amount of cash
 ,INLT.""Cash ReOpen Amount""::NUMBER(18,2)         AS ""Cash ReOpen Amount""
 ,INLT.""Deposit""::NUMBER(18,2)                    AS ""Deposit""--The opening amount of cash
 ,INLT.""Withdrawl""::NUMBER(18,2)                  AS ""Withdrawl""--The opening amount of cash   
 ,INLT.open_amount::NUMBER(18,2)                  AS ""Open Amount""
 ,INLT.close_amount::NUMBER(18,2)                 AS ""Close Amount""
 ,INLT.""Cash Due""::NUMBER(18,2)                   AS ""Cash Due""
 ,INLT.""Expected Amount""::NUMBER(18,2)            AS ""Expected Amount""
 ,INLT.""Cash Change Amount""::NUMBER(18,2)         AS ""Cash Change Amount""    
 ,INLT.""Cash Tendered Amount""::NUMBER(18,2)       AS ""Cash Tendered Amount"" 
 ,INLT.""Cash Payment Amount""::NUMBER(18,2)        AS ""Cash Payment Amount"" 
-- ,0.0000  AS ""Non Cash Payments""---This could be gift certificate or some other  per davis put on hold
-- ,0.0000  AS ""All Payments""--sum cash PLUS non cash  --Possibly removed from requirements?
 ,INLT.""Cash Tip Amount""::NUMBER(18,2)            AS ""Cash Tip Amount"" 
 ,INLT.""Pay In Amount""::NUMBER(18,2)              AS ""Pay In Amount""
 ,INLT.""Pay Out Amount""::NUMBER(18,2)             AS ""Pay Out Amount""
-------------------------------------------------------------------------------------------------------
  FROM (
        SELECT ''CBE:'' || TO_CHAR(CHF.CASHBANKEVENT_FACT_PK) AS ""Support ID""    --unique id not for displayeing id
        ,shd.""Cashbank ID""                        AS ""Cashbank ID""
        ,shd.EMPLOYEE_NAME                        AS ""Employee Name""
        ,shd.""Fiscal Day""                         AS ""Fiscal Day""
        ,chf.EVENT_TYPE                           AS ""Event Type""
        ,shd.SHIFT_DIM_NK                         AS ""Shift ID""
        ,''None''                                   AS ""Check ID""
        ,''None''                                   AS ""Check NO""
        ,shd.STATUS                               AS ""Status""
        ,''None''                                   AS ""Payment Method""
        ,''None''                                   AS ""Payment Type""
        ,''None''                                   AS ""Terminal""
        ,IFNULL(chf.notes,''None'')                 AS ""Notes""
        ,''None''                                   AS ""Reason""
        ,''None''                                   AS ""Payment ID""

        ,shd.""Time Zone""                          AS ""Time Zone""  
        ,CASE chf.EVENT_TYPE 
          WHEN ''BankOpened'' THEN shd.CLOCKEDIN_AT
          WHEN ''BankClosed'' THEN shd.CLOCKEDOUT_AT
          ELSE chf.dw_startdate END
                                                  AS ""Transaction Date""
        ,''None''                                   AS ""Daypart""
        ,''None''                                   AS ""Cash Drawer ID"" --OPTIONAL
        ,shd.LOCATIONNAME                         AS ""Location""
        ,shd.""Location ID""                        AS ""Location ID""
        ,chf.CREATED_AT                           AS ""Paid At""
        ,shd.CLOCKEDIN_AT                         AS ""Clocked In At""
        ,shd.CLOCKEDOUT_AT                        AS ""Clocked Out At""
        --===================================================================================
        ,CASE WHEN chf.EVENT_TYPE = ''AdjustedOpenAmount'' 
          THEN IFNULL(chf.AMOUNT,0.0000) 
          ELSE 0.0000 END                         AS ""Adjusted Cash Open Amount""--The opening amount of cash  
        ,CASE WHEN chf.EVENT_TYPE = ''BankClosed'' 
          THEN IFNULL(chf.AMOUNT,0.0000)
          ELSE 0.0000 END                         AS ""Cash Close Amount""--The closing amount of cash
        ,CASE WHEN chf.EVENT_TYPE = ''BankOpened'' 
          THEN IFNULL(chf.AMOUNT ,0.0000)
          ELSE 0.0000 END 
                                                  AS ""Cash Open Amount""--The opening amount of cash
        ,CASE WHEN chf.EVENT_TYPE = ''BankReopened''
          THEN IFNULL(chf.AMOUNT ,0.0000)
          ELSE 0.0000 END 
                                                  AS ""Cash ReOpen Amount""
        ,CASE WHEN chf.EVENT_TYPE = ''Deposit'' 
          THEN IFNULL(chf.AMOUNT ,0.0000)
          ELSE 0.0000 END                         AS ""Deposit""--The opening amount of cash
        ,CASE WHEN chf.EVENT_TYPE = ''Withdrawal'' 
          THEN IFNULL(chf.AMOUNT,0.0000) 
          ELSE 0.0000 END                         AS ""Withdrawl""--The opening amount of cash
        
          ,shd.open_amount, shd.close_amount
        ,CASE WHEN chf.EVENT_TYPE = ''BankClosed'' AND shd.IS_OPENHIGHERTHANCLOSE   
          THEN IFNULL(shd.OPENDELTA_AMOUNT,0.0000)
         ELSE 0.00 END                            AS ""Cash Due""--If the opening amount is less than closing amou            --NOTE:  1ST half of union is the open and close amounts so all 
         --=================
         --EXPECTED_AMOUNT
         ,CASE WHEN chf.EVENT_TYPE = ''BankOpened''    
          THEN IFNULL(shd.EXPECTED_AMOUNT,0.0000)
          ELSE 0.0000 END                         AS ""Expected Amount""
        --===================================================================================
        ,0.0000                                   AS ""Cash Change Amount""    
        ,0.0000                                   AS ""Cash Tendered Amount"" 
        ,0.0000                                   AS ""Cash Payment Amount""  --Total Payments in Cash Received
        -- ,0.0000  AS ""Non Cash Payments""---This could be gift certificate or some other  per davis put on hold
        -- ,0.0000  AS ""All Payments""--sum cash PLUS non cash  --Possibly removed from requirements?
        ,0.0000                                   AS ""Cash Tip Amount"" 
        ,0.0000                                   AS ""Pay In Amount""
        ,0.0000                                   AS ""Pay Out Amount""
         -----------------------------------------------------------------------------------------  
        FROM TEMP_SHIFT                                        SHD
            INNER JOIN DATAWAREHOUSE.CASHBANKEVENT_FACT            CHF
              ON SHD.CASHBANK_DIM_NK = CHF.CASHBANK_DIM_FK
                  AND CHF.DW_ISCURRENTROW
                  AND NOT CHF.DW_ISDELETED
                  --AND CBD.STATUS <> ''Open''
--         -----------------------------------------------------------------------------------------
         UNION ALL
--         -- -----------------------------------------------------------------------------------------
        SELECT ''PAY:'' || TO_CHAR(pay.PAYMENTS_FACT_PK)               AS ""Support ID""    --unique id 
        ,SHD.""Cashbank ID""                        AS ""Cashbank ID""
        ,shd.EMPLOYEE_NAME                        AS ""Employee Name""
        ,shd.""Fiscal Day""                         AS ""Fiscal Day""
        ,''Cash Payment''                           AS ""Event Type""
        ,shd.SHIFT_DIM_NK                         AS ""Shift ID""
        ,to_char(pay.cheque_fact_fk)              AS ""Check ID""
        ,to_char(pay.CHEQUENUMBER)                AS ""Check""
        ,shd.STATUS                               AS ""Status""
        ,pmd.PAYMENTMETHODNAME                    AS ""Payment Method""
        ,pmd.PAYMENTMETHODTYPE                    AS ""Payment Type""
        ,TED.TERMINALNAME                         AS ""Terminal""
        ,''None''                                   AS ""Notes""
        ,''None''                                   AS ""Reason""
        ,TO_CHAR(pay.PAYMENTS_FACT_NK)            AS ""Payment ID""
        ,shd.""Time Zone""                          AS ""Time Zone""          
        ,pay.PAID_AT::timestamp_ntz 
                                                  AS ""Transaction Date""
        ,dpd.DAYPART                              AS ""Daypart""
        ,null                                     AS ""Cash Drawer ID"" --OPTIONAL
        ,shd.LOCATIONNAME                         AS ""Location""
        ,shd.""Location ID""                        AS ""Location ID""
        ,pay.PAID_AT::timestamp_ntz                              
                                                  AS ""Paid At""
        ,shd.CLOCKEDIN_AT                         AS ""Clocked In At""
        ,shd.CLOCKEDOUT_AT                        AS ""Clocked Out At""
        --===================================================================================
        ,0.0000                                   AS ""Adjusted Cash Open Amount""
        ,0.0000   
        AS ""Cash Close Amount""--The closing amount of cash
        ,0.0000                                   AS ""Cash Open Amount""--The opening amount of cash
        ,0.0000                                   AS ""Cash ReOpen Amount""
        ,0.0000                                   AS ""Deposit""--The opening amount of cash
        ,0.0000                                   AS ""Withdrawl""--The opening amount of cash
        
        ,shd.open_amount
        , shd.close_amount
        ,0.0000                                   AS ""Cash Due""
        ,0.0000                                   AS ""Expected Amount""
        --===================================================================================
        ,IFNULL(CPL.AMOUNT_CHANGED,0.0000)         AS ""Cash Change Amount""    
        ,IFNULL(CPL.AMOUNT_TENDERED,0.0000)       AS ""Cash Tendered Amount""     
        ,IFNULL(PAY.TOTAL,0.0000)                 AS ""Cash Payment Amount""  --Total Payments in Cash Received
        -- ,NULL AS ""Non Cash Payments""---This could be gift certificate or some other per davis put on hold
        -- ,NULL AS ""All Payments""--sum cash PLUS non cash
        ,IFNULL(PAY.TIP,0.0000)                    AS ""Cash Tip Amount"" 
        ,0.0000                                    AS ""Pay In Amount""
        ,0.0000                                    AS ""Pay Out Amount""
         ----------------------------------------------------------------------------------------- 
           FROM TEMP_SHIFT                                       SHD
            INNER JOIN  CHECKCASHPAYMENTLEDGER_FACT              CPL
              ON SHD.SHIFT_DIM_NK = CPL.SHIFT_DIM_FK
                AND CPL.DW_ISCURRENTROW
                AND NOT CPL.DW_ISDELETED
                AND NOT CPL.IS_VOID
            INNER JOIN DATAWAREHOUSE.PAYMENTS_FACT                   PAY    --465
              ON PAY.PAYMENTS_FACT_NK = CPL.PAYMENTS_FACT_FK
                -- AND pay.PAYMENTSTATUS = ''Success''    --No need to check payment method for cash as all ledger rows are cash
                AND pay.DW_ISCURRENTROW
                AND NOT pay.IS_TRAINING
            INNER JOIN DATAWAREHOUSE.PAYMENTMETHOD_DIM                PMD
               ON PMD.PAYMENTMETHOD_DIM_NK = PAY.PAYMENTMETHOD_DIM_FK
                AND PAY.DW_ISCURRENTROW
            INNER JOIN DATAWAREHOUSE.DAYPART_DIM                       DPD
               ON dpd.DAYPART_DIM_NK = pay.DAYPART_DIM_FK
                 AND dpd.dw_iscurrentrow
            LEFT JOIN DATAWAREHOUSE.TERMINAL_DIM                       TED
                ON TED.TERMINAL_DIM_NK = PAY.TERMINAL_DIM_FK
                  AND TED.DW_ISCURRENTROW
        -- -----------------------------------------------------------------------------------------
        UNION ALL
        -- -----------------------------------------------------------------------------------------
        SELECT ''PIO:'' || TO_CHAR(PIO.PAYINOUT_FACT_PK)      AS ""Support ID""   
        ,shd.""Cashbank ID""                        AS ""Cashbank ID""
        ,shd.EMPLOYEE_NAME                        AS ""Employee Name""
        ,shd.""Fiscal Day""                         AS ""Fiscal Day""
        ,CASE WHEN PAR.IS_PAY_IN THEN ''Pay In''
          ELSE ''Pay Out'' END                      AS ""Event Type""
        ,shd.SHIFT_DIM_NK                         AS ""Shift ID""
        ,''None''                                   AS ""Check ID""
        ,''None''                                   AS ""Check NO""
        ,PIO.STATUS                               AS ""Status""
        ,pmd.PAYMENTMETHODNAME                    AS ""Payment Method""
        ,pmd.PAYMENTMETHODTYPE                    AS ""Payment Type""
        ,''None''                                   AS ""Terminal""
        ,IFNULL(pio.NOTES,''None'')                 AS ""Notes""
        ,IFNULL(par.PAYINPAYOUTREASON,''None'')     AS ""Reason"" 
        ,''None''                                   AS ""Payment ID""
         ,shd.""Time Zone""                         AS ""Time Zone""          
        ,pio.dw_startdate                         AS ""Transaction Date""
        ,''None''                                   AS ""Daypart""
        ,''None''                                   AS ""Cash Drawer ID"" 
        ,shd.LOCATIONNAME                         AS ""Location""
        ,shd.""Location ID""                        AS ""Location ID""
        ,pio.CREATED_AT::timestamp_ntz                           
                                                  AS ""Paid At""
        ,shd.CLOCKEDIN_AT                         AS ""Clocked In At""
        ,shd.CLOCKEDOUT_AT                        AS ""Clocked Out At""
        --===================================================================================
        ,0.0000                                   AS ""Adjusted Cash Open Amount""
        ,0.0000                                   AS ""Cash Close Amount""
        ,0.0000                                   AS ""Cash Open Amount""
        ,0.0000                                   AS ""Cash ReOpen Amount""
        ,0.0000                                   AS ""Deposit""
        ,0.0000                                   AS ""Withdrawl""
        ,NULL, NULL
        ,0.0000                                   AS ""Cash Due""--If the opening amount is less than closing amou  
        ,0.0000                                   AS ""Expected Amount""
        --===================================================================================
        ,0.0000                                   AS ""Cash Change Amount""    
        ,0.0000                                   AS ""Cash Tendered Amount"" 
        ,0.0000                                   AS ""Cash Payment Amount""
        ,0.0000                                   AS ""Cash Tip Amount""
        ,CASE WHEN PAR.IS_PAY_IN THEN PIO.AMOUNT 
          ELSE 0.0000 END                         AS ""Pay In Amount""  --Total Payments in Cash Received
        ,CASE WHEN NOT PAR.IS_PAY_IN THEN PIO.AMOUNT 
          ELSE 0.0000 END                         AS ""Pay Out Amount"" 
         -----------------------------------------------------------------------------------------  
        FROM TEMP_SHIFT                                        SHD
            INNER JOIN DATAWAREHOUSE.PAYINOUT_FACT                 PIO
              ON SHD.SHIFT_DIM_NK = PIO.SHIFT_DIM_FK
                  AND PIO.DW_ISCURRENTROW
                  AND NOT PIO.DW_ISDELETED
                  AND NOT PIO.IS_VOID
                  AND PIO.STATUS = ''Success''
            INNER JOIN DATAWAREHOUSE.PAYMENTMETHOD_DIM             PMD
              ON PMD.PAYMENTMETHOD_DIM_NK = PIO.PAYMENTMETHOD_DIM_FK
                  AND PMD.DW_ISCURRENTROW
                  AND PMD.PAYMENTMETHODTYPE = ''Cash''
                  -- AND PMD.PAYMENTMETHODNAME <> ''Error''
            INNER JOIN DATAWAREHOUSE.PAYINPAYOUTREASON_DIM         PAR
              ON PAR.PAYINPAYOUTREASON_DIM_NK = PIO.PAYINPAYOUTREASON_DIM_FK
                  AND PAR.DW_ISCURRENTROW
                  
           ) INLT
-- =================================================================================================================
); 
 RETURN TABLE(reportSet); 
END';"
PROCEDURE,DATAWAREHOUSE_HOLD,"SP_REPORT_PMIX(TIMESTAMP_TZ, TIMESTAMP_TZ, VARCHAR)","CREATE OR REPLACE PROCEDURE ""SP_REPORT_PMIX""(""STARTDATE"" TIMESTAMP_TZ(9), ""ENDDATE"" TIMESTAMP_TZ(9), ""LOCATIONID"" VARCHAR(16777216))
RETURNS TABLE ()
LANGUAGE SQL
EXECUTE AS OWNER
AS '
-- -- =====================================================================================
-- Example Call Statement
-- CALL DATAWAREHOUSE.SP_REPORT_PMIX(''2000-11-20T14:48:37.661Z'',''2026-11-20T14:48:37.661Z'',''[2]'');
-- =======================================================================================
-- CALL DATAWAREHOUSE.SP_REPORTDATAGROOM(''SP_REPORT_PMIX'',2,3);
-- CALL DATAWAREHOUSE.SP_REPORT_PMIX(''2001-01-20T14:48:37.661Z'',''2026-11-20T14:48:37.661Z'',''[361, 352, 353, 351, 574, 480, 433, 421, 408, 399, 390, 389, 379, 382, 385, 387, 388]'');
-- GRANT usage ON procedure DATAWAREHOUSE.SP_REPORT_PMIX(timestamp_tz,timestamp_tz,string) TO ROLE DATA_REPLICATION_HOSPENG;
-- --=========================================================================================
DECLARE 
  reportSet resultset;
  -- startdate timestamp_tz := ''2020-08-20T14:48:37.661Z'';  
  -- enddate timestamp_tz   := ''2029-08-20T14:48:37.661Z''; 
  -- locationid string      := ''[2,3,4]'';
  locationidS string     :=  REPLACE(REPLACE(:locationid,''['',''''),'']'','''');
--=========================================================================================
BEGIN
 reportSet:= (
SELECT itf.ITEM_FACT_NK                                   as ""Support ID"" 
    , ''PMIX-'' ||row_number() over (order by itf.ITEM_FACT_NK) 
                                                          as ""Detail ID""
--status, category, level-------------------------------------------------------------------
    ,IFNULL(itf.CHECKSTATUS,''None'')                       as ""Check Status""
    ,IFNULL(itf.ITEMSTATUS,''None'')                        as ""Item Status""
    ,IFNULL(itf.STATUSREASON,''None'')                      as ""Status Reason""
    ,IFNULL(ccd.COGSCATEGORY,''None'')                      as ""Category""
    -- ,IFNULL(ccd.COGSCATEGORY,''None'')                   as ""COGS Category""
-- --geography--------------------------------------------------------------------------------
    ,IFNULL(loc.LOCATIONNAME,''None'')                      as ""Location""
    ,IFNULL(itf.REVENUECENTERNAME,''None'')                 as ""Revenue Center""
-- --dates-------------------------------------------------------------------------------------
    ,LOC.TZ_NAME                                          as ""Time Zone""
    ,to_char(LEFT(chk.FISCAL_DATE,4))                     as ""Year""
    ,to_char(YEAR(chk.FISCAL_DATE)) || ''|'' || TO_CHAR(LEFT(''0'' || MONTH(chk.FISCAL_DATE),2))                                       
                                                          as ""Year and Month""
    ,IFNULL(dad.DAYPART,''None'')                           as ""Daypart""
    ,to_char(chk.FISCAL_DATE)                             as ""Fiscal Date""
    ,to_char(CONVERT_TIMEZONE(''UTC'',LOC.TZ_NAME,chk.OPENED_AT::timestamp_ntz )::timestamp )                                                                           
                                                          as ""Opened At""                                                           
    ,IFNULL(DAYNAME(chk.FISCAL_DATE),''None'')              as ""Day of Week""
    ,CASE WHEN DAYNAME(chk.FISCAL_DATE) IN (''Sat'',''Sun'')  
             THEN TRUE ELSE FALSE END                     as ""Is Weekend""
-- --flags--------------------------------------------------------------------------------------
    ,IFNULL(itf.HASMODIFIERS,FALSE)                       as ""Has Modifiers""
-- --people-------------------------------------------------------------------------------------
    ,IFNULL(emd.EMPLOYEE_NAME,''None'')                     as ""Employee""
-- --Descriptors-------------------------------------------------------------------------------- 
    ,IFNULL(itf.chequenumber ,''None'')                     as ""Check""
    ,IFNULL(med.MENUITEMNAME,'' None'')                     as ""Menu Item""
    ,IFNULL(itf.NOTE,''None'')                              as ""Note""
    ,IFNULL(itf.DESCRIPTION,''None'')                       as ""Description""
    ,IFNULL(itf.COMBINEDNAME,''Regular'')                   as ""Variant""     
    ,itf.SPLITBY::NUMBER(18,0)                            as ""Split By""
-- --Facts-----------------------------------------------------------------------------------------
    ,itf.QUANTITY::NUMBER(10,0)                           as ""Count""
    ,itf.REPORTQUANTITY::NUMBER(18,2)                     as ""Report Quantity""   
    ,itf.APPLIEDAMOUNT::NUMBER(18,2)                      as ""Applied Amount""
    ,itf.BASEPRICE::NUMBER(18,2)                          as ""Base Price""
    ,itf.PRICE::NUMBER(18,2)                              as ""Price""
    ,itf.GROSS::NUMBER(18,2)                              as ""Gross"" 
    ,dis.""Item Discount Amount""::NUMBER(18,2)             as ""Item Discount Amount""
    ,(IFNULL(itf.GROSS,0) - IFNULL(dis.""Item Discount Amount"",0))::NUMBER(18,2)                      
                                                          as ""Net""  
    ,itf.INCLUSIVETAX::NUMBER(18,2)                       as ""Inclusive Tax""    
    ,itf.TAX::NUMBER(18,2)                                as ""Tax""
    ,itf.TOTAL::NUMBER(18,2)                              as ""Total"" 
--------------------------------------------------------------------------------------------   
FROM DATAWAREHOUSE.ITEM_FACT                                  itf
     INNER JOIN DATAWAREHOUSE.MENUITEMNAME_DIM                med
       ON med.MENUITEMNAME_DIM_NK = itf.MENUITEMNAME_DIM_FK
          AND itf.ITEMSTATUS IN (''Added'',''Sent'')
          AND itf.CHECKSTATUS = ''Closed''
          AND itf.DW_ISCURRENTROW  
          AND med.DW_ISCURRENTROW  
          AND NOT itf.DW_ISDELETED
          AND NOT itf.IS_TRAINING
          AND itf.LOCATION_DIM_FK IN (--351,352
             SELECT table1.value 
                  FROM table(split_to_table(:locationidS, '',''))  table1)
      INNER JOIN DATAWAREHOUSE.CHEQUE_FACT                                chk
        ON chk.CHEQUE_FACT_NK = itf.CHEQUE_FACT_FK
          AND chk.DW_ISCURRENTROW
          AND chk.STATUS = ''Closed''
          AND itf.ITEMSTATUS IN (''Added'',''Sent'')
          AND (chk.FISCAL_DATE::date >= :startdate::date 
                AND chk.FISCAL_DATE::date  <= :enddate::date)
      INNER JOIN DATAWAREHOUSE.LOCATION_DIM                     loc
        ON itf.LOCATION_DIM_FK = loc.LOCATION_DIM_NK
          AND loc.DW_ISCURRENTROW
      INNER JOIN DATAWAREHOUSE.EMPLOYEE_DIM                     emd
        ON itf.employee_dim_fk = emd.employee_dim_Nk
          AND emd.DW_ISCURRENTROW 
      INNER JOIN DATAWAREHOUSE.DAYPART_DIM                      dad
        ON itf.daypart_dim_fk = dad.daypart_dim_nk
          AND dad.DW_ISCURRENTROW = TRUE         
      INNER JOIN DATAWAREHOUSE.REPORTCATEGORY_DIM               meg
        ON med.REPORTCATEGORY_DIM_FK = meg.REPORTCATEGORY_DIM_NK
          AND meg.DW_ISCURRENTROW = TRUE
      INNER JOIN DATAWAREHOUSE.COGSCATEGORY_DIM                  ccd
        ON ccd.COGSCATEGORY_DIM_NK = meg.COGSCATEGORY_DIM_FK    
          AND ccd.DW_ISCURRENTROW
      LEFT JOIN (
          SELECT daf.ITEM_FACT_FK, SUM(daf.APPLIED_AMOUNT) AS ""Item Discount Amount""
              FROM DATAWAREHOUSE.DISCOUNTITEM_FACT daf
                WHERE daf.DW_ISCURRENTROW 
                  AND (daf.FISCAL_DATE::date >= :startdate::date 
                  AND daf.FISCAL_DATE::date  <= :enddate::date)
                  AND daf.LOCATION_DIM_FK IN (--351,352
                     SELECT table1.value 
                        FROM table(split_to_table(:locationidS, '',''))  table1)
                  AND NOT daf.IS_TRAINING
                GROUP BY daf.ITEM_FACT_FK
                                                          )dis 
            ON dis.ITEM_FACT_FK = itf.ITEM_FACT_NK
          
--==========================================================================================
);
RETURN TABLE(reportSet); 
END;
-- ';"
PROCEDURE,DATAWAREHOUSE_OLD,CREATE_DW_LOAD(VARCHAR),"CREATE OR REPLACE PROCEDURE ""CREATE_DW_LOAD""(""TABLE_NAME_INPUT"" VARCHAR(16777216))
RETURNS TABLE (""SQLTEXT"" VARCHAR(16777216))
LANGUAGE SQL
EXECUTE AS OWNER
AS '
declare select_statement varchar;
        col_list    resultset;
        --select_list resultset;
        res         resultset;
        sqlText2    varchar := '')'';
        sqlTextA    varchar := ''select '';
        --table_name_input varchar := ''ADDRESS_DIM'';
        table_name  varchar := table_name_input; 
        sqlText1    varchar := ''insert into DEV_HOSPENG_REPORTING.DATAWAREHOUSE.'' 
                    || :table_name ||'' (''; 
        sqlTextB    varchar := '' from DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.'' || :table_name || '';''; 
        all_sqltext varchar;
-----------------------------------------------------------------------------------------
begin
  drop table if exists DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_cols; 
  drop table if exists DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_sql;
  
  create temp table DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_sql (
    ordinal int
    ,sqlText varchar
  );

------------------------------------------------------------------------------------
  create temp table DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_cols as
      select c.column_name 
              || case when c.ordinal_position = max(ordinal_position) over (partition by 1)
                     then '' ''
                   else '', ''
                   end as column_name
              ,c.ordinal_position
              ,min(c.ordinal_position) over(partition by 1) as minOrdinal
              ,max(c.ordinal_position) over(partition by 1) as maxOrdinal
      from information_schema.tables t
         inner join information_schema.columns c
            on t.table_schema      = c.table_schema
                and t.table_name   = c.table_name
                and t.table_type   = ''BASE TABLE''
                and t.table_schema = ''DATAWAREHOUSE''
                and t.table_name   = :table_name
                and c.column_name Not like ''DW_%''
            order by c.ordinal_position;
            
-----------------------------------------------------------------------------------------           
  insert into DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_sql (ordinal,sqlText)
     select  1 as ordinal
       ,:sqlText1 || listagg(column_name) within group (order by ordinal_position) 
         || :sqlText2 as sqlText
        from DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_cols;

------------------------------------------------------------------------------------
col_list := (
  SELECT LISTAGG(sqlText) WITHIN GROUP (ORDER BY inlt1.ORDINAL)
    FROM (
      SELECT sqlText || '' \\n '' as sqlText, 1 AS ORDINAL 
      FROM DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_sql   
        UNION
      SELECT LISTAGG(case when ordinal_position = minordinal 
         then :sqlTextA
         else '' '' 
         end
        || replace(column_name,'','') 
        || case when column_name like ''%_FK%'' then '' || ''''.'''' ||  DW_BATCHID '' else '' '' end
        || '' as '' 
        || case when ordinal_position = maxordinal 
             then replace(column_name,'','') || :sqlTextB
            else column_name
            end  || '' \\n'') WITHIN GROUP (ORDER BY ordinal_position) 
        as output_text
      , 2 AS ORDINAL 
        --,ordinal_position + 100 as ordinal
      from DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_cols 
    ) inlt1
);

res := (
     select ''skssksk sksk'' as output_text
   );
   
  
--======================================================================================         
return table(col_list);

end;
';"
PROCEDURE,DATAWAREHOUSE_OLD,CREATE_DW_UPDATE(VARCHAR),"CREATE OR REPLACE PROCEDURE ""CREATE_DW_UPDATE""(""TABLE_NAME_INPUT"" VARCHAR(16777216))
RETURNS TABLE (""SQLTEXT"" VARCHAR(16777216))
LANGUAGE SQL
EXECUTE AS OWNER
AS '
DECLARE res_list    resultset;
        --table_name_input varchar := ''PAYMENT_FACT''; --uncomment for development
        table_name  varchar := table_name_input; 
        
-----------------------------------------------------------------------------------------
BEGIN
  res_list := (        
   SELECT LISTAGG(REPLACE(txt.SQLTEXTVALUE,''<Table Name>'',:table_name) || '' \\n '') 
        WITHIN GROUP(ORDER BY txt.SQLTEXTORDINAL)
    FROM DEV_HOSPENG_REPORTING.DATAWAREHOUSE.DW_SQLTEXT  txt
    WHERE txt.SQLTEXTGROUP = ''DWUpdateText''
      AND NOT txt.ISDELETED
      AND txt.ISCURRENTVERSION        
   )  --end of select stmt for sql_text variable
   
   ;
--======================================================================================    
    return table(res_list);
--======================================================================================
END;
--======================================================================================
';"
PROCEDURE,DATAWAREHOUSE_OLD,CREATE_LOAD_STAGE(VARCHAR),"CREATE OR REPLACE PROCEDURE ""CREATE_LOAD_STAGE""(""TABLE_NAME_INPUT"" VARCHAR(16777216))
RETURNS TABLE (""SQLTEXT"" VARCHAR(16777216))
LANGUAGE SQL
EXECUTE AS OWNER
AS '
declare select_statement varchar;
        col_list    resultset;
        --select_list resultset;
        res         resultset;
        sqlText2    varchar := '')'';
        sqlTextA    varchar := ''SELECT '';
        --table_name_input varchar := ''ADDRESS_DIM'';
        table_name  varchar := table_name_input; 
        sqlText1    varchar := ''INSERT OVERWRITE INTO DEV_HOSPENG_REPORTING.DATASTAGE.'' 
                    || :table_name ||'' (  \\n''; 
        sqlTextB    varchar := '' from DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.'' || :table_name || '';''; 
        all_sqltext varchar;
-----------------------------------------------------------------------------------------
begin
  drop table if exists DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_cols; 
  drop table if exists DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_sql;
  
  create temp table DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_sql (
    ordinal int
    ,sqlText varchar
  );

------------------------------------------------------------------------------------
  create temp table DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_cols as
      select  c.column_name 
              || case when c.ordinal_position = max(ordinal_position) over (partition by 1)
                     then '' ''
                   else '', ''
                   end as column_name
              ,c.ordinal_position
              ,min(c.ordinal_position) over(partition by 1) as minOrdinal
              ,max(c.ordinal_position) over(partition by 1) as maxOrdinal
      from information_schema.tables t
         inner join information_schema.columns c
            on t.table_schema      = c.table_schema
                and t.table_name   = c.table_name
                and t.table_type   = ''BASE TABLE''
                and t.table_schema = ''DATASTAGE''
                and t.table_name   = :table_name
                --and c.column_name Not like ''DW_%               
            order by c.ordinal_position;
            
-----------------------------------------------------------------------------------------           
  insert into DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_sql (ordinal,sqlText)
     select  1 as ordinal
       ,:sqlText1 || listagg(column_name) within group (order by ordinal_position) 
         || :sqlText2 as sqlText
        from DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_cols;

------------------------------------------------------------------------------------
col_list := (
  SELECT LISTAGG(sqlText) WITHIN GROUP (ORDER BY inlt1.ORDINAL)
    FROM (
      SELECT sqlText || '' \\n '' as sqlText, 1 AS ORDINAL 
      FROM DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_sql   
        UNION
      SELECT LISTAGG(case when ordinal_position = minordinal 
         then :sqlTextA
         else '' '' 
         end
        || replace(column_name,'','') 
        --|| case when column_name like ''%_FK%'' then '' || ''''.'''' ||  DW_BATCHID '' else '' '' end
        || '' as '' 
        || case when ordinal_position = maxordinal 
             then replace(column_name,'','') || :sqlTextB
            else column_name
            end  || '' \\n'') WITHIN GROUP (ORDER BY ordinal_position) 
        as output_text
      , 2 AS ORDINAL 
        --,ordinal_position + 100 as ordinal
      from DEV_HOSPENG_REPORTING.POSTGRES_PUBLIC.all_cols 
    ) inlt1
);

res := (
     select ''skssksk sksk'' as output_text
   );
   
  
--======================================================================================         
return table(col_list);

end;
';"
PROCEDURE,DATAWAREHOUSE_OLD,CREATE_TABLE_DW(VARCHAR),"CREATE OR REPLACE PROCEDURE ""CREATE_TABLE_DW""(""TABLE_NAME_INPUT"" VARCHAR(16777216))
RETURNS TABLE (""SQLTEXT"" VARCHAR(16777216))
LANGUAGE SQL
EXECUTE AS OWNER
AS '
DECLARE res_list            resultset;
        --table_name_input    varchar := ''PAYMENTS_FACT''; --uncomment for dev
        table_name          varchar := table_name_input; 
-----------------------------------------------------------------------------------------
BEGIN
  res_list := (
    SELECT LISTAGG(INLT2.SQLTextValue  || '' \\n '') WITHIN GROUP (ORDER BY INLT2.SQLTextOrdinal) AS sqlText
      FROM(
      --additional columns added to the view for the dw table
      SELECT INLT1.SQLTextOrdinal
          ,REPLACE(INLT1.SQLTextValue,''<TableName>'', MAX(INLT1.TableName)OVER(PARTITION BY 1)) as SQLTextValue
        FROM (
           SELECT SQT.SQLTextOrdinal     AS SQLTextOrdinal
             ,NULL                       AS TableName
             ,SQT.SQLTextValue           AS SQLTextValue
             FROM dev_hospeng_reporting.datawarehouse.DW_SQLText  SQT
            WHERE SQT.SQLTextGroup = ''DWAdditionalColumns''
              AND SQT.IsCurrentVersion 
              AND NOT SQT.ISDELETED
        
           UNION
          
--grab all of the columns from the conforming view to include in the dw table
        SELECT
             c.Ordinal_position, t.table_name
             ,'' '' || c.column_name || '''' || '' '' 
                || CASE WHEN c.column_name LIKE ''%_PK''
                    THEN ''int identity(1,1),''
                  ELSE 
                     CASE WHEN c.column_name LIKE ''%_FK''
                        THEN '' int,''
                      ELSE 
                  c.DATA_TYPE || CASE WHEN DATA_TYPE NOT IN (''BOOLEAN'',''VARIANT'') 
                    THEN '' (''  || COALESCE(CAST(c.CHARACTER_MAXIMUM_LENGTH as STRING)
                               ,CAST(c.DATETIME_PRECISION as STRING)
                               ,CAST(c.CHARACTER_OCTET_LENGTH as STRING)
                               ,CAST(c.NUMERIC_PRECISION as STRING),'' '')
                 ELSE '' ''
                     END
              
               || CASE WHEN DATA_TYPE  = ''NUMBER'' THEN '','' || CAST(NUMERIC_SCALE AS STRING)  ELSE '' '' END
               || CASE WHEN DATA_TYPE NOT IN (''BOOLEAN'',''VARIANT'') THEN '')'' ELSE '' '' END
              

               || CASE WHEN c.ordinal_position = MAX(c.ordinal_position) OVER (PARTITION BY 1) THEN '');'' ELSE '', '' END
              END 
            END
                        AS sqlText
      from information_schema.tables t
      inner join information_schema.columns c
          on t.table_schema     = c.table_schema
            and t.table_name    = c.table_name
            and t.table_type    = ''VIEW''
            and t.table_schema  = ''POSTGRES_PUBLIC''
            and t.table_name    = :table_name
            
        UNION
     --add natural key for all foreign keys      
     select c.Ordinal_position + 0.5                  as ordinal_position 
      , :table_name                                   as table_name
      --,replace(c.column_name,''FK'',''NK'') || '',''        as column_name
            ,'' '' || replace(c.column_name,''FK'',''NK'') || '''' || '' '' || c.DATA_TYPE
                || CASE WHEN DATA_TYPE NOT IN (''BOOLEAN'',''VARIANT'')
                  THEN '' (''  || COALESCE(CAST(c.CHARACTER_MAXIMUM_LENGTH as STRING)
                               ,CAST(c.DATETIME_PRECISION as STRING)
                               ,CAST(c.CHARACTER_OCTET_LENGTH as STRING)
                               ,CAST(c.NUMERIC_PRECISION as STRING),'' '')
                              
               ELSE '' '' END
       
               || CASE WHEN DATA_TYPE  = ''NUMBER'' THEN '','' || CAST(NUMERIC_SCALE AS STRING)  ELSE '' '' END
               || CASE WHEN DATA_TYPE NOT IN (''BOOLEAN'',''VARIANT'') THEN ''),'' ELSE '','' END
    
              
                        AS sqlText
     from information_schema.tables t
      inner join information_schema.columns c
          on t.table_schema     = c.table_schema
            and t.table_name    = c.table_name
            and t.table_type    = ''VIEW''
            and t.table_schema  = ''POSTGRES_PUBLIC''
            and t.table_name    = :table_name
            and c.column_name   like ''%_FK''
                                                    ) INLT1
      --order by SQLTextOrdinal
                                                            ) INLT2
                                                                    )
    ;
--======================================================================================    
return table(res_list);
--======================================================================================
END;
';"
PROCEDURE,GITHUB,"EXPORT_STAGES_DDLS(VARCHAR, VARCHAR)","CREATE OR REPLACE PROCEDURE ""EXPORT_STAGES_DDLS""(""P_DB_NAME"" VARCHAR, ""P_OUTPUT_SCHEMA"" VARCHAR)
RETURNS VARCHAR
LANGUAGE PYTHON
RUNTIME_VERSION = '3.9'
PACKAGES = ('snowflake-snowpark-python')
HANDLER = 'run'
EXECUTE AS OWNER
AS '
from snowflake.snowpark import Session

def run(session: Session, P_DB_NAME: str, P_OUTPUT_SCHEMA: str) -> str:
    # 1) Target table: ""P_DB_NAME"".""P_OUTPUT_SCHEMA"".""EXPORT_DDLS_STAGES""
    target_table = f''""{P_DB_NAME}"".""{P_OUTPUT_SCHEMA}"".""EXPORT_DDLS_STAGES""''

    # 2) Create table if not exists
    create_sql = f""""""
        CREATE TABLE IF NOT EXISTS {target_table} (
            OBJECT_TYPE STRING,
            SCHEMA_NAME STRING,
            OBJECT_NAME STRING,
            DDL         STRING
        )
    """"""
    session.sql(create_sql).collect()

    # 3) Truncate table
    session.sql(f""TRUNCATE TABLE {target_table}"").collect()

    # 4) Read all stages in the database
    stages_sql = f''''''
        SELECT
            STAGE_CATALOG,
            STAGE_SCHEMA,
            STAGE_NAME
        FROM ""{P_DB_NAME}"".INFORMATION_SCHEMA.STAGES
    ''''''
    stages_df = session.sql(stages_sql)

    rows_to_insert = []

    for row in stages_df.collect():
        stage_catalog = row[""STAGE_CATALOG""]
        stage_schema  = row[""STAGE_SCHEMA""]
        stage_name    = row[""STAGE_NAME""]

        # FQN: ""DB"".""SCHEMA"".""STAGE""
        stage_fqn = f''""{stage_catalog}"".""{stage_schema}"".""{stage_name}""''

        # Describe the stage
        desc_df = session.sql(f""DESCRIBE STAGE {stage_fqn}"").collect()
        props = {r[""property""]: r[""property_value""] for r in desc_df}

        url                 = props.get(""URL"")
        TYPE = props.get(""TYPE"")
        COMPRESSION        = props.get(""COMPRESSION"")
        ENCODING          = props.get(""ENCODING"")
        LAST_REFRESHED_ON             = props.get(""LAST_REFRESHED_ON"")

        def nz(value: str) -> str:
            return value if value is not None else ""<NULL>""

        ddl_prefix = f""CREATE OR REPLACE STAGE {stage_fqn}""
        ddl = (
            f""{ddl_prefix} ""
            f""/* URL={nz(url)}""
            f"" TYPE={nz(TYPE)}""
            f"" COMPRESSION={nz(COMPRESSION)}""
            f"" ENCODING={nz(ENCODING)}""
            f"" LAST_REFRESHED_ON={nz(LAST_REFRESHED_ON)}""
            f"" */""
        )

        rows_to_insert.append((
            ""STAGE"",        # OBJECT_TYPE
            stage_schema,   # SCHEMA_NAME
            stage_name,     # OBJECT_NAME
            ddl             # DDL
        ))

    if rows_to_insert:
        df_out = session.create_dataframe(
            rows_to_insert,
            schema=[""OBJECT_TYPE"", ""SCHEMA_NAME"", ""OBJECT_NAME"", ""DDL""]
        )
        df_out.write.mode(""append"").save_as_table(target_table)

    return f""STAGE DDLs exported into {target_table} (rows={len(rows_to_insert)})""
';"
PROCEDURE,GITHUB,"EXPORT_PROCEDURES_DDLS(VARCHAR, VARCHAR)","CREATE OR REPLACE PROCEDURE ""EXPORT_PROCEDURES_DDLS""(""DB"" VARCHAR, ""TARGET_SCHEMA"" VARCHAR)
RETURNS VARCHAR
LANGUAGE PYTHON
RUNTIME_VERSION = '3.9'
PACKAGES = ('snowflake-snowpark-python')
HANDLER = 'main'
EXECUTE AS OWNER
AS '
from snowflake.snowpark import Session

def _to_type_only_signature(argument_signature: str) -> str:
    """"""
    Convert ''(IN P_ID NUMBER, P_NAME VARCHAR)'' -> ''(NUMBER, VARCHAR)''
    and handle NULL/empty argument_signature as ''()''.
    """"""
    if not argument_signature or argument_signature.strip() == """":
        return ""()""

    sig = argument_signature.strip()

    # Remove outer parentheses
    if sig.startswith(""("") and sig.endswith("")""):
        sig = sig[1:-1]

    if sig.strip() == """":
        return ""()""

    parts = sig.split("","")
    type_parts = []

    for part in parts:
        arg = part.strip()
        if not arg:
            continue

        # Split on whitespace: e.g. [""IN"",""P_ID"",""NUMBER""] or [""P_ID"",""NUMBER""]
        tokens = arg.split()

        # Remove IN/OUT/INOUT if present
        if tokens and tokens[0].upper() in (""IN"", ""OUT"", ""INOUT""):
            tokens = tokens[1:]

        # Remove parameter name (first token), keep rest as type
        if len(tokens) > 1:
            tokens = tokens[1:]

        if tokens:
            type_parts.append("" "".join(tokens))  # e.g. ''NUMBER'', ''TIMESTAMP_NTZ(9)''

    return ""("" + "", "".join(type_parts) + "")"" if type_parts else ""()""


def main(session: Session, DB: str, TARGET_SCHEMA: str) -> str:
    if not TARGET_SCHEMA or TARGET_SCHEMA.strip() == """":
        return ""Error: TARGET_SCHEMA parameter is required and cannot be empty.""

    # 1) Ensure output table exists
    create_table_sql = f""""""
        CREATE TABLE IF NOT EXISTS {TARGET_SCHEMA}.export_ddls_sp (
            object_type STRING,
            schema_name STRING,
            object_name STRING,
            ddl         STRING
        )
    """"""
    session.sql(create_table_sql).collect()

    # 2) Truncate output table
    session.sql(f""TRUNCATE TABLE {TARGET_SCHEMA}.export_ddls_sp"").collect()

    # 3) Get all schemas in DB (except INFORMATION_SCHEMA)
    schemas_df = session.sql(f""""""
        SELECT schema_name
        FROM {DB}.information_schema.schemata
        WHERE schema_name <> ''INFORMATION_SCHEMA''
    """""")
    schemas = [row[0] for row in schemas_df.collect()]

    for schema in schemas:
        # 4) Get procedures for this schema
        procs_df = session.sql(
            f""""""
            SELECT procedure_name, argument_signature
            FROM {DB}.information_schema.procedures
            WHERE procedure_schema = ?
            """""",
            params=[schema]
        )
        procs = procs_df.collect()

        for row in procs:
            name = row[0]
            argument_signature = row[1]

            # Build type-only signature for GET_DDL
            type_signature = _to_type_only_signature(argument_signature)

            # Fully qualified procedure name with types only
            # Example: ""MYDB"".""MYSCHEMA"".""MY_PROC""(NUMBER, VARCHAR)
            full_name = f''""{DB}"".""{schema}"".""{name}""{type_signature}''
            object_name = f""{name}{type_signature}""

            try:
                # 5) Get DDL via GET_DDL(''PROCEDURE'', full_name)
                ddl_df = session.sql(
                    ""SELECT GET_DDL(''PROCEDURE'', ?)"",
                    params=[full_name]
                )
                ddl_rows = ddl_df.collect()
                ddl_text = ddl_rows[0][0] if ddl_rows else None

                # 6) Insert DDL into output table
                session.sql(
                    f""""""
                    INSERT INTO {TARGET_SCHEMA}.export_ddls_sp
                        (object_type, schema_name, object_name, ddl)
                    VALUES (''PROCEDURE'', ?, ?, ?)
                    """""",
                    params=[schema, object_name, ddl_text]
                ).collect()

            except Exception as e:
                # 7) Insert error into output table
                err_msg = ""ERROR: "" + str(e)
                session.sql(
                    f""""""
                    INSERT INTO {TARGET_SCHEMA}.export_ddls_sp
                        (object_type, schema_name, object_name, ddl)
                    VALUES (''PROCEDURE'', ?, ?, ?)
                    """""",
                    params=[schema, object_name, err_msg]
                ).collect()

    return ""Stored Procedure DDL export completed.""
';"
PROCEDURE,GITHUB,"EXPORT_TASKS_DDLS(VARCHAR, VARCHAR)","CREATE OR REPLACE PROCEDURE ""EXPORT_TASKS_DDLS""(""DB"" VARCHAR, ""TARGET_SCHEMA"" VARCHAR)
RETURNS VARCHAR
LANGUAGE PYTHON
RUNTIME_VERSION = '3.9'
PACKAGES = ('snowflake-snowpark-python')
HANDLER = 'main'
EXECUTE AS OWNER
AS '
from snowflake.snowpark import Session

def main(session: Session, DB: str, TARGET_SCHEMA: str) -> str:
    if not TARGET_SCHEMA or TARGET_SCHEMA.strip() == """":
        return ""Error: TARGET_SCHEMA parameter is required and cannot be empty.""

    # 1) Ensure output table exists
    create_table_sql = f""""""
        CREATE TABLE IF NOT EXISTS {TARGET_SCHEMA}.export_ddls_tasks (
            object_type STRING,
            schema_name STRING,
            object_name STRING,
            ddl         STRING
        )
    """"""
    session.sql(create_table_sql).collect()

    # 2) Truncate output table
    session.sql(f""TRUNCATE TABLE {TARGET_SCHEMA}.export_ddls_tasks"").collect()

    # 3) SHOW TASKS in the given database and capture results
    #    This avoids relying on {DB}.information_schema.tasks
    show_sql = f''SHOW TASKS IN DATABASE ""{DB}""''
    session.sql(show_sql).collect()

    # Use RESULT_SCAN on the LAST_QUERY_ID() from SHOW TASKS
    tasks_df = session.sql(""""""
        SELECT ""name"", ""schema_name""
        FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()))
    """""")
    tasks = tasks_df.collect()

    for row in tasks:
        task_name = row[""name""]
        schema    = row[""schema_name""]

        # Fully qualified task name for GET_DDL
        # Example: ""MYDB"".""MYSCHEMA"".""MY_TASK""
        full_name   = f''""{DB}"".""{schema}"".""{task_name}""''
        object_name = task_name

        try:
            # 4) Get DDL via GET_DDL(''TASK'', full_name)
            ddl_df   = session.sql(""SELECT GET_DDL(''TASK'', ?)"", params=[full_name])
            ddl_rows = ddl_df.collect()
            ddl_text = ddl_rows[0][0] if ddl_rows else None

            # 5) Insert DDL into output table
            session.sql(
                f""""""
                INSERT INTO {TARGET_SCHEMA}.export_ddls_tasks
                    (object_type, schema_name, object_name, ddl)
                VALUES (''TASK'', ?, ?, ?)
                """""",
                params=[schema, object_name, ddl_text]
            ).collect()

        except Exception as e:
            # 6) Insert error into output table
            err_msg = ""ERROR: "" + str(e)
            session.sql(
                f""""""
                INSERT INTO {TARGET_SCHEMA}.export_ddls_tasks
                    (object_type, schema_name, object_name, ddl)
                VALUES (''TASK'', ?, ?, ?)
                """""",
                params=[schema, object_name, err_msg]
            ).collect()

    return ""Task DDL export completed.""
';"
PROCEDURE,GITHUB,"EXPORT_VIEWS_DDLS(VARCHAR, VARCHAR)","CREATE OR REPLACE PROCEDURE ""EXPORT_VIEWS_DDLS""(""DB"" VARCHAR, ""TARGET_SCHEMA"" VARCHAR)
RETURNS VARCHAR
LANGUAGE JAVASCRIPT
EXECUTE AS OWNER
AS '
if (!TARGET_SCHEMA || TARGET_SCHEMA.trim() === '''') {
    return ""Error: TARGET_SCHEMA parameter is required and cannot be empty."";
}
var createTable = `
CREATE TABLE IF NOT EXISTS ${TARGET_SCHEMA}.export_ddls_views (
    object_type STRING,
    schema_name STRING,
    object_name STRING,
    ddl STRING
)
`;
snowflake.createStatement({ sqlText: createTable }).execute();

snowflake.createStatement({ sqlText: `TRUNCATE TABLE ${TARGET_SCHEMA}.export_ddls_views` }).execute();

var getSchemas = `
    SELECT schema_name
    FROM ${DB}.information_schema.schemata
    WHERE schema_name NOT IN (''INFORMATION_SCHEMA'')
`;
var schemaStmt = snowflake.createStatement({ sqlText: getSchemas });
var rsSchemas = schemaStmt.execute();

while (rsSchemas.next()) {
    var schema = rsSchemas.getColumnValue(1);

    var getViews = `
        SELECT table_name
        FROM ${DB}.information_schema.views
        WHERE table_schema = ''${schema}''
    `;
    var viewStmt = snowflake.createStatement({ sqlText: getViews });
    var rsViews = viewStmt.execute();

    while (rsViews.next()) {
        var name = rsViews.getColumnValue(1);
        var fullName = `${DB}.${schema}.${name}`;

        try {
            var ddlStmt = snowflake.createStatement({
                sqlText: `SELECT GET_DDL(''VIEW'', ''${fullName}'')`
            });
            var ddlRs = ddlStmt.execute(); ddlRs.next();
            var ddlText = ddlRs.getColumnValue(1);

            var insert = `
                INSERT INTO ${TARGET_SCHEMA}.export_ddls_views (object_type, schema_name, object_name, ddl)
                VALUES (''VIEW'', ''${schema}'', ''${name}'', :1)
            `;
            snowflake.createStatement({ sqlText: insert, binds: [ddlText] }).execute();

        } catch (err) {
            var insertErr = `
                INSERT INTO ${TARGET_SCHEMA}.export_ddls_views (object_type, schema_name, object_name, ddl)
                VALUES (''VIEW'', ''${schema}'', ''${name}'', ''ERROR: '' || :1)
            `;
            snowflake.createStatement({ sqlText: insertErr, binds: [err.message] }).execute();
        }
    }
}

return ''Views DDL export completed.'';
';"
PROCEDURE,GITHUB,"EXPORT_TABLES_DDLS(VARCHAR, VARCHAR)","CREATE OR REPLACE PROCEDURE ""EXPORT_TABLES_DDLS""(""DB"" VARCHAR, ""TARGET_SCHEMA"" VARCHAR)
RETURNS VARCHAR
LANGUAGE JAVASCRIPT
EXECUTE AS OWNER
AS '
if (!TARGET_SCHEMA || TARGET_SCHEMA.trim() === '''') {
    return ""Error: TARGET_SCHEMA parameter is required and cannot be empty."";
}

var createTable = `
CREATE TABLE IF NOT EXISTS ${TARGET_SCHEMA}.export_ddls_tables (
    object_type STRING,
    schema_name STRING,
    object_name STRING,
    ddl STRING
)
`;
snowflake.createStatement({ sqlText: createTable }).execute();

snowflake.createStatement({ sqlText: `TRUNCATE TABLE ${TARGET_SCHEMA}.export_ddls_tables` }).execute();

var getSchemas = `
    SELECT schema_name
    FROM ${DB}.information_schema.schemata
    WHERE schema_name NOT IN (''INFORMATION_SCHEMA'')
`;
var schemaStmt = snowflake.createStatement({ sqlText: getSchemas });
var rsSchemas = schemaStmt.execute();

while (rsSchemas.next()) {
    var schema = rsSchemas.getColumnValue(1);

    var getTables = `
        SELECT table_name
        FROM ${DB}.information_schema.tables
        WHERE table_schema = ''${schema}''
          AND table_type = ''BASE TABLE''
    `;
    var tblStmt = snowflake.createStatement({ sqlText: getTables });
    var rsTables = tblStmt.execute();

    while (rsTables.next()) {
        var name = rsTables.getColumnValue(1);
        var fullName = `${DB}.${schema}.${name}`;

        try {
            var ddlStmt = snowflake.createStatement({
                sqlText: `SELECT GET_DDL(''TABLE'', ''${fullName}'')`
            });
            var ddlRs = ddlStmt.execute(); ddlRs.next();
            var ddlText = ddlRs.getColumnValue(1);

            var insert = `
                INSERT INTO ${TARGET_SCHEMA}.export_ddls_tables (object_type, schema_name, object_name, ddl)
                VALUES (''TABLE'', ''${schema}'', ''${name}'', :1)
            `;
            snowflake.createStatement({ sqlText: insert, binds: [ddlText] }).execute();

        } catch (err) {
            var insertErr = `
                INSERT INTO ${TARGET_SCHEMA}.export_ddls_tables (object_type, schema_name, object_name, ddl)
                VALUES (''TABLE'', ''${schema}'', ''${name}'', ''ERROR: '' || :1)
            `;
            snowflake.createStatement({ sqlText: insertErr, binds: [err.message] }).execute();
        }
    }
}

return ''Tables DDL export completed.'';
';"
